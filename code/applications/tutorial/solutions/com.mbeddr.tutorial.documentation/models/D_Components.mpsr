<?xml version="1.0" encoding="UTF-8"?>
<model ref="r:38897e08-83fd-42c7-91d3-65b102721940(com.mbeddr.tutorial.documentation.ug.cextensions)" content="root">
  <persistence version="9" />
  <imports>
    <import index="1842" ref="r:af9946fd-1a63-4ece-b383-78243d689d45(com.mbeddr.tutorial.documentation.ug.common)" implicit="true" />
    <import index="e1tx" ref="r:bd5ec23c-c294-47cc-a078-675c03abdb69(mbeddr.tutorial.main.defaultExtensions)" implicit="true" />
    <import index="v7ag" ref="r:9596407c-f27a-49d3-abde-3a66293c5b61(com.mbeddr.ext.components.structure)" implicit="true" />
    <import index="mxvz" ref="r:b92c0a08-d42f-4c78-a3f4-d5f989493286(com.mbeddr.ext.components.mock.structure)" implicit="true" />
    <import index="us0v" ref="r:22b9d29d-483d-4f08-8d1b-4e6567157caf(com.mbeddr.tutorial.documentation.ug.analyses)" implicit="true" />
  </imports>
  <registry>
    <language id="92d2ea16-5a42-4fdf-a676-c7604efe3504" name="de.slisson.mps.richtext">
      <concept id="2557074442922380897" name="de.slisson.mps.richtext.structure.Text" flags="ng" index="19SGf9">
        <child id="2557074442922392302" name="words" index="19SJt6" />
      </concept>
      <concept id="2557074442922438156" name="de.slisson.mps.richtext.structure.Word" flags="ng" index="19SUe$">
        <property id="2557074442922438158" name="escapedValue" index="19SUeA" />
      </concept>
    </language>
    <language id="2374bc90-7e37-41f1-a9c4-c2e35194c36a" name="com.mbeddr.doc">
      <concept id="4400783559374052800" name="com.mbeddr.doc.structure.EmphFormattedText" flags="ng" index="28N2ik" />
      <concept id="2728443031450669962" name="com.mbeddr.doc.structure.FootnoteWord" flags="ng" index="anbfL">
        <child id="2728443031450670151" name="text" index="anbgW" />
      </concept>
      <concept id="4317007310193476045" name="com.mbeddr.doc.structure.ScaleDownNotUp100" flags="ng" index="2bctqb" />
      <concept id="620304030119138923" name="com.mbeddr.doc.structure.BoldFormattedText" flags="ng" index="2vpllh" />
      <concept id="6165313375055797476" name="com.mbeddr.doc.structure.FormattedText" flags="ng" index="$DsGX">
        <child id="6165313375055797477" name="text" index="$DsGW" />
      </concept>
      <concept id="2179458690439382890" name="com.mbeddr.doc.structure.ConceptModelContentRemoval" flags="ng" index="2Cuv_b">
        <reference id="2179458690439403347" name="conceptDecl" index="2Cuq_M" />
      </concept>
      <concept id="2179458690449473542" name="com.mbeddr.doc.structure.ModelContentEmbeddingPrefix" flags="ng" index="2CRZSB">
        <child id="2179458690449479999" name="prefix" index="2CRYsu" />
      </concept>
      <concept id="6657644269295214799" name="com.mbeddr.doc.structure.IDocumentLike" flags="ng" index="G9hjZ">
        <reference id="6657644269295214800" name="config" index="G9hjw" />
        <child id="8730648445433290694" name="dependsOn" index="1DXQ57" />
      </concept>
      <concept id="2286331641395252232" name="com.mbeddr.doc.structure.NamedNodeModelContentPointerElement" flags="ng" index="2NCMab">
        <reference id="2286331641395252233" name="node" index="2NCMaa" />
      </concept>
      <concept id="2286331641395238583" name="com.mbeddr.doc.structure.ModelContentPointer" flags="ng" index="2NCZwO">
        <child id="2286331641395252236" name="elements" index="2NCMaf" />
      </concept>
      <concept id="2286331641392318852" name="com.mbeddr.doc.structure.MenuFormattedText" flags="ng" index="2OlAs7" />
      <concept id="2286331641391049225" name="com.mbeddr.doc.structure.KeyPressFormattedText" flags="ng" index="2OoWia" />
      <concept id="6386504476136263187" name="com.mbeddr.doc.structure.ImageParagraph" flags="ng" index="2SaynC">
        <property id="6386504476136358630" name="showImage" index="2Sbq$t" />
        <property id="8730648445434174368" name="center" index="1DKIkx" />
        <child id="6386504476136278696" name="description" index="2SaI5j" />
        <child id="6386504476136531838" name="resource" index="2SbwM5" />
        <child id="8624890525767908695" name="sizeSpec" index="3SHJ_F" />
      </concept>
      <concept id="6386504476136420159" name="com.mbeddr.doc.structure.ImgRefWord" flags="ng" index="2Sbdz4">
        <reference id="6386504476136420174" name="image" index="2SbdyP" />
      </concept>
      <concept id="6386504476136521407" name="com.mbeddr.doc.structure.Resource" flags="ng" index="2Sb_l4">
        <property id="6386504476136521408" name="fileName" index="2Sb_kV" />
        <reference id="6386504476136521409" name="path" index="2Sb_kU" />
      </concept>
      <concept id="4220250885135199523" name="com.mbeddr.doc.structure.ToDoWord" flags="ng" index="3d4VFM">
        <child id="4220250885135204208" name="text" index="3d4Uyx" />
      </concept>
      <concept id="4457500422381571986" name="com.mbeddr.doc.structure.CodeFormattedText" flags="ng" index="1jUjqm" />
      <concept id="6955693250238922820" name="com.mbeddr.doc.structure.AbstractModelContentParagraph" flags="ng" index="3z_lpG">
        <property id="6955693250238922823" name="showContents" index="3z_lpJ" />
        <child id="6955693250238922821" name="removals" index="3z_lpH" />
        <child id="6955693250238922822" name="codeptr" index="3z_lpI" />
      </concept>
      <concept id="6955693250238922840" name="com.mbeddr.doc.structure.NodeModelContentRemoval" flags="ng" index="3z_lpK">
        <reference id="6955693250238922841" name="removedNode" index="3z_lpL" />
      </concept>
      <concept id="6955693250238922834" name="com.mbeddr.doc.structure.ModelContentAsTextParagraph" flags="ng" index="3z_lpU">
        <property id="6955693250238922835" name="text" index="3z_lpV" />
        <property id="6955693250238922836" name="language" index="3z_lpW" />
      </concept>
      <concept id="6955693250238922838" name="com.mbeddr.doc.structure.ModelContentRefWord" flags="ng" index="3z_lpY">
        <child id="6955693250238922839" name="modelContentPtr" index="3z_lpZ" />
      </concept>
      <concept id="3350625596580225385" name="com.mbeddr.doc.structure.DocumentRef" flags="ng" index="1_0j5j">
        <reference id="3350625596580225386" name="doc" index="1_0j5g" />
      </concept>
      <concept id="3350625596580108709" name="com.mbeddr.doc.structure.SectRefWord" flags="ng" index="1_0GAv">
        <reference id="3350625596580108719" name="target" index="1_0GAl" />
      </concept>
      <concept id="3350625596580089586" name="com.mbeddr.doc.structure.TextParagraph" flags="ng" index="1_0LV8">
        <child id="3350625596580089613" name="text" index="1_0LWR" />
      </concept>
      <concept id="3350625596580064249" name="com.mbeddr.doc.structure.IDocContentContainer" flags="ng" index="1_0VJ3">
        <child id="3350625596580064250" name="contents" index="1_0VJ0" />
      </concept>
      <concept id="3350625596580064222" name="com.mbeddr.doc.structure.AbstractSection" flags="ng" index="1_0VJ$">
        <property id="3350625596580064225" name="text" index="1_0VJr" />
      </concept>
      <concept id="3350625596580064455" name="com.mbeddr.doc.structure.Section" flags="ng" index="1_0VNX" />
      <concept id="3350625596579911728" name="com.mbeddr.doc.structure.Document" flags="ng" index="1_1swa">
        <property id="5572730672710143343" name="chapterStartIndex" index="yApLE" />
      </concept>
      <concept id="3350625596579911760" name="com.mbeddr.doc.structure.EmptyDocContent" flags="ng" index="1_1sxE" />
      <concept id="8730648445434044903" name="com.mbeddr.doc.structure.ListingParagraph" flags="ng" index="1DKdXA">
        <property id="8730648445434044905" name="language" index="1DKdXC" />
        <property id="8730648445434044906" name="text" index="1DKdXF" />
      </concept>
      <concept id="8624890525767637976" name="com.mbeddr.doc.structure.PageWidthSizeSpec" flags="ng" index="3SGHZ$">
        <property id="8624890525767637977" name="percentage" index="3SGHZ_" />
      </concept>
      <concept id="5378658552262903588" name="com.mbeddr.doc.structure.Item" flags="ng" index="3X6T9g">
        <child id="5378658552262903589" name="text" index="3X6T9h" />
      </concept>
      <concept id="5378658552262893169" name="com.mbeddr.doc.structure.ItemList" flags="ng" index="3X6WG5">
        <child id="5378658552262986137" name="items" index="3Xp5NH" />
      </concept>
    </language>
    <language id="d4280a54-f6df-4383-aa41-d1b2bffa7eb1" name="com.mbeddr.core.base">
      <concept id="8375407818529178006" name="com.mbeddr.core.base.structure.TextBlock" flags="ng" index="OjmMv">
        <child id="8375407818529178007" name="text" index="OjmMu" />
      </concept>
    </language>
    <language id="ceab5195-25ea-4f22-9b92-103b95ca8c0c" name="jetbrains.mps.lang.core">
      <concept id="1133920641626" name="jetbrains.mps.lang.core.structure.BaseConcept" flags="ng" index="2VYdi">
        <child id="5169995583184591170" name="smodelAttribute" index="lGtFl" />
      </concept>
      <concept id="1169194658468" name="jetbrains.mps.lang.core.structure.INamedConcept" flags="ng" index="TrEIO">
        <property id="1169194664001" name="name" index="TrG5h" />
      </concept>
    </language>
  </registry>
  <node concept="1_1swa" id="3D8Uf60N7kD">
    <property role="TrG5h" value="D_Components" />
    <property role="yApLE" value="6" />
    <ref role="G9hjw" to="1842:2fBMM_3XZ4C" resolve="Config" />
    <node concept="1_0VNX" id="3mn43GO8cLU" role="1_0VJ0">
      <property role="TrG5h" value="components" />
      <property role="1_0VJr" value="Components" />
      <node concept="1_0LV8" id="3D8Uf60XdUz" role="1_0VJ0">
        <node concept="19SGf9" id="3D8Uf60XdU$" role="1_0LWR">
          <node concept="19SUe$" id="3D8Uf60XdU_" role="19SJt6">
            <property role="19SUeA" value="Let us now introduce components to further structure the system. We start by factoring the " />
          </node>
          <node concept="1jUjqm" id="3D8Uf60XdUE" role="19SJt6">
            <node concept="19SGf9" id="3D8Uf60XdUF" role="$DsGW">
              <node concept="19SUe$" id="3D8Uf60XdUH" role="19SJt6">
                <property role="19SUeA" value="Trackpoint" />
              </node>
            </node>
          </node>
          <node concept="19SUe$" id="3D8Uf60XdUI" role="19SJt6">
            <property role="19SUeA" value=" data structure into a separate module and export it to make it accessible from importing modules." />
          </node>
        </node>
      </node>
      <node concept="3z_lpU" id="3DAECxFFwCJ" role="1_0VJ0">
        <property role="3z_lpW" value="mbeddr" />
        <property role="3z_lpJ" value="true" />
        <property role="3z_lpV" value="                            &#10;exported struct Trackpoint {&#10;  int8 id;                  &#10;  int8/s/ time;             &#10;  int8/m/ x;                &#10;  int8/m/ y;                &#10;  int16/m/ alt;             &#10;  int16/mps/ speed;         &#10;};                          " />
        <node concept="2NCZwO" id="1YUFCeGolDS" role="3z_lpI">
          <node concept="2NCMab" id="1YUFCeGolDT" role="2NCMaf">
            <ref role="2NCMaa" to="e1tx:1w5Xuj1QYMp" resolve="DataStructures" />
          </node>
          <node concept="2NCMab" id="1YUFCeGolDU" role="2NCMaf">
            <ref role="2NCMaa" to="e1tx:1w5Xuj1QYMq" resolve="Trackpoint" />
          </node>
        </node>
      </node>
      <node concept="1_0VNX" id="3D8Uf6111fR" role="1_0VJ0">
        <property role="TrG5h" value="interfWithContract" />
        <property role="1_0VJr" value="An Interface with Contracts" />
        <node concept="1_0LV8" id="3D8Uf6112mP" role="1_0VJ0">
          <node concept="19SGf9" id="3D8Uf6112mQ" role="1_0LWR">
            <node concept="19SUe$" id="3D8Uf6112mR" role="19SJt6">
              <property role="19SUeA" value="We now define an interface that processes " />
            </node>
            <node concept="1jUjqm" id="3D8Uf6112UO" role="19SJt6">
              <node concept="19SGf9" id="3D8Uf6112UP" role="$DsGW">
                <node concept="19SUe$" id="3D8Uf6112UR" role="19SJt6">
                  <property role="19SUeA" value="Trackpoint" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="3D8Uf6112US" role="19SJt6">
              <property role="19SUeA" value="s. To be able to do that we have to add the " />
            </node>
            <node concept="1jUjqm" id="3D8Uf6112UT" role="19SJt6">
              <node concept="19SGf9" id="3D8Uf6112UU" role="$DsGW">
                <node concept="19SUe$" id="3D8Uf6112UW" role="19SJt6">
                  <property role="19SUeA" value="com.mbeddr.components" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="3D8Uf6112UX" role="19SJt6">
              <property role="19SUeA" value=" devkit to the current model. We can then enter a client-server interface in a new module " />
            </node>
            <node concept="3z_lpY" id="627_yy4ebvO" role="19SJt6">
              <node concept="2NCZwO" id="627_yy4ebvP" role="3z_lpZ">
                <node concept="2NCMab" id="627_yy4ebwA" role="2NCMaf">
                  <ref role="2NCMaa" to="e1tx:1w5Xuj1QYPN" resolve="Components" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="627_yy4ebvN" role="19SJt6">
              <property role="19SUeA" value=". We use pointers for the trackpoints here to optimize performance. Note that you can just press " />
            </node>
            <node concept="2OoWia" id="627_yy4ebwD" role="19SJt6">
              <node concept="19SGf9" id="627_yy4ebwG" role="$DsGW">
                <node concept="19SUe$" id="627_yy4ebwH" role="19SJt6">
                  <property role="19SUeA" value="*" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="3D8Uf6112V7" role="19SJt6">
              <property role="19SUeA" value=" on the right side of " />
            </node>
            <node concept="1jUjqm" id="3D8Uf6112V8" role="19SJt6">
              <node concept="19SGf9" id="3D8Uf6112V9" role="$DsGW">
                <node concept="19SUe$" id="3D8Uf6112Vb" role="19SJt6">
                  <property role="19SUeA" value="Trackpoint" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="3D8Uf6112Vc" role="19SJt6">
              <property role="19SUeA" value=" to make it a " />
            </node>
            <node concept="1jUjqm" id="3D8Uf6112Vd" role="19SJt6">
              <node concept="19SGf9" id="3D8Uf6112Ve" role="$DsGW">
                <node concept="19SUe$" id="3D8Uf6112Vg" role="19SJt6">
                  <property role="19SUeA" value="Trackpoint*" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="3D8Uf6112Vh" role="19SJt6">
              <property role="19SUeA" value=". " />
            </node>
          </node>
        </node>
        <node concept="1_0LV8" id="3D8Uf6115FS" role="1_0VJ0">
          <node concept="19SGf9" id="3D8Uf6115FT" role="1_0LWR">
            <node concept="19SUe$" id="3D8Uf6115FU" role="19SJt6">
              <property role="19SUeA" value="The interface has one operation " />
            </node>
            <node concept="3z_lpY" id="627_yy4ggeG" role="19SJt6">
              <node concept="2NCZwO" id="627_yy4ggeH" role="3z_lpZ">
                <node concept="2NCMab" id="627_yy4ggeY" role="2NCMaf">
                  <ref role="2NCMaa" to="e1tx:1w5Xuj1QYPN" resolve="Components" />
                </node>
                <node concept="2NCMab" id="627_yy4ggf6" role="2NCMaf">
                  <ref role="2NCMaa" to="e1tx:1w5Xuj1QYPS" resolve="TrackpointProcessor" />
                </node>
                <node concept="2NCMab" id="627_yy4ggfi" role="2NCMaf">
                  <ref role="2NCMaa" to="e1tx:1w5Xuj1QYPT" resolve="process" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="627_yy4ggeF" role="19SJt6">
              <property role="19SUeA" value="." />
            </node>
          </node>
        </node>
        <node concept="3z_lpU" id="3D8Uf61142M" role="1_0VJ0">
          <property role="3z_lpW" value="mbeddr" />
          <property role="3z_lpJ" value="true" />
          <property role="3z_lpV" value="exported cs interface TrackpointProcessor {&#10;  Trackpoint* process(Trackpoint* p)       &#10;}                                          " />
          <node concept="2NCZwO" id="1YUFCeGolBQ" role="3z_lpI">
            <node concept="2NCMab" id="1YUFCeGolBR" role="2NCMaf">
              <ref role="2NCMaa" to="e1tx:1w5Xuj1QYPN" resolve="Components" />
            </node>
            <node concept="2NCMab" id="1YUFCeGolBS" role="2NCMaf">
              <ref role="2NCMaa" to="e1tx:1w5Xuj1QYPS" resolve="TrackpointProcessor" />
            </node>
          </node>
          <node concept="2Cuv_b" id="1SYZy6Qn20Q" role="3z_lpH">
            <ref role="2Cuq_M" to="v7ag:5HTuIUP_k1N" resolve="PrePostCondition" />
          </node>
        </node>
        <node concept="1_0LV8" id="1SYZy6QsxE$" role="1_0VJ0">
          <node concept="19SGf9" id="1SYZy6QsxE_" role="1_0LWR">
            <node concept="19SUe$" id="1SYZy6QsxEA" role="19SJt6">
              <property role="19SUeA" value="To enhance the semantic &quot;richness&quot; of the interface we add preconditions and a postcondition. To do so, use an intention " />
            </node>
            <node concept="2OlAs7" id="yaVrOuw0O9" role="19SJt6">
              <node concept="19SGf9" id="yaVrOuw0Oc" role="$DsGW">
                <node concept="19SUe$" id="yaVrOuw0Od" role="19SJt6">
                  <property role="19SUeA" value="Add Precondition" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="1SYZy6QsxEK" role="19SJt6">
              <property role="19SUeA" value=" on the operation itself. Please add the following pre- and postconditions (note how you can of course use units in the precondition). The " />
            </node>
            <node concept="1jUjqm" id="1SYZy6QsxEL" role="19SJt6">
              <node concept="19SGf9" id="1SYZy6QsxEM" role="$DsGW">
                <node concept="19SUe$" id="1SYZy6QsxEN" role="19SJt6">
                  <property role="19SUeA" value="result" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="1SYZy6QsxEO" role="19SJt6">
              <property role="19SUeA" value=" expression is only available in postconditions and represents the result of the executed operation." />
            </node>
          </node>
        </node>
        <node concept="3z_lpU" id="1SYZy6Qn1ZD" role="1_0VJ0">
          <property role="3z_lpW" value="mbeddr" />
          <property role="3z_lpJ" value="true" />
          <property role="3z_lpV" value="exported cs interface TrackpointProcessor {&#10;  Trackpoint* process(Trackpoint* p)       &#10;  pre(0) p != null                         &#10;  pre(1) p.id != 0                         &#10;  pre(2) p.time != 0 s                     &#10;  post(3) result.id != 0                   &#10;}                                          " />
          <node concept="2NCZwO" id="1SYZy6Qn1ZE" role="3z_lpI">
            <node concept="2NCMab" id="1SYZy6Qn1ZF" role="2NCMaf">
              <ref role="2NCMaa" to="e1tx:1w5Xuj1QYPN" resolve="Components" />
            </node>
            <node concept="2NCMab" id="1SYZy6Qn1ZG" role="2NCMaf">
              <ref role="2NCMaa" to="e1tx:1w5Xuj1QYPS" resolve="TrackpointProcessor" />
            </node>
          </node>
        </node>
        <node concept="1_0LV8" id="3D8Uf6116hB" role="1_0VJ0">
          <node concept="19SGf9" id="3D8Uf6116hC" role="1_0LWR">
            <node concept="19SUe$" id="3D8Uf6116hD" role="19SJt6">
              <property role="19SUeA" value="After you have added these contracts, you will get an error message on the interface. The problem is this: if a contract (pre- or postcondition) fails, the system will report a message (this message can be deactivated in case you don't want any reporting). However, for the program to work you have to specify a message on the interface. We create a new message list and a messge." />
            </node>
          </node>
        </node>
        <node concept="3z_lpU" id="3D8Uf611taf" role="1_0VJ0">
          <property role="3z_lpW" value="mbeddr" />
          <property role="3z_lpJ" value="true" />
          <property role="3z_lpV" value="exported messagelist ContractMessages {                                                &#10;  message contractFailed(int8 opID, int8 constraintID) ERROR: contract failed  (active)&#10;}                                                                                      " />
          <node concept="2NCZwO" id="1YUFCeGolCt" role="3z_lpI">
            <node concept="2NCMab" id="1YUFCeGolCu" role="2NCMaf">
              <ref role="2NCMaa" to="e1tx:1w5Xuj1QYPN" resolve="Components" />
            </node>
            <node concept="2NCMab" id="1YUFCeGolCv" role="2NCMaf">
              <ref role="2NCMaa" to="e1tx:1w5Xuj1RHZF" resolve="ContractMessages" />
            </node>
          </node>
        </node>
        <node concept="1_0LV8" id="3D8Uf611tJR" role="1_0VJ0">
          <node concept="19SGf9" id="3D8Uf611tJS" role="1_0LWR">
            <node concept="19SUe$" id="3D8Uf611tJT" role="19SJt6">
              <property role="19SUeA" value="You can now open the inspector for the interface and reference this message from there:" />
            </node>
          </node>
        </node>
        <node concept="2SaynC" id="3D8Uf611urm" role="1_0VJ0">
          <property role="TrG5h" value="contractMessages" />
          <property role="1DKIkx" value="true" />
          <property role="2Sbq$t" value="true" />
          <node concept="2Sb_l4" id="3D8Uf611vxr" role="2SbwM5">
            <property role="2Sb_kV" value="tutorial/contractmessage.png" />
            <ref role="2Sb_kU" to="1842:2fBMM_3XZ4D" resolve="images" />
          </node>
          <node concept="OjmMv" id="3D8Uf611urq" role="2SaI5j">
            <node concept="19SGf9" id="3D8Uf611urr" role="OjmMu">
              <node concept="19SUe$" id="3D8Uf611urs" role="19SJt6">
                <property role="19SUeA" value="A message definition used in the interface definition to report contract failures." />
              </node>
            </node>
          </node>
          <node concept="3SGHZ$" id="3D8Uf611VJa" role="3SHJ_F">
            <property role="3SGHZ_" value="50" />
          </node>
        </node>
        <node concept="1_0LV8" id="3D8Uf612cQd" role="1_0VJ0">
          <node concept="19SGf9" id="3D8Uf612cQe" role="1_0LWR">
            <node concept="19SUe$" id="3D8Uf612cQf" role="19SJt6">
              <property role="19SUeA" value="There are still errors. The first one complains that the message list must be exported if the interface is exported. We fix it by exporting the message list (via an intention). The next error complains that the message needs to have to integer arguments to represent the operation and the pre- or postcondition. We change it thusly (note that there are quick fixes available to adapt the signatures in the required way)." />
            </node>
          </node>
        </node>
      </node>
      <node concept="1_0VNX" id="3D8Uf612e6t" role="1_0VJ0">
        <property role="TrG5h" value="AFirstComponent" />
        <property role="1_0VJr" value="A first Component" />
        <node concept="1_0LV8" id="3D8Uf612ffE" role="1_0VJ0">
          <node concept="19SGf9" id="3D8Uf612ffF" role="1_0LWR">
            <node concept="19SUe$" id="3D8Uf612ffG" role="19SJt6">
              <property role="19SUeA" value="We create a new component by typing " />
            </node>
            <node concept="1jUjqm" id="3D8Uf612ffM" role="19SJt6">
              <node concept="19SGf9" id="3D8Uf612ffN" role="$DsGW">
                <node concept="19SUe$" id="3D8Uf612ffP" role="19SJt6">
                  <property role="19SUeA" value="component" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="3D8Uf612ffQ" role="19SJt6">
              <property role="19SUeA" value=". We call it " />
            </node>
            <node concept="1jUjqm" id="3D8Uf612ffR" role="19SJt6">
              <node concept="19SGf9" id="3D8Uf612ffS" role="$DsGW">
                <node concept="19SUe$" id="3D8Uf612ffU" role="19SJt6">
                  <property role="19SUeA" value="Nuller" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="3D8Uf612ffV" role="19SJt6">
              <property role="19SUeA" value=". It has one provided port called " />
            </node>
            <node concept="1jUjqm" id="3D8Uf612ffW" role="19SJt6">
              <node concept="19SGf9" id="3D8Uf612ffX" role="$DsGW">
                <node concept="19SUe$" id="3D8Uf612ffZ" role="19SJt6">
                  <property role="19SUeA" value="processor" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="3D8Uf612fg0" role="19SJt6">
              <property role="19SUeA" value=" that provides the " />
            </node>
            <node concept="3z_lpY" id="1SYZy6PNlkj" role="19SJt6">
              <node concept="2NCZwO" id="1SYZy6PNlkk" role="3z_lpZ">
                <node concept="2NCMab" id="1SYZy6PNmQ0" role="2NCMaf">
                  <ref role="2NCMaa" to="e1tx:1w5Xuj1QYPN" resolve="Components" />
                </node>
                <node concept="2NCMab" id="1SYZy6PNmQ5" role="2NCMaf">
                  <ref role="2NCMaa" to="e1tx:1w5Xuj1QYPS" resolve="TrackpointProcessor" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="3D8Uf612fg5" role="19SJt6">
              <property role="19SUeA" value=" interface.  " />
            </node>
          </node>
        </node>
        <node concept="3z_lpU" id="3D8Uf612fk4" role="1_0VJ0">
          <property role="3z_lpW" value="mbeddr" />
          <property role="3z_lpJ" value="true" />
          <property role="3z_lpV" value="exported component Nuller extends nothing {&#10;  provides TrackpointProcessor processor   &#10;} component Nuller                         " />
          <node concept="2NCZwO" id="1YUFCeGolI_" role="3z_lpI">
            <node concept="2NCMab" id="1YUFCeGolIA" role="2NCMaf">
              <ref role="2NCMaa" to="e1tx:1w5Xuj1QYPN" resolve="Components" />
            </node>
            <node concept="2NCMab" id="1YUFCeGolIB" role="2NCMaf">
              <ref role="2NCMaa" to="e1tx:1w5Xuj1RI6M" resolve="Nuller" />
            </node>
          </node>
          <node concept="3z_lpK" id="1SYZy6PNATF" role="3z_lpH">
            <ref role="3z_lpL" to="e1tx:1w5Xuj1RIph" resolve="processor_process" />
          </node>
        </node>
        <node concept="1_0LV8" id="3D8Uf612_jA" role="1_0VJ0">
          <node concept="19SGf9" id="3D8Uf612_jB" role="1_0LWR">
            <node concept="19SUe$" id="3D8Uf612_jC" role="19SJt6">
              <property role="19SUeA" value="After you add only the provided port, you get an error that complains that the component needs to implement the operations defined by the port's interface; we can get those automatically generated by using a quick fix from the intentions menu on the provided port. This gets us the following: " />
            </node>
          </node>
        </node>
        <node concept="3z_lpU" id="1SYZy6PNmQP" role="1_0VJ0">
          <property role="3z_lpW" value="mbeddr" />
          <property role="3z_lpJ" value="true" />
          <property role="3z_lpV" value="exported component Nuller extends nothing {                             &#10;  provides TrackpointProcessor processor                                &#10;  Trackpoint* processor_process(Trackpoint* p) &lt;= op processor.process {&#10;  p.alt = 42 m;                                                         &#10;  return p;                                                             &#10;} runnable processor_process                                            &#10;} component Nuller                                                      " />
          <node concept="2NCZwO" id="1SYZy6PNmQQ" role="3z_lpI">
            <node concept="2NCMab" id="1SYZy6PNmQR" role="2NCMaf">
              <ref role="2NCMaa" to="e1tx:1w5Xuj1QYPN" resolve="Components" />
            </node>
            <node concept="2NCMab" id="1SYZy6PNmQS" role="2NCMaf">
              <ref role="2NCMaa" to="e1tx:1w5Xuj1RI6M" resolve="Nuller" />
            </node>
          </node>
        </node>
        <node concept="1_0LV8" id="3D8Uf612AqB" role="1_0VJ0">
          <node concept="19SGf9" id="3D8Uf612AqC" role="1_0LWR">
            <node concept="19SUe$" id="3D8Uf612AqD" role="19SJt6">
              <property role="19SUeA" value="The " />
            </node>
            <node concept="3z_lpY" id="1SYZy6PQ7LN" role="19SJt6">
              <node concept="2NCZwO" id="1SYZy6PQ7LO" role="3z_lpZ">
                <node concept="2NCMab" id="1SYZy6PQ7M5" role="2NCMaf">
                  <ref role="2NCMaa" to="e1tx:1w5Xuj1QYPN" resolve="Components" />
                </node>
                <node concept="2NCMab" id="1SYZy6PQ7Ma" role="2NCMaf">
                  <ref role="2NCMaa" to="e1tx:1w5Xuj1RI6M" resolve="Nuller" />
                </node>
                <node concept="2NCMab" id="1SYZy6PQ7Mh" role="2NCMaf">
                  <ref role="2NCMaa" to="e1tx:1w5Xuj1RIph" resolve="processor_process" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="1SYZy6PQ7LM" role="19SJt6">
              <property role="19SUeA" value=" runnable is triggered by an incoming invocation of the " />
            </node>
            <node concept="3z_lpY" id="1SYZy6PWJCA" role="19SJt6">
              <node concept="2NCZwO" id="1SYZy6PWJCB" role="3z_lpZ">
                <node concept="2NCMab" id="1SYZy6PWJCX" role="2NCMaf">
                  <ref role="2NCMaa" to="e1tx:1w5Xuj1QYPN" resolve="Components" />
                </node>
                <node concept="2NCMab" id="1SYZy6PWJD2" role="2NCMaf">
                  <ref role="2NCMaa" to="e1tx:1w5Xuj1QYPS" resolve="TrackpointProcessor" />
                </node>
                <node concept="2NCMab" id="1SYZy6PWJD9" role="2NCMaf">
                  <ref role="2NCMaa" to="e1tx:1w5Xuj1QYPT" resolve="process" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="3D8Uf612Arn" role="19SJt6">
              <property role="19SUeA" value=" operation defined in the " />
            </node>
            <node concept="3z_lpY" id="1SYZy6PWJDx" role="19SJt6">
              <node concept="2NCZwO" id="1SYZy6PWJDy" role="3z_lpZ">
                <node concept="2NCMab" id="1SYZy6PWJDU" role="2NCMaf">
                  <ref role="2NCMaa" to="e1tx:1w5Xuj1QYPN" resolve="Components" />
                </node>
                <node concept="2NCMab" id="1SYZy6PWJDZ" role="2NCMaf">
                  <ref role="2NCMaa" to="e1tx:1w5Xuj1QYPS" resolve="TrackpointProcessor" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="3D8Uf612Ars" role="19SJt6">
              <property role="19SUeA" value=" interface. The " />
            </node>
            <node concept="3z_lpY" id="1SYZy6PWJEC" role="19SJt6">
              <node concept="2NCZwO" id="1SYZy6PWJED" role="3z_lpZ">
                <node concept="2NCMab" id="1SYZy6PWJEZ" role="2NCMaf">
                  <ref role="2NCMaa" to="e1tx:1w5Xuj1QYPN" resolve="Components" />
                </node>
                <node concept="2NCMab" id="1SYZy6PWJF4" role="2NCMaf">
                  <ref role="2NCMaa" to="e1tx:1w5Xuj1RI6M" resolve="Nuller" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="1SYZy6PWJEB" role="19SJt6">
              <property role="19SUeA" value=" simply sets the altitute to zero." />
            </node>
          </node>
        </node>
        <node concept="1_0LV8" id="3D8Uf612Atj" role="1_0VJ0">
          <node concept="19SGf9" id="3D8Uf612Atk" role="1_0LWR">
            <node concept="19SUe$" id="3D8Uf612Atl" role="19SJt6">
              <property role="19SUeA" value="Let us now write a simple test case to check this component. To do that, we first have to create an instance of " />
            </node>
            <node concept="1jUjqm" id="3D8Uf612B06" role="19SJt6">
              <node concept="19SGf9" id="3D8Uf612B07" role="$DsGW">
                <node concept="19SUe$" id="3D8Uf612B09" role="19SJt6">
                  <property role="19SUeA" value="Nuller" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="3D8Uf612B0a" role="19SJt6">
              <property role="19SUeA" value=". We create an " />
            </node>
            <node concept="28N2ik" id="1SYZy6PWJF7" role="19SJt6">
              <node concept="19SGf9" id="1SYZy6PWJF8" role="$DsGW">
                <node concept="19SUe$" id="1SYZy6PWJF9" role="19SJt6">
                  <property role="19SUeA" value="instance configuration" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="1SYZy6PWJFb" role="19SJt6">
              <property role="19SUeA" value=" that defines exactly one instance of this component. Also, we add an adapter. An adapter makes a provided port of a component instance (" />
            </node>
            <node concept="1jUjqm" id="3D8Uf612B0b" role="19SJt6">
              <node concept="19SGf9" id="3D8Uf612B0c" role="$DsGW">
                <node concept="19SUe$" id="3D8Uf612B0e" role="19SJt6">
                  <property role="19SUeA" value="Nuller.processor" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="3D8Uf612B0f" role="19SJt6">
              <property role="19SUeA" value=") available to a regular C program under the specified name " />
            </node>
            <node concept="1jUjqm" id="3D8Uf612B0g" role="19SJt6">
              <node concept="19SGf9" id="3D8Uf612B0h" role="$DsGW">
                <node concept="19SUe$" id="3D8Uf612B0j" role="19SJt6">
                  <property role="19SUeA" value="n" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="3D8Uf612B0k" role="19SJt6">
              <property role="19SUeA" value=":" />
            </node>
          </node>
        </node>
        <node concept="3z_lpU" id="3D8Uf615TfS" role="1_0VJ0">
          <property role="3z_lpW" value="mbeddr" />
          <property role="3z_lpJ" value="true" />
          <property role="3z_lpV" value="instances nullerInstancesFailing {&#10;  instance Nuller nuller          &#10;  adapt n -&gt; nuller.processor     &#10;}                                 " />
          <node concept="2NCZwO" id="1YUFCeGolAP" role="3z_lpI">
            <node concept="2NCMab" id="1YUFCeGolAQ" role="2NCMaf">
              <ref role="2NCMaa" to="e1tx:1w5Xuj1QYPN" resolve="Components" />
            </node>
            <node concept="2NCMab" id="1YUFCeGolAR" role="2NCMaf">
              <ref role="2NCMaa" to="e1tx:1w5Xuj1RIpU" resolve="nullerInstancesFailing" />
            </node>
          </node>
        </node>
        <node concept="1_0LV8" id="3D8Uf615Thp" role="1_0VJ0">
          <node concept="19SGf9" id="3D8Uf615Thq" role="1_0LWR">
            <node concept="19SUe$" id="3D8Uf615Th$" role="19SJt6">
              <property role="19SUeA" value="Now we can write a test case that accesses the " />
            </node>
            <node concept="1jUjqm" id="3D8Uf615TP9" role="19SJt6">
              <node concept="19SGf9" id="3D8Uf615TPa" role="$DsGW">
                <node concept="19SUe$" id="3D8Uf615TPc" role="19SJt6">
                  <property role="19SUeA" value="n" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="3D8Uf615TPd" role="19SJt6">
              <property role="19SUeA" value=" adapter -- and through it, the " />
            </node>
            <node concept="1jUjqm" id="3D8Uf615TPe" role="19SJt6">
              <node concept="19SGf9" id="3D8Uf615TPf" role="$DsGW">
                <node concept="19SUe$" id="3D8Uf615TPh" role="19SJt6">
                  <property role="19SUeA" value="processor" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="3D8Uf615TPi" role="19SJt6">
              <property role="19SUeA" value=" port of the " />
            </node>
            <node concept="1jUjqm" id="3D8Uf615TPj" role="19SJt6">
              <node concept="19SGf9" id="3D8Uf615TPk" role="$DsGW">
                <node concept="19SUe$" id="3D8Uf615TPm" role="19SJt6">
                  <property role="19SUeA" value="Nuller" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="3D8Uf615TPn" role="19SJt6">
              <property role="19SUeA" value=" component instance " />
            </node>
            <node concept="1jUjqm" id="3D8Uf615TPo" role="19SJt6">
              <node concept="19SGf9" id="3D8Uf615TPp" role="$DsGW">
                <node concept="19SUe$" id="3D8Uf615TPr" role="19SJt6">
                  <property role="19SUeA" value="nuller" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="3D8Uf615TPs" role="19SJt6">
              <property role="19SUeA" value=". We create a new " />
            </node>
            <node concept="1jUjqm" id="3D8Uf615TPt" role="19SJt6">
              <node concept="19SGf9" id="3D8Uf615TPu" role="$DsGW">
                <node concept="19SUe$" id="3D8Uf615TPw" role="19SJt6">
                  <property role="19SUeA" value="Trackpoint" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="3D8Uf615TPx" role="19SJt6">
              <property role="19SUeA" value=", using 0 as the " />
            </node>
            <node concept="1jUjqm" id="3D8Uf615TPy" role="19SJt6">
              <node concept="19SGf9" id="3D8Uf615TPz" role="$DsGW">
                <node concept="19SUe$" id="3D8Uf615TP_" role="19SJt6">
                  <property role="19SUeA" value="id" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="3D8Uf615TPA" role="19SJt6">
              <property role="19SUeA" value=" -- intended to trigger a contract violation (remember " />
            </node>
            <node concept="1jUjqm" id="3D8Uf615TPB" role="19SJt6">
              <node concept="19SGf9" id="3D8Uf615TPC" role="$DsGW">
                <node concept="19SUe$" id="3D8Uf615TPE" role="19SJt6">
                  <property role="19SUeA" value="pre(1) p-&gt;id != 0" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="3D8Uf615TPF" role="19SJt6">
              <property role="19SUeA" value="). To enter the " />
            </node>
            <node concept="1jUjqm" id="3D8Uf615TPG" role="19SJt6">
              <node concept="19SGf9" id="3D8Uf615TPH" role="$DsGW">
                <node concept="19SUe$" id="3D8Uf615TPJ" role="19SJt6">
                  <property role="19SUeA" value="&amp;tp" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="3D8Uf615TPK" role="19SJt6">
              <property role="19SUeA" value=" just enter a " />
            </node>
            <node concept="1jUjqm" id="3D8Uf615TPL" role="19SJt6">
              <node concept="19SGf9" id="3D8Uf615TPM" role="$DsGW">
                <node concept="19SUe$" id="3D8Uf615TPO" role="19SJt6">
                  <property role="19SUeA" value="&amp;" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="3D8Uf615TPP" role="19SJt6">
              <property role="19SUeA" value=", followed by " />
            </node>
            <node concept="1jUjqm" id="3D8Uf615TPQ" role="19SJt6">
              <node concept="19SGf9" id="3D8Uf615TPR" role="$DsGW">
                <node concept="19SUe$" id="3D8Uf615TPT" role="19SJt6">
                  <property role="19SUeA" value="tp" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="3D8Uf615TPU" role="19SJt6">
              <property role="19SUeA" value=". " />
            </node>
          </node>
        </node>
        <node concept="3z_lpU" id="3D8Uf615V9e" role="1_0VJ0">
          <property role="3z_lpW" value="mbeddr" />
          <property role="3z_lpJ" value="true" />
          <property role="3z_lpV" value="                                       &#10;section testNullerFailing {            &#10;  instances nullerInstancesFailing {   &#10;  instance Nuller nuller               &#10;  adapt n -&gt; nuller.processor          &#10;}                                      &#10;                                       &#10;  exported testcase testNullerFailing {&#10;  initialize nullerInstancesFailing;   &#10;  Trackpoint tp = {                    &#10;  id = 0,                              &#10;  time = 0 s,                          &#10;  alt = 1000 m                         &#10;};                                     &#10;  n.process(&amp;tp);                      &#10;  assert(0) tp.alt == 0 m;             &#10;} testNullerFailing(test case)         &#10;} section testNullerFailing            " />
          <node concept="2NCZwO" id="1YUFCeGolA1" role="3z_lpI">
            <node concept="2NCMab" id="1YUFCeGolA2" role="2NCMaf">
              <ref role="2NCMaa" to="e1tx:1w5Xuj1QYPN" resolve="Components" />
            </node>
            <node concept="2NCMab" id="1YUFCeGolA3" role="2NCMaf">
              <ref role="2NCMaa" to="e1tx:1w5Xuj1SfLZ" resolve="testNullerFailing" />
            </node>
          </node>
        </node>
        <node concept="1_0LV8" id="3D8Uf615WOM" role="1_0VJ0">
          <node concept="19SGf9" id="3D8Uf615WON" role="1_0LWR">
            <node concept="19SUe$" id="3D8Uf615WOO" role="19SJt6">
              <property role="19SUeA" value="Before we can run this, we have to make sure that the " />
            </node>
            <node concept="1jUjqm" id="3D8Uf615WQE" role="19SJt6">
              <node concept="19SGf9" id="3D8Uf615WQF" role="$DsGW">
                <node concept="19SUe$" id="3D8Uf615WQH" role="19SJt6">
                  <property role="19SUeA" value="instances" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="3D8Uf615WQI" role="19SJt6">
              <property role="19SUeA" value=" are initialized (cf. the warning you get on them). We do this right in the beginning of the test case. We then create a trackpoint and assert that it is correctly nulled by the " />
            </node>
            <node concept="1jUjqm" id="1SYZy6PWSv_" role="19SJt6">
              <node concept="19SGf9" id="1SYZy6PWSvA" role="$DsGW">
                <node concept="19SUe$" id="1SYZy6PWSvB" role="19SJt6">
                  <property role="19SUeA" value="Nuller" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="1SYZy6PWSv$" role="19SJt6">
              <property role="19SUeA" value=". " />
            </node>
          </node>
        </node>
        <node concept="3z_lpU" id="1SYZy6PWRQW" role="1_0VJ0">
          <property role="3z_lpW" value="mbeddr" />
          <property role="3z_lpJ" value="true" />
          <property role="3z_lpV" value="                                       &#10;section testNullerFailing {            &#10;  instances nullerInstancesFailing {   &#10;  instance Nuller nuller               &#10;  adapt n -&gt; nuller.processor          &#10;}                                      &#10;                                       &#10;  exported testcase testNullerFailing {&#10;  initialize nullerInstancesFailing;   &#10;  Trackpoint tp = {                    &#10;  id = 0,                              &#10;  time = 0 s,                          &#10;  alt = 1000 m                         &#10;};                                     &#10;  n.process(&amp;tp);                      &#10;  assert(0) tp.alt == 0 m;             &#10;} testNullerFailing(test case)         &#10;} section testNullerFailing            " />
          <node concept="2NCZwO" id="1SYZy6PWRQX" role="3z_lpI">
            <node concept="2NCMab" id="1SYZy6PWRUa" role="2NCMaf">
              <ref role="2NCMaa" to="e1tx:1w5Xuj1QYPN" resolve="Components" />
            </node>
            <node concept="2NCMab" id="1SYZy6PWRUf" role="2NCMaf">
              <ref role="2NCMaa" to="e1tx:1w5Xuj1SfLZ" resolve="testNullerFailing" />
            </node>
          </node>
        </node>
        <node concept="1_0LV8" id="3D8Uf615XXa" role="1_0VJ0">
          <node concept="19SGf9" id="3D8Uf615XXb" role="1_0LWR">
            <node concept="19SUe$" id="3D8Uf615XXc" role="19SJt6">
              <property role="19SUeA" value="To make the system work, you have to import the " />
            </node>
            <node concept="1jUjqm" id="3D8Uf615XZ8" role="19SJt6">
              <node concept="19SGf9" id="3D8Uf615XZ9" role="$DsGW">
                <node concept="19SUe$" id="3D8Uf615XZb" role="19SJt6">
                  <property role="19SUeA" value="Components" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="3D8Uf615XZc" role="19SJt6">
              <property role="19SUeA" value=" module into the " />
            </node>
            <node concept="3z_lpY" id="1SYZy6PWSN6" role="19SJt6">
              <node concept="2NCZwO" id="1SYZy6PWSN7" role="3z_lpZ">
                <node concept="2NCMab" id="1SYZy6PWSNw" role="2NCMaf">
                  <ref role="2NCMaa" to="e1tx:7VsgA5L654u" resolve="Main" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="1SYZy6PWSN5" role="19SJt6">
              <property role="19SUeA" value=" module so you can call the " />
            </node>
            <node concept="3z_lpY" id="1SYZy6PWSQe" role="19SJt6">
              <node concept="2NCZwO" id="1SYZy6PWSQf" role="3z_lpZ">
                <node concept="2NCMab" id="1SYZy6PWSQF" role="2NCMaf">
                  <ref role="2NCMaa" to="e1tx:1w5Xuj1QYPN" resolve="Components" />
                </node>
                <node concept="2NCMab" id="1SYZy6PX0Xy" role="2NCMaf">
                  <ref role="2NCMaa" to="e1tx:1w5Xuj1SfLZ" resolve="testNullerFailing" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="3D8Uf615XZm" role="19SJt6">
              <property role="19SUeA" value=" test case from the " />
            </node>
            <node concept="1jUjqm" id="3D8Uf615XZn" role="19SJt6">
              <node concept="19SGf9" id="3D8Uf615XZo" role="$DsGW">
                <node concept="19SUe$" id="3D8Uf615XZq" role="19SJt6">
                  <property role="19SUeA" value="test" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="3D8Uf615XZr" role="19SJt6">
              <property role="19SUeA" value=" expression in " />
            </node>
            <node concept="1jUjqm" id="3D8Uf615XZs" role="19SJt6">
              <node concept="19SGf9" id="3D8Uf615XZt" role="$DsGW">
                <node concept="19SUe$" id="3D8Uf615XZv" role="19SJt6">
                  <property role="19SUeA" value="Main" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="3D8Uf615XZw" role="19SJt6">
              <property role="19SUeA" value=". In the build configuration, you have to add the missing modules to the executable (using the quick fix). Finally, also in the build configuration, you have to add the " />
            </node>
            <node concept="1jUjqm" id="3D8Uf615XZx" role="19SJt6">
              <node concept="19SGf9" id="3D8Uf615XZy" role="$DsGW">
                <node concept="19SUe$" id="3D8Uf615XZ$" role="19SJt6">
                  <property role="19SUeA" value="components" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="3D8Uf615XZ_" role="19SJt6">
              <property role="19SUeA" value=" configuration item:" />
            </node>
          </node>
        </node>
        <node concept="1DKdXA" id="3D8Uf615Zbh" role="1_0VJ0">
          <property role="1DKdXC" value="mbeddr" />
          <property role="1DKdXF" value="Configuration Items:&#10;  reporting: printf (add labels false) &#10;  physical units (config = Units Declarations (mbeddr.tutorial.main.m1)) &#10;  components: no middleware         &#10;              wire statically: false&#10;" />
        </node>
        <node concept="1_0LV8" id="3D8Uf617IDD" role="1_0VJ0">
          <node concept="19SGf9" id="3D8Uf617IDE" role="1_0LWR">
            <node concept="19SUe$" id="3D8Uf617IDF" role="19SJt6">
              <property role="19SUeA" value="You can now rebuild and run. As a result, you'll get contract failures: " />
            </node>
          </node>
        </node>
        <node concept="1DKdXA" id="3D8Uf61bghC" role="1_0VJ0">
          <property role="1DKdXF" value="./MbeddrTutorial&#10;$$runningTest: running test () @FunctionPointers:test_testProcessing:0#767515563077315487&#10;$$runningTest: running test () @Components:test_testNuller:0#767515563077315487&#10;$$contractFailed: contract failed (op=0, pc=1) @Components:null:-1#1731059994647588232&#10;$$contractFailed: contract faied (op=0, pc=2) @Components:null:-1#1731059994647588253&#10;" />
          <property role="1DKdXC" value="mbeddr" />
        </node>
        <node concept="1_0LV8" id="3D8Uf61bi87" role="1_0VJ0">
          <node concept="19SGf9" id="3D8Uf61bi88" role="1_0LWR">
            <node concept="19SUe$" id="3D8Uf61bi89" role="19SJt6">
              <property role="19SUeA" value="We can fix these problems by changing the test data to conform to the contract, i.e.  " />
            </node>
          </node>
        </node>
        <node concept="3z_lpU" id="3D8Uf61b_bE" role="1_0VJ0">
          <property role="3z_lpW" value="mbeddr" />
          <property role="3z_lpJ" value="true" />
          <property role="3z_lpV" value="                                  &#10;section testNullerOK {            &#10;  instances nullerInstancesOK {   &#10;  instance Nuller nuller          &#10;  adapt n -&gt; nuller.processor     &#10;}                                 &#10;                                  &#10;  exported testcase testNullerOK {&#10;  initialize nullerInstancesOK;   &#10;  Trackpoint tp = {               &#10;  id = 10,                        &#10;  time = 10 s,                    &#10;  alt = 100 m                     &#10;};                                &#10;  n.process(&amp;tp);                 &#10;  assert(0) tp.alt == 0 m;        &#10;} testNullerOK(test case)         &#10;} section testNullerOK            " />
          <node concept="2NCZwO" id="1YUFCeGolGS" role="3z_lpI">
            <node concept="2NCMab" id="1YUFCeGolGT" role="2NCMaf">
              <ref role="2NCMaa" to="e1tx:1w5Xuj1QYPN" resolve="Components" />
            </node>
            <node concept="2NCMab" id="6Fkja4cg7Bv" role="2NCMaf">
              <ref role="2NCMaa" to="e1tx:6Fkja4ceTWX" resolve="testNullerOK" />
            </node>
          </node>
        </node>
        <node concept="1_0LV8" id="3D8Uf61b_ej" role="1_0VJ0">
          <node concept="19SGf9" id="3D8Uf61b_ek" role="1_0LWR">
            <node concept="19SUe$" id="3D8Uf61b_el" role="19SJt6">
              <property role="19SUeA" value="Let us provoke another contract violation by returning from the implementation in the " />
            </node>
            <node concept="1jUjqm" id="3D8Uf61b_en" role="19SJt6">
              <node concept="19SGf9" id="3D8Uf61b_eo" role="$DsGW">
                <node concept="19SUe$" id="3D8Uf61b_eq" role="19SJt6">
                  <property role="19SUeA" value="Nuller" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="3D8Uf61b_er" role="19SJt6">
              <property role="19SUeA" value=" component a " />
            </node>
            <node concept="1jUjqm" id="3D8Uf61b_es" role="19SJt6">
              <node concept="19SGf9" id="3D8Uf61b_et" role="$DsGW">
                <node concept="19SUe$" id="3D8Uf61b_ev" role="19SJt6">
                  <property role="19SUeA" value="Trackpoint" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="3D8Uf61b_ew" role="19SJt6">
              <property role="19SUeA" value=" whose " />
            </node>
            <node concept="1jUjqm" id="3D8Uf61b_ex" role="19SJt6">
              <node concept="19SGf9" id="3D8Uf61b_ey" role="$DsGW">
                <node concept="19SUe$" id="3D8Uf61b_e$" role="19SJt6">
                  <property role="19SUeA" value="id" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="3D8Uf61b_e_" role="19SJt6">
              <property role="19SUeA" value=" is 0. " />
            </node>
          </node>
        </node>
        <node concept="1_0LV8" id="3D8Uf61b_kH" role="1_0VJ0">
          <node concept="19SGf9" id="3D8Uf61b_kI" role="1_0LWR">
            <node concept="19SUe$" id="3D8Uf61b_kJ" role="19SJt6">
              <property role="19SUeA" value="Running it again provokes another contract failure. Notice how the contract is specified on the " />
            </node>
            <node concept="28N2ik" id="3D8Uf61b_kL" role="19SJt6">
              <node concept="19SGf9" id="3D8Uf61b_kM" role="$DsGW">
                <node concept="19SUe$" id="3D8Uf61b_kO" role="19SJt6">
                  <property role="19SUeA" value="interface" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="3D8Uf61b_kP" role="19SJt6">
              <property role="19SUeA" value=", but they are checked for each " />
            </node>
            <node concept="28N2ik" id="3D8Uf61b_kQ" role="19SJt6">
              <node concept="19SGf9" id="3D8Uf61b_kR" role="$DsGW">
                <node concept="19SUe$" id="3D8Uf61b_kT" role="19SJt6">
                  <property role="19SUeA" value="component" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="3D8Uf61b_kU" role="19SJt6">
              <property role="19SUeA" value=" implementing the interface. There is no way how an implementation can violate the interface contract without the respective error being reported!" />
            </node>
          </node>
        </node>
      </node>
      <node concept="1_0VNX" id="1SYZy6PX9JI" role="1_0VJ0">
        <property role="TrG5h" value="ContractVerification" />
        <property role="1_0VJr" value="Verifying Contracts Statically" />
        <node concept="1_0LV8" id="1SYZy6PX9WS" role="1_0VJ0">
          <node concept="19SGf9" id="1SYZy6PX9WT" role="1_0LWR">
            <node concept="19SUe$" id="1SYZy6PX9X1" role="19SJt6" />
            <node concept="3d4VFM" id="1SYZy6PX9WY" role="19SJt6">
              <node concept="19SGf9" id="1SYZy6PX9WZ" role="3d4Uyx">
                <node concept="19SUe$" id="1SYZy6PX9X0" role="19SJt6">
                  <property role="19SUeA" value="Need to fill in the static verification part here." />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="1SYZy6PX9X2" role="19SJt6" />
          </node>
        </node>
      </node>
      <node concept="1_0VNX" id="3D8Uf61b_K3" role="1_0VJ0">
        <property role="TrG5h" value="collab" />
        <property role="1_0VJr" value="Collaborating and Stateful Components" />
        <node concept="1_0LV8" id="3zwhDFH0fP$" role="1_0VJ0">
          <node concept="19SGf9" id="3zwhDFH0fP_" role="1_0LWR">
            <node concept="19SUe$" id="3zwhDFH0fPA" role="19SJt6">
              <property role="19SUeA" value="Let us look at interactions between components. We create a new interface, the \n" />
            </node>
            <node concept="3z_lpY" id="1SYZy6Q6Jwm" role="19SJt6">
              <node concept="2NCZwO" id="1SYZy6Q6Jwn" role="3z_lpZ">
                <node concept="2NCMab" id="1SYZy6Q6Jw$" role="2NCMaf">
                  <ref role="2NCMaa" to="e1tx:1w5Xuj1QYPN" resolve="Components" />
                </node>
                <node concept="2NCMab" id="1SYZy6Q6JwD" role="2NCMaf">
                  <ref role="2NCMaa" to="e1tx:1w5Xuj1RPXU" resolve="TrackpointStore1" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="1SYZy6Q6Jwl" role="19SJt6">
              <property role="19SUeA" value=". It can store and return trackpoints" />
            </node>
            <node concept="anbfL" id="3zwhDFH0h3g" role="19SJt6">
              <node concept="19SGf9" id="3zwhDFH0h3h" role="anbgW">
                <node concept="19SUe$" id="1SYZy6Q8Dd0" role="19SJt6">
                  <property role="19SUeA" value="sure, it is completely overdone to separate this out into a separate interface/component, but for the sake of the tutorial it makes sense." />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="3zwhDFH0h3f" role="19SJt6">
              <property role="19SUeA" value=". Here is the basic interface: " />
            </node>
          </node>
        </node>
        <node concept="3z_lpU" id="1SYZy6QE3ci" role="1_0VJ0">
          <property role="3z_lpW" value="mbeddr" />
          <property role="3z_lpJ" value="true" />
          <property role="3z_lpV" value="exported cs interface TrackpointStore1 {&#10;  void store(Trackpoint* tp)            &#10;  Trackpoint* get()                     &#10;  Trackpoint* take()                    &#10;  query boolean isEmpty()               &#10;}                                       " />
          <node concept="2NCZwO" id="1SYZy6QE3ck" role="3z_lpI">
            <node concept="2NCMab" id="1SYZy6QE3cl" role="2NCMaf">
              <ref role="2NCMaa" to="e1tx:1w5Xuj1QYPN" resolve="Components" />
            </node>
            <node concept="2NCMab" id="1SYZy6QE3cm" role="2NCMaf">
              <ref role="2NCMaa" to="e1tx:1w5Xuj1RPXU" resolve="TrackpointStore1" />
            </node>
          </node>
          <node concept="2Cuv_b" id="1SYZy6QIt3n" role="3z_lpH">
            <ref role="2Cuq_M" to="v7ag:5HTuIUP_k1N" resolve="PrePostCondition" />
          </node>
        </node>
        <node concept="1_0LV8" id="A6HWGwJm_$" role="1_0VJ0">
          <node concept="19SGf9" id="A6HWGwJm__" role="1_0LWR">
            <node concept="19SUe$" id="A6HWGwJm_A" role="19SJt6">
              <property role="19SUeA" value="Let us again think about the semantics: you shouldn't be able to get or take stuff from the store if it is empty, you should not put stuff into it when it is full, etc. These things can be expressed as pre- and postconditions. The following should be pretty self-explaining. The only new thing is the " />
            </node>
            <node concept="1jUjqm" id="A6HWGwJm_X" role="19SJt6">
              <node concept="19SGf9" id="A6HWGwJm_Y" role="$DsGW">
                <node concept="19SUe$" id="A6HWGwJm_Z" role="19SJt6">
                  <property role="19SUeA" value="query" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="A6HWGwJm_W" role="19SJt6">
              <property role="19SUeA" value=" operation. Queries can be used from inside pre- and postconditions, but cannot modify state " />
            </node>
            <node concept="anbfL" id="A6HWGwJmA6" role="19SJt6">
              <node concept="19SGf9" id="A6HWGwJmA7" role="anbgW">
                <node concept="19SUe$" id="A6HWGwJmA8" role="19SJt6">
                  <property role="19SUeA" value="Currently this is not yet checked. But it will be." />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="A6HWGwJmA5" role="19SJt6" />
          </node>
        </node>
        <node concept="3z_lpU" id="w_3lYHDaUM" role="1_0VJ0">
          <property role="3z_lpW" value="mbeddr" />
          <property role="3z_lpJ" value="true" />
          <property role="3z_lpV" value="exported cs interface TrackpointStore1 {&#10;  void store(Trackpoint* tp)            &#10;  pre(0) isEmpty()                      &#10;  pre(1) tp != null                     &#10;  post(2) !isEmpty()                    &#10;  Trackpoint* get()                     &#10;  pre(0) !isEmpty()                     &#10;  Trackpoint* take()                    &#10;  pre(0) !isEmpty()                     &#10;  post(1) result != null                &#10;  post(2) isEmpty()                     &#10;  query boolean isEmpty()               &#10;}                                       " />
          <node concept="2NCZwO" id="1YUFCeGol_l" role="3z_lpI">
            <node concept="2NCMab" id="1YUFCeGol_m" role="2NCMaf">
              <ref role="2NCMaa" to="e1tx:1w5Xuj1QYPN" resolve="Components" />
            </node>
            <node concept="2NCMab" id="1YUFCeGol_n" role="2NCMaf">
              <ref role="2NCMaa" to="e1tx:1w5Xuj1RPXU" resolve="TrackpointStore1" />
            </node>
          </node>
        </node>
        <node concept="1_0LV8" id="A6HWGwJAbw" role="1_0VJ0">
          <node concept="19SGf9" id="A6HWGwJAbx" role="1_0LWR">
            <node concept="19SUe$" id="A6HWGwJAby" role="19SJt6">
              <property role="19SUeA" value="These pre- and postconditions mostly express a valid sequence of the operation calls: you have to call " />
            </node>
            <node concept="1jUjqm" id="A6HWGwJAc4" role="19SJt6">
              <node concept="19SGf9" id="A6HWGwJAc5" role="$DsGW">
                <node concept="19SUe$" id="A6HWGwJAc6" role="19SJt6">
                  <property role="19SUeA" value="store" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="A6HWGwJAc3" role="19SJt6">
              <property role="19SUeA" value=" before you can call " />
            </node>
            <node concept="1jUjqm" id="A6HWGwJAcd" role="19SJt6">
              <node concept="19SGf9" id="A6HWGwJAce" role="$DsGW">
                <node concept="19SUe$" id="A6HWGwJAcf" role="19SJt6">
                  <property role="19SUeA" value="get" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="A6HWGwJAcc" role="19SJt6">
              <property role="19SUeA" value=", etc. This can be expressed directly with protocols, as implemented in " />
            </node>
            <node concept="3z_lpY" id="1SYZy6QOkGd" role="19SJt6">
              <node concept="2NCZwO" id="1SYZy6QOkGe" role="3z_lpZ">
                <node concept="2NCMab" id="1SYZy6QOkGs" role="2NCMaf">
                  <ref role="2NCMaa" to="e1tx:1w5Xuj1QYPN" resolve="Components" />
                </node>
                <node concept="2NCMab" id="1SYZy6QOkGx" role="2NCMaf">
                  <ref role="2NCMaa" to="e1tx:1w5Xuj1RPZ9" resolve="TrackpointStore2" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="1SYZy6QOkGf" role="19SJt6">
              <property role="19SUeA" value=":" />
            </node>
          </node>
        </node>
        <node concept="3z_lpU" id="3UY8BSpCwHQ" role="1_0VJ0">
          <property role="3z_lpW" value="mbeddr" />
          <property role="3z_lpJ" value="true" />
          <property role="3z_lpV" value="exported cs interface TrackpointStore2 {&#10;                                        &#10;  void store(Trackpoint* tp)            &#10;  protocol init(0) -&gt; new full(1)       &#10;                                        &#10;  Trackpoint* get()                     &#10;  protocol full -&gt; full                 &#10;                                        &#10;  Trackpoint* take()                    &#10;  post(0) result != null                &#10;  protocol full -&gt; init(0)              &#10;                                        &#10;  query boolean isEmpty()               &#10;}                                       " />
          <node concept="2NCZwO" id="1YUFCeGol$s" role="3z_lpI">
            <node concept="2NCMab" id="1YUFCeGol$t" role="2NCMaf">
              <ref role="2NCMaa" to="e1tx:1w5Xuj1QYPN" resolve="Components" />
            </node>
            <node concept="2NCMab" id="1YUFCeGol$u" role="2NCMaf">
              <ref role="2NCMaa" to="e1tx:1w5Xuj1RPZ9" resolve="TrackpointStore2" />
            </node>
          </node>
        </node>
        <node concept="1_0LV8" id="1i2OI5uzHxZ" role="1_0VJ0">
          <node concept="19SGf9" id="1i2OI5uzHy0" role="1_0LWR">
            <node concept="19SUe$" id="1i2OI5uzH__" role="19SJt6">
              <property role="19SUeA" value="You can add a new protocol using the respective intention. The protocol is essentially a state machine. On each operation you can specify the transition from the old to the new state. We have one special state which is called initial. On a transition you can either jump into an already existing state or create a new state and then directy move into that. I.e. you see on the " />
            </node>
            <node concept="3z_lpY" id="1i2OI5uzKui" role="19SJt6">
              <node concept="2NCZwO" id="1i2OI5uzKup" role="3z_lpZ">
                <node concept="2NCMab" id="1i2OI5uzKuq" role="2NCMaf">
                  <ref role="2NCMaa" to="e1tx:1w5Xuj1QYPN" resolve="Components" />
                </node>
                <node concept="2NCMab" id="1i2OI5uzUtg" role="2NCMaf">
                  <ref role="2NCMaa" to="e1tx:1w5Xuj1RPZa" resolve="store" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="1i2OI5uzKuk" role="19SJt6">
              <property role="19SUeA" value=" operation that we transition from the " />
            </node>
            <node concept="1jUjqm" id="1i2OI5u$1zW" role="19SJt6">
              <node concept="19SGf9" id="1i2OI5u$1zX" role="$DsGW">
                <node concept="19SUe$" id="1i2OI5u$1zY" role="19SJt6">
                  <property role="19SUeA" value="initial" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="1i2OI5u$1zZ" role="19SJt6">
              <property role="19SUeA" value=" state into the newly created " />
            </node>
            <node concept="3z_lpY" id="1i2OI5u$1$a" role="19SJt6">
              <node concept="2NCZwO" id="1i2OI5u$1$q" role="3z_lpZ">
                <node concept="2NCMab" id="1i2OI5u$1$r" role="2NCMaf">
                  <ref role="2NCMaa" to="e1tx:1w5Xuj1QYPN" resolve="Components" />
                </node>
                <node concept="2NCMab" id="1i2OI5u$1$x" role="2NCMaf">
                  <ref role="2NCMaa" to="e1tx:1w5Xuj1RPZq" resolve="full" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="1i2OI5u$1$c" role="19SJt6">
              <property role="19SUeA" value=" state. The operation " />
            </node>
            <node concept="3z_lpY" id="1i2OI5u$1$_" role="19SJt6">
              <node concept="2NCZwO" id="1i2OI5u$1$U" role="3z_lpZ">
                <node concept="2NCMab" id="1i2OI5u$1$V" role="2NCMaf">
                  <ref role="2NCMaa" to="e1tx:1w5Xuj1QYPN" resolve="Components" />
                </node>
                <node concept="2NCMab" id="1i2OI5u$1_1" role="2NCMaf">
                  <ref role="2NCMaa" to="e1tx:1w5Xuj1RPZr" resolve="get" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="1i2OI5u$1$B" role="19SJt6">
              <property role="19SUeA" value=" can now make use of the previously created " />
            </node>
            <node concept="3z_lpY" id="1i2OI5u$4np" role="19SJt6">
              <node concept="2NCZwO" id="1i2OI5u$4nq" role="3z_lpZ">
                <node concept="2NCMab" id="1i2OI5u$4nr" role="2NCMaf">
                  <ref role="2NCMaa" to="e1tx:1w5Xuj1QYPN" resolve="Components" />
                </node>
                <node concept="2NCMab" id="1i2OI5u$4ns" role="2NCMaf">
                  <ref role="2NCMaa" to="e1tx:1w5Xuj1RPZq" resolve="full" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="1i2OI5u$4no" role="19SJt6">
              <property role="19SUeA" value=" state and does not create a new state. It is also worth mentioning that you can reset the protocol by transitioning into the " />
            </node>
            <node concept="1jUjqm" id="1i2OI5u$4nQ" role="19SJt6">
              <node concept="19SGf9" id="1i2OI5u$4nR" role="$DsGW">
                <node concept="19SUe$" id="1i2OI5u$4nS" role="19SJt6">
                  <property role="19SUeA" value="initial" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="1i2OI5u$4nT" role="19SJt6">
              <property role="19SUeA" value=" state again (as done in " />
            </node>
            <node concept="3z_lpY" id="1i2OI5u$4os" role="19SJt6">
              <node concept="2NCZwO" id="1i2OI5u$4ot" role="3z_lpZ">
                <node concept="2NCMab" id="1i2OI5u$4ou" role="2NCMaf">
                  <ref role="2NCMaa" to="e1tx:1w5Xuj1QYPN" resolve="Components" />
                </node>
                <node concept="2NCMab" id="1i2OI5u$4p2" role="2NCMaf">
                  <ref role="2NCMaa" to="e1tx:1w5Xuj1RPZ$" resolve="take" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="1i2OI5u$4or" role="19SJt6">
              <property role="19SUeA" value=")" />
            </node>
          </node>
        </node>
        <node concept="1_0LV8" id="w_3lYHDfZD" role="1_0VJ0">
          <node concept="19SGf9" id="w_3lYHDfZE" role="1_0LWR">
            <node concept="19SUe$" id="w_3lYHDfZF" role="19SJt6">
              <property role="19SUeA" value="The two interfaces are essentially equivalent, and both are checked at runtime and lead to errors if the contract is violated. " />
            </node>
          </node>
        </node>
        <node concept="1_0LV8" id="1SYZy6QOkG_" role="1_0VJ0">
          <node concept="19SGf9" id="1SYZy6QOkGA" role="1_0LWR">
            <node concept="19SUe$" id="1SYZy6QOkGB" role="19SJt6">
              <property role="19SUeA" value="We can now implement a component that provides this interface: " />
            </node>
            <node concept="3z_lpY" id="1SYZy6QQevm" role="19SJt6">
              <node concept="2NCZwO" id="1SYZy6QQevn" role="3z_lpZ">
                <node concept="2NCMab" id="1SYZy6QQevw" role="2NCMaf">
                  <ref role="2NCMaa" to="e1tx:1w5Xuj1QYPN" resolve="Components" />
                </node>
                <node concept="2NCMab" id="1SYZy6QQev_" role="2NCMaf">
                  <ref role="2NCMaa" to="e1tx:1w5Xuj1RQ09" resolve="InMemoryStorage" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="1SYZy6QQevl" role="19SJt6">
              <property role="19SUeA" value=" Most of the following code should be easy to understand based on what we have discussed so far. There are two new things. There is a field " />
            </node>
            <node concept="1jUjqm" id="w_3lYHDiqY" role="19SJt6">
              <node concept="19SGf9" id="w_3lYHDiqZ" role="$DsGW">
                <node concept="19SUe$" id="w_3lYHDir0" role="19SJt6">
                  <property role="19SUeA" value="Trackpoint* storedTP;" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="w_3lYHDiqX" role="19SJt6">
              <property role="19SUeA" value=" that represents component state." />
            </node>
          </node>
        </node>
        <node concept="3z_lpU" id="1SYZy6QQeyJ" role="1_0VJ0">
          <property role="3z_lpW" value="mbeddr" />
          <property role="3z_lpJ" value="true" />
          <property role="3z_lpV" value="Trackpoint* storedTP;" />
          <node concept="2NCZwO" id="1SYZy6QQeyL" role="3z_lpI">
            <node concept="2NCMab" id="1SYZy6QQeyM" role="2NCMaf">
              <ref role="2NCMaa" to="e1tx:1w5Xuj1QYPN" resolve="Components" />
            </node>
            <node concept="2NCMab" id="1SYZy6QQeyN" role="2NCMaf">
              <ref role="2NCMaa" to="e1tx:1w5Xuj1RQ09" resolve="InMemoryStorage" />
            </node>
            <node concept="2NCMab" id="1SYZy6QQeA3" role="2NCMaf">
              <ref role="2NCMaa" to="e1tx:1w5Xuj1RQ0H" resolve="storedTP" />
            </node>
          </node>
        </node>
        <node concept="1_0LV8" id="1SYZy6QOkJX" role="1_0VJ0">
          <node concept="19SGf9" id="1SYZy6QOkJY" role="1_0LWR">
            <node concept="19SUe$" id="1SYZy6QOkJZ" role="19SJt6">
              <property role="19SUeA" value="Second there is an " />
            </node>
            <node concept="1jUjqm" id="w_3lYHDir7" role="19SJt6">
              <node concept="19SGf9" id="w_3lYHDir8" role="$DsGW">
                <node concept="19SUe$" id="w_3lYHDir9" role="19SJt6">
                  <property role="19SUeA" value="on-init" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="w_3lYHDir6" role="19SJt6">
              <property role="19SUeA" value=" runnable: this is essentially a constructor that is executed as an instance is created." />
            </node>
          </node>
        </node>
        <node concept="3z_lpU" id="3UY8BSpCATg" role="1_0VJ0">
          <property role="3z_lpW" value="mbeddr" />
          <property role="3z_lpJ" value="true" />
          <property role="3z_lpV" value="void init() &lt;= on init {&#10;  storedTP = null;      &#10;  return;               &#10;} runnable init         " />
          <node concept="2NCZwO" id="1YUFCeGolF6" role="3z_lpI">
            <node concept="2NCMab" id="1YUFCeGolF7" role="2NCMaf">
              <ref role="2NCMaa" to="e1tx:1w5Xuj1QYPN" resolve="Components" />
            </node>
            <node concept="2NCMab" id="1YUFCeGolF8" role="2NCMaf">
              <ref role="2NCMaa" to="e1tx:1w5Xuj1RQ09" resolve="InMemoryStorage" />
            </node>
            <node concept="2NCMab" id="1SYZy6QS89r" role="2NCMaf">
              <ref role="2NCMaa" to="e1tx:1w5Xuj1Saoj" resolve="init" />
            </node>
          </node>
        </node>
        <node concept="1_0LV8" id="3UY8BSpCCU8" role="1_0VJ0">
          <node concept="19SGf9" id="3UY8BSpCCU9" role="1_0LWR">
            <node concept="19SUe$" id="3UY8BSpCCUa" role="19SJt6">
              <property role="19SUeA" value="To keep our implementation module " />
            </node>
            <node concept="3z_lpY" id="1SYZy6QS8cR" role="19SJt6">
              <node concept="2NCZwO" id="1SYZy6QS8cS" role="3z_lpZ">
                <node concept="2NCMab" id="1SYZy6QS8d1" role="2NCMaf">
                  <ref role="2NCMaa" to="e1tx:1w5Xuj1QYPN" resolve="Components" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="1SYZy6QS8cQ" role="19SJt6">
              <property role="19SUeA" value=" well structured we can use sections. A " />
            </node>
            <node concept="1jUjqm" id="3UY8BSpCE7Q" role="19SJt6">
              <node concept="19SGf9" id="3UY8BSpCE7R" role="$DsGW">
                <node concept="19SUe$" id="3UY8BSpCE7S" role="19SJt6">
                  <property role="19SUeA" value="section" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="3UY8BSpCE7P" role="19SJt6">
              <property role="19SUeA" value=" is a named part of the implementation module that has no semantic effect beyond that. Sections can be collapsed." />
            </node>
          </node>
        </node>
        <node concept="1DKdXA" id="3UY8BSpCFlG" role="1_0VJ0">
          <property role="1DKdXC" value="mbeddr" />
          <property role="1DKdXF" value="module Components imports DataStructures { &#10;   &#10;  exported messagelist ContractMessages {...}&#10;   &#10;  section processor {...} &#10; &#10;  section store { &#10;  &#9;exported cs interface TrackpointStore1 { &#10;    &#9;... &#10;  &#9;} &#10;  &#9;exported cs interface TrackpointStore2 { &#10;    &#9;... &#10;  &#9;} &#10;    exported component InMemoryStorage extends nothing { &#10;&#9;    ... &#9;&#10;  &#9;} &#10;  }&#10;    &#10;  instances nullerInstances {...} &#10;  test case testNuller {...} &#10;  instances interpolatorInstances {...} &#10;  exported test case testInterpolator { ... } &#10;}" />
        </node>
        <node concept="1_0LV8" id="3UY8BSpCHaH" role="1_0VJ0">
          <node concept="19SGf9" id="3UY8BSpCHaI" role="1_0LWR">
            <node concept="19SUe$" id="3UY8BSpCHaJ" role="19SJt6">
              <property role="19SUeA" value="We can now implement a second processor, the " />
            </node>
            <node concept="3z_lpY" id="1SYZy6Reazc" role="19SJt6">
              <node concept="2NCZwO" id="1SYZy6ReazS" role="3z_lpZ">
                <node concept="2NCMab" id="1SYZy6ReazT" role="2NCMaf">
                  <ref role="2NCMaa" to="e1tx:1w5Xuj1QYPN" resolve="Components" />
                </node>
                <node concept="2NCMab" id="1SYZy6Rea$3" role="2NCMaf">
                  <ref role="2NCMaa" to="e1tx:1w5Xuj1S2ME" resolve="Interpolator" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="1SYZy6Reazb" role="19SJt6">
              <property role="19SUeA" value=". For subsequent calls of " />
            </node>
            <node concept="3z_lpY" id="1SYZy6R9W0C" role="19SJt6">
              <node concept="2NCZwO" id="1SYZy6Re9Rd" role="3z_lpZ">
                <node concept="2NCMab" id="1SYZy6Re9Re" role="2NCMaf">
                  <ref role="2NCMaa" to="e1tx:1w5Xuj1QYPN" resolve="Components" />
                </node>
                <node concept="2NCMab" id="1SYZy6Re9Ro" role="2NCMaf">
                  <ref role="2NCMaa" to="e1tx:1w5Xuj1QYPT" resolve="process" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="1SYZy6R9W0B" role="19SJt6">
              <property role="19SUeA" value=" it computes the average of the two last speeds of the passed trackpoints. Let us start with the test case. Note how " />
            </node>
            <node concept="1jUjqm" id="3UY8BSpCHMi" role="19SJt6">
              <node concept="19SGf9" id="3UY8BSpCHMj" role="$DsGW">
                <node concept="19SUe$" id="3UY8BSpCHMk" role="19SJt6">
                  <property role="19SUeA" value="p2" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="3UY8BSpCHMh" role="19SJt6">
              <property role="19SUeA" value=" has its speed changed to the average of the " />
            </node>
            <node concept="1jUjqm" id="3UY8BSpCHMK" role="19SJt6">
              <node concept="19SGf9" id="3UY8BSpCHML" role="$DsGW">
                <node concept="19SUe$" id="3UY8BSpCHMM" role="19SJt6">
                  <property role="19SUeA" value="p1" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="3UY8BSpCHMJ" role="19SJt6">
              <property role="19SUeA" value=" and " />
            </node>
            <node concept="1jUjqm" id="3UY8BSpCHMv" role="19SJt6">
              <node concept="19SGf9" id="3UY8BSpCHMw" role="$DsGW">
                <node concept="19SUe$" id="3UY8BSpCHMx" role="19SJt6">
                  <property role="19SUeA" value="p2" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="3UY8BSpCHMu" role="19SJt6">
              <property role="19SUeA" value=" originally." />
            </node>
          </node>
        </node>
        <node concept="3z_lpU" id="3UY8BSpCTtS" role="1_0VJ0">
          <property role="3z_lpW" value="mbeddr" />
          <property role="3z_lpJ" value="true" />
          <property role="3z_lpV" value="                                                          &#10;section testInterpolator {                                &#10;                                                          &#10;  instances interpolatorInstances {                       &#10;  instance InMemoryStorage store                          &#10;  instance Interpolator interpolator(divident = 10)       &#10;  connect interpolator.store to store.store               &#10;  adapt ip -&gt; interpolator.processor                      &#10;}                                                         &#10;                                                          &#10;                                                          &#10;  exported testcase testInterpolator {                    &#10;  initialize interpolatorInstances;                       &#10;  Trackpoint p1 = {                                       &#10;  id = 1,                                                 &#10;  time = 1 s,                                             &#10;  speed = 10 mps                                          &#10;};                                                        &#10;  Trackpoint p2 = {                                       &#10;  id = 1,                                                 &#10;  time = 1 s,                                             &#10;  speed = 20 mps                                          &#10;};                                                        &#10;  ip.process(&amp;p1);                                        &#10;  assert(0) p1.speed == 10 mps;                           &#10;  ip.process(&amp;p2);                                        &#10;  assert-equals(1) p2.speed == 3 mps;                     &#10;                                                          &#10;} testInterpolator(test case)                             &#10;                                                          &#10;                                                          &#10;                                                          &#10;  mock component StorageMock report messages: true {      &#10;  provides TrackpointStore1 store                         &#10;  Trackpoint* lastTP;                                     &#10;  total no. of calls is 5                                 &#10;  sequence {                                              &#10;  step 0: store.isEmpty return true;                      &#10;  step 1: store.store {                                   &#10;    assert 0: parameter tp: tp != null                    &#10;  }                                                       &#10;  do { lastTP = tp; }                                     &#10;  step 2: store.isEmpty return false;                     &#10;  step 3: store.take return lastTP;                       &#10;  step 4: store.store                                     &#10;}                                                         &#10;}                                                         &#10;                                                          &#10;  instances interpolatorInstancesWithMock {               &#10;  instance StorageMock storeMock                          &#10;  instance Interpolator ip(divident = 2)                  &#10;  connect ip.store to storeMock.store                     &#10;  adapt ipMock -&gt; ip.processor                            &#10;}                                                         &#10;                                                          &#10;                                                          &#10;  exported testcase testInterpolatorWithMock {            &#10;  initialize interpolatorInstancesWithMock;               &#10;  Trackpoint p1 = {                                       &#10;  id = 1,                                                 &#10;  time = 1 s,                                             &#10;  speed = 10 mps                                          &#10;};                                                        &#10;  Trackpoint p2 = {                                       &#10;  id = 2,                                                 &#10;  time = 2 s,                                             &#10;  speed = 20 mps                                          &#10;};                                                        &#10;  ipMock.process(&amp;p1);                                    &#10;  ipMock.process(&amp;p2);                                    &#10;  validatemock(0) interpolatorInstancesWithMock:storeMock;&#10;} testInterpolatorWithMock(test case)                     &#10;} section testInterpolator                                " />
          <node concept="2NCZwO" id="1YUFCeGolGu" role="3z_lpI">
            <node concept="2NCMab" id="1YUFCeGolGv" role="2NCMaf">
              <ref role="2NCMaa" to="e1tx:1w5Xuj1QYPN" resolve="Components" />
            </node>
            <node concept="2NCMab" id="1YUFCeGolGw" role="2NCMaf">
              <ref role="2NCMaa" to="e1tx:1w5Xuj1SfMd" resolve="testInterpolator" />
            </node>
          </node>
        </node>
        <node concept="1_0LV8" id="3UY8BSpCTwy" role="1_0VJ0">
          <node concept="19SGf9" id="3UY8BSpCTwz" role="1_0LWR">
            <node concept="19SUe$" id="3UY8BSpCTw$" role="19SJt6">
              <property role="19SUeA" value="Let us look at the implementation of the " />
            </node>
            <node concept="3z_lpY" id="1SYZy6ReayL" role="19SJt6">
              <node concept="2NCZwO" id="1SYZy6ReayV" role="3z_lpZ">
                <node concept="2NCMab" id="1SYZy6ReayW" role="2NCMaf">
                  <ref role="2NCMaa" to="e1tx:1w5Xuj1QYPN" resolve="Components" />
                </node>
                <node concept="2NCMab" id="1SYZy6Reaz6" role="2NCMaf">
                  <ref role="2NCMaa" to="e1tx:1w5Xuj1S2ME" resolve="Interpolator" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="1SYZy6ReayK" role="19SJt6">
              <property role="19SUeA" value=":" />
            </node>
          </node>
        </node>
        <node concept="3z_lpU" id="3UY8BSpD0$R" role="1_0VJ0">
          <property role="3z_lpW" value="mbeddr" />
          <property role="3z_lpJ" value="true" />
          <property role="3z_lpV" value="exported component Interpolator extends nothing {                       &#10;  provides TrackpointProcessor processor                                &#10;  requires TrackpointStore1 store                                       &#10;  init int8 divident;                                                   &#10;                                                                        &#10;  Trackpoint* processor_process(Trackpoint* p) &lt;= op processor.process {&#10;  if (store.isEmpty()) {                                                &#10;  store.store(p);                                                       &#10;  return p;                                                             &#10;} else {                                                                &#10;  Trackpoint* old = store.take();                                       &#10;  p.speed = (p.speed + old.speed) / divident;                           &#10;  store.store(p);                                                       &#10;  return p;                                                             &#10;}                                                                       &#10;} runnable processor_process                                            &#10;} component Interpolator                                                " />
          <node concept="2NCZwO" id="1YUFCeGolC3" role="3z_lpI">
            <node concept="2NCMab" id="1YUFCeGolC4" role="2NCMaf">
              <ref role="2NCMaa" to="e1tx:1w5Xuj1QYPN" resolve="Components" />
            </node>
            <node concept="2NCMab" id="1YUFCeGolC5" role="2NCMaf">
              <ref role="2NCMaa" to="e1tx:1w5Xuj1S2ME" resolve="Interpolator" />
            </node>
          </node>
        </node>
        <node concept="1_0LV8" id="3UY8BSpD0BL" role="1_0VJ0">
          <node concept="19SGf9" id="3UY8BSpD0BM" role="1_0LWR">
            <node concept="19SUe$" id="3UY8BSpD0BN" role="19SJt6">
              <property role="19SUeA" value="A few things are worth mentioning. First, the component " />
            </node>
            <node concept="1jUjqm" id="3UY8BSpD1Ru" role="19SJt6">
              <node concept="19SGf9" id="3UY8BSpD1Rv" role="$DsGW">
                <node concept="19SUe$" id="3UY8BSpD1Rw" role="19SJt6">
                  <property role="19SUeA" value="requires" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="3UY8BSpD1Rt" role="19SJt6">
              <property role="19SUeA" value=" another interface, " />
            </node>
            <node concept="1jUjqm" id="3UY8BSpD1RB" role="19SJt6">
              <node concept="19SGf9" id="3UY8BSpD1RC" role="$DsGW">
                <node concept="19SUe$" id="3UY8BSpD1RD" role="19SJt6">
                  <property role="19SUeA" value="TrackpointStore1" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="3UY8BSpD1RA" role="19SJt6">
              <property role="19SUeA" value=". Any component that implements this interface can be used to fulfil this requirement (we'll discuss how, below). Second, we use an " />
            </node>
            <node concept="1jUjqm" id="3UY8BSpD1RO" role="19SJt6">
              <node concept="19SGf9" id="3UY8BSpD1RP" role="$DsGW">
                <node concept="19SUe$" id="3UY8BSpD1RQ" role="19SJt6">
                  <property role="19SUeA" value="init" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="3UY8BSpD1RN" role="19SJt6">
              <property role="19SUeA" value=" field. This is a regular field from the perspective of the component (i.e. it can be accessed from within the implementation), but it is special in that a value for it has to be supplied when the component is instantiated. Third, this example shows how to call operations on required ports (" />
            </node>
            <node concept="1jUjqm" id="3UY8BSpD1S5" role="19SJt6">
              <node concept="19SGf9" id="3UY8BSpD1S6" role="$DsGW">
                <node concept="19SUe$" id="3UY8BSpD1S7" role="19SJt6">
                  <property role="19SUeA" value="store.store(p);" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="3UY8BSpD1S4" role="19SJt6">
              <property role="19SUeA" value="). The only remaining step before running the test is to define the instances:" />
            </node>
          </node>
        </node>
        <node concept="3z_lpU" id="3UY8BSpD1Sp" role="1_0VJ0">
          <property role="3z_lpW" value="mbeddr" />
          <property role="3z_lpJ" value="true" />
          <property role="3z_lpV" value="instances interpolatorInstances {                  &#10;  instance InMemoryStorage store                   &#10;  instance Interpolator interpolator(divident = 10)&#10;  connect interpolator.store to store.store        &#10;  adapt ip -&gt; interpolator.processor               &#10;}                                                  " />
          <node concept="2NCZwO" id="1YUFCeGolBf" role="3z_lpI">
            <node concept="2NCMab" id="1YUFCeGolBg" role="2NCMaf">
              <ref role="2NCMaa" to="e1tx:1w5Xuj1QYPN" resolve="Components" />
            </node>
            <node concept="2NCMab" id="1YUFCeGolBh" role="2NCMaf">
              <ref role="2NCMaa" to="e1tx:1w5Xuj1S5I1" resolve="interpolatorInstances" />
            </node>
          </node>
        </node>
        <node concept="1_0LV8" id="3UY8BSpD8mO" role="1_0VJ0">
          <node concept="19SGf9" id="3UY8BSpD8mP" role="1_0LWR">
            <node concept="19SUe$" id="3UY8BSpD8mQ" role="19SJt6">
              <property role="19SUeA" value="A few interesting things. First, notice how we pass in a value for the init field " />
            </node>
            <node concept="1jUjqm" id="3UY8BSpD8Z8" role="19SJt6">
              <node concept="19SGf9" id="3UY8BSpD8Z9" role="$DsGW">
                <node concept="19SUe$" id="3UY8BSpD8Za" role="19SJt6">
                  <property role="19SUeA" value="divident" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="3UY8BSpD8Z7" role="19SJt6">
              <property role="19SUeA" value=" as we define an instance of " />
            </node>
            <node concept="1jUjqm" id="3UY8BSpD8Zh" role="19SJt6">
              <node concept="19SGf9" id="3UY8BSpD8Zi" role="$DsGW">
                <node concept="19SUe$" id="3UY8BSpD8Zj" role="19SJt6">
                  <property role="19SUeA" value="Interpolator" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="3UY8BSpD8Zg" role="19SJt6">
              <property role="19SUeA" value=". Second, we use " />
            </node>
            <node concept="1jUjqm" id="3UY8BSpD8Zu" role="19SJt6">
              <node concept="19SGf9" id="3UY8BSpD8Zv" role="$DsGW">
                <node concept="19SUe$" id="3UY8BSpD8Zw" role="19SJt6">
                  <property role="19SUeA" value="connect" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="3UY8BSpD8Zt" role="19SJt6">
              <property role="19SUeA" value=" to connect the required port " />
            </node>
            <node concept="1jUjqm" id="3UY8BSpD8ZJ" role="19SJt6">
              <node concept="19SGf9" id="3UY8BSpD8ZK" role="$DsGW">
                <node concept="19SUe$" id="3UY8BSpD8ZL" role="19SJt6">
                  <property role="19SUeA" value="store" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="3UY8BSpD8ZI" role="19SJt6">
              <property role="19SUeA" value=" of the " />
            </node>
            <node concept="1jUjqm" id="3UY8BSpD904" role="19SJt6">
              <node concept="19SGf9" id="3UY8BSpD905" role="$DsGW">
                <node concept="19SUe$" id="3UY8BSpD906" role="19SJt6">
                  <property role="19SUeA" value="ipc" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="3UY8BSpD903" role="19SJt6">
              <property role="19SUeA" value=" instance to the " />
            </node>
            <node concept="1jUjqm" id="3UY8BSpD90t" role="19SJt6">
              <node concept="19SGf9" id="3UY8BSpD90u" role="$DsGW">
                <node concept="19SUe$" id="3UY8BSpD90v" role="19SJt6">
                  <property role="19SUeA" value="store" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="3UY8BSpD90s" role="19SJt6">
              <property role="19SUeA" value=" provided port of the " />
            </node>
            <node concept="1jUjqm" id="3UY8BSpD90U" role="19SJt6">
              <node concept="19SGf9" id="3UY8BSpD90V" role="$DsGW">
                <node concept="19SUe$" id="3UY8BSpD90W" role="19SJt6">
                  <property role="19SUeA" value="store" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="3UY8BSpD90T" role="19SJt6">
              <property role="19SUeA" value=" instance. If you don't do this you will get an error on the " />
            </node>
            <node concept="1jUjqm" id="3UY8BSpD91r" role="19SJt6">
              <node concept="19SGf9" id="3UY8BSpD91s" role="$DsGW">
                <node concept="19SUe$" id="3UY8BSpD91t" role="19SJt6">
                  <property role="19SUeA" value="ipc" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="3UY8BSpD91q" role="19SJt6">
              <property role="19SUeA" value=" instance since it " />
            </node>
            <node concept="28N2ik" id="3UY8BSpDeQG" role="19SJt6">
              <node concept="19SGf9" id="3UY8BSpDeQH" role="$DsGW">
                <node concept="19SUe$" id="3UY8BSpDeQI" role="19SJt6">
                  <property role="19SUeA" value="requires" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="3UY8BSpDeQF" role="19SJt6">
              <property role="19SUeA" value=" this thing to be connected (there are also " />
            </node>
            <node concept="1jUjqm" id="3UY8BSpDeRl" role="19SJt6">
              <node concept="19SGf9" id="3UY8BSpDeRm" role="$DsGW">
                <node concept="19SUe$" id="3UY8BSpDeRn" role="19SJt6">
                  <property role="19SUeA" value="optional" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="3UY8BSpDeRk" role="19SJt6">
              <property role="19SUeA" value=" required ports which may remain unconnected and " />
            </node>
            <node concept="1jUjqm" id="4dKKrcE0EkG" role="19SJt6">
              <node concept="19SGf9" id="4dKKrcE0EkH" role="$DsGW">
                <node concept="19SUe$" id="4dKKrcE0EkI" role="19SJt6">
                  <property role="19SUeA" value="multiple" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="4dKKrcE0EkF" role="19SJt6">
              <property role="19SUeA" value=" required ports which can be connected to more than one required port). Finally, the provided interface " />
            </node>
            <node concept="1jUjqm" id="3UY8BSpDkHv" role="19SJt6">
              <node concept="19SGf9" id="3UY8BSpDkHw" role="$DsGW">
                <node concept="19SUe$" id="3UY8BSpDkHx" role="19SJt6">
                  <property role="19SUeA" value="processor" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="3UY8BSpDkHu" role="19SJt6">
              <property role="19SUeA" value=" is made available to other code as the variable " />
            </node>
            <node concept="1jUjqm" id="3UY8BSpDeS2" role="19SJt6">
              <node concept="19SGf9" id="3UY8BSpDeS3" role="$DsGW">
                <node concept="19SUe$" id="3UY8BSpDeS4" role="19SJt6">
                  <property role="19SUeA" value="ip" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="3UY8BSpDeS1" role="19SJt6">
              <property role="19SUeA" value=". You can run the test case now. On my machine here it works successfully :-) " />
            </node>
          </node>
        </node>
        <node concept="1_0LV8" id="5MdJlx$bho7" role="1_0VJ0">
          <node concept="19SGf9" id="5MdJlx$bho8" role="1_0LWR">
            <node concept="19SUe$" id="5MdJlx$bho9" role="19SJt6">
              <property role="19SUeA" value="To better understand the connections between component instances, there is also a graphical editor available. To switch to the graphical wireing you can select the respective option form the " />
            </node>
            <node concept="2OlAs7" id="yaVrOuw0Ow" role="19SJt6">
              <node concept="19SGf9" id="yaVrOuw0Oz" role="$DsGW">
                <node concept="19SUe$" id="yaVrOuw0O$" role="19SJt6">
                  <property role="19SUeA" value="Code-&gt;Projection Mode-&gt;Component Wiring as Diagram" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="4dKKrcDSE47" role="19SJt6">
              <property role="19SUeA" value=" menu." />
            </node>
          </node>
        </node>
      </node>
      <node concept="1_0VNX" id="3zwhDFH0cvi" role="1_0VJ0">
        <property role="TrG5h" value="mocks" />
        <property role="1_0VJr" value="Mocks" />
        <node concept="1_0LV8" id="3UY8BSpDlUX" role="1_0VJ0">
          <node concept="19SGf9" id="3UY8BSpDlUY" role="1_0LWR">
            <node concept="19SUe$" id="3UY8BSpDlUZ" role="19SJt6">
              <property role="19SUeA" value="Let us assume we wanted to test if the " />
            </node>
            <node concept="1jUjqm" id="3UY8BSpDlV4" role="19SJt6">
              <node concept="19SGf9" id="3UY8BSpDlV5" role="$DsGW">
                <node concept="19SUe$" id="3UY8BSpDlV6" role="19SJt6">
                  <property role="19SUeA" value="Interpolator" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="3UY8BSpDlV3" role="19SJt6">
              <property role="19SUeA" value=" works correctly with the " />
            </node>
            <node concept="1jUjqm" id="3UY8BSpDlVd" role="19SJt6">
              <node concept="19SGf9" id="3UY8BSpDlVe" role="$DsGW">
                <node concept="19SUe$" id="3UY8BSpDlVf" role="19SJt6">
                  <property role="19SUeA" value="TrackpointStore" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="3UY8BSpDlVc" role="19SJt6">
              <property role="19SUeA" value=" interface. Of course, since we have already described the interface contract semantically we would find out quickly if the " />
            </node>
            <node concept="1jUjqm" id="3UY8BSpDlVq" role="19SJt6">
              <node concept="19SGf9" id="3UY8BSpDlVr" role="$DsGW">
                <node concept="19SUe$" id="3UY8BSpDlVs" role="19SJt6">
                  <property role="19SUeA" value="Interpolator" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="3UY8BSpDlVp" role="19SJt6">
              <property role="19SUeA" value=" would behave badly. However, we can make such a test more explicit. Let us revisit the test from above:" />
            </node>
          </node>
        </node>
        <node concept="3z_lpU" id="5MdJlx$Jlhg" role="1_0VJ0">
          <property role="3z_lpW" value="mbeddr" />
          <property role="3z_lpJ" value="true" />
          <property role="3z_lpV" value="                                                          &#10;section testInterpolator {                                &#10;                                                          &#10;  instances interpolatorInstances {                       &#10;  instance InMemoryStorage store                          &#10;  instance Interpolator interpolator(divident = 10)       &#10;  connect interpolator.store to store.store               &#10;  adapt ip -&gt; interpolator.processor                      &#10;}                                                         &#10;                                                          &#10;                                                          &#10;  exported testcase testInterpolator {                    &#10;  initialize interpolatorInstances;                       &#10;  Trackpoint p1 = {                                       &#10;  id = 1,                                                 &#10;  time = 1 s,                                             &#10;  speed = 10 mps                                          &#10;};                                                        &#10;  Trackpoint p2 = {                                       &#10;  id = 1,                                                 &#10;  time = 1 s,                                             &#10;  speed = 20 mps                                          &#10;};                                                        &#10;  ip.process(&amp;p1);                                        &#10;  assert(0) p1.speed == 10 mps;                           &#10;  ip.process(&amp;p2);                                        &#10;  assert-equals(1) p2.speed == 3 mps;                     &#10;                                                          &#10;} testInterpolator(test case)                             &#10;                                                          &#10;                                                          &#10;                                                          &#10;  mock component StorageMock report messages: true {      &#10;  provides TrackpointStore1 store                         &#10;  Trackpoint* lastTP;                                     &#10;  total no. of calls is 5                                 &#10;  sequence {                                              &#10;  step 0: store.isEmpty return true;                      &#10;  step 1: store.store {                                   &#10;    assert 0: parameter tp: tp != null                    &#10;  }                                                       &#10;  do { lastTP = tp; }                                     &#10;  step 2: store.isEmpty return false;                     &#10;  step 3: store.take return lastTP;                       &#10;  step 4: store.store                                     &#10;}                                                         &#10;}                                                         &#10;                                                          &#10;  instances interpolatorInstancesWithMock {               &#10;  instance StorageMock storeMock                          &#10;  instance Interpolator ip(divident = 2)                  &#10;  connect ip.store to storeMock.store                     &#10;  adapt ipMock -&gt; ip.processor                            &#10;}                                                         &#10;                                                          &#10;                                                          &#10;  exported testcase testInterpolatorWithMock {            &#10;  initialize interpolatorInstancesWithMock;               &#10;  Trackpoint p1 = {                                       &#10;  id = 1,                                                 &#10;  time = 1 s,                                             &#10;  speed = 10 mps                                          &#10;};                                                        &#10;  Trackpoint p2 = {                                       &#10;  id = 2,                                                 &#10;  time = 2 s,                                             &#10;  speed = 20 mps                                          &#10;};                                                        &#10;  ipMock.process(&amp;p1);                                    &#10;  ipMock.process(&amp;p2);                                    &#10;  validatemock(0) interpolatorInstancesWithMock:storeMock;&#10;} testInterpolatorWithMock(test case)                     &#10;} section testInterpolator                                " />
          <node concept="2NCZwO" id="5MdJlx$Jlhh" role="3z_lpI">
            <node concept="2NCMab" id="5MdJlx$Jlhi" role="2NCMaf">
              <ref role="2NCMaa" to="e1tx:1w5Xuj1QYPN" resolve="Components" />
            </node>
            <node concept="2NCMab" id="5MdJlx$Jlhj" role="2NCMaf">
              <ref role="2NCMaa" to="e1tx:1w5Xuj1SfMd" resolve="testInterpolator" />
            </node>
          </node>
        </node>
        <node concept="1_0LV8" id="3UY8BSpDolN" role="1_0VJ0">
          <node concept="19SGf9" id="3UY8BSpDolO" role="1_0LWR">
            <node concept="19SUe$" id="3UY8BSpDolP" role="19SJt6">
              <property role="19SUeA" value="In this test, we expect the following: when we call " />
            </node>
            <node concept="1jUjqm" id="3UY8BSpDomb" role="19SJt6">
              <node concept="19SGf9" id="3UY8BSpDomc" role="$DsGW">
                <node concept="19SUe$" id="3UY8BSpDomd" role="19SJt6">
                  <property role="19SUeA" value="process" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="3UY8BSpDoma" role="19SJt6">
              <property role="19SUeA" value=" first, the store is still empty, so the interpolator stores a new trackpoint. When we call " />
            </node>
            <node concept="1jUjqm" id="3UY8BSpDomk" role="19SJt6">
              <node concept="19SGf9" id="3UY8BSpDoml" role="$DsGW">
                <node concept="19SUe$" id="3UY8BSpDomm" role="19SJt6">
                  <property role="19SUeA" value="process" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="3UY8BSpDomj" role="19SJt6">
              <property role="19SUeA" value=" again, we expect the interpolator to call " />
            </node>
            <node concept="1jUjqm" id="3UY8BSpDomx" role="19SJt6">
              <node concept="19SGf9" id="3UY8BSpDomy" role="$DsGW">
                <node concept="19SUe$" id="3UY8BSpDomz" role="19SJt6">
                  <property role="19SUeA" value="take" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="3UY8BSpDomw" role="19SJt6">
              <property role="19SUeA" value=" and then " />
            </node>
            <node concept="1jUjqm" id="3UY8BSpDomM" role="19SJt6">
              <node concept="19SGf9" id="3UY8BSpDomN" role="$DsGW">
                <node concept="19SUe$" id="3UY8BSpDomO" role="19SJt6">
                  <property role="19SUeA" value="store" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="3UY8BSpDomL" role="19SJt6">
              <property role="19SUeA" value=". In both cases we expect " />
            </node>
            <node concept="1jUjqm" id="3UY8BSpDon7" role="19SJt6">
              <node concept="19SGf9" id="3UY8BSpDon8" role="$DsGW">
                <node concept="19SUe$" id="3UY8BSpDon9" role="19SJt6">
                  <property role="19SUeA" value="isEmpty" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="3UY8BSpDon6" role="19SJt6">
              <property role="19SUeA" value=" to be called first. " />
            </node>
          </node>
        </node>
        <node concept="1_0LV8" id="5MdJlx$JoMB" role="1_0VJ0">
          <node concept="19SGf9" id="5MdJlx$JoMC" role="1_0LWR">
            <node concept="19SUe$" id="5MdJlx$JoMD" role="19SJt6">
              <property role="19SUeA" value="We can test for this behavior explicitly via a mock. A mock is a component that specifies the " />
            </node>
            <node concept="28N2ik" id="3UY8BSpDonw" role="19SJt6">
              <node concept="19SGf9" id="3UY8BSpDonx" role="$DsGW">
                <node concept="19SUe$" id="3UY8BSpDony" role="19SJt6">
                  <property role="19SUeA" value="behavior it expects" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="3UY8BSpDonv" role="19SJt6">
              <property role="19SUeA" value=" to see on a provided port during a " />
            </node>
            <node concept="28N2ik" id="3UY8BSpDonX" role="19SJt6">
              <node concept="19SGf9" id="3UY8BSpDonY" role="$DsGW">
                <node concept="19SUe$" id="3UY8BSpDonZ" role="19SJt6">
                  <property role="19SUeA" value="specific" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="3UY8BSpDonW" role="19SJt6">
              <property role="19SUeA" value=" test case. The crucial point about mocks is that a mock implements each operation " />
            </node>
            <node concept="28N2ik" id="3UY8BSpDoou" role="19SJt6">
              <node concept="19SGf9" id="3UY8BSpDoov" role="$DsGW">
                <node concept="19SUe$" id="3UY8BSpDoow" role="19SJt6">
                  <property role="19SUeA" value="invocation" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="3UY8BSpDoot" role="19SJt6">
              <property role="19SUeA" value=" separately (the " />
            </node>
            <node concept="1jUjqm" id="3UY8BSpDop3" role="19SJt6">
              <node concept="19SGf9" id="3UY8BSpDop4" role="$DsGW">
                <node concept="19SUe$" id="3UY8BSpDop5" role="19SJt6">
                  <property role="19SUeA" value="step" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="3UY8BSpDop2" role="19SJt6">
              <property role="19SUeA" value="s below), whereas a regular component or even a stub just describes each operation with " />
            </node>
            <node concept="28N2ik" id="3UY8BSpDopG" role="19SJt6">
              <node concept="19SGf9" id="3UY8BSpDopH" role="$DsGW">
                <node concept="19SUe$" id="3UY8BSpDopI" role="19SJt6">
                  <property role="19SUeA" value="one" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="3UY8BSpDopF" role="19SJt6">
              <property role="19SUeA" value=" implementation. This makes a mock implementation much simpler -- it doesn't have to replicate the algorithmic implementation of the real component. Let us look at the implementation:" />
            </node>
          </node>
        </node>
        <node concept="3z_lpU" id="3UY8BSpDug1" role="1_0VJ0">
          <property role="3z_lpW" value="mbeddr" />
          <property role="3z_lpJ" value="true" />
          <property role="3z_lpV" value="mock component StorageMock report messages: true {&#10;  provides TrackpointStore1 store                 &#10;  Trackpoint* lastTP;                             &#10;  total no. of calls is 5                         &#10;  sequence {                                      &#10;  step 0: store.isEmpty return true;              &#10;  step 1: store.store {                           &#10;    assert 0: parameter tp: tp != null            &#10;  }                                               &#10;  do { lastTP = tp; }                             &#10;  step 2: store.isEmpty return false;             &#10;  step 3: store.take return lastTP;               &#10;  step 4: store.store                             &#10;}                                                 &#10;}                                                 " />
          <node concept="2NCZwO" id="1YUFCeGolBs" role="3z_lpI">
            <node concept="2NCMab" id="1YUFCeGolBt" role="2NCMaf">
              <ref role="2NCMaa" to="e1tx:1w5Xuj1QYPN" resolve="Components" />
            </node>
            <node concept="2NCMab" id="1YUFCeGolBu" role="2NCMaf">
              <ref role="2NCMaa" to="e1tx:4usdeMNSKaC" resolve="StorageMock" />
            </node>
          </node>
        </node>
        <node concept="1_0LV8" id="3UY8BSpDuSi" role="1_0VJ0">
          <node concept="19SGf9" id="3UY8BSpDuSj" role="1_0LWR">
            <node concept="19SUe$" id="3UY8BSpDuSk" role="19SJt6">
              <property role="19SUeA" value="This mock component expresses that we expect 5 calls in total. Then we describe the sequence of calls we expect. The first one must be a call to " />
            </node>
            <node concept="1jUjqm" id="3UY8BSpDvvF" role="19SJt6">
              <node concept="19SGf9" id="3UY8BSpDvvG" role="$DsGW">
                <node concept="19SUe$" id="3UY8BSpDvvH" role="19SJt6">
                  <property role="19SUeA" value="isEmpty" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="3UY8BSpDvvE" role="19SJt6">
              <property role="19SUeA" value=" and we return " />
            </node>
            <node concept="1jUjqm" id="3UY8BSpDvvO" role="19SJt6">
              <node concept="19SGf9" id="3UY8BSpDvvP" role="$DsGW">
                <node concept="19SUe$" id="3UY8BSpDvvQ" role="19SJt6">
                  <property role="19SUeA" value="true" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="3UY8BSpDvvN" role="19SJt6">
              <property role="19SUeA" value=". Then we expect a " />
            </node>
            <node concept="1jUjqm" id="3UY8BSpDvw1" role="19SJt6">
              <node concept="19SGf9" id="3UY8BSpDvw2" role="$DsGW">
                <node concept="19SUe$" id="3UY8BSpDvw3" role="19SJt6">
                  <property role="19SUeA" value="store," />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="3UY8BSpDvw0" role="19SJt6">
              <property role="19SUeA" value=" and for the sake of the example, we check that " />
            </node>
            <node concept="1jUjqm" id="3UY8BSpDvwi" role="19SJt6">
              <node concept="19SGf9" id="3UY8BSpDvwj" role="$DsGW">
                <node concept="19SUe$" id="3UY8BSpDvwk" role="19SJt6">
                  <property role="19SUeA" value="tp" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="3UY8BSpDvwh" role="19SJt6">
              <property role="19SUeA" value=" is not " />
            </node>
            <node concept="1jUjqm" id="3UY8BSpDvwB" role="19SJt6">
              <node concept="19SGf9" id="3UY8BSpDvwC" role="$DsGW">
                <node concept="19SUe$" id="3UY8BSpDvwD" role="19SJt6">
                  <property role="19SUeA" value="null" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="3UY8BSpDvwA" role="19SJt6">
              <property role="19SUeA" value=". We also store the " />
            </node>
            <node concept="1jUjqm" id="3UY8BSpDvx0" role="19SJt6">
              <node concept="19SGf9" id="3UY8BSpDvx1" role="$DsGW">
                <node concept="19SUe$" id="3UY8BSpDvx2" role="19SJt6">
                  <property role="19SUeA" value="tp" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="3UY8BSpDvwZ" role="19SJt6">
              <property role="19SUeA" value=" parameter in a field " />
            </node>
            <node concept="1jUjqm" id="3UY8BSpDvxt" role="19SJt6">
              <node concept="19SGf9" id="3UY8BSpDvxu" role="$DsGW">
                <node concept="19SUe$" id="3UY8BSpDvxv" role="19SJt6">
                  <property role="19SUeA" value="lastTP" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="3UY8BSpDvxs" role="19SJt6">
              <property role="19SUeA" value=" so we can return it later (you can add the parameter assertions and the " />
            </node>
            <node concept="1jUjqm" id="3UY8BSpDvxY" role="19SJt6">
              <node concept="19SGf9" id="3UY8BSpDvxZ" role="$DsGW">
                <node concept="19SUe$" id="3UY8BSpDvy0" role="19SJt6">
                  <property role="19SUeA" value="do" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="3UY8BSpDvxX" role="19SJt6">
              <property role="19SUeA" value=" body with " />
            </node>
            <node concept="28N2ik" id="3UY8BSpDvyz" role="19SJt6">
              <node concept="19SGf9" id="3UY8BSpDvy$" role="$DsGW">
                <node concept="19SUe$" id="3UY8BSpDvy_" role="19SJt6">
                  <property role="19SUeA" value="intentions" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="3UY8BSpDvyy" role="19SJt6">
              <property role="19SUeA" value="). We then expect another " />
            </node>
            <node concept="1jUjqm" id="3UY8BSpDvzc" role="19SJt6">
              <node concept="19SGf9" id="3UY8BSpDvzd" role="$DsGW">
                <node concept="19SUe$" id="3UY8BSpDvze" role="19SJt6">
                  <property role="19SUeA" value="isEmpty" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="3UY8BSpDvzb" role="19SJt6">
              <property role="19SUeA" value=" query, which we now answer with " />
            </node>
            <node concept="1jUjqm" id="3UY8BSpDvzT" role="19SJt6">
              <node concept="19SGf9" id="3UY8BSpDvzU" role="$DsGW">
                <node concept="19SUe$" id="3UY8BSpDvzV" role="19SJt6">
                  <property role="19SUeA" value="false" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="3UY8BSpDvzS" role="19SJt6">
              <property role="19SUeA" value=". At this point we expect a call to " />
            </node>
            <node concept="1jUjqm" id="3UY8BSpDv$E" role="19SJt6">
              <node concept="19SGf9" id="3UY8BSpDv$F" role="$DsGW">
                <node concept="19SUe$" id="3UY8BSpDv$G" role="19SJt6">
                  <property role="19SUeA" value="take" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="3UY8BSpDv$D" role="19SJt6">
              <property role="19SUeA" value=", and another call to " />
            </node>
            <node concept="1jUjqm" id="3UY8BSpDv_v" role="19SJt6">
              <node concept="19SGf9" id="3UY8BSpDv_w" role="$DsGW">
                <node concept="19SUe$" id="3UY8BSpDv_x" role="19SJt6">
                  <property role="19SUeA" value="store." />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="3UY8BSpDv_u" role="19SJt6">
              <property role="19SUeA" value=" Notice how we return " />
            </node>
            <node concept="1jUjqm" id="3UY8BSpDvAo" role="19SJt6">
              <node concept="19SGf9" id="3UY8BSpDvAp" role="$DsGW">
                <node concept="19SUe$" id="3UY8BSpDvAq" role="19SJt6">
                  <property role="19SUeA" value="null" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="3UY8BSpDvAn" role="19SJt6">
              <property role="19SUeA" value=" from " />
            </node>
            <node concept="1jUjqm" id="3UY8BSpDvBl" role="19SJt6">
              <node concept="19SGf9" id="3UY8BSpDvBm" role="$DsGW">
                <node concept="19SUe$" id="3UY8BSpDvBn" role="19SJt6">
                  <property role="19SUeA" value="take" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="3UY8BSpDvBk" role="19SJt6">
              <property role="19SUeA" value=": this violates the postcondition!" />
            </node>
            <node concept="2vpllh" id="3UY8BSpDvCm" role="19SJt6">
              <node concept="19SGf9" id="3UY8BSpDvCn" role="$DsGW">
                <node concept="19SUe$" id="3UY8BSpDvCo" role="19SJt6">
                  <property role="19SUeA" value="" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="3UY8BSpDvCl" role="19SJt6">
              <property role="19SUeA" value=" However, pre- and postconditions are " />
            </node>
            <node concept="28N2ik" id="3UY8BSpDvDr" role="19SJt6">
              <node concept="19SGf9" id="3UY8BSpDvDs" role="$DsGW">
                <node concept="19SUe$" id="3UY8BSpDvDt" role="19SJt6">
                  <property role="19SUeA" value="not" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="3UY8BSpDvDq" role="19SJt6">
              <property role="19SUeA" value=" checked in mock components because their checking may interfere with the expectations! Also, we have slightly changed the test case so we don't stumble over the " />
            </node>
            <node concept="1jUjqm" id="3UY8BSpDvE$" role="19SJt6">
              <node concept="19SGf9" id="3UY8BSpDvE_" role="$DsGW">
                <node concept="19SUe$" id="3UY8BSpDvEA" role="19SJt6">
                  <property role="19SUeA" value="null" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="3UY8BSpDvEz" role="19SJt6">
              <property role="19SUeA" value=". We don't " />
            </node>
            <node concept="1jUjqm" id="3UY8BSpDvFL" role="19SJt6">
              <node concept="19SGf9" id="3UY8BSpDvFM" role="$DsGW">
                <node concept="19SUe$" id="3UY8BSpDvFN" role="19SJt6">
                  <property role="19SUeA" value="assert" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="3UY8BSpDvFK" role="19SJt6">
              <property role="19SUeA" value=" anything about the result of the " />
            </node>
            <node concept="1jUjqm" id="3UY8BSpDvH2" role="19SJt6">
              <node concept="19SGf9" id="3UY8BSpDvH3" role="$DsGW">
                <node concept="19SUe$" id="3UY8BSpDvH4" role="19SJt6">
                  <property role="19SUeA" value="process" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="3UY8BSpDvH1" role="19SJt6">
              <property role="19SUeA" value=" calls:" />
            </node>
          </node>
        </node>
        <node concept="3z_lpU" id="5MdJlx$JKZa" role="1_0VJ0">
          <property role="3z_lpW" value="mbeddr" />
          <property role="3z_lpJ" value="true" />
          <property role="3z_lpV" value="exported testcase testInterpolatorWithMock {&#10;  initialize interpolatorInstancesWithMock; &#10;  Trackpoint p1 = {                         &#10;  id = 1,                                   &#10;  time = 1 s,                               &#10;  speed = 10 mps                            &#10;};                                          &#10;  Trackpoint p2 = {                         &#10;  id = 2,                                   &#10;  time = 2 s,                               &#10;  speed = 20 mps                            &#10;};                                          &#10;  ipMock.process(&amp;p1);                      &#10;  ipMock.process(&amp;p2);                      &#10;} testInterpolatorWithMock(test case)       " />
          <node concept="2NCZwO" id="5MdJlx$JKZb" role="3z_lpI">
            <node concept="2NCMab" id="5MdJlx$JKZc" role="2NCMaf">
              <ref role="2NCMaa" to="e1tx:1w5Xuj1QYPN" resolve="Components" />
            </node>
            <node concept="2NCMab" id="5MdJlx$JKZd" role="2NCMaf">
              <ref role="2NCMaa" to="e1tx:4usdeMNSK9i" resolve="testInterpolatorWithMock" />
            </node>
          </node>
          <node concept="2Cuv_b" id="5MdJlx$K17v" role="3z_lpH">
            <ref role="2Cuq_M" to="mxvz:1Rr52SX$57s" resolve="ValidateMock" />
          </node>
        </node>
        <node concept="1_1sxE" id="5MdJlx$JCRd" role="1_0VJ0">
          <property role="TrG5h" value="empty_-1" />
        </node>
        <node concept="1_0LV8" id="3UY8BSpDBsQ" role="1_0VJ0">
          <node concept="19SGf9" id="3UY8BSpDBsR" role="1_0LWR">
            <node concept="19SUe$" id="3UY8BSpDBsS" role="19SJt6">
              <property role="19SUeA" value="Two more steps are required for this test to work. The first one is the instances and the wiring. Notice how we now connect the interpolator with the mock:" />
            </node>
          </node>
        </node>
        <node concept="3z_lpU" id="3UY8BSpDC7R" role="1_0VJ0">
          <property role="3z_lpW" value="mbeddr" />
          <property role="3z_lpJ" value="true" />
          <property role="3z_lpV" value="instances interpolatorInstancesWithMock {&#10;  instance StorageMock storeMock         &#10;  instance Interpolator ip(divident = 2) &#10;  connect ip.store to storeMock.store    &#10;  adapt ipMock -&gt; ip.processor           &#10;}                                        " />
          <node concept="2NCZwO" id="1YUFCeGolBD" role="3z_lpI">
            <node concept="2NCMab" id="1YUFCeGolBE" role="2NCMaf">
              <ref role="2NCMaa" to="e1tx:1w5Xuj1QYPN" resolve="Components" />
            </node>
            <node concept="2NCMab" id="1YUFCeGolBF" role="2NCMaf">
              <ref role="2NCMaa" to="e1tx:4usdeMNSU2s" resolve="interpolatorInstancesWithMock" />
            </node>
          </node>
        </node>
        <node concept="1_0LV8" id="3UY8BSpDCyU" role="1_0VJ0">
          <node concept="19SGf9" id="3UY8BSpDCyV" role="1_0LWR">
            <node concept="19SUe$" id="3UY8BSpDCyW" role="19SJt6">
              <property role="19SUeA" value="The second thing is the test case itself. Obviously, we want the test case to fail if the mock saw something other than what it expects on its port. We can achieve this by using the " />
            </node>
            <node concept="1jUjqm" id="3UY8BSpDDu1" role="19SJt6">
              <node concept="19SGf9" id="3UY8BSpDDu2" role="$DsGW">
                <node concept="19SUe$" id="3UY8BSpDDu3" role="19SJt6">
                  <property role="19SUeA" value="validate mock" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="3UY8BSpDDu0" role="19SJt6">
              <property role="19SUeA" value=" statement in the test:" />
            </node>
          </node>
        </node>
        <node concept="3z_lpU" id="3UY8BSpDJqm" role="1_0VJ0">
          <property role="3z_lpW" value="mbeddr" />
          <property role="3z_lpJ" value="true" />
          <property role="3z_lpV" value="validatemock(0) interpolatorInstancesWithMock:storeMock;" />
          <node concept="2NCZwO" id="1YUFCeGolHq" role="3z_lpI">
            <node concept="2NCMab" id="1YUFCeGolHr" role="2NCMaf">
              <ref role="2NCMaa" to="e1tx:1w5Xuj1QYPN" resolve="Components" />
            </node>
            <node concept="2NCMab" id="1YUFCeGolHs" role="2NCMaf">
              <ref role="2NCMaa" to="e1tx:4usdeMNSK9i" resolve="testInterpolatorWithMock" />
            </node>
            <node concept="2NCMab" id="5MdJlx$Kiq0" role="2NCMaf">
              <ref role="2NCMaa" to="e1tx:5MdJlx$K9gm" resolve="aValidateMock" />
            </node>
          </node>
        </node>
        <node concept="1_0LV8" id="5MdJlx$KitB" role="1_0VJ0">
          <node concept="19SGf9" id="5MdJlx$KitC" role="1_0LWR">
            <node concept="19SUe$" id="5MdJlx$KitD" role="19SJt6">
              <property role="19SUeA" value="Check out the complete " />
            </node>
            <node concept="3z_lpY" id="5MdJlx$Kizk" role="19SJt6">
              <node concept="2NCZwO" id="5MdJlx$Kizr" role="3z_lpZ">
                <node concept="2NCMab" id="5MdJlx$Kizs" role="2NCMaf">
                  <ref role="2NCMaa" to="e1tx:1w5Xuj1QYPN" resolve="Components" />
                </node>
                <node concept="2NCMab" id="5MdJlx$Kizy" role="2NCMaf">
                  <ref role="2NCMaa" to="e1tx:1w5Xuj1SfMd" resolve="testInterpolator" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="5MdJlx$Kizm" role="19SJt6">
              <property role="19SUeA" value=" test case." />
            </node>
          </node>
        </node>
      </node>
      <node concept="1_1sxE" id="3zwhDFH0zjX" role="1_0VJ0">
        <property role="TrG5h" value="empty_1392530971278_9" />
      </node>
      <node concept="1_0VNX" id="3zwhDFH0cAM" role="1_0VJ0">
        <property role="TrG5h" value="senderReceiver" />
        <property role="1_0VJr" value="Sender/Receiver Interfaces" />
        <node concept="1_0LV8" id="3UY8BSpDK5J" role="1_0VJ0">
          <node concept="19SGf9" id="3UY8BSpDK5K" role="1_0LWR">
            <node concept="19SUe$" id="3UY8BSpDK5L" role="19SJt6">
              <property role="19SUeA" value="So far we have always used client/server interfaces to communicate between components. These essentially define a set of operations, plus contracts, that can be invoked in a client/server style. However, mbeddr comes with a second kind of interface, the sender/receiver interface. In this case, the providing and requiring components exchange " />
            </node>
            <node concept="28N2ik" id="3UY8BSpDKGb" role="19SJt6">
              <node concept="19SGf9" id="3UY8BSpDKGc" role="$DsGW">
                <node concept="19SUe$" id="3UY8BSpDKGd" role="19SJt6">
                  <property role="19SUeA" value="data items" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="3UY8BSpDKGa" role="19SJt6">
              <property role="19SUeA" value=". To demonstrate how they work, let us explore another aspect of the application around " />
            </node>
            <node concept="1jUjqm" id="3UY8BSpDKGk" role="19SJt6">
              <node concept="19SGf9" id="3UY8BSpDKGl" role="$DsGW">
                <node concept="19SUe$" id="3UY8BSpDKGm" role="19SJt6">
                  <property role="19SUeA" value="Trackpoint" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="3UY8BSpDKGj" role="19SJt6">
              <property role="19SUeA" value="s (the example is in the " />
            </node>
            <node concept="3z_lpY" id="1i2OI5u$4pi" role="19SJt6">
              <node concept="2NCZwO" id="1i2OI5u$4pz" role="3z_lpZ">
                <node concept="2NCMab" id="1i2OI5u$4pB" role="2NCMaf">
                  <ref role="2NCMaa" to="e1tx:5NYlgF0xW$c" resolve="ComponentsSRI" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="3UY8BSpDKGw" role="19SJt6">
              <property role="19SUeA" value=" implementation module). The data has to be collected in the airplane. Let us assume we have the following components:   " />
            </node>
          </node>
        </node>
        <node concept="3X6WG5" id="7bDJBXhcmcj" role="1_0VJ0">
          <node concept="3X6T9g" id="7bDJBXhcmck" role="3Xp5NH">
            <node concept="OjmMv" id="7bDJBXhcmcl" role="3X6T9h">
              <node concept="19SGf9" id="7bDJBXhcmcm" role="OjmMu">
                <node concept="19SUe$" id="7bDJBXhcmcn" role="19SJt6">
                  <property role="19SUeA" value="a GPS to provide the position" />
                </node>
              </node>
            </node>
          </node>
          <node concept="3X6T9g" id="7bDJBXhcmdI" role="3Xp5NH">
            <node concept="OjmMv" id="7bDJBXhcmdJ" role="3X6T9h">
              <node concept="19SGf9" id="7bDJBXhcmdK" role="OjmMu">
                <node concept="19SUe$" id="7bDJBXhcmdL" role="19SJt6">
                  <property role="19SUeA" value="a speed indicator for the speed" />
                </node>
              </node>
            </node>
          </node>
          <node concept="3X6T9g" id="7bDJBXhcmdV" role="3Xp5NH">
            <node concept="OjmMv" id="7bDJBXhcmdW" role="3X6T9h">
              <node concept="19SGf9" id="7bDJBXhcmdX" role="OjmMu">
                <node concept="19SUe$" id="7bDJBXhcmdY" role="19SJt6">
                  <property role="19SUeA" value="a flight recorder, whose job it is to create lists of " />
                </node>
                <node concept="1jUjqm" id="7bDJBXhcmec" role="19SJt6">
                  <node concept="19SGf9" id="7bDJBXhcmed" role="$DsGW">
                    <node concept="19SUe$" id="7bDJBXhcmee" role="19SJt6">
                      <property role="19SUeA" value="Trackpoint" />
                    </node>
                  </node>
                </node>
                <node concept="19SUe$" id="7bDJBXhcmef" role="19SJt6">
                  <property role="19SUeA" value="s that capture the progress of the flight" />
                </node>
              </node>
            </node>
          </node>
        </node>
        <node concept="1_0LV8" id="7bDJBXhcncV" role="1_0VJ0">
          <node concept="19SGf9" id="7bDJBXhcncW" role="1_0LWR">
            <node concept="19SUe$" id="7bDJBXhcncX" role="19SJt6">
              <property role="19SUeA" value="All these components are time-triggered, i.e. it is assumed that they execute in regular intervals, by some kind of scheduler. They all provide an interface " />
            </node>
            <node concept="1jUjqm" id="7bDJBXhcnev" role="19SJt6">
              <node concept="19SGf9" id="7bDJBXhcnew" role="$DsGW">
                <node concept="19SUe$" id="7bDJBXhcnex" role="19SJt6">
                  <property role="19SUeA" value="Timed" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="7bDJBXhcney" role="19SJt6">
              <property role="19SUeA" value=" that provides an operation " />
            </node>
            <node concept="1jUjqm" id="7bDJBXhcnez" role="19SJt6">
              <node concept="19SGf9" id="7bDJBXhcne$" role="$DsGW">
                <node concept="19SUe$" id="7bDJBXhcne_" role="19SJt6">
                  <property role="19SUeA" value="tick" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="7bDJBXhcneA" role="19SJt6">
              <property role="19SUeA" value=" that is called by the scheduler.  So far, these components don't exchange any data yet: sender/receiver interfaces will be used for that later" />
            </node>
            <node concept="anbfL" id="7bDJBXhcneB" role="19SJt6">
              <node concept="19SGf9" id="7bDJBXhcneC" role="anbgW">
                <node concept="19SUe$" id="7bDJBXhcneD" role="19SJt6">
                  <property role="19SUeA" value="Note that this time-triggered architecture is very widespread in embedded software. In future releases of mbeddr we will provide direct support for time-triggered runnables, so you don't have to use an explicit interface such as " />
                </node>
                <node concept="1jUjqm" id="7bDJBXhcneE" role="19SJt6">
                  <node concept="19SGf9" id="7bDJBXhcneF" role="$DsGW">
                    <node concept="19SUe$" id="7bDJBXhcneG" role="19SJt6">
                      <property role="19SUeA" value="Timed" />
                    </node>
                  </node>
                </node>
                <node concept="19SUe$" id="7bDJBXhcneH" role="19SJt6">
                  <property role="19SUeA" value="." />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="7bDJBXhcneI" role="19SJt6">
              <property role="19SUeA" value=". Here is the code so far:" />
            </node>
          </node>
        </node>
        <node concept="1DKdXA" id="3UY8BSpDMV7" role="1_0VJ0">
          <property role="1DKdXC" value="mbeddr" />
          <property role="1DKdXF" value="module ComponentsSRI imports DataStructures { &#10;   &#10;  exported cs interface Timed { &#10;    void tick() &#10;  }    &#10;   &#10;  exported component GPS extends nothing { &#10;    provides Timed timed &#10;    void timed_tick() &lt;= op timed.tick {}&#10;  } &#10;   &#10;  exported component SpeedIndicator extends nothing { &#10;    provides Timed timed &#10;    void timed_tick() &lt;= op timed.tick {}&#10;  } &#10;   &#10;  exported component FlightRecorder extends nothing { &#10;    provides Timed timed &#10;    void timed_tick() &lt;= op timed.tick {}&#10;  } &#10;     &#10;}&#10;" />
        </node>
        <node concept="1_0LV8" id="3UY8BSpDQhI" role="1_0VJ0">
          <node concept="19SGf9" id="3UY8BSpDQhJ" role="1_0LWR">
            <node concept="19SUe$" id="3UY8BSpDQhK" role="19SJt6">
              <property role="19SUeA" value="Let's now look at the data exchange, focussing on the position first. Here is a sender/receiver interface position provider. The interface declares a set of data elements, in this case with physical units:" />
            </node>
          </node>
        </node>
        <node concept="3z_lpU" id="3UY8BSpDRvG" role="1_0VJ0">
          <property role="3z_lpW" value="mbeddr" />
          <property role="3z_lpJ" value="true" />
          <property role="3z_lpV" value="exported sr interface PositionProvider {&#10;  int8/m/ x;                            &#10;  int8/m/ y;                            &#10;  int16/m/ alt;                         &#10;}                                       " />
          <node concept="2NCZwO" id="1YUFCeGolFj" role="3z_lpI">
            <node concept="2NCMab" id="1YUFCeGolFk" role="2NCMaf">
              <ref role="2NCMaa" to="e1tx:5NYlgF0xW$c" resolve="ComponentsSRI" />
            </node>
            <node concept="2NCMab" id="1YUFCeGolFl" role="2NCMaf">
              <ref role="2NCMaa" to="e1tx:5NYlgF0xW$g" resolve="PositionProvider" />
            </node>
          </node>
        </node>
        <node concept="1_0LV8" id="3UY8BSpDS2$" role="1_0VJ0">
          <node concept="19SGf9" id="3UY8BSpDS2_" role="1_0LWR">
            <node concept="19SUe$" id="3UY8BSpDS2A" role="19SJt6">
              <property role="19SUeA" value="The GPS is supposed to provide this data, so we give it a provided port with this interface:" />
            </node>
          </node>
        </node>
        <node concept="3z_lpU" id="3UY8BSpDTMT" role="1_0VJ0">
          <property role="3z_lpW" value="mbeddr" />
          <property role="3z_lpJ" value="true" />
          <property role="3z_lpV" value="exported component GPS extends nothing {&#10;  provides PositionProvider pos         &#10;  provides Timed timed                  &#10;  void init() &lt;= on init {              &#10;  pos.x = 0 m;                          &#10;  pos.y = 0 m;                          &#10;  pos.alt = 0 m;                        &#10;} runnable init                         &#10;  void timed_tick() &lt;= op timed.tick {  &#10;  pos.x++;                              &#10;  pos.y++;                              &#10;} runnable timed_tick                   &#10;} component GPS                         " />
          <node concept="2NCZwO" id="1YUFCeGolEv" role="3z_lpI">
            <node concept="2NCMab" id="1YUFCeGolEw" role="2NCMaf">
              <ref role="2NCMaa" to="e1tx:5NYlgF0xW$c" resolve="ComponentsSRI" />
            </node>
            <node concept="2NCMab" id="1YUFCeGolEx" role="2NCMaf">
              <ref role="2NCMaa" to="e1tx:5NYlgF0xW$L" resolve="GPS" />
            </node>
          </node>
        </node>
        <node concept="1_0LV8" id="3UY8BSpDUqE" role="1_0VJ0">
          <node concept="19SGf9" id="3UY8BSpDUqF" role="1_0LWR">
            <node concept="19SUe$" id="3UY8BSpDUqG" role="19SJt6">
              <property role="19SUeA" value="Note how from within component runnables we can use expressions to assign to the data values defined in the interface as if they were normal fields. Let us now look at the flight recorder. It is supposed to read the data written by the GPS (and the same with the speed indicator):" />
            </node>
          </node>
        </node>
        <node concept="3z_lpU" id="3UY8BSpDV2z" role="1_0VJ0">
          <property role="3z_lpW" value="mbeddr" />
          <property role="3z_lpJ" value="true" />
          <property role="3z_lpV" value="exported component FlightRecorder extends nothing {&#10;  provides Timed timed                             &#10;  requires PositionProvider pp                     &#10;  requires SpeedProvider sp                        &#10;  Trackpoint[1000] recordedFlight;                 &#10;  uint16 count = 0;                                &#10;  void timed_tick() &lt;= op timed.tick {             &#10;                                                   &#10;  with (recordedFlight[count]) {                   &#10;  id = ((int8) count);                             &#10;  x = pp.x;                                        &#10;  y = pp.y;                                        &#10;  alt = pp.alt;                                    &#10;  speed = sp.speed;                                &#10;}                                                  &#10;  count++;                                         &#10;} runnable timed_tick                              &#10;  Trackpoint getFlightNo(uint16 no) &lt;= no trigger {&#10;  return recordedFlight[no];                       &#10;} runnable getFlightNo                             &#10;} component FlightRecorder                         " />
          <node concept="2NCZwO" id="1YUFCeGolH5" role="3z_lpI">
            <node concept="2NCMab" id="1YUFCeGolH6" role="2NCMaf">
              <ref role="2NCMaa" to="e1tx:5NYlgF0xW$c" resolve="ComponentsSRI" />
            </node>
            <node concept="2NCMab" id="1YUFCeGolH7" role="2NCMaf">
              <ref role="2NCMaa" to="e1tx:5NYlgF0xWBk" resolve="FlightRecorder" />
            </node>
          </node>
        </node>
        <node concept="1_0LV8" id="3UY8BSpDWIf" role="1_0VJ0">
          <node concept="19SGf9" id="3UY8BSpDWIg" role="1_0LWR">
            <node concept="19SUe$" id="3UY8BSpDWIh" role="19SJt6">
              <property role="19SUeA" value="Inside the " />
            </node>
            <node concept="1jUjqm" id="3UY8BSpDXls" role="19SJt6">
              <node concept="19SGf9" id="3UY8BSpDXlt" role="$DsGW">
                <node concept="19SUe$" id="3UY8BSpDXlu" role="19SJt6">
                  <property role="19SUeA" value="with" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="3UY8BSpDXlr" role="19SJt6">
              <property role="19SUeA" value="-statement, we can access the data acquired via the " />
            </node>
            <node concept="1jUjqm" id="3UY8BSpDXl_" role="19SJt6">
              <node concept="19SGf9" id="3UY8BSpDXlA" role="$DsGW">
                <node concept="19SUe$" id="3UY8BSpDXlB" role="19SJt6">
                  <property role="19SUeA" value="pp" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="3UY8BSpDXl$" role="19SJt6">
              <property role="19SUeA" value=" and " />
            </node>
            <node concept="1jUjqm" id="3UY8BSpDXlM" role="19SJt6">
              <node concept="19SGf9" id="3UY8BSpDXlN" role="$DsGW">
                <node concept="19SUe$" id="3UY8BSpDXlO" role="19SJt6">
                  <property role="19SUeA" value="sp" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="3UY8BSpDXlL" role="19SJt6">
              <property role="19SUeA" value=" required ports.  What distinguishes this from global variables, of course, is that the component instances still have to be wired: required ports have to be connected to provided ports, in this case, defining access to the data items:" />
            </node>
          </node>
        </node>
        <node concept="3z_lpU" id="3UY8BSpDYqQ" role="1_0VJ0">
          <property role="3z_lpW" value="mbeddr" />
          <property role="3z_lpJ" value="true" />
          <property role="3z_lpV" value="instances instances {                   &#10;  instance GPS gps_comp                 &#10;  instance SpeedIndicator indicator     &#10;  instance FlightRecorder recorder      &#10;  connect recorder.sp to indicator.speed&#10;  connect recorder.pp to gps_comp.pos   &#10;  adapt gps -&gt; gps_comp.timed           &#10;  adapt si -&gt; indicator.timed           &#10;  adapt rec -&gt; recorder.timed           &#10;}                                       " />
          <node concept="2NCZwO" id="1YUFCeGolHB" role="3z_lpI">
            <node concept="2NCMab" id="1YUFCeGolHC" role="2NCMaf">
              <ref role="2NCMaa" to="e1tx:5NYlgF0xW$c" resolve="ComponentsSRI" />
            </node>
            <node concept="2NCMab" id="1YUFCeGolHD" role="2NCMaf">
              <ref role="2NCMaa" to="e1tx:5NYlgF0xXPm" resolve="instances" />
            </node>
          </node>
        </node>
        <node concept="1_0LV8" id="3UY8BSpDZD$" role="1_0VJ0">
          <node concept="19SGf9" id="3UY8BSpDZD_" role="1_0LWR">
            <node concept="19SUe$" id="3UY8BSpDZDA" role="19SJt6">
              <property role="19SUeA" value="This part of the tutorial only provided a few examples of Interfaces and Components. For a full discussion of Interfaces and Components see \\fordetails{Interfaces and Components}{\\sect{details_components}}" />
            </node>
          </node>
        </node>
      </node>
      <node concept="1_0VNX" id="5MdJlx$fMK$" role="1_0VJ0">
        <property role="TrG5h" value="compositeComponents" />
        <property role="1_0VJr" value="Composite Components" />
        <node concept="1_0LV8" id="5MdJlx$fMK_" role="1_0VJ0">
          <node concept="19SGf9" id="5MdJlx$fMKA" role="1_0LWR">
            <node concept="19SUe$" id="5MdJlx$fMKB" role="19SJt6">
              <property role="19SUeA" value="Components are great to structure your code in reusable pieces. But typically when your systems grow you want to reuse whole subsystems. To the outside they look exactly like any other component but on the inside they again are wired up out of many components. This can be achieved with mbeddr's composite components.\nA composite component, as any other component can require and provide interfaces from/to its environment. In addition to regular components it has an additional code block called " />
            </node>
            <node concept="1jUjqm" id="4dKKrcDSYTe" role="19SJt6">
              <node concept="19SGf9" id="4dKKrcDSYTf" role="$DsGW">
                <node concept="19SUe$" id="4dKKrcDSYTg" role="19SJt6">
                  <property role="19SUeA" value="internal instances" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="4dKKrcDSYTd" role="19SJt6">
              <property role="19SUeA" value=" for instantiating other components and wire them up. \nLet's build an imaginary GPS parser that can be reused. The first interface we create is a client server interface which accepts single characters. Those characters will be used by a line parser which can tokenize the stream of chars into whole lines and at the same time figures out which command was send by the client. Each line is then fed into another component which itself delegates the command to a command handler. This command handler parses the command and transforms the data into a struct that can be easily consumed by a client. The client of the GPS parser does not need to know how the parsing works internally and that it again is split up into separate components. The only relevant part is that she needs to provide the system with the stream of characters and takes the events produced by the GPS parser to work on them. To achieve this we create a composite component which provides the " />
            </node>
            <node concept="3z_lpY" id="4dKKrcE0B9l" role="19SJt6">
              <node concept="2NCZwO" id="4dKKrcE0B9B" role="3z_lpZ">
                <node concept="2NCMab" id="4dKKrcE0B9H" role="2NCMaf">
                  <ref role="2NCMaa" to="e1tx:4dKKrcDT0iK" resolve="CompositeComponents" />
                </node>
                <node concept="2NCMab" id="4dKKrcE0BYQ" role="2NCMaf">
                  <ref role="2NCMaa" to="e1tx:6xLvLBZODf2" resolve="CharParser" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="4dKKrcE0B9k" role="19SJt6">
              <property role="19SUeA" value=" and requires the " />
            </node>
            <node concept="3z_lpY" id="4dKKrcE0BYX" role="19SJt6">
              <node concept="2NCZwO" id="4dKKrcE0BZp" role="3z_lpZ">
                <node concept="2NCMab" id="4dKKrcE0BZv" role="2NCMaf">
                  <ref role="2NCMaa" to="e1tx:4dKKrcDT0iK" resolve="CompositeComponents" />
                </node>
                <node concept="2NCMab" id="4dKKrcE0BZC" role="2NCMaf">
                  <ref role="2NCMaa" to="e1tx:1ye7yATSDv1" resolve="NmeaRmcEventProcessor" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="4dKKrcE0BYW" role="19SJt6">
              <property role="19SUeA" value=". In the wiring we instantiate the respective components and wire them up. Finally, we " />
            </node>
            <node concept="28N2ik" id="4dKKrcE0COD" role="19SJt6">
              <node concept="19SGf9" id="4dKKrcE0COE" role="$DsGW">
                <node concept="19SUe$" id="4dKKrcE0COF" role="19SJt6">
                  <property role="19SUeA" value="delegate" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="4dKKrcE0COC" role="19SJt6">
              <property role="19SUeA" value=" the outside required and provided ports. The whole code for the composite component is here. Don't forget to add the " />
            </node>
            <node concept="1jUjqm" id="4dKKrcE0Ea3" role="19SJt6">
              <node concept="19SGf9" id="4dKKrcE0Ea4" role="$DsGW">
                <node concept="19SUe$" id="4dKKrcE0Ea5" role="19SJt6">
                  <property role="19SUeA" value="composite components" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="4dKKrcE0Ea2" role="19SJt6">
              <property role="19SUeA" value=" config item to the build configuration." />
            </node>
          </node>
        </node>
        <node concept="3z_lpU" id="4dKKrcE0Ejt" role="1_0VJ0">
          <property role="3z_lpW" value="mbeddr" />
          <property role="3z_lpV" value="exported composite component NmeaStack {                                        &#10;                                                                                &#10;  provides CharParser charParser                                                &#10;  requires NmeaRmcEventProcessor rmcEventProcessor                              &#10;                                                                                &#10;  internal instances {                                                          &#10;  instance NmeaLineParserImpl lineParser                                        &#10;  instance NmeaSentenceHandlerImpl sentenceHandler                              &#10;                                                                                &#10;  instance NmeaRmcHandlerImpl rmcHandler                                        &#10;  connect lineParser.sentenceHandler to sentenceHandler.sentenceHandler         &#10;  connect multi sentenceHandler.commandHandlers to rmcHandler.nmeaCommandHandler&#10;                                                                                &#10;  delegate charParser to lineParser.charParser                                  &#10;  delegate rmcEventProcessor to rmcHandler.nmeaRmcEventProcessor                &#10;}                                                                               &#10;}                                                                               " />
          <property role="3z_lpJ" value="false" />
          <node concept="2NCZwO" id="4dKKrcE0Ekm" role="3z_lpI">
            <node concept="2NCMab" id="4dKKrcE0Eks" role="2NCMaf">
              <ref role="2NCMaa" to="e1tx:4dKKrcDT0iK" resolve="CompositeComponents" />
            </node>
            <node concept="2NCMab" id="4dKKrcE0Ek_" role="2NCMaf">
              <ref role="2NCMaa" to="e1tx:6xLvLC0cJ4Z" resolve="NmeaStack" />
            </node>
          </node>
        </node>
      </node>
      <node concept="1_0VNX" id="5MdJlx$fMJ4" role="1_0VJ0">
        <property role="TrG5h" value="interfaceTypes" />
        <property role="1_0VJr" value="Interface Types" />
        <node concept="1_0LV8" id="5MdJlx$fMKk" role="1_0VJ0">
          <node concept="19SGf9" id="5MdJlx$fMKl" role="1_0LWR">
            <node concept="19SUe$" id="5MdJlx$fMKt" role="19SJt6">
              <property role="19SUeA" value="In a few rare cases you want to store a required port also as a local variable (e.g. when iterating over a bunch of multiports where you filter out some of them). In even rarer cases you may want to pass a required port as an argument to a function or runnable you are calling or store it in a global variable. To address those use cases we introduces a type in mbeddr called " />
            </node>
            <node concept="1jUjqm" id="4dKKrcE0Ibi" role="19SJt6">
              <node concept="19SGf9" id="4dKKrcE0Ibj" role="$DsGW">
                <node concept="19SUe$" id="4dKKrcE0Ibk" role="19SJt6">
                  <property role="19SUeA" value="interface" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="4dKKrcE0Ibl" role="19SJt6">
              <property role="19SUeA" value=". In order to use an interface in such a interface type this interface has to be specially marked with an annotation " />
            </node>
            <node concept="2OlAs7" id="yaVrOuw0OJ" role="19SJt6">
              <node concept="19SGf9" id="yaVrOuw0OM" role="$DsGW">
                <node concept="19SUe$" id="yaVrOuw0ON" role="19SJt6">
                  <property role="19SUeA" value="Toggle Can be used as Type" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="4dKKrcE0Jvc" role="19SJt6">
              <property role="19SUeA" value="." />
            </node>
          </node>
        </node>
        <node concept="3z_lpU" id="4dKKrcE2aYI" role="1_0VJ0">
          <property role="3z_lpW" value="mbeddr" />
          <property role="3z_lpV" value="exported cs interface NmeaCommandHandler can be used as type {  &#10;  boolean canHandle(string command)                             &#10;  void handle(int8[MAX_NMEA_WORD_COUNT]* words, uint8 wordCount)&#10;}                                                               " />
          <property role="3z_lpJ" value="false" />
          <node concept="2NCZwO" id="4dKKrcE2aZo" role="3z_lpI">
            <node concept="2NCMab" id="4dKKrcE2aZw" role="2NCMaf">
              <ref role="2NCMaa" to="e1tx:4dKKrcDT0iK" resolve="CompositeComponents" />
            </node>
            <node concept="2NCMab" id="4dKKrcE2aZG" role="2NCMaf">
              <ref role="2NCMaa" to="e1tx:6xLvLC0aXJK" resolve="NmeaCommandHandler" />
            </node>
          </node>
        </node>
        <node concept="1_1sxE" id="4dKKrcE2aZO" role="1_0VJ0">
          <property role="TrG5h" value="empty_-1" />
        </node>
        <node concept="3z_lpU" id="4dKKrcE2b1p" role="1_0VJ0">
          <property role="3z_lpW" value="mbeddr" />
          <property role="3z_lpJ" value="true" />
          <property role="3z_lpV" value="void sentenceHandler_parseSentence(int8[MAX_NMEA_WORD_COUNT]* words, uint8 wordCount) &lt;= op sentenceHandler.parseSentence {&#10;  interface&lt;NmeaCommandHandler&gt; handlerToCall = null;                                                                      &#10;  for (i ++ in [0..MAX_NMEA_COMMAND_HANDLER_COUNT[) {                                                                      &#10;  if (commandHandlers[i] != null &amp;&amp; commandHandlers[i].canHandle(words[0])) {                                              &#10;  handlerToCall = commandHandlers[i];                                                                                      &#10;} if                                                                                                                       &#10;} for                                                                                                                      &#10;  handlerToCall.handle(words, wordCount);                                                                                  &#10;} runnable sentenceHandler_parseSentence                                                                                   " />
          <node concept="2NCZwO" id="4dKKrcE2b2i" role="3z_lpI">
            <node concept="2NCMab" id="4dKKrcE2b2q" role="2NCMaf">
              <ref role="2NCMaa" to="e1tx:4dKKrcDT0iK" resolve="CompositeComponents" />
            </node>
            <node concept="2NCMab" id="4dKKrcE2cfj" role="2NCMaf">
              <ref role="2NCMaa" to="e1tx:6xLvLC0aSCr" resolve="sentenceHandler_parseSentence" />
            </node>
          </node>
        </node>
        <node concept="1_0LV8" id="4dKKrcE2cgr" role="1_0VJ0">
          <node concept="19SGf9" id="4dKKrcE2cgs" role="1_0LWR">
            <node concept="19SUe$" id="4dKKrcE2cgt" role="19SJt6">
              <property role="19SUeA" value="The example above actually would not need the interface type as the " />
            </node>
            <node concept="1jUjqm" id="4dKKrcE2ch$" role="19SJt6">
              <node concept="19SGf9" id="4dKKrcE2ch_" role="$DsGW">
                <node concept="19SUe$" id="4dKKrcE2chA" role="19SJt6">
                  <property role="19SUeA" value="handle" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="4dKKrcE2chB" role="19SJt6">
              <property role="19SUeA" value=" runnable could be called right in place." />
            </node>
          </node>
        </node>
      </node>
      <node concept="1_0VNX" id="3zwhDFH0cIk" role="1_0VJ0">
        <property role="TrG5h" value="visual" />
        <property role="1_0VJr" value="Visualizing Components" />
        <node concept="1_0LV8" id="7bDJBXhcnlB" role="1_0VJ0">
          <node concept="19SGf9" id="7bDJBXhcnlC" role="1_0LWR">
            <node concept="19SUe$" id="7bDJBXhcnlD" role="19SJt6">
              <property role="19SUeA" value="mbeddr's diagramming capabilities are put to use in two ways in the context of components: component/interface dependencies and instance diagrams." />
            </node>
          </node>
        </node>
        <node concept="1_0LV8" id="1Pi5yleGkDB" role="1_0VJ0">
          <node concept="19SGf9" id="1Pi5yleGkDC" role="1_0LWR">
            <node concept="19SUe$" id="1Pi5yleGkDD" role="19SJt6" />
            <node concept="2vpllh" id="1Pi5yleGo6M" role="19SJt6">
              <node concept="19SGf9" id="1Pi5yleGo6N" role="$DsGW">
                <node concept="19SUe$" id="1Pi5yleGo6O" role="19SJt6">
                  <property role="19SUeA" value="* Component/Interface Dependencies" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="1Pi5yleGo6L" role="19SJt6">
              <property role="19SUeA" value=" Select a component or an interface and execute the " />
            </node>
            <node concept="28N2ik" id="1Pi5yleGo6W" role="19SJt6">
              <node concept="19SGf9" id="1Pi5yleGo6X" role="$DsGW">
                <node concept="19SUe$" id="1Pi5yleGo6Y" role="19SJt6">
                  <property role="19SUeA" value="Visualize" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="1Pi5yleGo6V" role="19SJt6">
              <property role="19SUeA" value=" action from the context menu (or press " />
            </node>
            <node concept="2OoWia" id="yaVrOuw0P6" role="19SJt6">
              <node concept="19SGf9" id="yaVrOuw0P9" role="$DsGW">
                <node concept="19SUe$" id="yaVrOuw0Pa" role="19SJt6">
                  <property role="19SUeA" value="Ctrl-Alt-V" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="1Pi5yleGo8i" role="19SJt6">
              <property role="19SUeA" value="). " />
            </node>
            <node concept="2Sbdz4" id="6UY8Kx5eX1t" role="19SJt6">
              <ref role="2SbdyP" node="1Pi5yleHyq7" resolve="vcomponents" />
            </node>
            <node concept="19SUe$" id="6UY8Kx5eX1s" role="19SJt6">
              <property role="19SUeA" value=" shows the result. " />
            </node>
          </node>
        </node>
        <node concept="2SaynC" id="1Pi5yleHyq7" role="1_0VJ0">
          <property role="TrG5h" value="vcomponents" />
          <node concept="2Sb_l4" id="3DAECxFCKzg" role="2SbwM5">
            <property role="2Sb_kV" value="tutorial/v_components.png" />
            <ref role="2Sb_kU" to="1842:2fBMM_3XZ4D" resolve="images" />
          </node>
          <node concept="OjmMv" id="1Pi5yleHyqb" role="2SaI5j">
            <node concept="19SGf9" id="1Pi5yleHyqc" role="OjmMu">
              <node concept="19SUe$" id="1Pi5yleHyqd" role="19SJt6">
                <property role="19SUeA" value="The interface/components dependency diagram shows all components visible from the current module, the interfaces, and the provided (solid lines) and required ports (dashed lines)." />
              </node>
            </node>
          </node>
          <node concept="2bctqb" id="1Pi5yleHyqf" role="3SHJ_F" />
        </node>
        <node concept="1_0LV8" id="1Pi5yleHx2g" role="1_0VJ0">
          <node concept="19SGf9" id="1Pi5yleHx2h" role="1_0LWR">
            <node concept="19SUe$" id="1Pi5yleHzMf" role="19SJt6" />
            <node concept="2vpllh" id="1Pi5yleHzMc" role="19SJt6">
              <node concept="19SGf9" id="1Pi5yleHzMd" role="$DsGW">
                <node concept="19SUe$" id="1Pi5yleHzMe" role="19SJt6">
                  <property role="19SUeA" value="* Instance/Wiring Diagrams" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="1Pi5yleHzMb" role="19SJt6">
              <property role="19SUeA" value=" You can also select an instance configuration and visualize it. You'll get a diagram that shows component instances and their connections (" />
            </node>
            <node concept="2Sbdz4" id="6UY8Kx5eX1k" role="19SJt6">
              <ref role="2SbdyP" node="1Pi5yleHzNj" resolve="vinstances" />
            </node>
            <node concept="19SUe$" id="6UY8Kx5eX1j" role="19SJt6">
              <property role="19SUeA" value=")." />
            </node>
          </node>
        </node>
        <node concept="2SaynC" id="1Pi5yleHzNj" role="1_0VJ0">
          <property role="TrG5h" value="vinstances" />
          <node concept="2Sb_l4" id="1Pi5yleHzO0" role="2SbwM5">
            <property role="2Sb_kV" value="tutorial/v_instances.png" />
            <ref role="2Sb_kU" to="1842:2fBMM_3XZ4D" resolve="images" />
          </node>
          <node concept="OjmMv" id="1Pi5yleHzNn" role="2SaI5j">
            <node concept="19SGf9" id="1Pi5yleHzNo" role="OjmMu">
              <node concept="19SUe$" id="1Pi5yleHzNp" role="19SJt6">
                <property role="19SUeA" value="This diagram shows component instances and their connectors. The label in the instance boxes contain the instance name and the component name (after the colon). The edges represent connectors. The label shows the required port (before the arrow, the provided port name (after the arrow), and the name of the interface used by the two ports (on the new line)." />
              </node>
            </node>
          </node>
          <node concept="2bctqb" id="1Pi5yleHzNr" role="3SHJ_F" />
        </node>
        <node concept="1_1sxE" id="1Pi5yleHzMO" role="1_0VJ0">
          <property role="TrG5h" value="empty_1394868521113_6" />
        </node>
      </node>
      <node concept="1_0VNX" id="3zwhDFH0cPS" role="1_0VJ0">
        <property role="TrG5h" value="contract" />
        <property role="1_0VJr" value="Contract Verification" />
        <node concept="1_0LV8" id="6UY8Kx5f7Ma" role="1_0VJ0">
          <node concept="19SGf9" id="6UY8Kx5f7Mb" role="1_0LWR">
            <node concept="19SUe$" id="6UY8Kx5f7Mc" role="19SJt6">
              <property role="19SUeA" value="mbeddr comes with support for verifying contracts of components statically. This verification is based on C-level verification with CBMC (for a more detailed discussion about the formal verification with mbeddr, please look at " />
            </node>
            <node concept="1_0GAv" id="2JeiqU7f4YR" role="19SJt6">
              <ref role="1_0GAl" to="us0v:7OKLwZ_7lPw" resolve="functional_verification" />
            </node>
            <node concept="19SUe$" id="2JeiqU7f4YQ" role="19SJt6">
              <property role="19SUeA" value=". Let's set up our tutorial to use verification.  Let us verify the " />
            </node>
            <node concept="1jUjqm" id="6UY8Kx5f9Ze" role="19SJt6">
              <node concept="19SGf9" id="6UY8Kx5f9Zf" role="$DsGW">
                <node concept="19SUe$" id="6UY8Kx5f9Zg" role="19SJt6">
                  <property role="19SUeA" value="InMemoryStorage" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="6UY8Kx5f9Zd" role="19SJt6">
              <property role="19SUeA" value=" component. To do so,  first add the " />
            </node>
            <node concept="1jUjqm" id="6UY8Kx5fbmR" role="19SJt6">
              <node concept="19SGf9" id="6UY8Kx5fbmS" role="$DsGW">
                <node concept="19SUe$" id="6UY8Kx5fbmT" role="19SJt6">
                  <property role="19SUeA" value="com.mbeddr.analyses.componentcontracts" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="6UY8Kx5fbmQ" role="19SJt6">
              <property role="19SUeA" value=" devkit to the model that contains the components code. Then use an intention to add the " />
            </node>
            <node concept="1jUjqm" id="6UY8Kx5fcI$" role="19SJt6">
              <node concept="19SGf9" id="6UY8Kx5fcI_" role="$DsGW">
                <node concept="19SUe$" id="6UY8Kx5fcIA" role="19SJt6">
                  <property role="19SUeA" value="verifiable" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="6UY8Kx5fcIz" role="19SJt6">
              <property role="19SUeA" value=" flag to the component. To make the verification work, you will have to provide some more information in the inspector:" />
            </node>
          </node>
        </node>
        <node concept="1DKdXA" id="6UY8Kx5fgPR" role="1_0VJ0">
          <property role="1DKdXC" value="mbeddr" />
          <property role="1DKdXF" value="  entry point: verification   &#10;  loops unwinding: 2         &#10;  unwinding assertions: false" />
        </node>
        <node concept="1_0LV8" id="6UY8Kx5fj_a" role="1_0VJ0">
          <node concept="19SGf9" id="6UY8Kx5fj_b" role="1_0LWR">
            <node concept="19SUe$" id="6UY8Kx5fj_c" role="19SJt6">
              <property role="19SUeA" value="Let us look at the three parameters you have to set here: The first one determines from where the program is &quot;executed&quot;. The entry point should be selected to be &quot;close&quot; to the to-be-verified component (if you verify the whole system, then, at least for big systems, this will take long). In our case we use a special test case " />
            </node>
            <node concept="1jUjqm" id="6UY8Kx5fj_y" role="19SJt6">
              <node concept="19SGf9" id="6UY8Kx5fj_z" role="$DsGW">
                <node concept="19SUe$" id="6UY8Kx5fj_$" role="19SJt6">
                  <property role="19SUeA" value="verification" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="6UY8Kx5fj_x" role="19SJt6">
              <property role="19SUeA" value=", which looks as follows:" />
            </node>
          </node>
        </node>
        <node concept="3z_lpU" id="6UY8Kx5hi2F" role="1_0VJ0">
          <property role="3z_lpW" value="mbeddr" />
          <property role="3z_lpJ" value="true" />
          <property role="3z_lpV" value="instances verificationInstances {                     &#10;  instance Interpolator interpol(divident = 2)        &#10;  connect interpol.store to store.store               &#10;  instance InMemoryStorage store                      &#10;  adapt verificationInterpolator -&gt; interpol.processor&#10;}                                                     " />
          <node concept="2NCZwO" id="1YUFCeGolDh" role="3z_lpI">
            <node concept="2NCMab" id="1YUFCeGolDi" role="2NCMaf">
              <ref role="2NCMaa" to="e1tx:1w5Xuj1QYPN" resolve="Components" />
            </node>
            <node concept="2NCMab" id="1YUFCeGolDj" role="2NCMaf">
              <ref role="2NCMaa" to="e1tx:1qK_mmzpCrP" resolve="verificationInstances" />
            </node>
          </node>
        </node>
        <node concept="3z_lpU" id="6UY8Kx5hi3v" role="1_0VJ0">
          <property role="3z_lpW" value="mbeddr" />
          <property role="3z_lpJ" value="true" />
          <property role="3z_lpV" value="exported testcase verification {        &#10;  initialize verificationInstances;     &#10;  Trackpoint p1 = {                     &#10;  id = 1,                               &#10;  time = 1 s,                           &#10;  speed = 10 mps                        &#10;};                                      &#10;  Trackpoint p2 = {                     &#10;  id = 1,                               &#10;  time = 1 s,                           &#10;  speed = 20 mps                        &#10;};                                      &#10;  verificationInterpolator.process(&amp;p1);&#10;  verificationInterpolator.process(&amp;p2);&#10;} verification(test case)               " />
          <node concept="2NCZwO" id="1YUFCeGolEG" role="3z_lpI">
            <node concept="2NCMab" id="1YUFCeGolEH" role="2NCMaf">
              <ref role="2NCMaa" to="e1tx:1w5Xuj1QYPN" resolve="Components" />
            </node>
            <node concept="2NCMab" id="1YUFCeGolEI" role="2NCMaf">
              <ref role="2NCMaa" to="e1tx:1qK_mmzpCsh" resolve="verification" />
            </node>
          </node>
        </node>
        <node concept="1_0LV8" id="6UY8Kx5hjrP" role="1_0VJ0">
          <node concept="19SGf9" id="6UY8Kx5hjrQ" role="1_0LWR">
            <node concept="19SUe$" id="6UY8Kx5hjrR" role="19SJt6">
              <property role="19SUeA" value="The second line in the configuration determines how often a loop is executed. You should start with low numbers to keep verification times low. Finally, the third parameter determines if the verification should fail in case it cannot be proven that the " />
            </node>
            <node concept="1jUjqm" id="6UY8Kx5hjsm" role="19SJt6">
              <node concept="19SGf9" id="6UY8Kx5hjsn" role="$DsGW">
                <node concept="19SUe$" id="6UY8Kx5hjso" role="19SJt6">
                  <property role="19SUeA" value="unwinding loops" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="6UY8Kx5hjsl" role="19SJt6">
              <property role="19SUeA" value=" number is sufficient.  You can now run the verification by selecting the component and executing the " />
            </node>
            <node concept="2OlAs7" id="yaVrOuw0PD" role="19SJt6">
              <node concept="19SGf9" id="yaVrOuw0PG" role="$DsGW">
                <node concept="19SUe$" id="yaVrOuw0PH" role="19SJt6">
                  <property role="19SUeA" value="Verify Component" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="6UY8Kx5hkNY" role="19SJt6">
              <property role="19SUeA" value=" action. After a few seconds, you'll get a result table that reports everything as ok (see " />
            </node>
            <node concept="2Sbdz4" id="6UY8Kx5hyCt" role="19SJt6">
              <ref role="2SbdyP" node="6UY8Kx5hnzL" resolve="verificationOK" />
            </node>
            <node concept="19SUe$" id="6UY8Kx5hyCs" role="19SJt6">
              <property role="19SUeA" value="): every precondition of every operation in every provided port has been proven to be correct." />
            </node>
          </node>
        </node>
        <node concept="2SaynC" id="6UY8Kx5hnzL" role="1_0VJ0">
          <property role="TrG5h" value="verificationOK" />
          <property role="2Sbq$t" value="true" />
          <node concept="2Sb_l4" id="3DAECxFCKza" role="2SbwM5">
            <property role="2Sb_kV" value="tutorial/verificationOK.png" />
            <ref role="2Sb_kU" to="1842:2fBMM_3XZ4D" resolve="images" />
          </node>
          <node concept="OjmMv" id="6UY8Kx5hnzP" role="2SaI5j">
            <node concept="19SGf9" id="6UY8Kx5hnzQ" role="OjmMu">
              <node concept="19SUe$" id="6UY8Kx5hnzR" role="19SJt6">
                <property role="19SUeA" value="The table that shows the verification results; everything is ok in this case." />
              </node>
            </node>
          </node>
          <node concept="3SGHZ$" id="6UY8Kx5hn$B" role="3SHJ_F">
            <property role="3SGHZ_" value="70" />
          </node>
        </node>
        <node concept="1_0LV8" id="6UY8Kx5hoWQ" role="1_0VJ0">
          <node concept="19SGf9" id="6UY8Kx5hoWR" role="1_0LWR">
            <node concept="19SUe$" id="6UY8Kx5hoWS" role="19SJt6">
              <property role="19SUeA" value="Let us introduce an error. The following version of the " />
            </node>
            <node concept="1jUjqm" id="6UY8Kx5hql8" role="19SJt6">
              <node concept="19SGf9" id="6UY8Kx5hql9" role="$DsGW">
                <node concept="19SUe$" id="6UY8Kx5hqla" role="19SJt6">
                  <property role="19SUeA" value="trackpointStore_store" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="6UY8Kx5hql7" role="19SJt6">
              <property role="19SUeA" value=" runnable does not actually store the trackpoint. This violates the postcondition, which claims that " />
            </node>
            <node concept="1jUjqm" id="6UY8Kx5hrGL" role="19SJt6">
              <node concept="19SGf9" id="6UY8Kx5hrGM" role="$DsGW">
                <node concept="19SUe$" id="6UY8Kx5hrGN" role="19SJt6">
                  <property role="19SUeA" value="storedTP != null" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="6UY8Kx5hrGK" role="19SJt6">
              <property role="19SUeA" value=". Note that for the analysis to work, all paths through the body of a function (or a runnable) must end with a return (you'll get an in-IDE error if you don't do this). " />
            </node>
          </node>
        </node>
        <node concept="1DKdXA" id="6UY8Kx5husO" role="1_0VJ0">
          <property role="1DKdXC" value="mbeddr" />
          <property role="1DKdXF" value="void trackpointStore_store(Trackpoint* tp) &lt;- op store.store { &#10;  return; &#10;} " />
        </node>
        <node concept="1_0LV8" id="6UY8Kx5hvQ4" role="1_0VJ0">
          <node concept="19SGf9" id="6UY8Kx5hvQ5" role="1_0LWR">
            <node concept="19SUe$" id="6UY8Kx5hvQ6" role="19SJt6">
              <property role="19SUeA" value="Let us rerun the verification. Now we get an error, as shown in " />
            </node>
            <node concept="2Sbdz4" id="6UY8Kx5hyCk" role="19SJt6">
              <ref role="2SbdyP" node="6UY8Kx5hvRW" resolve="verificationNotOK" />
            </node>
            <node concept="19SUe$" id="6UY8Kx5hyCj" role="19SJt6">
              <property role="19SUeA" value=". Note how the lower part of the table now shows the execution trace that led to the contract violation. You should check the " />
            </node>
            <node concept="1jUjqm" id="6UY8Kx5hxgF" role="19SJt6">
              <node concept="19SGf9" id="6UY8Kx5hxgG" role="$DsGW">
                <node concept="19SUe$" id="6UY8Kx5hxgH" role="19SJt6">
                  <property role="19SUeA" value="Call/Return" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="6UY8Kx5hxgE" role="19SJt6">
              <property role="19SUeA" value=" checkbox to filter the trace to only show the call/return-granularity, and not every statement. You can also double-click onto the trace elements to select the particular program element in the code." />
            </node>
          </node>
        </node>
        <node concept="2SaynC" id="6UY8Kx5hvRW" role="1_0VJ0">
          <property role="TrG5h" value="verificationNotOK" />
          <node concept="2Sb_l4" id="3DAECxFCKzd" role="2SbwM5">
            <property role="2Sb_kV" value="tutorial/verificationNotOK.png" />
            <ref role="2Sb_kU" to="1842:2fBMM_3XZ4D" resolve="images" />
          </node>
          <node concept="OjmMv" id="6UY8Kx5hvS0" role="2SaI5j">
            <node concept="19SGf9" id="6UY8Kx5hvS1" role="OjmMu">
              <node concept="19SUe$" id="6UY8Kx5hvS2" role="19SJt6">
                <property role="19SUeA" value="The table that shows the verification results; now we have an error, and the trace in the bottom half shows an example execution that led to the error." />
              </node>
            </node>
          </node>
          <node concept="3SGHZ$" id="6UY8Kx5hxgB" role="3SHJ_F">
            <property role="3SGHZ_" value="70" />
          </node>
        </node>
      </node>
    </node>
    <node concept="1_1sxE" id="3D8Uf60N7mY" role="1_0VJ0">
      <property role="TrG5h" value="empty_1383658449039_29" />
    </node>
    <node concept="2CRZSB" id="1SYZy6QWXKG" role="lGtFl">
      <node concept="2NCZwO" id="1SYZy6QWXKJ" role="2CRYsu">
        <node concept="2NCMab" id="1SYZy6QWXKP" role="2NCMaf">
          <ref role="2NCMaa" to="e1tx:1w5Xuj1QYPN" resolve="Components" />
        </node>
      </node>
    </node>
    <node concept="1_0j5j" id="3ZdGyCRQAT4" role="1DXQ57">
      <ref role="1_0j5g" to="us0v:7OKLwZ_7fp5" resolve="C_FormalVerification" />
    </node>
  </node>
</model>

