<?xml version="1.0" encoding="UTF-8"?>
<model ref="r:38897e08-83fd-42c7-91d3-65b102721940(com.mbeddr.tutorial.documentation.ug.cextensions)" content="root">
  <persistence version="9" />
  <imports>
    <import index="ntnz" ref="r:7f372397-146b-40d5-9f20-607974c4fed4(com.mbeddr.tutorial.documentation.ug._main)" implicit="true" />
    <import index="c4ys" ref="r:4fb22f91-1e13-48a0-a300-21fa004a07ef(com.mbeddr.tutorial.documentation.ug.mbeddrCvsC99)" implicit="true" />
    <import index="cmgk" ref="r:679066bc-2da8-4932-a09c-5d2b3d47b911(com.mbeddr.ext.units.siunits)" implicit="true" />
    <import index="e1tx" ref="r:bd5ec23c-c294-47cc-a078-675c03abdb69(mbeddr.tutorial.main.defaultExtensions)" implicit="true" />
  </imports>
  <registry>
    <language id="92d2ea16-5a42-4fdf-a676-c7604efe3504" name="de.slisson.mps.richtext">
      <concept id="2557074442922380897" name="de.slisson.mps.richtext.structure.Text" flags="ng" index="19SGf9">
        <child id="2557074442922392302" name="words" index="19SJt6" />
      </concept>
      <concept id="2557074442922438156" name="de.slisson.mps.richtext.structure.Word" flags="ng" index="19SUe$">
        <property id="2557074442922438158" name="escapedValue" index="19SUeA" />
      </concept>
    </language>
    <language id="2374bc90-7e37-41f1-a9c4-c2e35194c36a" name="com.mbeddr.doc">
      <concept id="620304030119138923" name="com.mbeddr.doc.structure.BoldFormattedText" flags="ng" index="2vpllh" />
      <concept id="6165313375055797476" name="com.mbeddr.doc.structure.FormattedText" flags="ng" index="$DsGX">
        <child id="6165313375055797477" name="text" index="$DsGW" />
      </concept>
      <concept id="6657644269295214799" name="com.mbeddr.doc.structure.IDocumentLike" flags="ng" index="G9hjZ">
        <reference id="6657644269295214800" name="config" index="G9hjw" />
        <child id="126932837435370865" name="authors" index="Wq1Bf" />
        <child id="8730648445433290694" name="dependsOn" index="1DXQ57" />
      </concept>
      <concept id="2286331641395252232" name="com.mbeddr.doc.structure.NamedNodeModelContentPointerElement" flags="ng" index="2NCMab">
        <reference id="2286331641395252233" name="node" index="2NCMaa" />
      </concept>
      <concept id="2286331641395238583" name="com.mbeddr.doc.structure.ModelContentPointer" flags="ng" index="2NCZwO">
        <child id="2286331641395252236" name="elements" index="2NCMaf" />
      </concept>
      <concept id="2286331641391049225" name="com.mbeddr.doc.structure.KeyPressFormattedText" flags="ng" index="2OoWia" />
      <concept id="126932837435370850" name="com.mbeddr.doc.structure.Author" flags="ng" index="Wq1Bs">
        <property id="126932837435370852" name="email" index="Wq1Bq" />
        <property id="126932837435370851" name="name" index="Wq1Bt" />
      </concept>
      <concept id="4457500422381571986" name="com.mbeddr.doc.structure.CodeFormattedText" flags="ng" index="1jUjqm" />
      <concept id="5185579450379273118" name="com.mbeddr.doc.structure.TextParHeader" flags="ng" index="1xAIan">
        <property id="5185579450379273119" name="text" index="1xAIam" />
      </concept>
      <concept id="6955693250238922820" name="com.mbeddr.doc.structure.AbstractModelContentParagraph" flags="ng" index="3z_lpG">
        <property id="6955693250238922823" name="showContents" index="3z_lpJ" />
        <child id="6955693250238922822" name="codeptr" index="3z_lpI" />
      </concept>
      <concept id="6955693250238922834" name="com.mbeddr.doc.structure.ModelContentAsTextParagraph" flags="ng" index="3z_lpU">
        <property id="6955693250238922835" name="text" index="3z_lpV" />
        <property id="6955693250238922836" name="language" index="3z_lpW" />
      </concept>
      <concept id="6955693250238922838" name="com.mbeddr.doc.structure.ModelContentRefWord" flags="ng" index="3z_lpY">
        <child id="6955693250238922839" name="modelContentPtr" index="3z_lpZ" />
      </concept>
      <concept id="3350625596580225385" name="com.mbeddr.doc.structure.DocumentRef" flags="ng" index="1_0j5j">
        <reference id="3350625596580225386" name="doc" index="1_0j5g" />
      </concept>
      <concept id="3350625596580108709" name="com.mbeddr.doc.structure.SectRefWord" flags="ng" index="1_0GAv">
        <reference id="3350625596580108719" name="target" index="1_0GAl" />
      </concept>
      <concept id="3350625596580089586" name="com.mbeddr.doc.structure.TextParagraph" flags="ng" index="1_0LV8">
        <child id="5185579450379273128" name="header" index="1xAIax" />
        <child id="3350625596580089613" name="text" index="1_0LWR" />
      </concept>
      <concept id="3350625596580064249" name="com.mbeddr.doc.structure.IDocContentContainer" flags="ng" index="1_0VJ3">
        <child id="3350625596580064250" name="contents" index="1_0VJ0" />
      </concept>
      <concept id="3350625596580064222" name="com.mbeddr.doc.structure.AbstractSection" flags="ng" index="1_0VJ$">
        <property id="3350625596580064225" name="text" index="1_0VJr" />
      </concept>
      <concept id="3350625596580064455" name="com.mbeddr.doc.structure.Section" flags="ng" index="1_0VNX" />
      <concept id="3350625596579911728" name="com.mbeddr.doc.structure.Document" flags="ng" index="1_1swa">
        <property id="5572730672710143343" name="chapterStartIndex" index="yApLE" />
      </concept>
      <concept id="3350625596579911760" name="com.mbeddr.doc.structure.EmptyDocContent" flags="ng" index="1_1sxE" />
      <concept id="8730648445434044903" name="com.mbeddr.doc.structure.ListingParagraph" flags="ng" index="1DKdXA">
        <property id="8730648445434044905" name="language" index="1DKdXC" />
        <property id="8730648445434044906" name="text" index="1DKdXF" />
      </concept>
      <concept id="5378658552262903588" name="com.mbeddr.doc.structure.Item" flags="ng" index="3X6T9g">
        <child id="5378658552262903589" name="text" index="3X6T9h" />
      </concept>
      <concept id="5378658552262893169" name="com.mbeddr.doc.structure.ItemList" flags="ng" index="3X6WG5">
        <child id="5378658552262986137" name="items" index="3Xp5NH" />
      </concept>
    </language>
    <language id="d4280a54-f6df-4383-aa41-d1b2bffa7eb1" name="com.mbeddr.core.base">
      <concept id="8375407818529178006" name="com.mbeddr.core.base.structure.TextBlock" flags="ng" index="OjmMv">
        <child id="8375407818529178007" name="text" index="OjmMu" />
      </concept>
    </language>
    <language id="ceab5195-25ea-4f22-9b92-103b95ca8c0c" name="jetbrains.mps.lang.core">
      <concept id="1169194658468" name="jetbrains.mps.lang.core.structure.INamedConcept" flags="ng" index="TrEIO">
        <property id="1169194664001" name="name" index="TrG5h" />
      </concept>
    </language>
  </registry>
  <node concept="1_1swa" id="yrKNEnw4lA">
    <property role="TrG5h" value="C_Units" />
    <property role="yApLE" value="5" />
    <ref role="G9hjw" to="ntnz:2fBMM_3XZ4C" resolve="Config" />
    <node concept="1_0VNX" id="3mn43GO8cu5" role="1_0VJ0">
      <property role="TrG5h" value="units" />
      <property role="1_0VJr" value="Units" />
      <node concept="1_0LV8" id="4lzRQzvlgDn" role="1_0VJ0">
        <node concept="19SGf9" id="4lzRQzvlgDo" role="1_0LWR">
          <node concept="19SUe$" id="4lzRQzvlgDp" role="19SJt6">
            <property role="19SUeA" value="The purpose of physical units is to annotate types and literals with additional information - units - used to improve type checking. Many embedded systems work with real-world quantities, and many of those have a physical unit associated with them. " />
          </node>
        </node>
      </node>
      <node concept="1_0VNX" id="4lzRQzvqudB" role="1_0VJ0">
        <property role="TrG5h" value="basicPhysicalUnits" />
        <property role="1_0VJr" value="Physical Units Basics" />
        <node concept="1_0LV8" id="yrKNEnwew_" role="1_0VJ0">
          <node concept="19SGf9" id="yrKNEnwewA" role="1_0LWR">
            <node concept="19SUe$" id="yrKNEnwewB" role="19SJt6">
              <property role="19SUeA" value="Let us go back to the definition of " />
            </node>
            <node concept="1jUjqm" id="yrKNEnwgn4" role="19SJt6">
              <node concept="19SGf9" id="yrKNEnwgn9" role="$DsGW">
                <node concept="19SUe$" id="yrKNEnwgnt" role="19SJt6">
                  <property role="19SUeA" value="Trackpoint" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="yrKNEnwgnU" role="19SJt6">
              <property role="19SUeA" value=" introduced in " />
            </node>
            <node concept="1_0GAv" id="4lzRQzvpYtx" role="19SJt6">
              <ref role="1_0GAl" to="c4ys:4IT6uoQrns" resolve="functionPointers" />
            </node>
            <node concept="19SUe$" id="4lzRQzvpYtw" role="19SJt6">
              <property role="19SUeA" value=" and make it more useful. Our application is supposed to work with tracking data (captured from a bike computer or a flight logger). For the examples so far we were not interested in the physical units. " />
            </node>
          </node>
          <node concept="1xAIan" id="4lzRQzvpYwM" role="1xAIax">
            <property role="1xAIam" value="Defining and Attaching Units to Types" />
          </node>
        </node>
        <node concept="1_0LV8" id="yrKNEnwk3R" role="1_0VJ0">
          <node concept="19SGf9" id="yrKNEnwk3S" role="1_0LWR">
            <node concept="19SUe$" id="yrKNEnwk3T" role="19SJt6">
              <property role="19SUeA" value="Let us now explore how we can work with physical units, adding more semantics to this data structure. In order to use the physical units language, we need to import the " />
            </node>
            <node concept="1jUjqm" id="1VdI9nUzjUQ" role="19SJt6">
              <node concept="19SGf9" id="1VdI9nUzjUR" role="$DsGW">
                <node concept="19SUe$" id="1VdI9nUzjUS" role="19SJt6">
                  <property role="19SUeA" value="com.mbeddr.physicalunits" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="1VdI9nUzjUP" role="19SJt6">
              <property role="19SUeA" value=" devkit. After the import we can add units for the types by simply pressing the " />
            </node>
            <node concept="2OoWia" id="4lzRQzvpYtN" role="19SJt6">
              <node concept="19SGf9" id="4lzRQzvpYtQ" role="$DsGW">
                <node concept="19SUe$" id="4lzRQzvpYtR" role="19SJt6">
                  <property role="19SUeA" value="/" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="yrKNEnwk4h" role="19SJt6">
              <property role="19SUeA" value=" at the right side of them." />
            </node>
          </node>
        </node>
        <node concept="1_0LV8" id="yrKNEnwl7I" role="1_0VJ0">
          <node concept="19SGf9" id="yrKNEnwl7J" role="1_0LWR">
            <node concept="19SUe$" id="yrKNEnwl7K" role="19SJt6">
              <property role="19SUeA" value="The 7 standard SI units are available from an accessory module called " />
            </node>
            <node concept="3z_lpY" id="2B__QU6nrzH" role="19SJt6">
              <node concept="2NCZwO" id="2B__QU6nrAn" role="3z_lpZ">
                <node concept="2NCMab" id="2B__QU6ox73" role="2NCMaf">
                  <ref role="2NCMaa" to="cmgk:yGiRIF6Rhw" resolve="SIUnits" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="2B__QU6nrzG" role="19SJt6">
              <property role="19SUeA" value=". It can be imported into any implementation module. There is an extra " />
            </node>
            <node concept="1jUjqm" id="1VdI9nUyGTY" role="19SJt6">
              <node concept="19SGf9" id="1VdI9nUyGTZ" role="$DsGW">
                <node concept="19SUe$" id="1VdI9nUyGU0" role="19SJt6">
                  <property role="19SUeA" value="nounit" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="1VdI9nUyGTX" role="19SJt6">
              <property role="19SUeA" value=" unit defined in this module. The usage of this unit is limited to test case definitions and conversion rules, which we will talk about in later sections. When you import this module, the simple units like " />
            </node>
            <node concept="1jUjqm" id="yrKNEnwlCw" role="19SJt6">
              <node concept="19SGf9" id="yrKNEnwlCx" role="$DsGW">
                <node concept="19SUe$" id="yrKNEnwlCz" role="19SJt6">
                  <property role="19SUeA" value="s" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="yrKNEnwlC$" role="19SJt6">
              <property role="19SUeA" value=" and " />
            </node>
            <node concept="1jUjqm" id="yrKNEnwlC_" role="19SJt6">
              <node concept="19SGf9" id="yrKNEnwlCA" role="$DsGW">
                <node concept="19SUe$" id="yrKNEnwlCC" role="19SJt6">
                  <property role="19SUeA" value="m" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="yrKNEnwlCD" role="19SJt6">
              <property role="19SUeA" value=" will be immediately available. " />
            </node>
          </node>
        </node>
        <node concept="1_0LV8" id="4aWU2iTwA1v" role="1_0VJ0">
          <node concept="19SGf9" id="4aWU2iTwA1w" role="1_0LWR">
            <node concept="19SUe$" id="4aWU2iTwA1x" role="19SJt6">
              <property role="19SUeA" value="For the " />
            </node>
            <node concept="1jUjqm" id="yrKNEnwlCE" role="19SJt6">
              <node concept="19SGf9" id="yrKNEnwlCF" role="$DsGW">
                <node concept="19SUe$" id="yrKNEnwlCH" role="19SJt6">
                  <property role="19SUeA" value="speed" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="yrKNEnwlCI" role="19SJt6">
              <property role="19SUeA" value=" member of the " />
            </node>
            <node concept="1jUjqm" id="4aWU2iTwA0y" role="19SJt6">
              <node concept="19SGf9" id="4aWU2iTwA0z" role="$DsGW">
                <node concept="19SUe$" id="4aWU2iTwA0$" role="19SJt6">
                  <property role="19SUeA" value="Trackpoint" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="4aWU2iTwA0x" role="19SJt6">
              <property role="19SUeA" value=" struct we need to add " />
            </node>
            <node concept="1jUjqm" id="yrKNEnwlCJ" role="19SJt6">
              <node concept="19SGf9" id="yrKNEnwlCK" role="$DsGW">
                <node concept="19SUe$" id="yrKNEnwlCM" role="19SJt6">
                  <property role="19SUeA" value="m/s" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="yrKNEnwlCN" role="19SJt6">
              <property role="19SUeA" value=". Since this is not an SI base unit, we first have to define it, which can be done either in the " />
            </node>
            <node concept="1jUjqm" id="6CnXAkqP1Y_" role="19SJt6">
              <node concept="19SGf9" id="6CnXAkqP1YA" role="$DsGW">
                <node concept="19SUe$" id="6CnXAkqP1YB" role="19SJt6">
                  <property role="19SUeA" value="ImplementationModule" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="6CnXAkqP1Y$" role="19SJt6">
              <property role="19SUeA" value=" or in a " />
            </node>
            <node concept="1jUjqm" id="6CnXAkqP21k" role="19SJt6">
              <node concept="19SGf9" id="6CnXAkqP21l" role="$DsGW">
                <node concept="19SUe$" id="6CnXAkqP21m" role="19SJt6">
                  <property role="19SUeA" value="UnitContainer" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="6CnXAkqP21j" role="19SJt6">
              <property role="19SUeA" value=" (such as " />
            </node>
            <node concept="3z_lpY" id="39jEAIlB9uU" role="19SJt6">
              <node concept="2NCZwO" id="39jEAIlB9uV" role="3z_lpZ">
                <node concept="2NCMab" id="39jEAIlB9vU" role="2NCMaf">
                  <ref role="2NCMaa" to="e1tx:5L$_W51ZPe7" resolve="UnitDeclarations" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="39jEAIlB9uT" role="19SJt6">
              <property role="19SUeA" value="). To create a new unit just use its alias " />
            </node>
            <node concept="1jUjqm" id="69uDFDbgwle" role="19SJt6">
              <node concept="19SGf9" id="69uDFDbgwlf" role="$DsGW">
                <node concept="19SUe$" id="69uDFDbgwlg" role="19SJt6">
                  <property role="19SUeA" value="unit" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="69uDFDbgwld" role="19SJt6">
              <property role="19SUeA" value=". The specification of the derived units can be typed in after the name of the unit. A simple unit specification consists of one unit with possibly an exponent. If you would like to type in a composite unit specification then press ENTER to expand the components in the specifiction. Exponents can be added to the units by pressing the cap (^) symbol and the value of the exponent. This works for all units in the specification except for the last component; there the cap is disabled because it conflicts with the binary XOR operator. At the last position use the appropriate intention (by the way it is available for all components regardless of the position in the specification) to add the exponent to the unit. An exponent can either be simple integer number or it can be transformed to a fraction by typing " />
            </node>
            <node concept="2OoWia" id="yaVrOuw0N2" role="19SJt6">
              <node concept="19SGf9" id="yaVrOuw0N5" role="$DsGW">
                <node concept="19SUe$" id="yaVrOuw0N6" role="19SJt6">
                  <property role="19SUeA" value="/" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="1VdI9nUyLxV" role="19SJt6">
              <property role="19SUeA" value=" in the exponent expression. " />
            </node>
          </node>
        </node>
        <node concept="1_0LV8" id="1VdI9nUzvM0" role="1_0VJ0">
          <node concept="19SGf9" id="1VdI9nUzvM1" role="1_0LWR">
            <node concept="19SUe$" id="1VdI9nUzvM2" role="19SJt6">
              <property role="19SUeA" value="The following code example shows how can we use units for the members of the " />
            </node>
            <node concept="1jUjqm" id="1VdI9nUzvRw" role="19SJt6">
              <node concept="19SGf9" id="1VdI9nUzvRx" role="$DsGW">
                <node concept="19SUe$" id="1VdI9nUzvRy" role="19SJt6">
                  <property role="19SUeA" value="Trackpoint" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="1VdI9nUzvRz" role="19SJt6">
              <property role="19SUeA" value=" struct." />
            </node>
          </node>
        </node>
        <node concept="3z_lpU" id="1VdI9nUzmeF" role="1_0VJ0">
          <property role="3z_lpW" value="mbeddr" />
          <property role="3z_lpJ" value="true" />
          <property role="3z_lpV" value="                            &#10;exported struct Trackpoint {&#10;  int8 id;                  &#10;  int8/s/ time;             &#10;  int8/m/ x;                &#10;  int8/m/ y;                &#10;  int16/m/ alt;             &#10;  int16/mps/ speed;         &#10;};                          " />
          <node concept="2NCZwO" id="1VdI9nUzupY" role="3z_lpI">
            <node concept="2NCMab" id="1VdI9nUzuq4" role="2NCMaf">
              <ref role="2NCMaa" to="e1tx:1w5Xuj1QYMp" resolve="DataStructures" />
            </node>
            <node concept="2NCMab" id="1VdI9nUzuqd" role="2NCMaf">
              <ref role="2NCMaa" to="e1tx:1w5Xuj1QYMq" resolve="Trackpoint" />
            </node>
          </node>
        </node>
        <node concept="1_0LV8" id="yrKNEnw$Lp" role="1_0VJ0">
          <node concept="1xAIan" id="4aWU2iTwA6o" role="1xAIax">
            <property role="1xAIam" value="Units on Literals" />
          </node>
          <node concept="19SGf9" id="yrKNEnw$Lq" role="1_0LWR">
            <node concept="19SUe$" id="yrKNEnw$Lr" role="19SJt6">
              <property role="19SUeA" value="Adding these units may result in errors in the existing code (depending on whether you had added them in previous tutorial steps) because you cannot simply assign a plain number to a variable or member whose type includes a physical unit (" />
            </node>
            <node concept="1jUjqm" id="4aWU2iTwA5W" role="19SJt6">
              <node concept="19SGf9" id="4aWU2iTwA5X" role="$DsGW">
                <node concept="19SUe$" id="4aWU2iTwA5Y" role="19SJt6">
                  <property role="19SUeA" value="int8/m/ length = 3;" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="4aWU2iTwA5V" role="19SJt6">
              <property role="19SUeA" value=" is illegal). Instead you have to add units to the literals as well. You can simply type the unit  name after the literal to get to the following:" />
            </node>
          </node>
        </node>
        <node concept="3z_lpU" id="yrKNEnwBNB" role="1_0VJ0">
          <property role="3z_lpW" value="mbeddr" />
          <property role="3z_lpJ" value="true" />
          <property role="3z_lpV" value="Trackpoint i1 = {&#10;  id = 1,        &#10;  time = 0 s,    &#10;  x = 0 m,       &#10;  y = 0 m,       &#10;  alt = 100 m    &#10;};               " />
          <node concept="2NCZwO" id="1YUFCeGolI6" role="3z_lpI">
            <node concept="2NCMab" id="1YUFCeGolI7" role="2NCMaf">
              <ref role="2NCMaa" to="e1tx:7VsgA5L655y" resolve="FunctionPointers" />
            </node>
            <node concept="2NCMab" id="1YUFCeGolI8" role="2NCMaf">
              <ref role="2NCMaa" to="e1tx:7VsgA5L65uE" resolve="testProcessing" />
            </node>
            <node concept="2NCMab" id="1YUFCeGolI9" role="2NCMaf">
              <ref role="2NCMaa" to="e1tx:7VsgA5L65v7" resolve="i1" />
            </node>
          </node>
        </node>
        <node concept="1_0LV8" id="yrKNEnwHCM" role="1_0VJ0">
          <node concept="19SGf9" id="yrKNEnwHCN" role="1_0LWR">
            <node concept="19SUe$" id="yrKNEnwHCO" role="19SJt6">
              <property role="19SUeA" value="You also have to add them to the comparison in the assertions as well, for example in this one:" />
            </node>
          </node>
        </node>
        <node concept="3z_lpU" id="yrKNEnwHG6" role="1_0VJ0">
          <property role="3z_lpW" value="mbeddr" />
          <property role="3z_lpJ" value="true" />
          <property role="3z_lpV" value="{                                         &#10;  processor = :process_doNothing;         &#10;  Trackpoint i2 = processor(i1);          &#10;  assert(0) i2.id == 1 &amp;&amp; i2.alt == 100 m;&#10;}                                         " />
          <node concept="2NCZwO" id="1YUFCeGolHO" role="3z_lpI">
            <node concept="2NCMab" id="1YUFCeGolHP" role="2NCMaf">
              <ref role="2NCMaa" to="e1tx:7VsgA5L655y" resolve="FunctionPointers" />
            </node>
            <node concept="2NCMab" id="1YUFCeGolHQ" role="2NCMaf">
              <ref role="2NCMaa" to="e1tx:7VsgA5L65uE" resolve="testProcessing" />
            </node>
            <node concept="2NCMab" id="4lzRQzvjmJL" role="2NCMaf">
              <ref role="2NCMaa" to="e1tx:2ncjLWk$qve" resolve="firstAssertion" />
            </node>
          </node>
        </node>
        <node concept="1_0LV8" id="4aWU2iTwA9j" role="1_0VJ0">
          <node concept="19SGf9" id="4aWU2iTwA9k" role="1_0LWR">
            <node concept="19SUe$" id="4aWU2iTwA9l" role="19SJt6">
              <property role="19SUeA" value="If we were to write the following code, we would get an error:" />
            </node>
          </node>
          <node concept="1xAIan" id="4aWU2iTwAIH" role="1xAIax">
            <property role="1xAIam" value="Operators" />
          </node>
        </node>
        <node concept="1DKdXA" id="yrKNEnwPO_" role="1_0VJ0">
          <property role="1DKdXC" value="mbeddr" />
          <property role="1DKdXF" value="int8 someInt = i1.x + i1.speed; // error, adding m and mps&#10;" />
        </node>
        <node concept="1_0LV8" id="yrKNEnwQR2" role="1_0VJ0">
          <node concept="19SGf9" id="yrKNEnwQR3" role="1_0LWR">
            <node concept="19SUe$" id="yrKNEnwQR4" role="19SJt6">
              <property role="19SUeA" value="This is because all the mathematical operators are overloaded for physical units and these operations are also type-checked accordingly. Clearly, the problem with this code is that you cannot add a length (" />
            </node>
            <node concept="1jUjqm" id="yrKNEnwRpj" role="19SJt6">
              <node concept="19SGf9" id="yrKNEnwRpk" role="$DsGW">
                <node concept="19SUe$" id="yrKNEnwRpm" role="19SJt6">
                  <property role="19SUeA" value="i1.x" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="yrKNEnwRpn" role="19SJt6">
              <property role="19SUeA" value=") and a speed (" />
            </node>
            <node concept="1jUjqm" id="yrKNEnwRpo" role="19SJt6">
              <node concept="19SGf9" id="yrKNEnwRpp" role="$DsGW">
                <node concept="19SUe$" id="yrKNEnwRpr" role="19SJt6">
                  <property role="19SUeA" value="i1.speed" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="yrKNEnwRps" role="19SJt6">
              <property role="19SUeA" value="). The result is certainly not a plain " />
            </node>
            <node concept="1jUjqm" id="yrKNEnwRpt" role="19SJt6">
              <node concept="19SGf9" id="yrKNEnwRpu" role="$DsGW">
                <node concept="19SUe$" id="yrKNEnwRpw" role="19SJt6">
                  <property role="19SUeA" value="int8" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="yrKNEnwRpx" role="19SJt6">
              <property role="19SUeA" value=", so you cannot assign the result to " />
            </node>
            <node concept="1jUjqm" id="yrKNEnwRpy" role="19SJt6">
              <node concept="19SGf9" id="yrKNEnwRpz" role="$DsGW">
                <node concept="19SUe$" id="yrKNEnwRp_" role="19SJt6">
                  <property role="19SUeA" value="someInt" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="yrKNEnwRpA" role="19SJt6">
              <property role="19SUeA" value=". Adding " />
            </node>
            <node concept="1jUjqm" id="yrKNEnwRpB" role="19SJt6">
              <node concept="19SGf9" id="yrKNEnwRpC" role="$DsGW">
                <node concept="19SUe$" id="yrKNEnwRpE" role="19SJt6">
                  <property role="19SUeA" value="i1.x" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="yrKNEnwRpF" role="19SJt6">
              <property role="19SUeA" value=" and " />
            </node>
            <node concept="1jUjqm" id="yrKNEnwRpG" role="19SJt6">
              <node concept="19SGf9" id="yrKNEnwRpH" role="$DsGW">
                <node concept="19SUe$" id="yrKNEnwRpJ" role="19SJt6">
                  <property role="19SUeA" value="i1.y" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="yrKNEnwRpK" role="19SJt6">
              <property role="19SUeA" value=" will work, though. Another example where the units are matched properly: " />
            </node>
          </node>
        </node>
        <node concept="3z_lpU" id="yrKNEnwSn0" role="1_0VJ0">
          <property role="3z_lpW" value="mbeddr" />
          <property role="3z_lpJ" value="true" />
          <property role="3z_lpV" value="int8/mps/ speed1 = (i4.x - i3.x) / (i4.time - i3.time);" />
          <node concept="2NCZwO" id="1YUFCeGolFM" role="3z_lpI">
            <node concept="2NCMab" id="1YUFCeGolFN" role="2NCMaf">
              <ref role="2NCMaa" to="e1tx:7VsgA5L655y" resolve="FunctionPointers" />
            </node>
            <node concept="2NCMab" id="1VdI9nU_yQI" role="2NCMaf">
              <ref role="2NCMaa" to="e1tx:73Ctzy_sFu4" resolve="speed1" />
            </node>
          </node>
        </node>
        <node concept="1_0LV8" id="4lzRQzvu3ZP" role="1_0VJ0">
          <node concept="19SGf9" id="4lzRQzvu3ZQ" role="1_0LWR">
            <node concept="19SUe$" id="4lzRQzvu3ZR" role="19SJt6">
              <property role="19SUeA" value="The " />
            </node>
            <node concept="3z_lpY" id="4lzRQzvu4az" role="19SJt6">
              <node concept="2NCZwO" id="4lzRQzvu4a$" role="3z_lpZ">
                <node concept="2NCMab" id="4lzRQzvu4aI" role="2NCMaf">
                  <ref role="2NCMaa" to="e1tx:1w5Xuj1QYMp" resolve="DataStructures" />
                </node>
                <node concept="2NCMab" id="4lzRQzvu4aQ" role="2NCMaf">
                  <ref role="2NCMaa" to="e1tx:21ict8otauW" resolve="calcVerticalSpeed" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="4lzRQzvu4a_" role="19SJt6">
              <property role="19SUeA" value=" provides a few more examples of working with units in expressions:" />
            </node>
          </node>
        </node>
        <node concept="3z_lpU" id="4lzRQzvu6Ew" role="1_0VJ0">
          <property role="3z_lpW" value="mbeddr" />
          <property role="3z_lpJ" value="true" />
          <property role="3z_lpV" value="void calcVerticalSpeed(TrackpointWithVertical* prev, TrackpointWithVertical* cur) {&#10;  /* cur.alt = 0 m; */                                                             &#10;  /* cur.speed = 0 mps; */                                                         &#10;  if (prev == null) {                                                              &#10;  cur.vSpeed = 0 mps;                                                              &#10;} else {                                                                           &#10;  int16/m/ dAlt = cur.alt - prev.alt;                                              &#10;  int8/s/ dTime = cur.time - prev.time;                                            &#10;  cur.vSpeed = dAlt / dTime;                                                       &#10;}                                                                                  &#10;} calcVerticalSpeed (function)                                                     " />
          <node concept="2NCZwO" id="4lzRQzvu6Ey" role="3z_lpI">
            <node concept="2NCMab" id="4lzRQzvu6Ka" role="2NCMaf">
              <ref role="2NCMaa" to="e1tx:1w5Xuj1QYMp" resolve="DataStructures" />
            </node>
            <node concept="2NCMab" id="4lzRQzvu6Ki" role="2NCMaf">
              <ref role="2NCMaa" to="e1tx:21ict8otauW" resolve="calcVerticalSpeed" />
            </node>
          </node>
        </node>
        <node concept="1_1sxE" id="1VdI9nU_H$N" role="1_0VJ0">
          <property role="TrG5h" value="empty_-1" />
        </node>
        <node concept="1_0LV8" id="1VdI9nU_LS4" role="1_0VJ0">
          <node concept="1xAIan" id="4aWU2iTwAIJ" role="1xAIax">
            <property role="1xAIam" value="Editing Composite Units" />
          </node>
          <node concept="19SGf9" id="1VdI9nU_LS5" role="1_0LWR">
            <node concept="19SUe$" id="1VdI9nU_LS6" role="19SJt6">
              <property role="19SUeA" value="When you edit an expression with composite units you may encounter the problem that multiple side transformations are available at a given place and so you need to make the choice by hand. Consider the following code example:" />
            </node>
          </node>
        </node>
        <node concept="3z_lpU" id="1VdI9nU_uPD" role="1_0VJ0">
          <property role="3z_lpW" value="mbeddr" />
          <property role="3z_lpJ" value="true" />
          <property role="3z_lpV" value="int8/mps/ speed2 = 2 m･s-1 + 3 s-1･m;" />
          <node concept="2NCZwO" id="1VdI9nU_uPE" role="3z_lpI">
            <node concept="2NCMab" id="1VdI9nU_uPF" role="2NCMaf">
              <ref role="2NCMaa" to="e1tx:7VsgA5L655y" resolve="FunctionPointers" />
            </node>
            <node concept="2NCMab" id="1VdI9nU_yQt" role="2NCMaf">
              <ref role="2NCMaa" to="e1tx:1VdI9nUzXhL" resolve="speed2" />
            </node>
          </node>
        </node>
        <node concept="1_0LV8" id="1VdI9nU_M2q" role="1_0VJ0">
          <node concept="19SGf9" id="1VdI9nU_M2r" role="1_0LWR">
            <node concept="19SUe$" id="1VdI9nU_M2s" role="19SJt6">
              <property role="19SUeA" value="Here, when you are editing the unit definition of the number literal 2, the * operator may be used at the end to introduce a multiplication in the expression or to extend the unit defition. Similarly, the ^ symbol may be used to introduce exponent for the units or could be also used for the binary xor operator. This problem only arises at the end of the unit definition. " />
            </node>
          </node>
        </node>
        <node concept="1_0LV8" id="yrKNEnwPLn" role="1_0VJ0">
          <node concept="19SGf9" id="yrKNEnwPLo" role="1_0LWR">
            <node concept="19SUe$" id="yrKNEnwPLp" role="19SJt6">
              <property role="19SUeA" value="If you try to rebuild the model, you will get an error message, saying that you need to add the " />
            </node>
            <node concept="1jUjqm" id="7FOMyx2B73w" role="19SJt6">
              <node concept="19SGf9" id="7FOMyx2B73x" role="$DsGW">
                <node concept="19SUe$" id="7FOMyx2B73y" role="19SJt6">
                  <property role="19SUeA" value="units" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="7FOMyx2B73v" role="19SJt6">
              <property role="19SUeA" value=" configuration item to the build configuration. If you have added this item, the build should be successful and we should be able to run the test again. " />
            </node>
          </node>
          <node concept="1xAIan" id="4aWU2iTwAcd" role="1xAIax">
            <property role="1xAIam" value="Build Configuration" />
          </node>
        </node>
      </node>
      <node concept="1_0VNX" id="4lzRQzvtJa6" role="1_0VJ0">
        <property role="TrG5h" value="UnitConversions" />
        <property role="1_0VJr" value="Unit Conversions" />
        <node concept="1_0LV8" id="627_yy3rFwv" role="1_0VJ0">
          <node concept="19SGf9" id="627_yy3rFww" role="1_0LWR">
            <node concept="19SUe$" id="627_yy3rFwx" role="19SJt6">
              <property role="19SUeA" value="So far, we have used units only for type checking. However, sometimes you have several units for the same physical quantity. For example, speed can be measured in " />
            </node>
            <node concept="1jUjqm" id="627_yy3rFwC" role="19SJt6">
              <node concept="19SGf9" id="627_yy3rFwD" role="$DsGW">
                <node concept="19SUe$" id="627_yy3rFwE" role="19SJt6">
                  <property role="19SUeA" value="m/s" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="627_yy3rFwF" role="19SJt6">
              <property role="19SUeA" value=" or " />
            </node>
            <node concept="1jUjqm" id="627_yy3rFwQ" role="19SJt6">
              <node concept="19SGf9" id="627_yy3rFwR" role="$DsGW">
                <node concept="19SUe$" id="627_yy3rFwS" role="19SJt6">
                  <property role="19SUeA" value="km/h" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="627_yy3rFwT" role="19SJt6">
              <property role="19SUeA" value=". For this purpose you can define conversion rules between the units.  " />
            </node>
          </node>
        </node>
        <node concept="1_0LV8" id="4aWU2iTwNxJ" role="1_0VJ0">
          <node concept="19SGf9" id="4aWU2iTwNxK" role="1_0LWR">
            <node concept="19SUe$" id="4aWU2iTwNxL" role="19SJt6">
              <property role="19SUeA" value="The " />
            </node>
            <node concept="1jUjqm" id="4aWU2iTwNxU" role="19SJt6">
              <node concept="19SGf9" id="4aWU2iTwNxV" role="$DsGW">
                <node concept="19SUe$" id="4aWU2iTwNxW" role="19SJt6">
                  <property role="19SUeA" value="conversion rule" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="4aWU2iTwNxX" role="19SJt6">
              <property role="19SUeA" value=" must define a source and a target unit (the conversion will happen between these units) and it must contain one or more conversion specifiers. A conversion specifier defines the conversion expression for a given type. Inside the conversion expression one can use the " />
            </node>
            <node concept="1jUjqm" id="4aWU2iTwNxY" role="19SJt6">
              <node concept="19SGf9" id="4aWU2iTwNxZ" role="$DsGW">
                <node concept="19SUe$" id="4aWU2iTwNy0" role="19SJt6">
                  <property role="19SUeA" value="val" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="4aWU2iTwNy1" role="19SJt6">
              <property role="19SUeA" value=" expression as a placeholder for the to-be-converted value. It will be substituted with the value that is passed to the conversion rule. The type that you define for the specifier is the type that the val expression will have. Additionally, it is also possible to omit the type: in this case the specifier works as a generic one, where the expression may be applied to any types (the type of the " />
            </node>
            <node concept="1jUjqm" id="4aWU2iTwNy2" role="19SJt6">
              <node concept="19SGf9" id="4aWU2iTwNy3" role="$DsGW">
                <node concept="19SUe$" id="4aWU2iTwNy4" role="19SJt6">
                  <property role="19SUeA" value="val" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="4aWU2iTwNy5" role="19SJt6">
              <property role="19SUeA" value=" expression will be double in this case, but this is just a trick that is needed for the typesystem to work properly). The conversion specifiers are checked, and redundant specifiers will be marked as erroneous (the ones that are covered by some other specifier due to its type being the supertype of the original type). " />
            </node>
          </node>
          <node concept="1xAIan" id="4aWU2iTwNy6" role="1xAIax">
            <property role="1xAIam" value="Defining Conversions" />
          </node>
        </node>
        <node concept="3z_lpU" id="627_yy3rO9v" role="1_0VJ0">
          <property role="3z_lpW" value="mbeddr" />
          <property role="3z_lpV" value="                                                                                                                                                                                    &#10;section conversions {                                                                                                                                                               &#10;                                                                                                                                                                                    &#10;  exported conversion mps -&gt; kmh {                                                                                                                                                  &#10;                                                                                                                                                                                    &#10;  exported conversion kmh -&gt; mps {                                                                                                                                                  &#10;                                                                                                                                                                                    &#10;  exported conversion s -&gt; h {                                                                                                                                                      &#10;                                                                                                                                                                                    &#10;  exported conversion m -&gt; km {                                                                                                                                                     &#10;} section conversions                                                                                                                                                               &#10;                               val as double -&gt; val * 3.6              val as &lt;no type&gt; -&gt; val / 3.6           val as &lt;no type&gt; -&gt; val / 3600         val as &lt;no type&gt; -&gt; val / 1000&#10;                              }                                       }                                       }                                      }                              " />
          <property role="3z_lpJ" value="false" />
          <node concept="2NCZwO" id="627_yy3rO9w" role="3z_lpI">
            <node concept="2NCMab" id="627_yy3rO9x" role="2NCMaf">
              <ref role="2NCMaa" to="e1tx:5L$_W51ZPe7" resolve="UnitDeclarations" />
            </node>
            <node concept="2NCMab" id="627_yy3rO9y" role="2NCMaf">
              <ref role="2NCMaa" to="e1tx:627_yy3rJpI" resolve="conversions" />
            </node>
          </node>
        </node>
        <node concept="1_0LV8" id="627_yy3stUo" role="1_0VJ0">
          <node concept="19SGf9" id="627_yy3stUp" role="1_0LWR">
            <node concept="19SUe$" id="627_yy3stUq" role="19SJt6">
              <property role="19SUeA" value="Conversion rules can be either lazy or eager. The default behavior is the lazy evaluation, you can switch to eager from the corresponding intention on the conversion rule itself." />
            </node>
          </node>
        </node>
        <node concept="3X6WG5" id="1VdI9nUAMVO" role="1_0VJ0">
          <node concept="3X6T9g" id="1VdI9nUAMXi" role="3Xp5NH">
            <node concept="OjmMv" id="1VdI9nUAMXj" role="3X6T9h">
              <node concept="19SGf9" id="1VdI9nUAMXk" role="OjmMu">
                <node concept="19SUe$" id="1VdI9nUAMXl" role="19SJt6">
                  <property role="19SUeA" value="" />
                </node>
                <node concept="2vpllh" id="4aWU2iTwAIL" role="19SJt6">
                  <node concept="19SGf9" id="4aWU2iTwAIM" role="$DsGW">
                    <node concept="19SUe$" id="4aWU2iTwAIN" role="19SJt6">
                      <property role="19SUeA" value="Lazy conversion rule:" />
                    </node>
                  </node>
                </node>
                <node concept="19SUe$" id="4aWU2iTwAIP" role="19SJt6">
                  <property role="19SUeA" value=" the val expression inside the conversion specifier has no unit, and the expression must evaluate to a type without units. During the usage of the conversion rule, the type system will just simply append the rule's target unit to the evaluated expression. " />
                </node>
              </node>
            </node>
          </node>
          <node concept="3X6T9g" id="1VdI9nUAMXu" role="3Xp5NH">
            <node concept="OjmMv" id="1VdI9nUAMXv" role="3X6T9h">
              <node concept="19SGf9" id="1VdI9nUAMXw" role="OjmMu">
                <node concept="19SUe$" id="1VdI9nUAMXx" role="19SJt6">
                  <property role="19SUeA" value="" />
                </node>
                <node concept="2vpllh" id="4aWU2iTwAIW" role="19SJt6">
                  <node concept="19SGf9" id="4aWU2iTwAIX" role="$DsGW">
                    <node concept="19SUe$" id="4aWU2iTwAIY" role="19SJt6">
                      <property role="19SUeA" value="Eager conversion rule:" />
                    </node>
                  </node>
                </node>
                <node concept="19SUe$" id="4aWU2iTwAJ0" role="19SJt6">
                  <property role="19SUeA" value=" the val expression has the same unit as the rule's source unit. The expression in the conversion specifier must evaluate to a type with the rule's target unit. During the usage of the conversion rule, the expression will be simply evaluated and the resulting type will be used (which must match the target unit)." />
                </node>
              </node>
            </node>
          </node>
        </node>
        <node concept="1_0LV8" id="1VdI9nUAMvY" role="1_0VJ0">
          <node concept="1xAIan" id="4aWU2iTwNzJ" role="1xAIax">
            <property role="1xAIam" value="Using Conversions" />
          </node>
          <node concept="19SGf9" id="1VdI9nUAMvZ" role="1_0LWR">
            <node concept="19SUe$" id="1VdI9nUAMrQ" role="19SJt6">
              <property role="19SUeA" value="You can now invoke this conversion within a convert expression:" />
            </node>
          </node>
        </node>
        <node concept="3z_lpU" id="627_yy3sLpd" role="1_0VJ0">
          <property role="3z_lpW" value="mbeddr" />
          <property role="3z_lpV" value="void somethingWithConversion() {                          &#10;  Trackpoint highSpeed;                                   &#10;  highSpeed.speed = ((int16/mps/) convert[300 kmh-&gt; mps]);&#10;} somethingWithConversion (function)                      " />
          <property role="3z_lpJ" value="false" />
          <node concept="2NCZwO" id="627_yy3sLpe" role="3z_lpI">
            <node concept="2NCMab" id="627_yy3sLpf" role="2NCMaf">
              <ref role="2NCMaa" to="e1tx:1w5Xuj1QYMp" resolve="DataStructures" />
            </node>
            <node concept="2NCMab" id="627_yy3sLpg" role="2NCMaf">
              <ref role="2NCMaa" to="e1tx:627_yy3rXe_" resolve="somethingWithConversion" />
            </node>
          </node>
        </node>
        <node concept="1_0LV8" id="627_yy3sLqp" role="1_0VJ0">
          <node concept="19SGf9" id="627_yy3sLqq" role="1_0LWR">
            <node concept="19SUe$" id="627_yy3sLqr" role="19SJt6">
              <property role="19SUeA" value="The convert expression does not explicitly refer to any specific conversion rule, you only need to define the target unit of the conversion, while the source unit is known from the type of the original expression. The system will try to find a matching conversion specifier (where both the units and the types match). Here comes the conversion specifier with no specific type handy, because it can be applied to any expression if the units match. \n\nThe conversion specifier can be set manually too in the Inspector of the convert expression. " />
            </node>
          </node>
        </node>
      </node>
      <node concept="1_0VNX" id="4lzRQzvtJkZ" role="1_0VJ0">
        <property role="TrG5h" value="GenericUnits" />
        <property role="1_0VJr" value="Generic Units" />
        <node concept="1_0LV8" id="627_yy3sRQd" role="1_0VJ0">
          <node concept="19SGf9" id="627_yy3sRQe" role="1_0LWR">
            <node concept="19SUe$" id="627_yy3sRQp" role="19SJt6">
              <property role="19SUeA" value="Generic units can be used to enhance the type safety for function calls by also providing the possibility to specify the function in a generic way with respect to the used type annotations. The following code snippets show some use cases of generic units:" />
            </node>
          </node>
        </node>
        <node concept="3z_lpU" id="2B__QU5WTMV" role="1_0VJ0">
          <property role="3z_lpW" value="mbeddr" />
          <property role="3z_lpJ" value="true" />
          <property role="3z_lpV" value="int8/U1/ sum(int8/U1/ a, int8/U1/ b) {&#10;  return a + b;                       &#10;} sum (function)                      " />
          <node concept="2NCZwO" id="2B__QU5WTNd" role="3z_lpI">
            <node concept="2NCMab" id="2B__QU5Xjnm" role="2NCMaf">
              <ref role="2NCMaa" to="e1tx:7VsgA5L655y" resolve="FunctionPointers" />
            </node>
            <node concept="2NCMab" id="2B__QU5Xjny" role="2NCMaf">
              <ref role="2NCMaa" to="e1tx:2B__QU5RFsQ" resolve="sum" />
            </node>
          </node>
        </node>
        <node concept="3z_lpU" id="2B__QU5XmXz" role="1_0VJ0">
          <property role="3z_lpW" value="mbeddr" />
          <property role="3z_lpJ" value="true" />
          <property role="3z_lpV" value="int8/U1･U2/ mul(int8/U1/ a, int8/U2/ b) {&#10;  return a * b;                          &#10;} mul (function)                         " />
          <node concept="2NCZwO" id="2B__QU5XmY1" role="3z_lpI">
            <node concept="2NCMab" id="2B__QU5XmY9" role="2NCMaf">
              <ref role="2NCMaa" to="e1tx:7VsgA5L655y" resolve="FunctionPointers" />
            </node>
            <node concept="2NCMab" id="2B__QU5XmYl" role="2NCMaf">
              <ref role="2NCMaa" to="e1tx:6CnXAkqZ9Sf" resolve="mul" />
            </node>
          </node>
        </node>
        <node concept="3z_lpU" id="2B__QU5XmZ2" role="1_0VJ0">
          <property role="3z_lpW" value="mbeddr" />
          <property role="3z_lpJ" value="true" />
          <property role="3z_lpV" value="Trackpoint process_generic(Trackpoint e) {&#10;  e.time = sum(10 s, 10 s);               &#10;  e.id = sum(1, 2);                       &#10;  e.x = sum(10 m, 10 m);                  &#10;  e.speed = mul(10 m, 10 s-1);            &#10;  return e;                               &#10;} process_generic (function)              " />
          <node concept="2NCZwO" id="2B__QU5XmZG" role="3z_lpI">
            <node concept="2NCMab" id="2B__QU5XmZO" role="2NCMaf">
              <ref role="2NCMaa" to="e1tx:7VsgA5L655y" resolve="FunctionPointers" />
            </node>
            <node concept="2NCMab" id="2B__QU5Xn00" role="2NCMaf">
              <ref role="2NCMaa" to="e1tx:6CnXAkqZ_lK" resolve="process_generic" />
            </node>
          </node>
        </node>
        <node concept="1_0LV8" id="2B__QU5XqAR" role="1_0VJ0">
          <node concept="19SGf9" id="2B__QU5XqAS" role="1_0LWR">
            <node concept="19SUe$" id="2B__QU5XqAT" role="19SJt6">
              <property role="19SUeA" value="First you need to create generic units by invoking the " />
            </node>
            <node concept="1jUjqm" id="4aWU2iTwNzN" role="19SJt6">
              <node concept="19SGf9" id="4aWU2iTwNzO" role="$DsGW">
                <node concept="19SUe$" id="4aWU2iTwNzP" role="19SJt6">
                  <property role="19SUeA" value="Add Generic Unit Declaration" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="4aWU2iTwNzR" role="19SJt6">
              <property role="19SUeA" value=" intention on the function. You can specify multiple generic units once the first one has been created by just simply pressing " />
            </node>
            <node concept="2OoWia" id="4aWU2iTwN$d" role="19SJt6">
              <node concept="19SGf9" id="4aWU2iTwN$g" role="$DsGW">
                <node concept="19SUe$" id="4aWU2iTwN$h" role="19SJt6">
                  <property role="19SUeA" value="Enter" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="4aWU2iTwN$2" role="19SJt6">
              <property role="19SUeA" value=" in the unit list. These newly created generic units can then be used for the type annotation just like any other unit. The substitutions will be computed based on the input parameters of the function call. One can also combine a generic unit with additional arbitrary non-generic units for the type annotations of the parameters and the return type. In addition, it is also possible to invoke the function with bare types, but be aware that once at least one substitution is present, the function call will be type checked also for matching units. The generic units can also have exponents (even as fractions) and the same type-checks also apply to them as it was described for the non-generic units. An example shows how this could be done for a square root function:" />
            </node>
          </node>
        </node>
        <node concept="3z_lpU" id="1VdI9nUFu_J" role="1_0VJ0">
          <property role="3z_lpW" value="mbeddr" />
          <property role="3z_lpJ" value="true" />
          <property role="3z_lpV" value="double/U112/ sqrt(double/U1/ a) {                         &#10;  double/U112/ res = 0 U112;                              &#10;  //here goes your sophisticated square root approximation&#10;  return res;                                             &#10;} sqrt (function)                                         " />
          <node concept="2NCZwO" id="1VdI9nUFuD1" role="3z_lpI">
            <node concept="2NCMab" id="1VdI9nUFuD7" role="2NCMaf">
              <ref role="2NCMaa" to="e1tx:7VsgA5L655y" resolve="FunctionPointers" />
            </node>
            <node concept="2NCMab" id="1VdI9nUFuDg" role="2NCMaf">
              <ref role="2NCMaa" to="e1tx:1VdI9nUEBp3" resolve="sqrt" />
            </node>
          </node>
        </node>
        <node concept="1_0LV8" id="1VdI9nUFuBR" role="1_0VJ0">
          <node concept="19SGf9" id="1VdI9nUFuBS" role="1_0LWR">
            <node concept="19SUe$" id="1VdI9nUFuBT" role="19SJt6">
              <property role="19SUeA" value="Some additional notes on the usage of the generic units:" />
            </node>
          </node>
        </node>
        <node concept="3X6WG5" id="1VdI9nUAUSe" role="1_0VJ0">
          <node concept="3X6T9g" id="1VdI9nUAUSQ" role="3Xp5NH">
            <node concept="OjmMv" id="1VdI9nUAUSR" role="3X6T9h">
              <node concept="19SGf9" id="1VdI9nUAUSS" role="OjmMu">
                <node concept="19SUe$" id="1VdI9nUAUST" role="19SJt6">
                  <property role="19SUeA" value="You should not use multiple generic units in the annotation of one given function parameter, because the non-generic units will be bound to the first generic unit (all of them), so the substitutions will probably not be the ones that you would expect. This is a constraint introduced to manage the complexity of the compuatation of the bindings; allowing multiple generic units for parameter types could result in a constraint solving problem which we do not support right now. " />
                </node>
              </node>
            </node>
          </node>
          <node concept="3X6T9g" id="1VdI9nUAUTo" role="3Xp5NH">
            <node concept="OjmMv" id="1VdI9nUAUTp" role="3X6T9h">
              <node concept="19SGf9" id="1VdI9nUAUTq" role="OjmMu">
                <node concept="19SUe$" id="1VdI9nUAUTr" role="19SJt6">
                  <property role="19SUeA" value="The generic units can only be used inside the function definition, this means that they are not visible outside of the function definition. " />
                </node>
              </node>
            </node>
          </node>
        </node>
      </node>
      <node concept="1_0VNX" id="4lzRQzvquMY" role="1_0VJ0">
        <property role="TrG5h" value="GettingRidOfUnits" />
        <property role="1_0VJr" value="Stripping and Reintroducing Units" />
        <node concept="1_0LV8" id="4lzRQzvuIr_" role="1_0VJ0">
          <node concept="19SGf9" id="4lzRQzvuIrA" role="1_0LWR">
            <node concept="19SUe$" id="4lzRQzvuIrB" role="19SJt6">
              <property role="19SUeA" value="Let us assume we have an existing (legacy or external) function that does not know about physial units and you cannot or do not want to use generic units. An example is " />
            </node>
            <node concept="3z_lpY" id="4lzRQzvxm0d" role="19SJt6">
              <node concept="2NCZwO" id="4lzRQzvxm0e" role="3z_lpZ">
                <node concept="2NCMab" id="4lzRQzvxm0o" role="2NCMaf">
                  <ref role="2NCMaa" to="e1tx:1w5Xuj1QYMp" resolve="DataStructures" />
                </node>
                <node concept="2NCMab" id="4lzRQzvxm0w" role="2NCMaf">
                  <ref role="2NCMaa" to="e1tx:4lzRQzvufrW" resolve="anExistingFunction" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="4lzRQzvxm0f" role="19SJt6">
              <property role="19SUeA" value=": " />
            </node>
          </node>
        </node>
        <node concept="3z_lpU" id="4lzRQzvy8ex" role="1_0VJ0">
          <property role="3z_lpW" value="mbeddr" />
          <property role="3z_lpJ" value="true" />
          <property role="3z_lpV" value="int16 anExistingFunction(int16 x) {&#10;  return x + 10;                   &#10;} anExistingFunction (function)    " />
          <node concept="2NCZwO" id="4lzRQzvy8ey" role="3z_lpI">
            <node concept="2NCMab" id="4lzRQzvy8ez" role="2NCMaf">
              <ref role="2NCMaa" to="e1tx:1w5Xuj1QYMp" resolve="DataStructures" />
            </node>
            <node concept="2NCMab" id="4lzRQzvy8e$" role="2NCMaf">
              <ref role="2NCMaa" to="e1tx:4lzRQzvufrW" resolve="anExistingFunction" />
            </node>
          </node>
        </node>
        <node concept="1_0LV8" id="627_yy3qcei" role="1_0VJ0">
          <node concept="19SGf9" id="627_yy3qcej" role="1_0LWR">
            <node concept="19SUe$" id="627_yy3qcek" role="19SJt6">
              <property role="19SUeA" value="To be able to call this function with arguments that have units, we have to strip away the units before we call the function. This can be achieved by selecting the corresponding expression and invoking the " />
            </node>
            <node concept="1jUjqm" id="4aWU2iTwN$r" role="19SJt6">
              <node concept="19SGf9" id="4aWU2iTwN$s" role="$DsGW">
                <node concept="19SUe$" id="4aWU2iTwN$t" role="19SJt6">
                  <property role="19SUeA" value="Strip Unit" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="4aWU2iTwN$v" role="19SJt6">
              <property role="19SUeA" value=" intention. The type of this stripped expression will be simply the type of the original expression but without units." />
            </node>
          </node>
        </node>
        <node concept="3z_lpU" id="627_yy3qUjD" role="1_0VJ0">
          <property role="3z_lpW" value="mbeddr" />
          <property role="3z_lpJ" value="true" />
          <property role="3z_lpV" value="int16/m/ someFunction(Trackpoint* p1, Trackpoint* p2) {             &#10;  int16 newValueWithoutUnit = anExistingFunction(stripunit[p1.alt]);&#10;  return newValueWithoutUnit m;                                     &#10;} someFunction (function)                                           " />
          <node concept="2NCZwO" id="627_yy3qUjE" role="3z_lpI">
            <node concept="2NCMab" id="627_yy3qUjF" role="2NCMaf">
              <ref role="2NCMaa" to="e1tx:1w5Xuj1QYMp" resolve="DataStructures" />
            </node>
            <node concept="2NCMab" id="627_yy3qUjG" role="2NCMaf">
              <ref role="2NCMaa" to="e1tx:4lzRQzvu$Ae" resolve="someFunction" />
            </node>
          </node>
        </node>
        <node concept="1_0LV8" id="4aWU2iTwR1O" role="1_0VJ0">
          <node concept="19SGf9" id="4aWU2iTwR1P" role="1_0LWR">
            <node concept="19SUe$" id="4aWU2iTwR1Q" role="19SJt6">
              <property role="19SUeA" value="The opposite direction (i.e., adding a unit to a value that has no unit) is also supported. The " />
            </node>
            <node concept="1jUjqm" id="4aWU2iTwR2i" role="19SJt6">
              <node concept="19SGf9" id="4aWU2iTwR2j" role="$DsGW">
                <node concept="19SUe$" id="4aWU2iTwR2k" role="19SJt6">
                  <property role="19SUeA" value="introduceunit" />
                </node>
              </node>
            </node>
            <node concept="19SUe$" id="4aWU2iTwR2l" role="19SJt6">
              <property role="19SUeA" value=" operator is available for this. It takes an expression plus the to-be-introduced unit as arguments." />
            </node>
          </node>
        </node>
      </node>
    </node>
    <node concept="1_1sxE" id="yrKNEnw4lH" role="1_0VJ0">
      <property role="TrG5h" value="empty_1383658449039_29" />
    </node>
    <node concept="1_0j5j" id="4lzRQzvpYtK" role="1DXQ57">
      <ref role="1_0j5g" to="c4ys:4rG3bBO0MpA" resolve="B_FunctionPointers" />
    </node>
    <node concept="Wq1Bs" id="1VdI9nUB1TN" role="Wq1Bf">
      <property role="Wq1Bt" value="Tamas Szabo" />
      <property role="Wq1Bq" value="tamas.szabo@itemis.de" />
    </node>
  </node>
</model>

