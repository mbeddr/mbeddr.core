package com.mbeddr.core.pointers.typesystem;

/*Generated by MPS */

import org.jetbrains.mps.openapi.model.SNode;
import java.util.Map;
import org.jetbrains.mps.openapi.language.SProperty;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.Objects;
import org.jetbrains.mps.openapi.language.SReferenceLink;
import org.jetbrains.mps.openapi.model.SReference;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.smodel.DynamicReference;
import java.util.Set;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import java.util.HashSet;
import jetbrains.mps.internal.collections.runtime.Sequence;
import java.util.List;
import jetbrains.mps.util.IterableUtil;

public class CompareHelper {
  private static boolean nodePropertiesEquals(SNode a, SNode b) {
    Map<SProperty, String> aMap = MapSequence.fromMap(new HashMap<SProperty, String>());
    Map<SProperty, String> bMap = MapSequence.fromMap(new HashMap<SProperty, String>());
    for (SProperty p : a.getProperties()) {
      MapSequence.fromMap(aMap).put(p, a.getProperty(p));
    }
    for (SProperty p : b.getProperties()) {
      MapSequence.fromMap(bMap).put(p, b.getProperty(p));
    }
    for (SProperty p : SetSequence.fromSet(MapSequence.fromMap(aMap).keySet()).union(SetSequence.fromSet(MapSequence.fromMap(bMap).keySet()))) {
      if (!(Objects.equals(MapSequence.fromMap(aMap).get(p), MapSequence.fromMap(bMap).get(p)))) {
        return false;
      }
    }
    return true;
  }
  private static boolean nodeReferencesEquals(SNode a, SNode b) {
    final Map<SReferenceLink, SReference> aMap = MapSequence.fromMap(new HashMap<SReferenceLink, SReference>());
    final Map<SReferenceLink, SReference> bMap = MapSequence.fromMap(new HashMap<SReferenceLink, SReference>());
    ListSequence.fromList(SNodeOperations.getReferences(a)).visitAll((ref) -> MapSequence.fromMap(aMap).put(SLinkOperations.getRefLink(ref), ref));
    ListSequence.fromList(SNodeOperations.getReferences(b)).visitAll((ref) -> MapSequence.fromMap(bMap).put(SLinkOperations.getRefLink(ref), ref));

    for (SReferenceLink r : SetSequence.fromSet(MapSequence.fromMap(aMap).keySet()).union(SetSequence.fromSet(MapSequence.fromMap(bMap).keySet()))) {
      SReference aRef = a.getReference(r);
      SReference bRef = b.getReference(r);
      if (aRef == null || bRef == null) {
        // cannot be both null
        return false;
      }

      if (!(Objects.equals(aRef.getTargetSModelReference(), bRef.getTargetSModelReference()))) {
        return false;
      }
      if (!(Objects.equals(((jetbrains.mps.smodel.SReference) aRef).getResolveInfo(), ((jetbrains.mps.smodel.SReference) bRef).getResolveInfo()))) {
        return false;
      }
      if (aRef instanceof DynamicReference || bRef instanceof DynamicReference) {
        if (aRef instanceof DynamicReference && bRef instanceof DynamicReference) {
          // both dynamic, ok
        } else {
          // dynamic and static
          return false;
        }
      } else {
        // both static
        if (!(Objects.equals(aRef.getTargetNodeId(), bRef.getTargetNodeId()))) {
          return false;
        }
      }
    }
    return true;
  }
  private static boolean nodeChildrenEquals(SNode a, SNode b) {
    Set<SContainmentLink> roles = SetSequence.fromSetWithValues(new HashSet<SContainmentLink>(), jetbrains.mps.util.SNodeOperations.getChildRoles(a, true));
    SetSequence.fromSet(roles).addSequence(Sequence.fromIterable(((Iterable<SContainmentLink>) jetbrains.mps.util.SNodeOperations.getChildRoles(b, false))));
    for (SContainmentLink r : SetSequence.fromSet(roles)) {
      List<SNode> aChildren = IterableUtil.asList(a.getChildren(r));
      List<SNode> bChildren = IterableUtil.asList(b.getChildren(r));
      if (aChildren.size() != bChildren.size()) {
        return false;
      }
      for (int i = 0; i < aChildren.size(); i++) {
        if (!(nodeEquals(aChildren.get(i), bChildren.get(i)))) {
          return false;
        }
      }
    }
    return true;
  }
  public static boolean nodeEquals(SNode a, SNode b) {
    return Objects.equals(a.getConcept().getQualifiedName(), b.getConcept().getQualifiedName()) && nodePropertiesEquals(a, b) && nodeReferencesEquals(a, b) && nodeChildrenEquals(a, b);
  }
}
