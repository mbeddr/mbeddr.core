package com.mbeddr.core.runconfiguration.pluginSolution.plugin;

/*Generated by MPS */

import java.io.File;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.vfs.IFile;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple;
import java.util.Map;
import java.util.TreeMap;
import java.util.Comparator;
import jetbrains.mps.internal.collections.runtime.MapSequence;

public class TestResultUtil {

  public static final String RESULT_GEN = "result_gen";
  public static final String TEST_GEN = "test_gen";
  public static final String SOURCE_GEN = "source_gen";
  public static final String ASSERTS = ".asserts";
  public static final String TESTRESULT_EXTENSION = ".xml";
  public static final String ASSERTS_XML = ASSERTS + TESTRESULT_EXTENSION;
  public static final String TIMESTAMP_SEPARATOR = "_";
  public static final int KEEP_TRESHOLD = 3;

  public static File getChild(File parent, String name) {
    return new File(parent.getPath() + File.separator + name);
  }

  public static void copy(File source, File target) {
    if (source != null && target != null && source.exists()) {
      // use the java IO mechanisms to avoid the read-write command madness
      String op = source.getPath();
      String cp = target.getPath();

      InputStream inputStream = null;
      OutputStream outputStream = null;
      try {
        if (!(target.getParentFile().exists())) {
          target.getParentFile().mkdirs();
        }
        if (!(target.exists())) {
          target.createNewFile();
        }

        inputStream = new FileInputStream(op);
        outputStream = new FileOutputStream(cp);
        byte[] buffer = new byte[1024];
        int length;
        while ((length = inputStream.read(buffer)) > 0) {
          outputStream.write(buffer, 0, length);
        }
      } catch (Exception e) {
        throw new RuntimeException("Unable to copy " + source + " to " + target + "!", e);
      } finally {
        if (inputStream != null) {
          try {
            inputStream.close();
          } catch (IOException e) {
            throw new RuntimeException("Unable to close input stream!", e);
          }
        }
        if (outputStream != null) {
          try {
            outputStream.close();
          } catch (IOException e) {
            throw new RuntimeException("Unable to close output stream!", e);
          }
        }
      }
    }
  }

  public static File getAssertsFile(SNode node) {
    File sourceFolder = getSourceFolder(node);
    return getChild(sourceFolder, ASSERTS_XML);
  }

  public static File getResultFolder(SNode node) {
    return getFolder(node, RESULT_GEN);
  }

  public static File getSourceFolder(SNode node) {
    return getFolder(node, SOURCE_GEN);
  }

  public static File getTestFolder(SNode node) {
    return getFolder(node, TEST_GEN);
  }

  private static File getFolder(SNode node, String folder) {
    IFile output = PlatformUtil.getOutputPath(node);
    String packageName = PlatformUtil.getPackage(node);
    if (output == null) {
      return null;
    }

    // get jump over source_gen/test_gn
    while (output != null && !(output.getName().equals(SOURCE_GEN)) && !(output.getName().equals(TEST_GEN))) {
      output = output.getParent();
    }
    if (output == null) {
      return null;
    }

    output = output.getParent();
    if (output == null) {
      return null;
    }

    output = output.getDescendant(folder).getDescendant(packageName.replace(".", File.separator));
    return new File(output.getPath());
  }

  public static Tuples._2<String, Long> split(String fileName) {
    if (fileName.endsWith(TESTRESULT_EXTENSION)) {
      int index = fileName.lastIndexOf(TIMESTAMP_SEPARATOR);
      if (index != -1) {
        String timestamp = fileName.substring(index + 1, fileName.length() - TESTRESULT_EXTENSION.length());
        String name = fileName.substring(0, index);
        try {
          return MultiTuple.<String,Long>from(name, Long.parseLong(timestamp));
        } catch (NumberFormatException e) {
          // ignore
        }
      }
    }
    return null;
  }

  public static Map<Long, File> getTestResultFiles(File container) {
    Map<Long, File> result = new TreeMap<Long, File>(new Comparator<Long>() {
      @Override
      public int compare(Long a, Long b) {
        return compareTo(a, b) * -1;
      }
    });
    if (container != null && container.listFiles() != null) {
      for (File file : container.listFiles()) {
        Tuples._2<String, Long> tuple = split(file.getName());
        if (tuple != null) {
          long timestamp = (long) tuple._1();
          MapSequence.fromMap(result).put(timestamp, file);
        }
      }
    }

    return result;
  }

  /**
   * Java 6 and below does not support the Long.compareTo method. 
   */
  private static int compareTo(long a, long b) {
    if (a < b) {
      return -1;
    } else if (a == b) {
      return 0;
    } else {
      return 1;
    }
  }

}
