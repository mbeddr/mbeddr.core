package com.mbeddr.core.runconfiguration.pluginSolution.plugin;

/*Generated by MPS */

import jetbrains.mps.execution.api.configurations.BaseMpsBeforeTaskProvider;
import com.intellij.openapi.util.Key;
import org.jetbrains.mps.openapi.model.SNode;
import com.intellij.openapi.project.Project;
import com.intellij.execution.runners.ExecutionEnvironment;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.atomic.AtomicReference;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import java.awt.EventQueue;
import com.intellij.openapi.progress.ProgressManager;
import com.intellij.openapi.progress.ProgressIndicator;
import java.util.List;
import java.util.concurrent.Future;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import java.util.concurrent.Callable;

public class Make_BeforeTask extends BaseMpsBeforeTaskProvider<Make_BeforeTask.Make_BeforeTask_RunTask> {
  public static final Key<Make_BeforeTask_RunTask> KEY = Key.create("com.mbeddr.core.runconfiguration.pluginSolution.plugin.Make_BeforeTask");

  public Make_BeforeTask() {
    super("make", "make");
  }

  protected Make_BeforeTask_RunTask createTaskImpl() {
    return new Make_BeforeTask_RunTask();
  }

  public Key<Make_BeforeTask_RunTask> getId() {
    return KEY;
  }

  public static class Make_BeforeTask_RunTask extends BaseMpsBeforeTaskProvider.BaseMpsBeforeRunTask<Make_BeforeTask_RunTask> {
    private SNode myBinary;

    public Make_BeforeTask_RunTask() {
      super(KEY);
    }

    public boolean configure(SNode binary) {
      myBinary = binary;
      return true;
    }

    public boolean execute(Project project, ExecutionEnvironment environment) {
      if ((myBinary == null)) {
        ErrorReporter.showErrorDialog("No Binary set in Runconfiguration");
      } else {
        final ExecutorService executor = Executors.newFixedThreadPool(5);
        final AtomicReference<Boolean> toolsInstalled = new AtomicReference<Boolean>(false);
        final AtomicReference<String> pathToMake = new AtomicReference<String>("make");
        SNodeOperations.getModel(myBinary).getRepository().getModelAccess().runReadAction(() -> pathToMake.set(BuildConfigHelper.getPathToMake(myBinary)));
        final Project finalProject = project;

        // first, we validate our tools are installed
        try {
          final AtomicReference<Exception> thrownException = new AtomicReference<Exception>();
          EventQueue.invokeAndWait(new Runnable() {
            public void run() {
              ProgressManager.getInstance().runProcessWithProgressSynchronously(new Runnable() {
                public void run() {
                  ProgressIndicator progressIndicator = ProgressManager.getInstance().getProgressIndicator();
                  progressIndicator.setIndeterminate(true);
                  List<Future<Boolean>> futures = ListSequence.fromList(new ArrayList<Future<Boolean>>());
                  List<Callable<Boolean>> validationTasks = BuildBinaryUtil.getValidationTasks(myBinary);
                  try {
                    for (Callable<Boolean> task : ListSequence.fromList(validationTasks)) {
                      ListSequence.fromList(futures).addElement(executor.submit(task));
                    }

                    boolean allValidationsSuccessful = true;
                    for (Future<Boolean> future : ListSequence.fromList(futures)) {
                      boolean successfulValidated = future.get();
                      if (!(successfulValidated)) {
                        allValidationsSuccessful = future.get();
                      }
                    }
                    toolsInstalled.set(allValidationsSuccessful);
                  } catch (Exception ex) {
                    thrownException.set(ex);
                  }
                }
              }, "Validating tools are installed ...", false, finalProject);
            }
          });
          if (thrownException.get() != null) {
            ErrorReporter.showErrorDialog(thrownException.get().getMessage());
          }

          if (!(toolsInstalled.get())) {
            return false;
          } else {
            final AtomicReference<Boolean> makeSuccessful = new AtomicReference<Boolean>(false);
            EventQueue.invokeAndWait(new Runnable() {
              public void run() {
                ProgressManager.getInstance().runProcessWithProgressSynchronously(new Runnable() {
                  public void run() {
                    try {
                      ProgressIndicator progressIndicator = ProgressManager.getInstance().getProgressIndicator();
                      progressIndicator.setIndeterminate(true);
                      Future<Boolean> future = executor.submit(MakeExecutor.makeBinary(pathToMake.get(), myBinary, true));
                      Thread.sleep(200);
                      makeSuccessful.set(future.get());
                    } catch (Exception ex) {
                      ex.printStackTrace();
                    }
                  }
                }, "Building binary ...", false, finalProject);
              }
            });
            if (!(makeSuccessful.get())) {
              ErrorReporter.showErrorDialog("Make failed - try running make from the command line to get more detailed information");
            }
            return makeSuccessful.get();
          }
        } catch (Exception ex) {
          ex.printStackTrace();
        }
      }
      return false;
    }
  }
}
