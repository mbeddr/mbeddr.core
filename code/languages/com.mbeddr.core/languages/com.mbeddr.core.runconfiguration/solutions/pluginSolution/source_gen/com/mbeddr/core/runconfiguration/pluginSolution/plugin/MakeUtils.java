package com.mbeddr.core.runconfiguration.pluginSolution.plugin;

/*Generated by MPS */

import java.util.concurrent.Future;
import jetbrains.mps.make.script.IResult;
import jetbrains.mps.project.Project;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.ide.save.SaveRepositoryCommand;
import java.util.Map;
import java.util.concurrent.ExecutionException;
import jetbrains.mps.generator.TransientModelsProvider;
import jetbrains.mps.ide.make.DefaultMakeMessageHandler;
import jetbrains.mps.generator.GenerationOptions;
import jetbrains.mps.generator.DefaultGenerationParametersProvider;
import jetbrains.mps.internal.collections.runtime.IMapping;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import jetbrains.mps.generator.GenerationFacade;
import jetbrains.mps.generator.GenerationStatus;
import jetbrains.mps.make.MakeSession;
import jetbrains.mps.messages.IMessageHandler;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.smodel.resources.ModelsToResources;
import jetbrains.mps.make.IMakeService;
import jetbrains.mps.make.MakeServiceComponent;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.progress.EmptyProgressMonitor;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;

/**
 * Utility methods for rebuilding the analyzed model.
 */
public class MakeUtils {

  /**
   * Is the make process active?
   */
  /*package*/ static boolean MAKE_PROCESS_ACTIVE = false;

  /**
   * Should we debug?
   */
  private static boolean DEBUG = false;

  /**
   * Returns a future that makes the project.
   */
  public static Future<IResult> makeProject(final Project proj, SModel model) {
    new SaveRepositoryCommand(proj.getRepository()).execute();
    return makeProject(proj, model, true);
  }

  /**
   * Returns a future that makes the project. If we run from tests then we should not rebuild.
   */
  public static Future<IResult> makeProject(final Project proj, SModel model, boolean shouldRebuild) {
    new SaveRepositoryCommand(proj.getRepository()).execute();
    return new MakeFuture(proj, model, shouldRebuild);
  }
  /**
   * Returns a future that makes the project. If we run from tests then we should not rebuild.
   */
  public static Future<IResult> makeProject(final Project proj, SModel model, boolean shouldRebuild, Map<String, Object> parameters) {
    new SaveRepositoryCommand(proj.getRepository()).execute();
    return new MakeFuture(proj, model, shouldRebuild, parameters);
  }

  /**
   * This method is used from tests where from we we should not rebuild or make on the build server.
   */
  public static Future<IResult> makeLastGeneratedModelsAvailable(final Project proj, SModel model) {
    new SaveRepositoryCommand(proj.getRepository()).execute();

    // Returns a future that makes available the last generated models without any make/rebuild.
    return new MakeFuture(proj, model);
  }

  /**
   * A future that makes and saves the transient models.
   */
  private static class MakeFuture implements Future<IResult> {

    /**
     * Flag if we should rebuild.
     */
    private boolean shouldRebuild;

    /**
     * Flag if we should only make available the last generated models without make/rebuild.
     */
    private boolean onlyLastGeneratedModels;

    /**
     * The model to make.
     */
    private SModel model;

    /**
     * The current project.
     */
    private Project proj;
    private Map<String, Object> parameters;

    /**
     * Constructor.
     */
    public MakeFuture(Project proj, SModel model, boolean shouldRebuild) {
      this.proj = proj;
      this.model = model;
      this.shouldRebuild = shouldRebuild;
      this.onlyLastGeneratedModels = false;
    }
    /**
     * Constructor.
     */
    public MakeFuture(Project proj, SModel model, boolean shouldRebuild, Map<String, Object> parameters) {
      this.proj = proj;
      this.model = model;
      this.shouldRebuild = shouldRebuild;
      this.onlyLastGeneratedModels = false;
      this.parameters = parameters;
    }

    /**
     * Constructor.
     */
    public MakeFuture(Project proj, SModel model) {
      this.proj = proj;
      this.model = model;
      this.shouldRebuild = true;
      this.onlyLastGeneratedModels = true;
    }

    /**
     * {@inheritDoc}
     */
    public boolean cancel(boolean b) {
      return false;
    }

    /**
     * {@inheritDoc}
     */
    public boolean isCancelled() {
      return false;
    }

    /**
     * {@inheritDoc}
     */
    public boolean isDone() {
      return false;
    }

    /**
     * {@inheritDoc}
     */
    public IResult get() throws InterruptedException, ExecutionException {
      IResult rebuildResult = null;
      try {
        MAKE_PROCESS_ACTIVE = true;
        if (!(onlyLastGeneratedModels)) {
          rebuildResult = doRebuildProject(proj, model);
        }
        //  FIXME this code duplicates com.mbeddr.mpsutil.lantest.rt.code_generator.Generator
        final TransientModelsProvider tmp = proj.getComponent(TransientModelsProvider.class);
        final ProgressMonitorWrapper epm = new ProgressMonitorWrapper();
        final DefaultMakeMessageHandler msgHandler = new DefaultMakeMessageHandler(proj);
        GenerationOptions.OptionsBuilder builder = GenerationOptions.getDefaults();
        DefaultGenerationParametersProvider provider = new DefaultGenerationParametersProvider();
        if (parameters != null) {
          for (IMapping<String, Object> param : MapSequence.fromMap(parameters)) {
            provider.addParameter(param.key(), param.value());
          }
        }

        final GenerationOptions genOpt = builder.reporting(false, false, false, -1).showBadChildWarning(true).parameters(provider).create();
        proj.getRepository().getModelAccess().runWriteAction(() -> {
          GenerationFacade genFacade = new GenerationFacade(proj.getRepository(), genOpt).transients(tmp).messages(msgHandler);
          GenerationStatus genStatus = genFacade.process(epm, model);
          lastOutputModel = genStatus.getOutputModel();
        });
        epm.countDownLatch.await();
      } finally {
        MAKE_PROCESS_ACTIVE = false;
      }
      return rebuildResult;
    }

    /**
     * Rebuilds the project.
     */
    private IResult doRebuildProject(final Project proj, SModel model) {
      final MakeSession session = new MakeSession(proj, IMessageHandler.NULL_HANDLER, shouldRebuild);
      List<SModel> seq = ListSequence.fromList(new ArrayList<SModel>());
      ListSequence.fromList(seq).addElement(model);
      final Iterable res = new ModelsToResources(seq).resources();
      IMakeService makeService = proj.getComponent(MakeServiceComponent.class).get();
      if (Sequence.fromIterable(res).isNotEmpty() && makeService.openNewSession(session)) {
        Future<IResult> future = makeService.make(session, res, null);
        try {
          return future.get();
        } catch (Exception ex) {
          ex.printStackTrace();
        }
      }
      return null;
    }

    /**
     * Simple wrapper for the progress monitor to get when the generation ended.
     */
    private static class ProgressMonitorWrapper extends EmptyProgressMonitor {
      public CountDownLatch countDownLatch = new CountDownLatch(1);

      @Override
      public void done() {
        super.done();
        countDownLatch.countDown();
      }
    }

    /**
     * {@inheritDoc}
     */
    public IResult get(long l, TimeUnit u) throws InterruptedException, ExecutionException, TimeoutException {
      return get();
    }
  }

  /**
   * The last output model before the text is generated.
   */
  public static SModel lastOutputModel;
}
