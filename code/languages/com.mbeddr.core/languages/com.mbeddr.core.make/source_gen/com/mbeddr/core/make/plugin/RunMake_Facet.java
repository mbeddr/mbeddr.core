package com.mbeddr.core.make.plugin;

/*Generated by MPS */

import jetbrains.mps.make.facet.IFacet;
import java.util.List;
import jetbrains.mps.make.facet.ITarget;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.make.resources.IPropertiesPersistence;
import jetbrains.mps.make.facet.ITargetEx;
import jetbrains.mps.make.script.IJob;
import jetbrains.mps.make.script.IResult;
import jetbrains.mps.make.resources.IResource;
import jetbrains.mps.make.script.IJobMonitor;
import jetbrains.mps.make.resources.IPropertiesAccessor;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.mps.openapi.util.ProgressMonitor;
import jetbrains.mps.smodel.resources.MResource;
import jetbrains.mps.internal.collections.runtime.LinkedListSequence;
import java.util.LinkedList;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import org.jetbrains.mps.openapi.model.SNode;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.vfs.IFile;
import jetbrains.mps.smodel.SModelOperations;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import com.mbeddr.core.make.behavior.IMakePathProviderContainer__BehaviorDescriptor;
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple;
import jetbrains.mps.make.script.IConfig;
import jetbrains.mps.make.script.IPropertiesPool;
import java.util.stream.IntStream;
import java.io.File;
import com.mbeddr.core.make.behavior.IMakePathProvider__BehaviorDescriptor;
import com.mbeddr.core.make.behavior.IGeneratesToMakefile__BehaviorDescriptor;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import jetbrains.mps.messages.IMessage;
import jetbrains.mps.make.script.IFeedback;
import java.util.Map;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import org.jetbrains.mps.openapi.language.SInterfaceConcept;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;

public class RunMake_Facet extends IFacet.Stub {
  private List<ITarget> targets = ListSequence.fromList(new ArrayList<ITarget>());
  private IFacet.Name name = new IFacet.Name("com.mbeddr.core.make.RunMake");
  public RunMake_Facet() {
    ListSequence.fromList(targets).addElement(new Target_collectPaths());
    ListSequence.fromList(targets).addElement(new Target_runMake());
  }
  public Iterable<ITarget> targets() {
    return targets;
  }
  public Iterable<IFacet.Name> optional() {
    return null;
  }
  public Iterable<IFacet.Name> required() {
    return Sequence.fromArray(new IFacet.Name[]{new IFacet.Name("jetbrains.mps.make.facets.Generate"), new IFacet.Name("jetbrains.mps.make.facets.TextGen"), new IFacet.Name("jetbrains.mps.make.facets.Make")});
  }
  public Iterable<IFacet.Name> extended() {
    return null;
  }
  public IFacet.Name getName() {
    return this.name;
  }
  public IPropertiesPersistence propertiesPersistence() {
    return new TargetProperties();
  }
  public static class Target_collectPaths implements ITargetEx {
    private static final ITarget.Name name = new ITarget.Name("com.mbeddr.core.make.RunMake.collectPaths");
    public Target_collectPaths() {
    }
    public IJob createJob() {
      return new IJob.Stub() {
        @Override
        public IResult execute(final Iterable<IResource> rawInput, final IJobMonitor monitor, final IPropertiesAccessor pa, @NotNull final ProgressMonitor progressMonitor) {
          Iterable<IResource> _output_qkwdbw_a0a = null;
          final Iterable<MResource> input = (Iterable<MResource>) (Iterable) rawInput;
          switch (0) {
            case 0:
              vars(pa.global()).paths(LinkedListSequence.fromLinkedList(new LinkedList<Tuples._4<String, String, SNode, SNode>>()));

              for (MResource _input : Sequence.fromIterable(input)) {
                for (final SModel _model : Sequence.fromIterable(_input.models())) {
                  IFile outputLocation = SModelOperations.getOutputLocation(_model);
                  if (outputLocation == null) {
                    throw new RuntimeException("Output location for " + _model.getName().getLongName() + " model not found");
                  }
                  String path = outputLocation.getPath();
                  String moduleName = _input.module().getModuleName() + "/" + _model.getName().getLongName();
                  final Wrappers._T<SNode> makePathProvider = new Wrappers._T<SNode>(null);
                  final Wrappers._T<SNode> parallelMakeGenerator = new Wrappers._T<SNode>(null);
                  monitor.getSession().getProject().getRepository().getModelAccess().runReadAction(() -> {
                    makePathProvider.value = IMakePathProviderContainer__BehaviorDescriptor.getMakePathProvider_id3s1LyzGfrML.invoke(ListSequence.fromList(jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations.roots(((SModel) _model), CONCEPTS.IMakePathProviderContainer$KZ)).first());
                    parallelMakeGenerator.value = ListSequence.fromList(jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations.nodes(((SModel) _model), CONCEPTS.IGeneratesToMakefile$Cj)).first();
                  });
                  ListSequence.fromList(vars(pa.global()).paths()).addElement(MultiTuple.<String,String,SNode,SNode>from(path, moduleName, makePathProvider.value, parallelMakeGenerator.value));
                }
              }

              _output_qkwdbw_a0a = Sequence.fromIterable(_output_qkwdbw_a0a).concat(Sequence.fromIterable(input));
              return new IResult.SUCCESS(_output_qkwdbw_a0a);
            default:
              progressMonitor.done();
              return new IResult.SUCCESS(_output_qkwdbw_a0a);
          }
        }
      };
    }
    public IConfig createConfig() {
      return null;
    }
    public Iterable<ITarget.Name> notAfter() {
      return null;
    }
    public Iterable<ITarget.Name> after() {
      return Sequence.fromArray(new ITarget.Name[]{new ITarget.Name("jetbrains.mps.make.facets.Generate.configure")});
    }
    public Iterable<ITarget.Name> notBefore() {
      return null;
    }
    public Iterable<ITarget.Name> before() {
      return Sequence.fromArray(new ITarget.Name[]{new ITarget.Name("jetbrains.mps.make.facets.Generate.generate")});
    }
    public ITarget.Name getName() {
      return name;
    }
    public boolean isOptional() {
      return false;
    }
    public boolean requiresInput() {
      return true;
    }
    public boolean producesOutput() {
      return true;
    }
    public Iterable<Class<? extends IResource>> expectedInput() {
      List<Class<? extends IResource>> rv = ListSequence.fromList(new ArrayList<Class<? extends IResource>>());
      ListSequence.fromList(rv).addElement(MResource.class);
      return rv;
    }
    public Iterable<Class<? extends IResource>> expectedOutput() {
      return null;
    }
    public <T> T createParameters(Class<T> cls) {
      return cls.cast(new Parameters());
    }
    public <T> T createParameters(Class<T> cls, T copyFrom) {
      T t = createParameters(cls);
      if (t != null) {
        ((Tuples._1) t).assign((Tuples._1) copyFrom);
      }
      return t;
    }
    public static Parameters vars(IPropertiesPool ppool) {
      return ppool.properties(name, Parameters.class);
    }
    public static class Parameters extends MultiTuple._1<List<Tuples._4<String, String, SNode, SNode>>> {
      public Parameters() {
        super();
      }
      public Parameters(List<Tuples._4<String, String, SNode, SNode>> paths) {
        super(paths);
      }
      public List<Tuples._4<String, String, SNode, SNode>> paths(List<Tuples._4<String, String, SNode, SNode>> value) {
        return super._0(value);
      }
      public List<Tuples._4<String, String, SNode, SNode>> paths() {
        return super._0();
      }
    }
  }
  public static class Target_runMake implements ITargetEx {
    private static final ITarget.Name name = new ITarget.Name("com.mbeddr.core.make.RunMake.runMake");
    public Target_runMake() {
    }
    public IJob createJob() {
      return new IJob.Stub() {
        @Override
        public IResult execute(final Iterable<IResource> rawInput, final IJobMonitor monitor, final IPropertiesAccessor pa, @NotNull final ProgressMonitor progressMonitor) {
          Iterable<IResource> _output_qkwdbw_a0b = null;
          final Iterable<MResource> input = (Iterable<MResource>) (Iterable) rawInput;
          progressMonitor.start("", IntStream.of(1000).sum());
          switch (0) {
            case 0:
              Iterable<Tuples._4<String, String, SNode, SNode>> pathTuples = ListSequence.fromList(Target_collectPaths.vars(pa.global()).paths()).where((it) -> new File(it._0() + "/Makefile").exists());

              if (Sequence.fromIterable(pathTuples).isEmpty()) {
                return new IResult.SUCCESS(_output_qkwdbw_a0b);
              }

              final ProgressMonitor subProgress_e0a0b = progressMonitor.subTask(1000);
              subProgress_e0a0b.start("run make", Sequence.fromIterable(pathTuples).count());

              boolean successfulCompilation = true;

              for (final Tuples._4<String, String, SNode, SNode> pathTuple : Sequence.fromIterable(pathTuples)) {
                final Wrappers._boolean canMake = new Wrappers._boolean(false);

                monitor.getSession().getProject().getRepository().getModelAccess().runReadAction(() -> canMake.value = (pathTuple._2() != null) && (boolean) IMakePathProvider__BehaviorDescriptor.canMake_id3s1LyzG6KRG.invoke(pathTuple._2()));

                if (!(canMake.value)) {
                  return new IResult.SUCCESS(_output_qkwdbw_a0b);
                }

                try {

                  subProgress_e0a0b.advance(1);
                  subProgress_e0a0b.step("running make for " + pathTuple._1());
                  // use ProcessBuilder to automatically get make.exe via PATH and environment
                  final Wrappers._T<String> makeCommand = new Wrappers._T<String>(null);

                  monitor.getSession().getProject().getRepository().getModelAccess().runReadAction(() -> makeCommand.value = IMakePathProvider__BehaviorDescriptor.getPathToMake_id3s1LyzG7eMZ.invoke(pathTuple._2()));

                  if (makeCommand.value == null) {
                    throw new RuntimeException("Path to make is null, please run the migration");
                  }

                  final Wrappers._T<ProcessBuilder> processBuilder = new Wrappers._T<ProcessBuilder>();
                  monitor.getSession().getProject().getRepository().getModelAccess().runReadAction(() -> {
                    SNode platform = pathTuple._3();
                    if ((boolean) IGeneratesToMakefile__BehaviorDescriptor.canBeParallelized_id3dZgFhDSzmf.invoke(platform)) {
                      // The -j option instructs the make to run it's recipes in parallel
                      processBuilder.value = new ProcessBuilder(makeCommand.value, "-j" + (int) IGeneratesToMakefile__BehaviorDescriptor.parallelProcesses_id71C71cTwEiX.invoke(platform));
                    } else {
                      processBuilder.value = new ProcessBuilder(makeCommand.value);
                    }
                  });

                  processBuilder.value.directory(new File(pathTuple._0()));
                  processBuilder.value.redirectErrorStream(true);
                  final Process process = processBuilder.value.start();

                  ExecutorService executor = Executors.newFixedThreadPool(2);
                  LogWriter standardInputWriter = new LogWriter(process.getInputStream(), pathTuple);
                  LogWriter standardErrorWriter = new LogWriter(process.getErrorStream(), pathTuple);

                  List<IMessage> standardInputMessages = (List<IMessage>) executor.submit(standardInputWriter).get();
                  List<IMessage> standardErrorMessages = (List<IMessage>) executor.submit(standardErrorWriter).get();
                  int exitValue = process.waitFor();

                  for (IMessage message : ListSequence.fromList(standardInputMessages)) {
                    monitor.reportFeedback(new IFeedback.MESSAGE(message));
                  }
                  for (IMessage message : ListSequence.fromList(standardErrorMessages)) {
                    monitor.reportFeedback(new IFeedback.MESSAGE(message));
                  }

                  MakeUtil.MAKE_EXIT_CODE = exitValue;
                  if (exitValue > 0) {
                    successfulCompilation = false;
                    monitor.reportFeedback(new IFeedback.ERROR(String.valueOf("make failed with exit code " + process.exitValue() + " for " + pathTuple._1() + " with make command " + processBuilder.value.command())));
                    break;
                  } else {
                    monitor.reportFeedback(new IFeedback.INFORMATION(String.valueOf("make for '" + pathTuple._1() + "' successfully completed (make command: '" + String.join(" ", processBuilder.value.command()) + "')")));
                  }
                } catch (Exception ex) {
                  successfulCompilation = false;
                  monitor.reportFeedback(new IFeedback.ERROR(String.valueOf("make for '" + pathTuple._1() + "' failed: " + ex.getMessage())));
                  break;
                }
              }

              subProgress_e0a0b.done();
              if (successfulCompilation) {
                return new IResult.SUCCESS(_output_qkwdbw_a0b);
              } else {
                return new IResult.FAILURE(_output_qkwdbw_a0b);
              }
            default:
              progressMonitor.done();
              return new IResult.SUCCESS(_output_qkwdbw_a0b);
          }
        }
      };
    }
    public IConfig createConfig() {
      return null;
    }
    public Iterable<ITarget.Name> notAfter() {
      return null;
    }
    public Iterable<ITarget.Name> after() {
      return Sequence.fromArray(new ITarget.Name[]{new ITarget.Name("jetbrains.mps.make.facets.TextGen.textGen"), new ITarget.Name("com.mbeddr.core.make.RunMake.collectPaths"), new ITarget.Name("jetbrains.mps.make.facets.Make.cleanup")});
    }
    public Iterable<ITarget.Name> notBefore() {
      return null;
    }
    public Iterable<ITarget.Name> before() {
      return Sequence.fromArray(new ITarget.Name[]{new ITarget.Name("jetbrains.mps.make.facets.Make.make")});
    }
    public ITarget.Name getName() {
      return name;
    }
    public boolean isOptional() {
      return false;
    }
    public boolean requiresInput() {
      return false;
    }
    public boolean producesOutput() {
      return false;
    }
    public Iterable<Class<? extends IResource>> expectedInput() {
      List<Class<? extends IResource>> rv = ListSequence.fromList(new ArrayList<Class<? extends IResource>>());
      ListSequence.fromList(rv).addElement(MResource.class);
      return rv;
    }
    public Iterable<Class<? extends IResource>> expectedOutput() {
      return null;
    }
    public <T> T createParameters(Class<T> cls) {
      return null;
    }
    public <T> T createParameters(Class<T> cls, T copyFrom) {
      T t = createParameters(cls);
      return t;
    }
  }
  public static class TargetProperties implements IPropertiesPersistence {
    public TargetProperties() {
    }
    public void storeValues(Map<String, String> store, IPropertiesPool properties) {
      {
        ITarget.Name name = new ITarget.Name("com.mbeddr.core.make.RunMake.collectPaths");
        if (properties.hasProperties(name)) {
          Target_collectPaths.Parameters props = properties.properties(name, Target_collectPaths.Parameters.class);
          MapSequence.fromMap(store).put("com.mbeddr.core.make.RunMake.collectPaths.paths", null);
        }
      }
    }
    public void loadValues(Map<String, String> store, IPropertiesPool properties) {
      try {
        {
          ITarget.Name name = new ITarget.Name("com.mbeddr.core.make.RunMake.collectPaths");
          Target_collectPaths.Parameters props = properties.properties(name, Target_collectPaths.Parameters.class);
          if (MapSequence.fromMap(store).containsKey("com.mbeddr.core.make.RunMake.collectPaths.paths")) {
            props.paths(null);
          }
        }
      } catch (RuntimeException re) {
      }
    }
  }

  private static final class CONCEPTS {
    /*package*/ static final SInterfaceConcept IMakePathProviderContainer$KZ = MetaAdapterFactory.getInterfaceConcept(0xf93d1dbebfd142ddL, 0x932af375fa6f5373L, 0x3701c628ec3dbcadL, "com.mbeddr.core.make.structure.IMakePathProviderContainer");
    /*package*/ static final SInterfaceConcept IGeneratesToMakefile$Cj = MetaAdapterFactory.getInterfaceConcept(0xf93d1dbebfd142ddL, 0x932af375fa6f5373L, 0x337f42b469e2013bL, "com.mbeddr.core.make.structure.IGeneratesToMakefile");
  }
}
