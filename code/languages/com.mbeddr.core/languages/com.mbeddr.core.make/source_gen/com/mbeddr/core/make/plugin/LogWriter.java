package com.mbeddr.core.make.plugin;

/*Generated by MPS */

import java.util.concurrent.Callable;
import java.io.BufferedReader;
import jetbrains.mps.messages.MessageKind;
import java.io.InputStream;
import java.io.InputStreamReader;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import org.jetbrains.mps.openapi.model.SNode;
import java.util.List;
import jetbrains.mps.messages.IMessage;
import jetbrains.mps.messages.Message;
import org.jetbrains.mps.openapi.model.SNodeReference;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;

public class LogWriter implements Callable {
  protected static final int FILE_NAME_INDEX = 0;
  protected static final int LINE_NUMBER_INDEX = 1;
  protected static final int MSG_KIND_INDEX = 3;

  protected final String fqModelName;
  protected BufferedReader reader;
  protected MessageKind currentMsgKind;

  public LogWriter(InputStream inStream, String fqModelName) {
    this.reader = new BufferedReader(new InputStreamReader(inStream));
    this.fqModelName = fqModelName;
  }

  public LogWriter(InputStream inStream, Tuples._4<String, String, SNode, SNode> dirInfoTuple) {
    this.reader = new BufferedReader(new InputStreamReader(inStream));
    fqModelName = dirInfoTuple._1();
  }

  private MessageKind parseMessageKind(String makeOutput) {
    String[] splittedOutput = makeOutput.split(":");
    if (splittedOutput.length >= 4) {
      String msgKind = splittedOutput[MSG_KIND_INDEX].toLowerCase();
      if (msgKind.contains("warning")) {
        return MessageKind.WARNING;
      } else if (msgKind.contains("error")) {
        return MessageKind.ERROR;
      }
    }
    return null;
  }

  private void contributeMessage(List<IMessage> msgs, String makeOutput) {
    TracingLocation location = TraceUtil.extractLocation(makeOutput, fqModelName);
    MessageKind messageKind = parseMessageKind(makeOutput);
    if (messageKind == null) {
      messageKind = MessageKind.INFORMATION;
    }
    Message msg = new Message(messageKind, makeOutput);
    if (location != null) {
      SNodeReference nodeRef = TraceUtil.loadNodeFromTrace(location);
      msg.setHintObject(nodeRef);
    }
    // always add the message to the list, even if it does not have location information
    ListSequence.fromList(msgs).addElement(msg);
  }


  public Object call() throws Exception {
    List<IMessage> msgs = ListSequence.fromList(new ArrayList<IMessage>());
    try {
      String makeOutput = reader.readLine();
      while (makeOutput != null) {
        contributeMessage(msgs, makeOutput);
        makeOutput = reader.readLine();
      }
    } catch (Exception e) {
      e.printStackTrace();
    } finally {
      try {
        reader.close();
      } catch (Exception e) {
      }
    }
    return msgs;
  }

}
