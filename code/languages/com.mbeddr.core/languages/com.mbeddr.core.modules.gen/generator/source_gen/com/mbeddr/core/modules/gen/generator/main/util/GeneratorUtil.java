package com.mbeddr.core.modules.gen.generator.main.util;

/*Generated by MPS */

import java.util.List;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.LinkedList;
import java.util.TreeSet;
import java.util.ArrayList;
import java.util.Collection;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.IAttributeDescriptor;
import java.util.Comparator;
import org.jetbrains.mps.openapi.language.SConcept;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import org.jetbrains.mps.openapi.language.SInterfaceConcept;

public class GeneratorUtil {
  public static List<SNode> sort(List<SNode> contents) {
    GraphDataSource<SNode> graph = new GraphDataSource<SNode>();

    // first insert all contents as nodes in the graph
    for (SNode content : ListSequence.fromList(contents)) {
      graph.addNode(content);
    }
    Dependencies dependenciesTracker = new Dependencies();
    for (SNode content : ListSequence.fromList(contents)) {
      dependenciesTracker.collectDependencies(content, graph);
    }

    // topological sorting
    List<SNode> result = ListSequence.fromList(new LinkedList<SNode>());
    TreeSet<SNode> nodes = new TreeSet<SNode>(contentComparator);

    nodes.addAll(graph.getSources());

    int nodeCount = 0;

    while (!(nodes.isEmpty())) {
      SNode source = nodes.first();
      nodes.remove(source);

      // already performing the reversal here
      ListSequence.fromList(result).insertElement(0, source);
      nodeCount++;

      List<SNode> targets = new ArrayList<SNode>();
      if (graph.getTargets(source) != null) {
        targets.addAll(graph.getTargets(source));
      }

      for (SNode target : ListSequence.fromList(targets)) {
        graph.removeEdge(source, target);
        Collection<SNode> sources = graph.getSources(target);
        if (sources == null || sources.isEmpty()) {
          nodes.add(target);
        }
      }
    }

    if (nodeCount == SetSequence.fromSet(graph.getAllNodes()).count()) {
      return result;
    } else {
      return null;
    }
  }

  public static boolean shouldKeepAlive(SNode n) {
    return SNodeOperations.isInstanceOf(n, CONCEPTS.IKeepAliveInGeneration$uM) || (new IAttributeDescriptor.NodeAttribute(CONCEPTS.KeepAliveInGeneration$HN).get(n) != null);
  }

  private static Comparator<SNode> contentComparator = new Comparator<SNode>() {
    public int compare(SNode c1, SNode c2) {
      int i1 = SNodeOperations.getIndexInParent(c1);
      int i2 = SNodeOperations.getIndexInParent(c2);

      if (i1 == i2) {
        return c1.getNodeId().toString().compareTo(c2.getNodeId().toString());
      } else {
        return -1 * (i1 - i2);
      }
    }
  };

  private static final class CONCEPTS {
    /*package*/ static final SConcept KeepAliveInGeneration$HN = MetaAdapterFactory.getConcept(0xd4280a54f6df4383L, 0xaa41d1b2bffa7eb1L, 0x3dcda6fe2300afcfL, "com.mbeddr.core.base.structure.KeepAliveInGeneration");
    /*package*/ static final SInterfaceConcept IKeepAliveInGeneration$uM = MetaAdapterFactory.getInterfaceConcept(0xd4280a54f6df4383L, 0xaa41d1b2bffa7eb1L, 0x3f878a0314aaffd2L, "com.mbeddr.core.base.structure.IKeepAliveInGeneration");
  }
}
