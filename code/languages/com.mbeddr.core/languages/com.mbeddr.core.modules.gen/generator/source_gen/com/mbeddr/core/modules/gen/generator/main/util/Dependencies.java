package com.mbeddr.core.modules.gen.generator.main.util;

/*Generated by MPS */

import java.util.Map;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import com.mbeddr.core.modules.behavior.IFunctionLike__BehaviorDescriptor;
import java.util.Set;
import com.mbeddr.core.modules.behavior.TypeWithDeclaration__BehaviorDescriptor;
import org.jetbrains.mps.openapi.language.SConcept;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import org.jetbrains.mps.openapi.language.SInterfaceConcept;
import org.jetbrains.mps.openapi.language.SReferenceLink;

public class Dependencies {
  private Map<String, SNode> signatureCache = MapSequence.fromMap(new HashMap<String, SNode>());
  private Map<String, SNode> prototypeCache = MapSequence.fromMap(new HashMap<String, SNode>());
  public void collectDependencies(SNode content, GraphDataSource<SNode> builder) {
    if (SNodeOperations.isInstanceOf(content, CONCEPTS.EmptyModuleContent$uN) || SNodeOperations.isInstanceOf(content, CONCEPTS.CommentModuleContent$Hx)) {
      // empty lines and comments
      if (SNodeOperations.getNextSibling(content) != null) {
        builder.addEdge(SNodeOperations.cast(SNodeOperations.getNextSibling(content), CONCEPTS.IModuleContent$H1), content);
      }
    } else
    if (SNodeOperations.isInstanceOf(content, CONCEPTS.FunctionPrototype$JD)) {
      // make sure that the function prototype comes before the matching function declaration
      builder.addEdge(getFunction(SNodeOperations.cast(content, CONCEPTS.FunctionPrototype$JD)), SNodeOperations.cast(content, CONCEPTS.FunctionPrototype$JD));
    }
    // global variable references
    for (SNode ref : ListSequence.fromList(SNodeOperations.getNodeDescendants(content, CONCEPTS.GlobalVarRef$hy, false, new SAbstractConcept[]{}))) {
      builder.addEdge(content, SLinkOperations.getTarget(ref, LINKS.var$wHP5));
    }

    // function references due to function calls
    for (SNode call : ListSequence.fromList(SNodeOperations.getNodeDescendants(content, CONCEPTS.FunctionCall$4q, false, new SAbstractConcept[]{}))) {
      SNode signature = SLinkOperations.getTarget(call, LINKS.function$oBh5);
      if (SNodeOperations.isInstanceOf(signature, CONCEPTS.FunctionPrototype$JD)) {
        builder.addEdge(content, signature);
      } else {
        // signature is a Function instance
        SNode prototype = getFunctionPrototype(SNodeOperations.cast(signature, CONCEPTS.Function$K8));
        if (prototype != null) {
          builder.addEdge(content, prototype);
        } else {
          builder.addEdge(content, signature);
        }
      }
    }

    collectDependencies_Type(content, content, builder, SetSequence.fromSet(new HashSet<SNode>()));
  }

  private SNode getFunction(SNode prototype) {
    String prototypeSignature = IFunctionLike__BehaviorDescriptor.signatureInfo_id7GUSN23Vq8.invoke(prototype);

    SNode fromCache = MapSequence.fromMap(signatureCache).get(prototypeSignature);
    if (fromCache != null) {
      return fromCache;
    }

    for (SNode function : ListSequence.fromList(SNodeOperations.getNodeDescendants(SNodeOperations.getContainingRoot(prototype), CONCEPTS.Function$K8, false, new SAbstractConcept[]{}))) {
      if (prototypeSignature.equals(IFunctionLike__BehaviorDescriptor.signatureInfo_id7GUSN23Vq8.invoke(function))) {
        MapSequence.fromMap(signatureCache).put(prototypeSignature, function);
        return function;
      }
    }

    return null;
  }

  private SNode getFunctionPrototype(SNode function) {
    String functionSignature = IFunctionLike__BehaviorDescriptor.signatureInfo_id7GUSN23Vq8.invoke(function);

    SNode fromCache = MapSequence.fromMap(prototypeCache).get(functionSignature);
    if (fromCache != null) {
      return fromCache;
    }


    for (SNode prototype : ListSequence.fromList(SNodeOperations.getNodeDescendants(SNodeOperations.getContainingRoot(function), CONCEPTS.FunctionPrototype$JD, false, new SAbstractConcept[]{}))) {
      if (functionSignature.equals(IFunctionLike__BehaviorDescriptor.signatureInfo_id7GUSN23Vq8.invoke(prototype))) {
        MapSequence.fromMap(prototypeCache).put(functionSignature, prototype);
        return prototype;
      }
    }

    return null;
  }

  private static boolean allowsIncompleteType(SNode node) {
    return SNodeOperations.isInstanceOf(node, CONCEPTS.FunctionPrototype$JD) || SNodeOperations.isInstanceOf(node, CONCEPTS.TypeDef$QP) || SNodeOperations.isInstanceOf(node, CONCEPTS.GlobalVariableDeclaration$TW);
  }

  private static boolean knownByDefault(SNode node) {
    return SNodeOperations.isInstanceOf(node, CONCEPTS.SUDeclaration$1p) || SNodeOperations.isInstanceOf(node, CONCEPTS.EnumDeclaration$PP);
  }

  public static void collectDependencies_Type(SNode original, SNode actual, GraphDataSource<SNode> builder, Set<SNode> seen) {
    SetSequence.fromSet(seen).addElement(actual);

    for (SNode type : ListSequence.fromList(SNodeOperations.getNodeDescendants(actual, CONCEPTS.Type$dP, false, new SAbstractConcept[]{}))) {
      if (SNodeOperations.isInstanceOf(type, CONCEPTS.TypeWithDeclaration$E2)) {
        SNode typeDeclaration = TypeWithDeclaration__BehaviorDescriptor.getDeclaration_id59zzgFRcVlN.invoke(SNodeOperations.cast(type, CONCEPTS.TypeWithDeclaration$E2));

        boolean inPointer = SNodeOperations.getNodeAncestor(type, CONCEPTS.PointerType$HX, false, false) != null;
        boolean allowsIncompleteType = allowsIncompleteType(original);

        // make sure it is known
        boolean c1 = !(knownByDefault(typeDeclaration));
        boolean c2 = !(c1) && !(allowsIncompleteType);
        boolean auxiliary = knownByDefault(typeDeclaration) && original == typeDeclaration;

        if (!(auxiliary) && (c1 || c2)) {
          builder.addEdge(original, typeDeclaration);
        }

        // decide if we need to recurse
        if (!(SetSequence.fromSet(seen).contains(typeDeclaration)) && (!(allowsIncompleteType) && !(inPointer))) {
          collectDependencies_Type(original, typeDeclaration, builder, seen);
        }
      }

    }
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept EmptyModuleContent$uN = MetaAdapterFactory.getConcept(0x6d11763d483d4b2bL, 0x8efc09336c1b0001L, 0x7bfc48eac80b1723L, "com.mbeddr.core.modules.structure.EmptyModuleContent");
    /*package*/ static final SConcept CommentModuleContent$Hx = MetaAdapterFactory.getConcept(0x6d11763d483d4b2bL, 0x8efc09336c1b0001L, 0xe468e66a9d049b6L, "com.mbeddr.core.modules.structure.CommentModuleContent");
    /*package*/ static final SConcept FunctionPrototype$JD = MetaAdapterFactory.getConcept(0x6d11763d483d4b2bL, 0x8efc09336c1b0001L, 0x595522006a5b97e0L, "com.mbeddr.core.modules.structure.FunctionPrototype");
    /*package*/ static final SInterfaceConcept IModuleContent$H1 = MetaAdapterFactory.getInterfaceConcept(0x6d11763d483d4b2bL, 0x8efc09336c1b0001L, 0x595522006a5b934fL, "com.mbeddr.core.modules.structure.IModuleContent");
    /*package*/ static final SConcept GlobalVarRef$hy = MetaAdapterFactory.getConcept(0x6d11763d483d4b2bL, 0x8efc09336c1b0001L, 0x5bbe8a6d23a20aeaL, "com.mbeddr.core.modules.structure.GlobalVarRef");
    /*package*/ static final SConcept Function$K8 = MetaAdapterFactory.getConcept(0x6d11763d483d4b2bL, 0x8efc09336c1b0001L, 0x595522006a5b97e1L, "com.mbeddr.core.modules.structure.Function");
    /*package*/ static final SConcept FunctionCall$4q = MetaAdapterFactory.getConcept(0x6d11763d483d4b2bL, 0x8efc09336c1b0001L, 0x52941adca601b38cL, "com.mbeddr.core.modules.structure.FunctionCall");
    /*package*/ static final SConcept TypeDef$QP = MetaAdapterFactory.getConcept(0xefda956e491e4f00L, 0xba1436af2f213ecfL, 0x54e261614fd09a11L, "com.mbeddr.core.udt.structure.TypeDef");
    /*package*/ static final SConcept GlobalVariableDeclaration$TW = MetaAdapterFactory.getConcept(0x6d11763d483d4b2bL, 0x8efc09336c1b0001L, 0x5bbe8a6d23a1b6ceL, "com.mbeddr.core.modules.structure.GlobalVariableDeclaration");
    /*package*/ static final SConcept SUDeclaration$1p = MetaAdapterFactory.getConcept(0xefda956e491e4f00L, 0xba1436af2f213ecfL, 0x6285e27d4ff6c9f5L, "com.mbeddr.core.udt.structure.SUDeclaration");
    /*package*/ static final SConcept EnumDeclaration$PP = MetaAdapterFactory.getConcept(0xefda956e491e4f00L, 0xba1436af2f213ecfL, 0x7a4924c71c1b401bL, "com.mbeddr.core.udt.structure.EnumDeclaration");
    /*package*/ static final SConcept TypeWithDeclaration$E2 = MetaAdapterFactory.getConcept(0x6d11763d483d4b2bL, 0x8efc09336c1b0001L, 0x52638d0af733b56eL, "com.mbeddr.core.modules.structure.TypeWithDeclaration");
    /*package*/ static final SConcept PointerType$HX = MetaAdapterFactory.getConcept(0x3bf5377ae9044dedL, 0x97545a516023bfaaL, 0x3e0cae5e366d630L, "com.mbeddr.core.pointers.structure.PointerType");
    /*package*/ static final SConcept Type$dP = MetaAdapterFactory.getConcept(0x61c69711ed614850L, 0x81d97714ff227fb0L, 0x7af69e2e83a1ba36L, "com.mbeddr.core.expressions.structure.Type");
  }

  private static final class LINKS {
    /*package*/ static final SReferenceLink var$wHP5 = MetaAdapterFactory.getReferenceLink(0x6d11763d483d4b2bL, 0x8efc09336c1b0001L, 0x5bbe8a6d23a20aeaL, 0x5bbe8a6d23a20aebL, "var");
    /*package*/ static final SReferenceLink function$oBh5 = MetaAdapterFactory.getReferenceLink(0x6d11763d483d4b2bL, 0x8efc09336c1b0001L, 0x52941adca601b38cL, 0x52941adca601b38dL, "function");
  }
}
