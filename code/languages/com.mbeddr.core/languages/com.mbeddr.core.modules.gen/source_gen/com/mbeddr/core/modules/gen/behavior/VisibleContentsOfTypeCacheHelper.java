package com.mbeddr.core.modules.gen.behavior;

/*Generated by MPS */

import java.util.WeakHashMap;
import org.jetbrains.mps.openapi.model.SNode;
import java.util.Map;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import java.util.ArrayList;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.internal.collections.runtime.Sequence;
import com.mbeddr.core.base.behavior.IVisibleElementProvider__BehaviorDescriptor;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import org.jetbrains.mps.openapi.language.SReferenceLink;
import org.jetbrains.mps.openapi.language.SConcept;

public class VisibleContentsOfTypeCacheHelper {
  private static WeakHashMap<SNode, Map<SNode, List<SNode>>> provider2concept2Content = new WeakHashMap<SNode, Map<SNode, List<SNode>>>();
  private static int max = 0;
  public VisibleContentsOfTypeCacheHelper() {
  }

  public static void reset() {
    provider2concept2Content = new WeakHashMap<SNode, Map<SNode, List<SNode>>>();
  }

  public static List<SNode> visibleConceptsOfTypeInGenModC(SNode provider, final SNode concept) {
    Map<SNode, List<SNode>> concept2Content = MapSequence.fromMap(provider2concept2Content).get(provider);
    if (concept2Content == null) {
      concept2Content = MapSequence.fromMap(new HashMap<SNode, List<SNode>>());
      MapSequence.fromMap(provider2concept2Content).put(provider, concept2Content);
    }
    List<SNode> result = MapSequence.fromMap(concept2Content).get(concept);

    if (result == null) {
      result = new ArrayList<SNode>();

      ListSequence.fromList(result).addSequence(ListSequence.fromList(SLinkOperations.getChildren(provider, LINKS.contents$F2ap)).where((it) -> SNodeOperations.isInstanceOf(it, SNodeOperations.asSConcept(SNodeOperations.asSConcept(concept)))));

      List<SNode> alreadyTraversedModules = new ArrayList<SNode>();

      for (SNode impModule : ListSequence.fromList(SLinkOperations.getChildren(provider, LINKS.refs$cI_h)).where((it) -> SNodeOperations.isInstanceOf(it, CONCEPTS.GenImplModuleImport$Rp)).select((it) -> SLinkOperations.getTarget(SNodeOperations.cast(it, CONCEPTS.GenImplModuleImport$Rp), LINKS.module$ddez))) {
        ListSequence.fromList(result).addSequence(Sequence.fromIterable(GenModuleH__BehaviorDescriptor.exportedContentsOfType_id5aaBiRoycuf.invoke(impModule, concept, alreadyTraversedModules)));
        max++;
        if (max > 10000) {
          throw new RuntimeException("Circle?");
        }
      }

      for (SNode extModule : ListSequence.fromList(SLinkOperations.getChildren(provider, LINKS.refs$cI_h)).where((it) -> SNodeOperations.isInstanceOf(it, CONCEPTS.GenExtModuleImport$qk)).select((it) -> SLinkOperations.getTarget(SNodeOperations.cast(it, CONCEPTS.GenExtModuleImport$qk), LINKS.moduleExt$uG3))) {
        ListSequence.fromList(result).addSequence(Sequence.fromIterable(IVisibleElementProvider__BehaviorDescriptor.visibleContentsOfType_id6clJcrJXo2_.invoke(extModule, concept)));
      }

      ListSequence.fromList(result).addSequence(ListSequence.fromList(SLinkOperations.getChildren(SLinkOperations.getTarget(provider, LINKS.myHeader$wbeB), LINKS.contents$F2O3)).where((it) -> SNodeOperations.isInstanceOf(it, SNodeOperations.asSConcept(SNodeOperations.asSConcept(concept)))));

      for (SNode impModule : ListSequence.fromList(SLinkOperations.getChildren(SLinkOperations.getTarget(provider, LINKS.myHeader$wbeB), LINKS.headerImports$M5SR)).where((it) -> SNodeOperations.isInstanceOf(it, CONCEPTS.GenImplModuleImport$Rp)).select((it) -> SLinkOperations.getTarget(SNodeOperations.cast(it, CONCEPTS.GenImplModuleImport$Rp), LINKS.module$ddez))) {
        ListSequence.fromList(result).addSequence(Sequence.fromIterable(GenModuleH__BehaviorDescriptor.exportedContentsOfType_id5aaBiRoycuf.invoke(impModule, concept, alreadyTraversedModules)));
        max++;
        if (max > 10000) {
          throw new RuntimeException("Circle?");
        }
      }

      MapSequence.fromMap(concept2Content).put(concept, result);
    }

    return result;
  }
  public static List<SNode> visibleConceptsOfTypeInModHNew(SNode provider, SNode concept) {
    // calculate all transitively imported headers
    Set<SNode> importedHeaders = SetSequence.fromSet(new HashSet<SNode>());
    collectImportedHeaders(importedHeaders, provider);
    List<SNode> result = new ArrayList<SNode>();
    for (SNode header : SetSequence.fromSet(importedHeaders)) {
      ListSequence.fromList(result).addSequence(ListSequence.fromList(visibleConceptsOfTypeInModH(header, concept)));
    }
    return result;
  }
  private static void collectImportedHeaders(Set<SNode> importedHeaders, SNode header) {
    if (SetSequence.fromSet(importedHeaders).contains(header)) {
      return;
    }
    SetSequence.fromSet(importedHeaders).addElement(header);
    for (SNode impHeader : Sequence.fromIterable(SNodeOperations.ofConcept(SLinkOperations.getChildren(header, LINKS.headerImports$M5SR), CONCEPTS.GenImplModuleImport$Rp))) {
      collectImportedHeaders(importedHeaders, SLinkOperations.getTarget(impHeader, LINKS.module$ddez));
    }
  }
  private static List<SNode> visibleConceptsOfTypeInModH(SNode provider, final SNode concept) {
    Map<SNode, List<SNode>> concept2Content = MapSequence.fromMap(provider2concept2Content).get(provider);
    if (concept2Content == null) {
      concept2Content = MapSequence.fromMap(new HashMap<SNode, List<SNode>>());
      MapSequence.fromMap(provider2concept2Content).put(provider, concept2Content);
    }
    List<SNode> result = MapSequence.fromMap(concept2Content).get(concept);
    if (result == null) {
      result = new ArrayList<SNode>();


      ListSequence.fromList(result).addSequence(ListSequence.fromList(SLinkOperations.getChildren(provider, LINKS.contents$F2O3)).where((it) -> SNodeOperations.isInstanceOf(it, SNodeOperations.asSConcept(SNodeOperations.asSConcept(concept)))));

      List<SNode> alreadyTraversedModules = new ArrayList<SNode>();
      for (SNode i : ListSequence.fromList(SLinkOperations.getChildren(provider, LINKS.headerImports$M5SR)).where((it) -> SNodeOperations.isInstanceOf(it, CONCEPTS.GenImplModuleImport$Rp)).select((it) -> SNodeOperations.cast(it, CONCEPTS.GenImplModuleImport$Rp))) {
        ListSequence.fromList(result).addSequence(Sequence.fromIterable(GenModuleH__BehaviorDescriptor.exportedContentsOfType_id5aaBiRoycuf.invoke(SLinkOperations.getTarget(i, LINKS.module$ddez), concept, alreadyTraversedModules)));
      }

      for (SNode extModule : ListSequence.fromList(SLinkOperations.getChildren(provider, LINKS.headerImports$M5SR)).where((it) -> SNodeOperations.isInstanceOf(it, CONCEPTS.GenExtModuleImport$qk)).select((it) -> SLinkOperations.getTarget(SNodeOperations.cast(it, CONCEPTS.GenExtModuleImport$qk), LINKS.moduleExt$uG3))) {
        ListSequence.fromList(result).addSequence(Sequence.fromIterable(IVisibleElementProvider__BehaviorDescriptor.visibleContentsOfType_id6clJcrJXo2_.invoke(extModule, concept)));
      }


      MapSequence.fromMap(concept2Content).put(concept, result);
    }

    return result;
  }
  public static List<SNode> visibleConceptsOfTypeInGenExt(SNode provider, final SNode concept) {
    Map<SNode, List<SNode>> concept2Content = MapSequence.fromMap(provider2concept2Content).get(provider);
    if (concept2Content == null) {
      concept2Content = MapSequence.fromMap(new HashMap<SNode, List<SNode>>());
      MapSequence.fromMap(provider2concept2Content).put(provider, concept2Content);
    }
    List<SNode> result = MapSequence.fromMap(concept2Content).get(concept);
    if (result == null) {
      result = new ArrayList<SNode>();

      ListSequence.fromList(result).addSequence(ListSequence.fromList(SLinkOperations.getChildren(provider, LINKS.contents$5Qf$)).where((it) -> SNodeOperations.isInstanceOf(it, SNodeOperations.asSConcept(SNodeOperations.asSConcept(concept)))));


      MapSequence.fromMap(concept2Content).put(concept, result);
    }

    return result;
  }

  private static final class LINKS {
    /*package*/ static final SContainmentLink contents$F2ap = MetaAdapterFactory.getContainmentLink(0x62296a07bc3846d2L, 0x8034198c24063588L, 0x1865bdb749ca065bL, 0x1865bdb749ca065dL, "contents");
    /*package*/ static final SContainmentLink refs$cI_h = MetaAdapterFactory.getContainmentLink(0x62296a07bc3846d2L, 0x8034198c24063588L, 0x1865bdb749ca065bL, 0x124a1a47a699b532L, "refs");
    /*package*/ static final SReferenceLink module$ddez = MetaAdapterFactory.getReferenceLink(0x62296a07bc3846d2L, 0x8034198c24063588L, 0x124a1a47a699cb26L, 0x124a1a47a699cb27L, "module");
    /*package*/ static final SReferenceLink moduleExt$uG3 = MetaAdapterFactory.getReferenceLink(0x62296a07bc3846d2L, 0x8034198c24063588L, 0x7dd23a0da554ace5L, 0x7dd23a0da554ace6L, "moduleExt");
    /*package*/ static final SReferenceLink myHeader$wbeB = MetaAdapterFactory.getReferenceLink(0x62296a07bc3846d2L, 0x8034198c24063588L, 0x1865bdb749ca065bL, 0x162e987a8c9dc171L, "myHeader");
    /*package*/ static final SContainmentLink contents$F2O3 = MetaAdapterFactory.getContainmentLink(0x62296a07bc3846d2L, 0x8034198c24063588L, 0x1865bdb749ca065eL, 0x1865bdb749ca065fL, "contents");
    /*package*/ static final SContainmentLink headerImports$M5SR = MetaAdapterFactory.getContainmentLink(0x62296a07bc3846d2L, 0x8034198c24063588L, 0x1865bdb749ca065eL, 0x4d4a3140e3d18b26L, "headerImports");
    /*package*/ static final SContainmentLink contents$5Qf$ = MetaAdapterFactory.getContainmentLink(0x62296a07bc3846d2L, 0x8034198c24063588L, 0x7dd23a0da5533172L, 0x7dd23a0da5533174L, "contents");
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept GenImplModuleImport$Rp = MetaAdapterFactory.getConcept(0x62296a07bc3846d2L, 0x8034198c24063588L, 0x124a1a47a699cb26L, "com.mbeddr.core.modules.gen.structure.GenImplModuleImport");
    /*package*/ static final SConcept GenExtModuleImport$qk = MetaAdapterFactory.getConcept(0x62296a07bc3846d2L, 0x8034198c24063588L, 0x7dd23a0da554ace5L, "com.mbeddr.core.modules.gen.structure.GenExtModuleImport");
  }
}
