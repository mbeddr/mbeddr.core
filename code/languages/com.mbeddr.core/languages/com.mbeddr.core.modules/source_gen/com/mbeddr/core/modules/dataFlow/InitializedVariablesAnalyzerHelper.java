package com.mbeddr.core.modules.dataFlow;

/*Generated by MPS */

import java.util.Set;
import java.util.HashSet;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import jetbrains.mps.lang.dataFlow.framework.Program;
import jetbrains.mps.lang.dataFlow.framework.AnalysisResult;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.analyzers.runtime.framework.CustomAnalyzerRunner;
import java.util.Map;
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple;
import jetbrains.mps.lang.dataFlow.framework.instructions.Instruction;
import java.util.Queue;
import java.util.LinkedList;
import jetbrains.mps.internal.collections.runtime.QueueSequence;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SEnumOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import org.jetbrains.mps.openapi.language.SConcept;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import org.jetbrains.mps.openapi.language.SProperty;

public final class InitializedVariablesAnalyzerHelper {

  private static Set<VariableWrapper> EMPTY_SET = new HashSet<VariableWrapper>();

  public static Tuples._2<Program, AnalysisResult<Set<VariableWrapper>>> analyze(SNode node) {
    CustomAnalyzerRunner<Map<VariableWrapper, Set<VariableWrapper>>> pointerAnalyzer = new PointsToAnalyzerRunner(node);
    AnalysisResult pointerAnalyzerResult = pointerAnalyzer.analyze();
    SymbolicInstructionMapping.store(pointerAnalyzer.getProgram());

    // Uninitialized read analysis
    CustomAnalyzerRunner<Set<VariableWrapper>> initializedReadAnalyzer = new InitializedVariablesAnalyzerRunner(node, pointerAnalyzerResult);
    SymbolicInstructionMapping.store(initializedReadAnalyzer.getProgram());
    AnalysisResult<Set<VariableWrapper>> initializedReadAnalyzerResult = initializedReadAnalyzer.analyze();

    return MultiTuple.<Program,AnalysisResult<Set<VariableWrapper>>>from(initializedReadAnalyzer.getProgram(), initializedReadAnalyzerResult);
  }

  public static Set<VariableWrapper> targets(VariableWrapper targetVariable, Instruction instruction, AnalysisResult<Map<VariableWrapper, Set<VariableWrapper>>> pointerAnalysisResult, int distance) {

    if (targetVariable == null || instruction == null || pointerAnalysisResult == null || distance <= 0) {
      return EMPTY_SET;
    } else {
      Set<VariableWrapper> result = new HashSet<VariableWrapper>();

      SymbolicInstructionMapping pointerMapping = SymbolicInstructionMapping.get(AnalyzerHelper.getProgram(pointerAnalysisResult));
      SymbolicInstructionMapping initializedMapping = SymbolicInstructionMapping.get(AnalyzerHelper.getProgram(instruction));

      if (pointerMapping != null && initializedMapping != null) {
        // perform double indirection between the two symbolic mappings
        int mappedIndex = initializedMapping.getIndex(instruction);
        Instruction mappedInstruction = pointerMapping.getInstruction(mappedIndex);

        Map<VariableWrapper, Set<VariableWrapper>> pointerMap = pointerAnalysisResult.get(mappedInstruction);

        Queue<VariableWrapper> queue = new LinkedList<VariableWrapper>();
        int currentDistance = 1;
        queue.add(targetVariable);

        while (currentDistance <= distance && !(queue.isEmpty())) {
          int take = queue.size();
          currentDistance++;

          // TODO possibility of a cycle?
          for (int i = 0; i < take; i++) {
            VariableWrapper head = queue.poll();

            Set<VariableWrapper> pointees = pointerMap.get(head);
            if (pointees != null) {
              queue.addAll(pointees);
            }
          }
        }

        // the variables that remain
        for (VariableWrapper variable : QueueSequence.fromQueue(queue)) {
          result.add(variable);
        }
      }

      return result;
    }
  }

  /**
   * By default all uninitialized reads will be marked as erroneous. 
   */
  public static Map<SAbstractConcept, MarkerType> markerSpecifications = MapSequence.fromMap(new HashMap<SAbstractConcept, MarkerType>());

  public static Set<VariableWrapper> getInitialVariableSet(Program program) {
    Set<VariableWrapper> result = new HashSet<VariableWrapper>();
    for (Object var : program.getVariables()) {
      if (var != null) {
        result.add(new VariableWrapper((SNode) var));
      }
    }

    // OUT arguments are not initiallized
    SNode firstInstruction = (SNode) program.getStart().getSource();
    {
      final SNode fun = SNodeOperations.getParent(firstInstruction);
      if (SNodeOperations.isInstanceOf(fun, CONCEPTS.Function$K8)) {
        for (SNode arg : ListSequence.fromList(SLinkOperations.getChildren(fun, LINKS.arguments$6da0))) {
          if (SEnumOperations.isMember(SPropertyOperations.getEnum(SLinkOperations.getTarget(arg, LINKS.kind$ebZT), PROPS.value$1$x_), 0x3968d4c5c324d92cL)) {
            result.add(new VariableWrapper(arg));
          }
        }
      }
    }

    return result;
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept Function$K8 = MetaAdapterFactory.getConcept(0x6d11763d483d4b2bL, 0x8efc09336c1b0001L, 0x595522006a5b97e1L, "com.mbeddr.core.modules.structure.Function");
  }

  private static final class LINKS {
    /*package*/ static final SContainmentLink kind$ebZT = MetaAdapterFactory.getContainmentLink(0x6d11763d483d4b2bL, 0x8efc09336c1b0001L, 0x75302b1261129ff9L, 0xc42f172f6d02776L, "kind");
    /*package*/ static final SContainmentLink arguments$6da0 = MetaAdapterFactory.getContainmentLink(0x6d11763d483d4b2bL, 0x8efc09336c1b0001L, 0x707ac195dd5d51f2L, 0x4f39f90935e92f45L, "arguments");
  }

  private static final class PROPS {
    /*package*/ static final SProperty value$1$x_ = MetaAdapterFactory.getProperty(0x6d11763d483d4b2bL, 0x8efc09336c1b0001L, 0xc42f172f6d01a6eL, 0xc42f172f6d01b82L, "value");
  }
}
