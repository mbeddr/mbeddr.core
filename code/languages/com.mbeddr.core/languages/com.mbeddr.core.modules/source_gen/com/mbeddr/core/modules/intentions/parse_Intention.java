package com.mbeddr.core.modules.intentions;

/*Generated by MPS */

import jetbrains.mps.intentions.AbstractIntentionDescriptor;
import jetbrains.mps.openapi.intentions.IntentionFactory;
import java.util.Collection;
import jetbrains.mps.openapi.intentions.IntentionExecutable;
import jetbrains.mps.openapi.intentions.Kind;
import jetbrains.mps.smodel.SNodePointer;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.openapi.editor.EditorContext;
import java.util.Collections;
import jetbrains.mps.intentions.AbstractIntentionExecutable;
import java.util.List;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import java.util.Random;
import com.mbeddr.mpsutil.grammarcells.runtime.Parser;
import com.mbeddr.core.expressions.behavior.Expression__BehaviorDescriptor;
import jetbrains.mps.openapi.intentions.IntentionDescriptor;
import jetbrains.mps.smodel.builder.SNodeBuilder;
import org.jetbrains.mps.openapi.language.SConcept;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import org.jetbrains.mps.openapi.language.SProperty;

public final class parse_Intention extends AbstractIntentionDescriptor implements IntentionFactory {
  private Collection<IntentionExecutable> myCachedExecutable;

  public parse_Intention() {
    super(Kind.NORMAL, false, new SNodePointer("r:6d9d2c39-3488-4adb-9856-546fafd40fa4(com.mbeddr.core.modules.intentions)", "1678656060861969500"));
  }

  @Override
  public String getPresentation() {
    return "parse";
  }

  @Override
  public boolean isSurroundWith() {
    return false;
  }

  public Collection<IntentionExecutable> instances(final SNode node, final EditorContext context) {
    if (myCachedExecutable == null) {
      myCachedExecutable = Collections.<IntentionExecutable>singletonList(new IntentionImplementation());
    }
    return myCachedExecutable;
  }
  /*package*/ final class IntentionImplementation extends AbstractIntentionExecutable {
    public IntentionImplementation() {
    }

    @Override
    public String getDescription(final SNode node, final EditorContext editorContext) {
      return "Parse";
    }

    @Override
    public void execute(final SNode node, final EditorContext editorContext) {
      List<SAbstractConcept> concepts = ListSequence.fromList(new ArrayList<SAbstractConcept>());
      ListSequence.fromList(concepts).addElement(CONCEPTS.PlusExpression$If);
      ListSequence.fromList(concepts).addElement(CONCEPTS.MultiExpression$VN);
      ListSequence.fromList(concepts).addElement(CONCEPTS.DivExpression$WL);
      ListSequence.fromList(concepts).addElement(CONCEPTS.MinusExpression$KE);

      int MAXSIZE = 50;
      int CYCLES = 5;
      int cp = 0;
      while (ListSequence.fromList(SNodeOperations.getNodeDescendants(SLinkOperations.getTarget(node, LINKS.init$$i$n), CONCEPTS.Expression$bT, false, new SAbstractConcept[]{})).count() < MAXSIZE) {
        SNode op = ((SNode) SConceptOperations.createNewNode(SNodeOperations.asInstanceConcept(ListSequence.fromList(concepts).getElement(cp))));
        SLinkOperations.setTarget(op, LINKS.left$SkXz, SNodeOperations.copyNode(SLinkOperations.getTarget(node, LINKS.init$$i$n)));
        SLinkOperations.setTarget(op, LINKS.right$Slc$, createNumberLiteral_vonrt_a0c0j0a((new Random(System.currentTimeMillis()).nextInt(100) + 2) + ""));
        SNodeOperations.replaceWithAnother(SLinkOperations.getTarget(node, LINKS.init$$i$n), op);

        long t1 = System.currentTimeMillis();
        for (int i = 0; i < CYCLES; i++) {
          Parser p = new Parser(editorContext.getModel());
          p.parse(SLinkOperations.getTarget(node, LINKS.init$$i$n), 1000000);
        }
        long t2 = System.currentTimeMillis();
        System.err.print("Parsing§");
        System.err.print(Expression__BehaviorDescriptor.renderReadable_id1VQvajLb13M.invoke(SLinkOperations.getTarget(node, LINKS.init$$i$n)) + "§");
        System.err.print("size§" + ListSequence.fromList(SNodeOperations.getNodeDescendants(node, CONCEPTS.Expression$bT, false, new SAbstractConcept[]{})).count() + "§");
        System.err.print("took§" + ((t2 - t1) / CYCLES));
        System.err.println();

        cp++;
        if (cp >= ListSequence.fromList(concepts).count()) {
          cp = 0;
        }
      }





    }

    @Override
    public boolean isApplicable(final SNode node, final EditorContext editorContext) {
      if (!(isApplicableToNode(node, editorContext))) {
        return false;
      }
      return true;
    }

    private boolean isApplicableToNode(final SNode node, final EditorContext editorContext) {
      return !(SNodeOperations.isInstanceOf(SNodeOperations.getParent(node), CONCEPTS.Expression$bT));
    }


    @Override
    public IntentionDescriptor getDescriptor() {
      return parse_Intention.this;
    }

  }
  private static SNode createNumberLiteral_vonrt_a0c0j0a(String p0) {
    SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.NumberLiteral$jK);
    n0.setProperty(PROPS.value$qZmE, p0);
    return n0.getResult();
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept PlusExpression$If = MetaAdapterFactory.getConcept(0x61c69711ed614850L, 0x81d97714ff227fb0L, 0x4ffba68fe82b6215L, "com.mbeddr.core.expressions.structure.PlusExpression");
    /*package*/ static final SConcept MultiExpression$VN = MetaAdapterFactory.getConcept(0x61c69711ed614850L, 0x81d97714ff227fb0L, 0x4ffba68fe82b621cL, "com.mbeddr.core.expressions.structure.MultiExpression");
    /*package*/ static final SConcept DivExpression$WL = MetaAdapterFactory.getConcept(0x61c69711ed614850L, 0x81d97714ff227fb0L, 0x4ffba68fe82b621eL, "com.mbeddr.core.expressions.structure.DivExpression");
    /*package*/ static final SConcept MinusExpression$KE = MetaAdapterFactory.getConcept(0x61c69711ed614850L, 0x81d97714ff227fb0L, 0x4ffba68fe82b621aL, "com.mbeddr.core.expressions.structure.MinusExpression");
    /*package*/ static final SConcept Expression$bT = MetaAdapterFactory.getConcept(0x61c69711ed614850L, 0x81d97714ff227fb0L, 0x7af69e2e83a1ba32L, "com.mbeddr.core.expressions.structure.Expression");
    /*package*/ static final SConcept NumberLiteral$jK = MetaAdapterFactory.getConcept(0x61c69711ed614850L, 0x81d97714ff227fb0L, 0x7af69e2e83a1ba67L, "com.mbeddr.core.expressions.structure.NumberLiteral");
  }

  private static final class LINKS {
    /*package*/ static final SContainmentLink left$SkXz = MetaAdapterFactory.getContainmentLink(0x61c69711ed614850L, 0x81d97714ff227fb0L, 0x7af69e2e83a1ba34L, 0x7af69e2e83a1ba40L, "left");
    /*package*/ static final SContainmentLink init$$i$n = MetaAdapterFactory.getContainmentLink(0xa9d696470840491eL, 0xbf392eb0805d2011L, 0x3a16e3a9c7ad96e6L, 0x3a16e3a9c7ae01f7L, "init");
    /*package*/ static final SContainmentLink right$Slc$ = MetaAdapterFactory.getContainmentLink(0x61c69711ed614850L, 0x81d97714ff227fb0L, 0x7af69e2e83a1ba34L, 0x7af69e2e83a1ba41L, "right");
  }

  private static final class PROPS {
    /*package*/ static final SProperty value$qZmE = MetaAdapterFactory.getProperty(0x61c69711ed614850L, 0x81d97714ff227fb0L, 0x1eb611a68febd3e5L, 0x1eb611a68fec38b0L, "value");
  }
}
