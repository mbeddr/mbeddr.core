package com.mbeddr.core.modules.dataFlow;

/*Generated by MPS */

import java.util.Map;
import jetbrains.mps.lang.dataFlow.framework.instructions.Instruction;
import jetbrains.mps.lang.dataFlow.framework.Program;
import java.util.Collections;
import java.util.WeakHashMap;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.analyzers.runtime.framework.GeneratedInstruction;
import java.util.HashMap;

/**
 * An instruction mapping provides an efficient index for the following two things:
 * - trace back an instruction from the instruction index in the CFG
 * - trace back the index of an instruction in the CFG
 * 
 * The index is computed sequentially from the beginning, NOT taking into accout any GeneratedInstructions.
 */
public class SymbolicInstructionMapping {

  private Map<Instruction, Integer> instructionMap;
  private Map<Integer, Instruction> reversedInstructionMap;

  private static Map<Program, SymbolicInstructionMapping> programs = Collections.synchronizedMap(new WeakHashMap<Program, SymbolicInstructionMapping>());

  public static SymbolicInstructionMapping get(Program program) {
    return programs.get(program);
  }

  public static SymbolicInstructionMapping store(Program program) {
    SymbolicInstructionMapping cache = new SymbolicInstructionMapping();

    int index = 1;
    for (Instruction instruction : ListSequence.fromList(program.getInstructions())) {
      if (!(instruction instanceof GeneratedInstruction)) {
        cache.instructionMap.put(instruction, index);
        cache.reversedInstructionMap.put(index, instruction);
        index++;
      }
    }

    programs.put(program, cache);

    return cache;
  }

  private SymbolicInstructionMapping() {
    this.instructionMap = new HashMap<Instruction, Integer>();
    this.reversedInstructionMap = new HashMap<Integer, Instruction>();
  }

  public int getIndex(Instruction instruction) {
    if (instruction instanceof GeneratedInstruction) {
      return -1;
    } else {
      return instructionMap.get(instruction);
    }
  }

  public Instruction getInstruction(int index) {
    if (index > reversedInstructionMap.size()) {
      return null;
    } else {
      return reversedInstructionMap.get(index);
    }
  }

}
