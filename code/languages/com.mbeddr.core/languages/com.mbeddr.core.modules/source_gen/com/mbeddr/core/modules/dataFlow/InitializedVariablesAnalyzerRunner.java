package com.mbeddr.core.modules.dataFlow;

/*Generated by MPS */

import jetbrains.mps.analyzers.runtime.framework.CustomAnalyzerRunner;
import java.util.Set;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.lang.dataFlow.framework.AnalysisResult;
import java.util.Map;
import jetbrains.mps.lang.dataFlow.MPSProgramFactory;
import java.util.Collections;
import jetbrains.mps.lang.dataFlow.framework.IDataFlowModeId;
import jetbrains.mps.lang.dataFlow.framework.ProgramFactory;
import jetbrains.mps.lang.dataFlow.framework.NamedAnalyzerId;
import jetbrains.mps.lang.dataFlow.framework.DataFlowAnalyzerBase;
import jetbrains.mps.lang.dataFlow.framework.Program;
import java.util.List;
import java.util.Iterator;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.dataFlow.framework.ProgramState;
import org.jetbrains.annotations.Nullable;
import jetbrains.mps.lang.dataFlow.framework.instructions.Instruction;
import jetbrains.mps.lang.dataFlow.framework.instructions.WriteInstruction;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.IAttributeDescriptor;
import com.mbeddr.core.expressions.behavior.IAssignmentLike__BehaviorDescriptor;
import jetbrains.mps.analyzers.runtime.framework.GeneratedInstruction;
import com.mbeddr.mpsutil.dataflow.runtime.plugin.InterProcUnmapInstruction;
import jetbrains.mps.lang.dataFlow.framework.AnalysisDirection;
import org.jetbrains.mps.openapi.language.SInterfaceConcept;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import org.jetbrains.mps.openapi.language.SConcept;

public class InitializedVariablesAnalyzerRunner extends CustomAnalyzerRunner<Set<VariableWrapper>> {
  private SNode myNode;
  public InitializedVariablesAnalyzerRunner(SNode node, AnalysisResult<Map<VariableWrapper, Set<VariableWrapper>>> pointerAnalysisResult) {
    this(node, new MPSProgramFactory(Collections.<IDataFlowModeId>emptyList()), pointerAnalysisResult);
  }
  public InitializedVariablesAnalyzerRunner(SNode node, ProgramFactory<NamedAnalyzerId> factory, AnalysisResult<Map<VariableWrapper, Set<VariableWrapper>>> pointerAnalysisResult) {
    super(null, null);
    myNode = node;
    myAnalyzer = new InitializedVariablesAnalyzer(pointerAnalysisResult);
    myProgram = factory.createProgram(myNode);
    factory.prepareProgram(myProgram, myNode, new NamedAnalyzerId("com.mbeddr.core.modules.dataFlow.InitializedVariables"));
  }

  public static class InitializedVariablesAnalyzer extends DataFlowAnalyzerBase<Set<VariableWrapper>> {
    private AnalysisResult<Map<VariableWrapper, Set<VariableWrapper>>> pointerAnalysisResult;
    public InitializedVariablesAnalyzer(AnalysisResult<Map<VariableWrapper, Set<VariableWrapper>>> pointerAnalysisResult) {
      this.pointerAnalysisResult = pointerAnalysisResult;
    }
    public Set<VariableWrapper> initial(Program program) {
      // returns all program variables as initialization
      // the must analysis will perform the restrictions along the computation
      return InitializedVariablesAnalyzerHelper.getInitialVariableSet(program);
    }
    public Set<VariableWrapper> merge(Program program, List<Set<VariableWrapper>> input) {
      // use intersection so that only those variables are treated as initialized which
      // are definitely initialized on all program paths which lead to a DFG node
      Set<VariableWrapper> result = InitializedVariablesAnalyzerHelper.getInitialVariableSet(program);

      Iterator<Set<VariableWrapper>> iterator = ListSequence.fromList(input).iterator();
      while (iterator.hasNext()) {
        result.retainAll(iterator.next());
      }

      return result;
    }
    public Set<VariableWrapper> fun(Set<VariableWrapper> input, ProgramState state, @Nullable Map<ProgramState, Set<VariableWrapper>> stateValues) {
      // handle write & defInit by adding the writte-to variable to
      // the set of initialized ones
      // in case of an unmap instruction, simply remove the unmapped variable from
      // the set of initialized ones
      Instruction instruction = state.getInstruction();
      SNode source = (SNode) instruction.getSource();

      if (instruction.isStart()) {
        input.clear();
      }

      SNode sourceExpression = AnalyzerHelper.extractStatement(source);

      if (instruction instanceof WriteInstruction && ((WriteInstruction) instruction).getVariable() != null) {
        SNode var = (SNode) ((WriteInstruction) instruction).getVariable();
        VariableWrapper targetVariable = new VariableWrapper(AnalyzerHelper.resolve(var));

        boolean omit = false;
        if (SNodeOperations.isInstanceOf(sourceExpression, CONCEPTS.IAssignmentLike$34) && AnalyzerHelper.isDereferenced(var, AnalyzerHelper.extractLeftSide(sourceExpression))) {
          omit = true;
        }

        if (!(omit)) {
          input.add(targetVariable);
        }

        if (SNodeOperations.isInstanceOf(sourceExpression, CONCEPTS.IAssignmentLike$34) && new IAttributeDescriptor.NodeAttribute(CONCEPTS.VirtualAttribute$US).get(sourceExpression) == null) {
          SNode left = IAssignmentLike__BehaviorDescriptor.getLValue_id7QxE2Vg8Hif.invoke(SNodeOperations.cast(sourceExpression, CONCEPTS.IAssignmentLike$34));
          input.addAll(InitializedVariablesAnalyzerHelper.targets(targetVariable, instruction, this.pointerAnalysisResult, targetVariable.indirection - AnalyzerHelper.computeIndirection(left)));
        }
      } else if (instruction instanceof GeneratedInstruction) {

        GeneratedInstruction genInstruction = ((GeneratedInstruction) instruction);
        VariableWrapper targetVariable = new VariableWrapper((SNode) (genInstruction.getParameter(0)));

        if (genInstruction.commandPresentation().startsWith("defInit")) {
          input.add(targetVariable);
        } else if (genInstruction.commandPresentation().startsWith("outInit")) {
          Boolean dereferenced = (Boolean) genInstruction.getParameter(1);

          if (targetVariable.indirection == 0 || dereferenced) {
            // this happens when a reference expression is used as an actual function argument
            input.add(targetVariable);
          }

          if (targetVariable.indirection > 0) {
            // this happens when a pointer typed variable reference is passed as an actual function argument
            input.addAll(InitializedVariablesAnalyzerHelper.targets(targetVariable, AnalyzerHelper.getNonGeneratedPredecessor(genInstruction), this.pointerAnalysisResult, 1));
          }
        }
      } else if (instruction instanceof InterProcUnmapInstruction) {
        SNode _variable = (SNode) ((InterProcUnmapInstruction) instruction).getVariable();
        VariableWrapper variable = new VariableWrapper(_variable);
        input.remove(variable);
      }

      return input;
    }
    public AnalysisDirection getDirection() {
      return AnalysisDirection.FORWARD;
    }
  }

  private static final class CONCEPTS {
    /*package*/ static final SInterfaceConcept IAssignmentLike$34 = MetaAdapterFactory.getInterfaceConcept(0x61c69711ed614850L, 0x81d97714ff227fb0L, 0x4945cc205934d00L, "com.mbeddr.core.expressions.structure.IAssignmentLike");
    /*package*/ static final SConcept VirtualAttribute$US = MetaAdapterFactory.getConcept(0x57416e5beba54910L, 0xade842ad18cb5f4dL, 0x378878b8f06d09faL, "com.mbeddr.mpsutil.dataflow.structure.VirtualAttribute");
  }
}
