package com.mbeddr.core.modules.dataFlow;

/*Generated by MPS */

import jetbrains.mps.analyzers.runtime.framework.CustomAnalyzerRunner;
import java.util.Map;
import java.util.Set;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.lang.dataFlow.MPSProgramFactory;
import java.util.Collections;
import jetbrains.mps.lang.dataFlow.framework.IDataFlowModeId;
import jetbrains.mps.lang.dataFlow.framework.ProgramFactory;
import jetbrains.mps.lang.dataFlow.framework.NamedAnalyzerId;
import jetbrains.mps.lang.dataFlow.framework.DataFlowAnalyzerBase;
import jetbrains.mps.lang.dataFlow.framework.Program;
import java.util.List;
import java.util.HashMap;
import java.util.Iterator;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.dataFlow.framework.ProgramState;
import org.jetbrains.annotations.Nullable;
import jetbrains.mps.lang.dataFlow.framework.instructions.Instruction;
import jetbrains.mps.lang.dataFlow.framework.instructions.WriteInstruction;
import com.mbeddr.mpsutil.dataflow.runtime.plugin.InterProceduralDataFlowGraph;
import com.mbeddr.mpsutil.dataflow.runtime.plugin.IInterProcAwareInstruction;
import java.util.HashSet;
import com.mbeddr.mpsutil.dataflow.runtime.plugin.InterProcRetInstruction;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import com.mbeddr.mpsutil.dataflow.runtime.plugin.InterProcUnmapInstruction;
import jetbrains.mps.lang.dataFlow.framework.AnalysisDirection;
import org.jetbrains.mps.openapi.language.SConcept;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import org.jetbrains.mps.openapi.language.SContainmentLink;

public class PointsToAnalyzerRunner extends CustomAnalyzerRunner<Map<VariableWrapper, Set<VariableWrapper>>> {
  private SNode myNode;
  public PointsToAnalyzerRunner(SNode node) {
    this(node, new MPSProgramFactory(Collections.<IDataFlowModeId>emptyList()));
  }
  public PointsToAnalyzerRunner(SNode node, ProgramFactory<NamedAnalyzerId> factory) {
    super(null, null);
    myNode = node;
    myAnalyzer = new PointsToAnalyzer();
    myProgram = factory.createProgram(myNode);
    factory.prepareProgram(myProgram, myNode, new NamedAnalyzerId("com.mbeddr.core.modules.dataFlow.PointsTo"));
  }

  public static class PointsToAnalyzer extends DataFlowAnalyzerBase<Map<VariableWrapper, Set<VariableWrapper>>> {
    public PointsToAnalyzer() {
    }
    public Map<VariableWrapper, Set<VariableWrapper>> initial(Program program) {
      return Collections.emptyMap();
    }
    public Map<VariableWrapper, Set<VariableWrapper>> merge(Program program, List<Map<VariableWrapper, Set<VariableWrapper>>> input) {
      Map<VariableWrapper, Set<VariableWrapper>> result = new HashMap<VariableWrapper, Set<VariableWrapper>>();

      Iterator<Map<VariableWrapper, Set<VariableWrapper>>> iterator = ListSequence.fromList(input).iterator();
      while (iterator.hasNext()) {
        result = AnalyzerHelper.union(result, iterator.next());
      }

      return result;
    }
    public Map<VariableWrapper, Set<VariableWrapper>> fun(Map<VariableWrapper, Set<VariableWrapper>> input, ProgramState state, @Nullable Map<ProgramState, Map<VariableWrapper, Set<VariableWrapper>>> stateValues) {
      Instruction instruction = state.getInstruction();

      if (instruction instanceof WriteInstruction) {
        // the variable which is written
        SNode sourceExpression = (SNode) ((WriteInstruction) instruction).getSource();

        SNode xE = AnalyzerHelper.extractLeftSide(sourceExpression);
        SNode yE = AnalyzerHelper.extractRightSide(sourceExpression);

        Set<VariableWrapper> pointers = PointerAnalyzerHelper.evaluateLeftSide(xE, input);
        Set<VariableWrapper> pointees = null;

        // check if the current instruction represents something that has a trace
        // in that case look up the predecessor return statements together with
        // the state values that were valid at that point
        if (instruction.getProgram() instanceof InterProceduralDataFlowGraph) {
          InterProceduralDataFlowGraph graph = (InterProceduralDataFlowGraph) instruction.getProgram();
          InterProceduralDataFlowGraph trace = graph.getTrace(yE, ((IInterProcAwareInstruction) instruction).getOwnProgram().getProgramPath());
          if (trace != null) {
            pointees = new HashSet<VariableWrapper>();

            for (Instruction _instruction : ListSequence.fromList(trace.getInstructions())) {
              if (_instruction instanceof InterProcRetInstruction) {
                ProgramState predecessor = new ProgramState(_instruction, state.isReturnMode());
                Map<VariableWrapper, Set<VariableWrapper>> previousMapping = stateValues.get(predecessor);
                assert as_y3i2nu_a0a2a0a2a2a21a2a3e(((InterProcRetInstruction) _instruction).getSource(), SNode.class).isInstanceOfConcept(CONCEPTS.ReturnStatement$Kx);
                SNode returnExpression = (SNode) ((InterProcRetInstruction) _instruction).getSource();
                pointees.addAll(PointerAnalyzerHelper.evaluateRightSide(SLinkOperations.getTarget(returnExpression, LINKS.expression$ayfU), previousMapping));
              }
            }
          }
        }

        // if pointees is still null at this point then no trace was available
        // simple resort to looking up pointees with the current state values
        if (pointees == null) {
          pointees = PointerAnalyzerHelper.evaluateRightSide(yE, input);
        }

        for (VariableWrapper pointer : SetSequence.fromSet(pointers)) {
          input.put(pointer, pointees);
        }
      } else if (instruction instanceof InterProcUnmapInstruction) {
        SNode _variable = (SNode) ((InterProcUnmapInstruction) instruction).getVariable();
        VariableWrapper variable = new VariableWrapper(_variable);
        input.remove(variable);
      }

      return input;
    }
    public AnalysisDirection getDirection() {
      return AnalysisDirection.FORWARD;
    }
    private static <T> T as_y3i2nu_a0a2a0a2a2a21a2a3e(Object o, Class<T> type) {
      return (type.isInstance(o) ? (T) o : null);
    }
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept ReturnStatement$Kx = MetaAdapterFactory.getConcept(0x6d11763d483d4b2bL, 0x8efc09336c1b0001L, 0x7c747300dbd94ea5L, "com.mbeddr.core.modules.structure.ReturnStatement");
  }

  private static final class LINKS {
    /*package*/ static final SContainmentLink expression$ayfU = MetaAdapterFactory.getContainmentLink(0x6d11763d483d4b2bL, 0x8efc09336c1b0001L, 0x7c747300dbd94ea5L, 0x7c747300dbd94ea6L, "expression");
  }
}
