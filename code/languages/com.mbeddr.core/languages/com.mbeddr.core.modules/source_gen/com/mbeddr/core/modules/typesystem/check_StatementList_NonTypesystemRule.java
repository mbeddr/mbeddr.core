package com.mbeddr.core.modules.typesystem;

/*Generated by MPS */

import jetbrains.mps.lang.typesystem.runtime.AbstractNonTypesystemRule_Runtime;
import jetbrains.mps.lang.typesystem.runtime.NonTypesystemRule_Runtime;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.typesystem.inference.TypeCheckingContext;
import jetbrains.mps.lang.typesystem.runtime.IsApplicableStatus;
import com.mbeddr.mpsutil.suppresswarning.behavior.SuppressWarnings__BehaviorDescriptor;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import java.util.Map;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import com.mbeddr.core.modules.dataFlow.VariableWrapper;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SEnumOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import jetbrains.mps.lang.dataFlow.framework.Program;
import jetbrains.mps.lang.dataFlow.framework.AnalysisResult;
import java.util.Set;
import com.mbeddr.core.modules.dataFlow.InitializedVariablesAnalyzerHelper;
import jetbrains.mps.lang.dataFlow.framework.instructions.Instruction;
import jetbrains.mps.lang.dataFlow.framework.instructions.ReadInstruction;
import jetbrains.mps.lang.core.behavior.BaseConcept__BehaviorDescriptor;
import com.mbeddr.core.modules.dataFlow.MarkerType;
import jetbrains.mps.errors.messageTargets.MessageTarget;
import jetbrains.mps.errors.messageTargets.NodeMessageTarget;
import jetbrains.mps.errors.IErrorReporter;
import jetbrains.mps.lang.dataFlow.framework.instructions.WriteInstruction;
import com.mbeddr.core.modules.dataFlow.AnalyzerHelper;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import jetbrains.mps.analyzers.runtime.framework.GeneratedInstruction;
import org.jetbrains.mps.openapi.language.SConcept;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import org.jetbrains.mps.openapi.language.SInterfaceConcept;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import org.jetbrains.mps.openapi.language.SProperty;

public class check_StatementList_NonTypesystemRule extends AbstractNonTypesystemRule_Runtime implements NonTypesystemRule_Runtime {
  public check_StatementList_NonTypesystemRule() {
  }
  public void applyRule(final SNode statements, final TypeCheckingContext typeCheckingContext, IsApplicableStatus status) {
    if ((boolean) SuppressWarnings__BehaviorDescriptor.isSuppressed_id7U3Fobb_8EV.invoke(SNodeOperations.asSConcept(CONCEPTS.SuppressWarnings$uu), statements, CONCEPTS.SuppressDataFlowWarning$ss)) {
      return;
    }
    // only perform the check for top level statement lists
    if (SNodeOperations.isInstanceOf(SNodeOperations.getParent(statements), CONCEPTS.IDataFlowAnalyzerEntryPoint$qk)) {
      SNode function = SNodeOperations.getNodeAncestor(statements, CONCEPTS.IFunctionLike$zN, false, false);

      final Map<SNode, Integer> inVariables = MapSequence.fromMap(new HashMap<SNode, Integer>());

      ListSequence.fromList(SLinkOperations.getChildren(function, LINKS.arguments$6da0)).visitAll((it) -> {
        if (SLinkOperations.getTarget(it, LINKS.kind$ebZT) != null) {
          VariableWrapper var = new VariableWrapper(it);
          if (SEnumOperations.isMember(SPropertyOperations.getEnum(SLinkOperations.getTarget(it, LINKS.kind$ebZT), PROPS.value$1$x_), 0x3968d4c5c324d822L)) {
            MapSequence.fromMap(inVariables).put(var.variable, var.indirection);
          }
        }
      });

      // check unreachable statements
      DataFlowUtil.checkUnreachable(typeCheckingContext, statements);

      // uninitialized read analysis
      Tuples._2<Program, AnalysisResult<Set<VariableWrapper>>> _result = InitializedVariablesAnalyzerHelper.analyze(statements);
      Program program = _result._0();
      AnalysisResult<Set<VariableWrapper>> result = _result._1();

      for (Instruction instruction : program.getInstructions()) {
        Set<VariableWrapper> variables = result.get(instruction);

        SNode source = (SNode) instruction.getSource();

        if (instruction instanceof ReadInstruction) {

          // check if the read variable is in the initialized set of variables
          // the only exception is the reference expression, because we
          // are allowed to get the address of the variable even if it is
          // uninitialized
          ReadInstruction read = ((ReadInstruction) instruction);
          VariableWrapper var = new VariableWrapper((SNode) read.getVariable());

          // the ReferenceExpr is an mbeddr specific exception
          if (SNodeOperations.getNodeAncestor(source, CONCEPTS.ReferenceExpr$Gw, false, false) == null && !(variables.contains(var))) {
            String message = "Variable " + BaseConcept__BehaviorDescriptor.getPresentation_idhEwIMiw.invoke(var.variable) + " may not be initialized!";
            MarkerType type = MapSequence.fromMap(InitializedVariablesAnalyzerHelper.markerSpecifications).get(SNodeOperations.getConcept(source));
            if (type == null || type == MarkerType.ERROR) {
              {
                final MessageTarget errorTarget = new NodeMessageTarget();
                IErrorReporter _reporter_2309309498 = typeCheckingContext.reportTypeError(source, message, "r:7b158038-abbe-4e11-b171-d5a959b4e91a(com.mbeddr.core.modules.typesystem)", "8307327904922171417", null, errorTarget);
              }
            } else if (type == MarkerType.WARNING) {
              {
                final MessageTarget errorTarget = new NodeMessageTarget();
                IErrorReporter _reporter_2309309498 = typeCheckingContext.reportWarning(source, message, "r:7b158038-abbe-4e11-b171-d5a959b4e91a(com.mbeddr.core.modules.typesystem)", "8307327904922172517", null, errorTarget);
              }
            } else {
              {
                final MessageTarget errorTarget = new NodeMessageTarget();
                IErrorReporter _reporter_2309309498 = typeCheckingContext.reportInfo(source, message, "r:7b158038-abbe-4e11-b171-d5a959b4e91a(com.mbeddr.core.modules.typesystem)", "8307327904922172711", null, errorTarget);
              }
            }
          }
        } else if (instruction instanceof WriteInstruction && ((WriteInstruction) instruction).getVariable() != null) {
          WriteInstruction write = (WriteInstruction) instruction;
          VariableWrapper var = new VariableWrapper((SNode) write.getVariable());

          SNode left = AnalyzerHelper.extractLeftSide(source);
          boolean dereferenced = ListSequence.fromList(SNodeOperations.getNodeDescendants(left, CONCEPTS.DerefExpr$1W, true, new SAbstractConcept[]{})).isNotEmpty() || ListSequence.fromList(SNodeOperations.getNodeDescendants(left, CONCEPTS.ArrayAccessExpr$IH, true, new SAbstractConcept[]{})).isNotEmpty();

          // a write on a smaller indirection level means that it would
          // have side effect which is visible to the outside
          if (MapSequence.fromMap(inVariables).containsKey(var.variable)) {
            if (dereferenced) {
              {
                final MessageTarget errorTarget = new NodeMessageTarget();
                IErrorReporter _reporter_2309309498 = typeCheckingContext.reportTypeError((SNode) write.getSource(), "Write to an IN variable must not have effect outside of the function!", "r:7b158038-abbe-4e11-b171-d5a959b4e91a(com.mbeddr.core.modules.typesystem)", "5882815100611403121", null, errorTarget);
              }
            }
          }
        } else if (instruction instanceof GeneratedInstruction && ((GeneratedInstruction) instruction).commandPresentation().startsWith("synthethisedOutRead")) {
          VariableWrapper var = new VariableWrapper((SNode) instruction.getUserObject("target"));
          if (!(variables.contains(var)) && var.variable != null) {
            String message = "OUT argument " + BaseConcept__BehaviorDescriptor.getPresentation_idhEwIMiw.invoke(var.variable) + " must be written on all paths!";
            MarkerType type = MapSequence.fromMap(InitializedVariablesAnalyzerHelper.markerSpecifications).get(SNodeOperations.getConcept(source));
            if (type == null || type == MarkerType.ERROR) {
              {
                final MessageTarget errorTarget = new NodeMessageTarget();
                IErrorReporter _reporter_2309309498 = typeCheckingContext.reportTypeError(var.variable, message, "r:7b158038-abbe-4e11-b171-d5a959b4e91a(com.mbeddr.core.modules.typesystem)", "8621148949343882998", null, errorTarget);
              }
            } else if (type == MarkerType.WARNING) {
              {
                final MessageTarget errorTarget = new NodeMessageTarget();
                IErrorReporter _reporter_2309309498 = typeCheckingContext.reportWarning(var.variable, message, "r:7b158038-abbe-4e11-b171-d5a959b4e91a(com.mbeddr.core.modules.typesystem)", "8621148949343883013", null, errorTarget);
              }
            } else {
              {
                final MessageTarget errorTarget = new NodeMessageTarget();
                IErrorReporter _reporter_2309309498 = typeCheckingContext.reportInfo(var.variable, message, "r:7b158038-abbe-4e11-b171-d5a959b4e91a(com.mbeddr.core.modules.typesystem)", "8621148949343883018", null, errorTarget);
              }
            }
          }
        }
      }
    }
  }
  public SAbstractConcept getApplicableConcept() {
    return CONCEPTS.StatementList$y1;
  }
  public IsApplicableStatus isApplicableAndPattern(SNode argument) {
    return new IsApplicableStatus(argument.getConcept().isSubConceptOf(getApplicableConcept()), null);
  }
  public boolean overrides() {
    return false;
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept SuppressWarnings$uu = MetaAdapterFactory.getConcept(0xc1c2a88a323c4605L, 0xa37d9ab77a2ccbd2L, 0x7e83ad82cb948a95L, "com.mbeddr.mpsutil.suppresswarning.structure.SuppressWarnings");
    /*package*/ static final SConcept SuppressDataFlowWarning$ss = MetaAdapterFactory.getConcept(0x6d11763d483d4b2bL, 0x8efc09336c1b0001L, 0x5e0e8c0879acb8c7L, "com.mbeddr.core.modules.structure.SuppressDataFlowWarning");
    /*package*/ static final SInterfaceConcept IFunctionLike$zN = MetaAdapterFactory.getInterfaceConcept(0x6d11763d483d4b2bL, 0x8efc09336c1b0001L, 0x707ac195dd5d51f2L, "com.mbeddr.core.modules.structure.IFunctionLike");
    /*package*/ static final SConcept ReferenceExpr$Gw = MetaAdapterFactory.getConcept(0x3bf5377ae9044dedL, 0x97545a516023bfaaL, 0x16258e86289cf6bdL, "com.mbeddr.core.pointers.structure.ReferenceExpr");
    /*package*/ static final SConcept ArrayAccessExpr$IH = MetaAdapterFactory.getConcept(0x3bf5377ae9044dedL, 0x97545a516023bfaaL, 0x572f431af7922901L, "com.mbeddr.core.pointers.structure.ArrayAccessExpr");
    /*package*/ static final SConcept DerefExpr$1W = MetaAdapterFactory.getConcept(0x3bf5377ae9044dedL, 0x97545a516023bfaaL, 0x3e0cae5e366e2a7L, "com.mbeddr.core.pointers.structure.DerefExpr");
    /*package*/ static final SInterfaceConcept IDataFlowAnalyzerEntryPoint$qk = MetaAdapterFactory.getInterfaceConcept(0x6d11763d483d4b2bL, 0x8efc09336c1b0001L, 0x6ec6e0108c573b64L, "com.mbeddr.core.modules.structure.IDataFlowAnalyzerEntryPoint");
    /*package*/ static final SConcept StatementList$y1 = MetaAdapterFactory.getConcept(0xa9d696470840491eL, 0xbf392eb0805d2011L, 0x3a16e3a9c7ad9955L, "com.mbeddr.core.statements.structure.StatementList");
  }

  private static final class LINKS {
    /*package*/ static final SContainmentLink arguments$6da0 = MetaAdapterFactory.getContainmentLink(0x6d11763d483d4b2bL, 0x8efc09336c1b0001L, 0x707ac195dd5d51f2L, 0x4f39f90935e92f45L, "arguments");
    /*package*/ static final SContainmentLink kind$ebZT = MetaAdapterFactory.getContainmentLink(0x6d11763d483d4b2bL, 0x8efc09336c1b0001L, 0x75302b1261129ff9L, 0xc42f172f6d02776L, "kind");
  }

  private static final class PROPS {
    /*package*/ static final SProperty value$1$x_ = MetaAdapterFactory.getProperty(0x6d11763d483d4b2bL, 0x8efc09336c1b0001L, 0xc42f172f6d01a6eL, 0xc42f172f6d01b82L, "value");
  }
}
