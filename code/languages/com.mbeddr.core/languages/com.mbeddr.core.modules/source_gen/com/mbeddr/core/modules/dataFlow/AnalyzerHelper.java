package com.mbeddr.core.modules.dataFlow;

/*Generated by MPS */

import jetbrains.mps.lang.dataFlow.framework.Program;
import jetbrains.mps.lang.dataFlow.framework.AnalysisResult;
import java.util.Set;
import jetbrains.mps.lang.dataFlow.framework.ProgramState;
import jetbrains.mps.lang.dataFlow.framework.instructions.Instruction;
import com.mbeddr.mpsutil.dataflow.runtime.plugin.InterProceduralDataFlowGraph;
import jetbrains.mps.analyzers.runtime.framework.GeneratedInstruction;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.typechecking.TypecheckingFacade;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import com.mbeddr.core.base.behavior.IReference__BehaviorDescriptor;
import com.mbeddr.core.expressions.behavior.IAssignmentLike__BehaviorDescriptor;
import com.mbeddr.core.expressions.behavior.IVariableDeclaration__BehaviorDescriptor;
import java.util.Map;
import java.util.HashMap;
import java.util.HashSet;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import org.jetbrains.mps.openapi.language.SConcept;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import org.jetbrains.mps.openapi.language.SInterfaceConcept;
import org.jetbrains.mps.openapi.language.SContainmentLink;

public class AnalyzerHelper {

  /**
   * Returns the Program instance for a given AnalysisResult. 
   * 
   * @param result the analysis result
   * @return the corresponding program
   */
  public static Program getProgram(AnalysisResult result) {
    Set<ProgramState> states = result.getStates();
    ProgramState state = states.iterator().next();
    return getProgram(state.getInstruction());
  }

  public static Program getProgram(Instruction instruction) {
    Program program = instruction.getProgram();
    if (program instanceof InterProceduralDataFlowGraph) {
      return ((InterProceduralDataFlowGraph) program).getRoot();
    } else {
      return program;
    }
  }

  /**
   * Returns the first non-generated instruction in the program graph 
   * which appears before the given generated instruction. 
   * 
   * @param instruction the generated instruction
   * @return the non-generated instruction that appears before
   */
  public static Instruction getNonGeneratedPredecessor(GeneratedInstruction instruction) {
    Instruction act = instruction;
    while (act != null && act instanceof GeneratedInstruction) {
      assert act.pred().size() == 1;
      act = act.pred().iterator().next();
    }
    return act;
  }

  /**
   * Computes the indirection level for a given expression.
   * The computation is based on the expression's type. 
   * 0 indirection is assigned to non-pointer types. 
   * A number greater than 0 means the number of pointer indirections in the type. 
   * 
   * @param expression the expression
   * @return the indirection level
   */
  public static int computeIndirection(SNode expression) {
    SNode type = TypecheckingFacade.getFromContext().getTypeOf(expression);
    int indirection = 0;

    while (SNodeOperations.isInstanceOf(type, CONCEPTS.PointerType$HX)) {
      indirection++;
      type = SLinkOperations.getTarget(SNodeOperations.cast(type, CONCEPTS.PointerType$HX), LINKS.baseType$zMGV);
    }

    return indirection;
  }

  public static boolean isDereferenced(SNode expression, SNode root) {
    return ListSequence.fromList(SNodeOperations.getNodeDescendants(root, CONCEPTS.DerefExpr$1W, true, new SAbstractConcept[]{})).isNotEmpty();
  }

  /**
   * Returns the root StatementList for a given node, if any. 
   * 
   * @param node the node instance
   * @return the root statement list
   */
  public static SNode getRootStatementList(SNode node) {
    SNode result = null;
    SNode act = node;

    while (act != null) {
      if (SNodeOperations.isInstanceOf(act, CONCEPTS.StatementList$y1)) {
        result = SNodeOperations.cast(act, CONCEPTS.StatementList$y1);
      }
      act = SNodeOperations.getParent(act);
    }

    return result;
  }

  public static SNode resolve(SNode expression) {
    if (SNodeOperations.isInstanceOf(expression, CONCEPTS.IVariableReference$WR)) {
      return IReference__BehaviorDescriptor.target_id70kXLV4LLzy.invoke(SNodeOperations.cast(expression, CONCEPTS.IVariableReference$WR));
    } else {
      return expression;
    }
  }

  public static SNode extractStatement(SNode expression) {
    if (SNodeOperations.isInstanceOf(expression, CONCEPTS.ParensExpression$Ng)) {
      return extractStatement(SLinkOperations.getTarget(SNodeOperations.cast(expression, CONCEPTS.ParensExpression$Ng), LINKS.expression$PfNq));
    } else {
      return expression;
    }
  }

  public static SNode extractVariable(SNode expression) {
    if (expression == null) {
      return null;
    } else if (SNodeOperations.isInstanceOf(expression, CONCEPTS.IVariableReference$WR)) {
      return IReference__BehaviorDescriptor.target_id70kXLV4LLzy.invoke(SNodeOperations.cast(expression, CONCEPTS.IVariableReference$WR));
    } else if (SNodeOperations.isInstanceOf(expression, CONCEPTS.ReferenceExpr$Gw)) {
      return extractVariable(SLinkOperations.getTarget(SNodeOperations.cast(expression, CONCEPTS.ReferenceExpr$Gw), LINKS.expression$PfNq));
    } else if (SNodeOperations.isInstanceOf(expression, CONCEPTS.DerefExpr$1W)) {
      return extractVariable(SLinkOperations.getTarget(SNodeOperations.cast(expression, CONCEPTS.DerefExpr$1W), LINKS.expression$PfNq));
    } else {
      return expression;
    }
  }

  public static SNode extractLeftSide(SNode expression) {
    if (expression == null) {
      return null;
    } else if (SNodeOperations.isInstanceOf(expression, CONCEPTS.IVariableDeclaration$O)) {
      return expression;
    } else if (SNodeOperations.isInstanceOf(expression, CONCEPTS.IAssignmentLike$34)) {
      return extractLeftSide(IAssignmentLike__BehaviorDescriptor.getLValue_id7QxE2Vg8Hif.invoke(SNodeOperations.cast(expression, CONCEPTS.IAssignmentLike$34)));
    } else if (SNodeOperations.isInstanceOf(expression, CONCEPTS.ParensExpression$Ng)) {
      return extractLeftSide(SLinkOperations.getTarget(SNodeOperations.cast(expression, CONCEPTS.ParensExpression$Ng), LINKS.expression$PfNq));
    } else {
      return expression;
    }
  }

  public static SNode extractRightSide(SNode expression) {
    if (expression == null) {
      return null;
    } else if (SNodeOperations.isInstanceOf(expression, CONCEPTS.IVariableDeclaration$O)) {
      return IVariableDeclaration__BehaviorDescriptor.getInitExpression_id1LDGRqyYkU1.invoke(SNodeOperations.cast(expression, CONCEPTS.IVariableDeclaration$O));
    } else if (SNodeOperations.isInstanceOf(expression, CONCEPTS.IAssignmentLike$34)) {
      return extractRightSide(IAssignmentLike__BehaviorDescriptor.getRValue_id7QxE2Vg8Hlr.invoke(SNodeOperations.cast(expression, CONCEPTS.IAssignmentLike$34)));
    } else if (SNodeOperations.isInstanceOf(expression, CONCEPTS.ParensExpression$Ng)) {
      return extractRightSide(SLinkOperations.getTarget(SNodeOperations.cast(expression, CONCEPTS.ParensExpression$Ng), LINKS.expression$PfNq));
    } else {
      return expression;
    }
  }

  /**
   * Generic map intersection between two multi-maps. 
   * 
   * @param m1 the first map
   * @param m2 the second map
   * @param <T> the type parameter of the maps
   * @return the resulting intersection
   */
  public static <T> Map<T, Set<T>> intersection(Map<T, Set<T>> m1, Map<T, Set<T>> m2) {
    Map<T, Set<T>> result = new HashMap<T, Set<T>>();

    for (T k1 : m1.keySet()) {
      if (m2.containsKey(k1)) {
        result.put(k1, new HashSet<T>());
        for (T v1 : SetSequence.fromSet(m1.get(k1))) {
          if (m2.get(k1).contains(v1)) {
            result.get(k1).add(v1);
          }
        }
      }
    }

    return result;
  }

  /**
   * Generic map union between two multi-maps. 
   * 
   * @param m1 the first map
   * @param m2 the second map
   * @param <T> the type parameter of the maps
   * @return the resulting intersection
   */
  public static <T> Map<T, Set<T>> union(Map<T, Set<T>> m1, Map<T, Set<T>> m2) {
    Map<T, Set<T>> result = new HashMap<T, Set<T>>();

    result.putAll(m1);

    for (T k : m2.keySet()) {
      Set<T> values = result.get(k);
      if (values == null) {
        values = new HashSet<T>();
        result.put(k, values);
      }
      values.addAll(m2.get(k));
    }

    return result;
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept PointerType$HX = MetaAdapterFactory.getConcept(0x3bf5377ae9044dedL, 0x97545a516023bfaaL, 0x3e0cae5e366d630L, "com.mbeddr.core.pointers.structure.PointerType");
    /*package*/ static final SConcept DerefExpr$1W = MetaAdapterFactory.getConcept(0x3bf5377ae9044dedL, 0x97545a516023bfaaL, 0x3e0cae5e366e2a7L, "com.mbeddr.core.pointers.structure.DerefExpr");
    /*package*/ static final SConcept StatementList$y1 = MetaAdapterFactory.getConcept(0xa9d696470840491eL, 0xbf392eb0805d2011L, 0x3a16e3a9c7ad9955L, "com.mbeddr.core.statements.structure.StatementList");
    /*package*/ static final SInterfaceConcept IVariableReference$WR = MetaAdapterFactory.getInterfaceConcept(0x61c69711ed614850L, 0x81d97714ff227fb0L, 0x1c69b376a2dab98aL, "com.mbeddr.core.expressions.structure.IVariableReference");
    /*package*/ static final SConcept ParensExpression$Ng = MetaAdapterFactory.getConcept(0x61c69711ed614850L, 0x81d97714ff227fb0L, 0x4ffba68fe82dd4c7L, "com.mbeddr.core.expressions.structure.ParensExpression");
    /*package*/ static final SConcept ReferenceExpr$Gw = MetaAdapterFactory.getConcept(0x3bf5377ae9044dedL, 0x97545a516023bfaaL, 0x16258e86289cf6bdL, "com.mbeddr.core.pointers.structure.ReferenceExpr");
    /*package*/ static final SInterfaceConcept IVariableDeclaration$O = MetaAdapterFactory.getInterfaceConcept(0x61c69711ed614850L, 0x81d97714ff227fb0L, 0x1c69b376a2f94e75L, "com.mbeddr.core.expressions.structure.IVariableDeclaration");
    /*package*/ static final SInterfaceConcept IAssignmentLike$34 = MetaAdapterFactory.getInterfaceConcept(0x61c69711ed614850L, 0x81d97714ff227fb0L, 0x4945cc205934d00L, "com.mbeddr.core.expressions.structure.IAssignmentLike");
  }

  private static final class LINKS {
    /*package*/ static final SContainmentLink baseType$zMGV = MetaAdapterFactory.getContainmentLink(0xa9d696470840491eL, 0xbf392eb0805d2011L, 0x6bbcdccef5e46755L, 0x6bbcdccef5e46756L, "baseType");
    /*package*/ static final SContainmentLink expression$PfNq = MetaAdapterFactory.getContainmentLink(0x61c69711ed614850L, 0x81d97714ff227fb0L, 0x29b5b7c4a3763232L, 0x64ae61a4018a9c50L, "expression");
  }
}
