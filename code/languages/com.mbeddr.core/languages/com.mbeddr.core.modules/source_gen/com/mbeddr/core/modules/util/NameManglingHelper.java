package com.mbeddr.core.modules.util;

/*Generated by MPS */

import java.util.List;
import org.jetbrains.mps.openapi.model.SNode;
import org.jetbrains.mps.openapi.model.SModel;
import java.util.Map;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import org.jetbrains.mps.openapi.language.SProperty;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import org.jetbrains.mps.openapi.language.SInterfaceConcept;

public class NameManglingHelper {

  /**
   * Returns those ICanMangleNames nodes from the model which have a unique name (within the model). 
   * 
   * During generation these nodes will have the prevent name mangling flag set to true, so no
   * module name will be prepended to their name in C. 
   */
  public static List<SNode> uniqueMangleableModuleContents(SModel model) {

    Map<String, Set<SNode>> allModuleContent = MapSequence.fromMap(new HashMap<String, Set<SNode>>());

    for (SNode content : ListSequence.fromList(SModelOperations.nodes(model, CONCEPTS.IModuleContent$H1))) {
      if (MapSequence.fromMap(allModuleContent).get(SPropertyOperations.getString(content, PROPS.name$MnvL)) == null) {
        MapSequence.fromMap(allModuleContent).put(SPropertyOperations.getString(content, PROPS.name$MnvL), SetSequence.fromSet(new HashSet<SNode>()));
      }
      SetSequence.fromSet(MapSequence.fromMap(allModuleContent).get(SPropertyOperations.getString(content, PROPS.name$MnvL))).addElement(content);
    }

    Set<SNode> uniqueNodes = SetSequence.fromSet(new HashSet<SNode>());

    // We can set the prevent name mangling for all those module content elements that can be name mangled and whose name is unique
    for (String contentName : MapSequence.fromMap(allModuleContent).keySet()) {
      if (SetSequence.fromSet(MapSequence.fromMap(allModuleContent).get(contentName)).count() == 1) {
        {
          final SNode mangleable = SetSequence.fromSet(MapSequence.fromMap(allModuleContent).get(contentName)).first();
          if (SNodeOperations.isInstanceOf(mangleable, CONCEPTS.ICanMangleNames$yI)) {
            SetSequence.fromSet(uniqueNodes).addElement(mangleable);
          }
        }
      }
    }

    return SetSequence.fromSet(uniqueNodes).toList();
  }

  private static final class PROPS {
    /*package*/ static final SProperty name$MnvL = MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name");
  }

  private static final class CONCEPTS {
    /*package*/ static final SInterfaceConcept IModuleContent$H1 = MetaAdapterFactory.getInterfaceConcept(0x6d11763d483d4b2bL, 0x8efc09336c1b0001L, 0x595522006a5b934fL, "com.mbeddr.core.modules.structure.IModuleContent");
    /*package*/ static final SInterfaceConcept ICanMangleNames$yI = MetaAdapterFactory.getInterfaceConcept(0x6d11763d483d4b2bL, 0x8efc09336c1b0001L, 0x260f4bd3a5779b7dL, "com.mbeddr.core.modules.structure.ICanMangleNames");
  }
}
