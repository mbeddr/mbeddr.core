package com.mbeddr.core.expressions.typesystem;

/*Generated by MPS */

import org.jetbrains.mps.openapi.model.SNode;
import java.util.Objects;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.typechecking.TypecheckingFacade;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import jetbrains.mps.typesystem.inference.SubtypingManager;
import jetbrains.mps.typesystem.inference.TypeChecker;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.internal.collections.runtime.Sequence;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import org.jetbrains.mps.openapi.language.SInterfaceConcept;

public class AssignableSuperTypeHelper {
  public static SNode getAssignableSuperType(SNode assignableConcept, SNode baseConcept) {
    if (Objects.equals(SNodeOperations.getConcept(assignableConcept), SNodeOperations.getConcept(baseConcept))) {
      return baseConcept;
    } else {

      for (SNode superType : TypecheckingFacade.getFromContext().getImmediateSupertypes(baseConcept)) {
        if (superType.getConcept().getQualifiedName().equals(baseConcept.getConcept().getQualifiedName())) {
          // End of recursion when superType == baseType
          return baseConcept;
        }
        SNode result = AssignableSuperTypeHelper.getAssignableSuperType(assignableConcept, superType);
        if (result != null) {
          return result;
        }
      }

      return null;

    }
  }

  public static SNode getCommonSuperType(SNode assignableConcept, SNode baseConcept) {
    if (Objects.equals(SNodeOperations.getConcept(assignableConcept), SNodeOperations.getConcept(baseConcept))) {
      return baseConcept;
    } else {

      Set<SNode> types = SetSequence.fromSet(new HashSet<SNode>());
      SetSequence.fromSet(types).addElement(assignableConcept);
      SetSequence.fromSet(types).addElement(baseConcept);

      SubtypingManager subtypingManager = TypeChecker.getInstance().getSubtypingManager();
      Set<SNode> leastCommonSupertypes = subtypingManager.leastCommonSupertypes(types, false);

      Set<SNode> result = (Set<SNode>) leastCommonSupertypes;
      if (SetSequence.fromSet(result).isNotEmpty()) {
        if (SetSequence.fromSet(result).count() == 1) {
          return SetSequence.fromSet(result).first();
        } else {
          SNode meet = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0x61c69711ed614850L, 0x81d97714ff227fb0L, 0x34ab7f1366694273L, "com.mbeddr.core.expressions.structure.PC99MeetType"));
          ListSequence.fromList(SLinkOperations.getChildren(meet, LINKS.argument$r2cT)).addSequence(Sequence.fromIterable(SNodeOperations.ofConcept(result, CONCEPTS.IType$a9)));
          return meet;
        }

      }

      return null;
    }
  }

  public static boolean hasComparableSuperTypes(SNode leftNode, SNode rightNode) {
    if (Objects.equals(SNodeOperations.getConcept(leftNode), SNodeOperations.getConcept(rightNode))) {
      return true;
    }
    if (getAssignableSuperType(leftNode, rightNode) != null) {
      return true;
    }
    if (getAssignableSuperType(rightNode, leftNode) != null) {
      return true;
    }

    return false;
  }

  private static final class LINKS {
    /*package*/ static final SContainmentLink argument$r2cT = MetaAdapterFactory.getContainmentLink(0x7a5dda6291404668L, 0xab76d5ed1746f2b2L, 0x114b68ad132L, 0x114b68b040bL, "argument");
  }

  private static final class CONCEPTS {
    /*package*/ static final SInterfaceConcept IType$a9 = MetaAdapterFactory.getInterfaceConcept(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x11f8a0774f2L, "jetbrains.mps.lang.core.structure.IType");
  }
}
