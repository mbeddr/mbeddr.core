package com.mbeddr.core.expressions.actions;

/*Generated by MPS */

import org.jetbrains.mps.openapi.language.SAbstractConcept;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.smodel.constraints.ConstraintsCanBeFacade;
import jetbrains.mps.core.aspects.constraints.rules.kinds.ContainmentContext;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.core.aspects.constraints.rules.kinds.CanBeAncestorContext;
import jetbrains.mps.internal.collections.runtime.ListSequence;

public class ModelConstraintsUtils {

  public static boolean binaryOperatorAllowed(SAbstractConcept c, SNode sourceNode) {
    if (!(ConstraintsCanBeFacade.checkCanBeChild(new ContainmentContext.Builder().parentNode(SNodeOperations.getParent(sourceNode)).childConcept(c).build()).isEmpty())) {
      return false;
    }
    if (!(ConstraintsCanBeFacade.checkCanBeParent(new ContainmentContext.Builder().parentNode(SNodeOperations.getParent(sourceNode)).childConcept(c).link(SNodeOperations.getContainingLink(sourceNode)).build()).isEmpty())) {
      return false;
    }
    CanBeAncestorContext.Builder canBeAncestorBuilder = new CanBeAncestorContext.Builder().parentNode(sourceNode).childConcept(c).link(SNodeOperations.getContainingLink(sourceNode));
    for (SNode currentAncestor : ListSequence.fromList(SNodeOperations.getNodeAncestors(sourceNode, null, false))) {
      if (!(ConstraintsCanBeFacade.checkCanBeAncestor(canBeAncestorBuilder.ancestorNode(currentAncestor).build()).isEmpty())) {
        return false;
      }
    }
    return true;
  }
}
