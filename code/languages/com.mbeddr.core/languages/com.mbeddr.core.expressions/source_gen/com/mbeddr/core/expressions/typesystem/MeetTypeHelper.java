package com.mbeddr.core.expressions.typesystem;

/*Generated by MPS */

import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.typechecking.TypecheckingFacade;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import java.util.Objects;
import com.mbeddr.core.expressions.behavior.DerivedPrimitiveType__BehaviorDescriptor;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import org.jetbrains.mps.openapi.language.SConcept;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import org.jetbrains.mps.openapi.language.SInterfaceConcept;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import org.jetbrains.mps.openapi.language.SProperty;

public class MeetTypeHelper {

  /**
   * Returns true if sub is a subtype of sup. In case of a meet type, both types will be considered to check if the 
   * subtyping relationship can be satisfied. 
   */
  public static boolean isSubType(SNode sub, SNode sup) {
    if (SNodeOperations.isInstanceOf(sub, CONCEPTS.PC99MeetType$$K) && SNodeOperations.isInstanceOf(sup, CONCEPTS.PC99MeetType$$K)) {
      return TypecheckingFacade.getFromContext().isSubtype(getConcreteNonConstVolatileSignedType(sub), getConcreteNonConstVolatileSignedType(sup));
    } else if (SNodeOperations.isInstanceOf(sub, CONCEPTS.PC99MeetType$$K) && !(SNodeOperations.isInstanceOf(sup, CONCEPTS.PC99MeetType$$K))) {
      return TypecheckingFacade.getFromContext().isSubtype(getConcreteNonConstVolatileSignedType(sub), sup) || TypecheckingFacade.getFromContext().isSubtype(getConcreteNonConstVolatileUnsignedType(sub), sup);
    } else if (!(SNodeOperations.isInstanceOf(sub, CONCEPTS.PC99MeetType$$K)) && SNodeOperations.isInstanceOf(sup, CONCEPTS.PC99MeetType$$K)) {
      return TypecheckingFacade.getFromContext().isSubtype(sub, getConcreteNonConstVolatileSignedType(sup)) || TypecheckingFacade.getFromContext().isSubtype(sub, getConcreteNonConstVolatileSignedType(sup));
    } else {
      return TypecheckingFacade.getFromContext().isSubtype(sub, sup);
    }
  }

  /**
   * Use new overload that takes concept and not conceptNode
   * 
   * @deprecated 
   */
  @Deprecated
  public static boolean isInstanceOf(SNode type, final SNode c) {
    boolean isDirectInstance = SNodeOperations.isInstanceOf(type, SNodeOperations.asSConcept(c));
    if (isDirectInstance) {
      return true;
    }
    if (SNodeOperations.isInstanceOf(type, CONCEPTS.MeetType$ZG)) {
      return ListSequence.fromList(SLinkOperations.getChildren(SNodeOperations.cast(type, CONCEPTS.MeetType$ZG), LINKS.argument$r2cT)).any((it) -> SNodeOperations.isInstanceOf(it, SNodeOperations.asSConcept(c)));
    }
    return false;
  }
  public static boolean isInstanceOf(SNode type, final SAbstractConcept c) {
    boolean isDirectInstance = SNodeOperations.isInstanceOf(type, SNodeOperations.asSConcept(c));
    if (isDirectInstance) {
      return true;
    }
    if (SNodeOperations.isInstanceOf(type, CONCEPTS.MeetType$ZG)) {
      return ListSequence.fromList(SLinkOperations.getChildren(SNodeOperations.cast(type, CONCEPTS.MeetType$ZG), LINKS.argument$r2cT)).any((it) -> SNodeOperations.isInstanceOf(it, SNodeOperations.asSConcept(c)));
    }
    return false;
  }

  public static boolean isSameTypeConcept(SNode t1, SNode t2) {
    if (!(SNodeOperations.isInstanceOf(t1, CONCEPTS.MeetType$ZG)) && !(SNodeOperations.isInstanceOf(t2, CONCEPTS.MeetType$ZG))) {
      return Objects.equals(SNodeOperations.getConcept(t1), SNodeOperations.getConcept(t2));
    }
    if (SNodeOperations.isInstanceOf(t1, CONCEPTS.MeetType$ZG) && !(SNodeOperations.isInstanceOf(t2, CONCEPTS.MeetType$ZG))) {
      return isInstanceOf(t1, SNodeOperations.getConcept(t2));
    }
    if (!(SNodeOperations.isInstanceOf(t1, CONCEPTS.MeetType$ZG)) && SNodeOperations.isInstanceOf(t2, CONCEPTS.MeetType$ZG)) {
      return isInstanceOf(t2, SNodeOperations.getConcept(t1));
    }
    // Both types are meetTypes
    for (SNode innerTypes : ListSequence.fromList(SLinkOperations.getChildren(SNodeOperations.cast(t1, CONCEPTS.MeetType$ZG), LINKS.argument$r2cT))) {
      if (isInstanceOf(t2, SNodeOperations.getConcept(innerTypes))) {
        return true;
      }
    }
    return false;
  }

  public static SNode getConcreteType(SNode type) {
    if (SNodeOperations.isInstanceOf(type, CONCEPTS.ITypeDecorator$9x)) {
      return SNodeOperations.copyNode(getConcreteType(SLinkOperations.getTarget(SNodeOperations.cast(type, CONCEPTS.ITypeDecorator$9x), LINKS.valueType$2o7e)));
    }
    if (SNodeOperations.isInstanceOf(type, CONCEPTS.DerivedPrimitiveType$C0)) {
      type = DerivedPrimitiveType__BehaviorDescriptor.getBaseType_id3dCMHw1DZZS.invoke(SNodeOperations.cast(type, CONCEPTS.DerivedPrimitiveType$C0));
    }

    if (SNodeOperations.isInstanceOf(type, CONCEPTS.MeetType$ZG)) {
      List<SNode> types = SLinkOperations.getChildren(SNodeOperations.cast(type, CONCEPTS.MeetType$ZG), LINKS.argument$r2cT);
      SNode c99Type = Sequence.fromIterable(SNodeOperations.ofConcept(types, CONCEPTS.PrimitiveC99IntegralType$E_)).first();
      if ((c99Type != null)) {
        return SNodeOperations.copyNode(c99Type);
      }
      return SNodeOperations.cast(SNodeOperations.copyNode(ListSequence.fromList(types).first()), CONCEPTS.Type$dP);
    }
    if (SNodeOperations.isInstanceOf(type, CONCEPTS.Type$dP)) {
      return SNodeOperations.cast(type, CONCEPTS.Type$dP);
    }
    // runtime type
    return null;
  }

  public static SNode getConcreteNonConstVolatileType(SNode type) {
    SNode t = getConcreteType(type);
    SPropertyOperations.assign(t, PROPS.const$VWr7, false);
    SPropertyOperations.assign(t, PROPS.volatile$hJNe, false);
    return t;
  }
  public static SNode getConcreteNonConstVolatileSignedType(SNode type) {
    if (SNodeOperations.isInstanceOf(type, CONCEPTS.ITypeDecorator$9x)) {
      SNode copy = SNodeOperations.cast(SNodeOperations.copyNode(type), CONCEPTS.ITypeDecorator$9x);
      SLinkOperations.setTarget(copy, LINKS.valueType$2o7e, getConcreteNonConstVolatileSignedType(SLinkOperations.getTarget(SNodeOperations.cast(type, CONCEPTS.ITypeDecorator$9x), LINKS.valueType$2o7e)));
      return SNodeOperations.cast(copy, CONCEPTS.Type$dP);
    }
    if (SNodeOperations.isInstanceOf(type, CONCEPTS.DerivedPrimitiveType$C0)) {
      type = DerivedPrimitiveType__BehaviorDescriptor.getBaseType_id3dCMHw1DZZS.invoke(SNodeOperations.cast(type, CONCEPTS.DerivedPrimitiveType$C0));
    }

    SNode t;
    if (SNodeOperations.isInstanceOf(type, CONCEPTS.MeetType$ZG)) {
      List<SNode> argument = SLinkOperations.getChildren(SNodeOperations.cast(type, CONCEPTS.MeetType$ZG), LINKS.argument$r2cT);
      t = SNodeOperations.cast(ListSequence.fromList(argument).findFirst((it) -> SNodeOperations.isInstanceOf(it, CONCEPTS.PrimitiveC99IntegralType$E_) && SNodeOperations.isInstanceOf(it, CONCEPTS.ISigned$EC)), CONCEPTS.Type$dP);
      if ((t == null)) {
        t = SNodeOperations.cast(ListSequence.fromList(argument).findFirst((it) -> SNodeOperations.isInstanceOf(it, CONCEPTS.ISigned$EC)), CONCEPTS.Type$dP);
      }
      if ((t == null)) {
        return null;
      }
    } else {
      t = SNodeOperations.cast(type, CONCEPTS.Type$dP);
    }

    t = SNodeOperations.copyNode(t);
    SPropertyOperations.assign(t, PROPS.const$VWr7, false);
    SPropertyOperations.assign(t, PROPS.volatile$hJNe, false);
    return t;
  }
  public static SNode getConcreteNonConstVolatileUnsignedType(SNode type) {
    if (SNodeOperations.isInstanceOf(type, CONCEPTS.ITypeDecorator$9x)) {
      SNode copy = SNodeOperations.cast(SNodeOperations.copyNode(type), CONCEPTS.ITypeDecorator$9x);
      SLinkOperations.setTarget(copy, LINKS.valueType$2o7e, getConcreteNonConstVolatileUnsignedType(SLinkOperations.getTarget(SNodeOperations.cast(type, CONCEPTS.ITypeDecorator$9x), LINKS.valueType$2o7e)));
      return SNodeOperations.cast(copy, CONCEPTS.Type$dP);
    }
    if (SNodeOperations.isInstanceOf(type, CONCEPTS.DerivedPrimitiveType$C0)) {
      type = DerivedPrimitiveType__BehaviorDescriptor.getBaseType_id3dCMHw1DZZS.invoke(SNodeOperations.cast(type, CONCEPTS.DerivedPrimitiveType$C0));
    }

    SNode t;
    if (SNodeOperations.isInstanceOf(type, CONCEPTS.MeetType$ZG)) {
      t = SNodeOperations.cast(ListSequence.fromList(SLinkOperations.getChildren(SNodeOperations.cast(type, CONCEPTS.MeetType$ZG), LINKS.argument$r2cT)).findFirst((it) -> SNodeOperations.isInstanceOf(it, CONCEPTS.IUnsigned$5A)), CONCEPTS.Type$dP);
      if ((t == null)) {
        return null;
      }
    } else {
      t = SNodeOperations.cast(type, CONCEPTS.Type$dP);
    }

    t = SNodeOperations.copyNode(t);
    SPropertyOperations.assign(t, PROPS.const$VWr7, false);
    SPropertyOperations.assign(t, PROPS.volatile$hJNe, false);
    return t;
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept PC99MeetType$$K = MetaAdapterFactory.getConcept(0x61c69711ed614850L, 0x81d97714ff227fb0L, 0x34ab7f1366694273L, "com.mbeddr.core.expressions.structure.PC99MeetType");
    /*package*/ static final SConcept MeetType$ZG = MetaAdapterFactory.getConcept(0x7a5dda6291404668L, 0xab76d5ed1746f2b2L, 0x114b68ad132L, "jetbrains.mps.lang.typesystem.structure.MeetType");
    /*package*/ static final SInterfaceConcept ITypeDecorator$9x = MetaAdapterFactory.getInterfaceConcept(0x61c69711ed614850L, 0x81d97714ff227fb0L, 0xa526fcd7806eb53L, "com.mbeddr.core.expressions.structure.ITypeDecorator");
    /*package*/ static final SConcept DerivedPrimitiveType$C0 = MetaAdapterFactory.getConcept(0x61c69711ed614850L, 0x81d97714ff227fb0L, 0x3368cad801a7debeL, "com.mbeddr.core.expressions.structure.DerivedPrimitiveType");
    /*package*/ static final SConcept PrimitiveC99IntegralType$E_ = MetaAdapterFactory.getConcept(0x61c69711ed614850L, 0x81d97714ff227fb0L, 0x75739ed9f39c4635L, "com.mbeddr.core.expressions.structure.PrimitiveC99IntegralType");
    /*package*/ static final SConcept Type$dP = MetaAdapterFactory.getConcept(0x61c69711ed614850L, 0x81d97714ff227fb0L, 0x7af69e2e83a1ba36L, "com.mbeddr.core.expressions.structure.Type");
    /*package*/ static final SInterfaceConcept ISigned$EC = MetaAdapterFactory.getInterfaceConcept(0x61c69711ed614850L, 0x81d97714ff227fb0L, 0x2115ca54c398ac06L, "com.mbeddr.core.expressions.structure.ISigned");
    /*package*/ static final SInterfaceConcept IUnsigned$5A = MetaAdapterFactory.getInterfaceConcept(0x61c69711ed614850L, 0x81d97714ff227fb0L, 0x61f402d2a8753377L, "com.mbeddr.core.expressions.structure.IUnsigned");
  }

  private static final class LINKS {
    /*package*/ static final SContainmentLink argument$r2cT = MetaAdapterFactory.getContainmentLink(0x7a5dda6291404668L, 0xab76d5ed1746f2b2L, 0x114b68ad132L, 0x114b68b040bL, "argument");
    /*package*/ static final SContainmentLink valueType$2o7e = MetaAdapterFactory.getContainmentLink(0x61c69711ed614850L, 0x81d97714ff227fb0L, 0xa526fcd7806eb53L, 0x65d0a4755f54174cL, "valueType");
  }

  private static final class PROPS {
    /*package*/ static final SProperty const$VWr7 = MetaAdapterFactory.getProperty(0x61c69711ed614850L, 0x81d97714ff227fb0L, 0x7af69e2e83a1ba36L, 0x28d183d9a4cc7da8L, "const");
    /*package*/ static final SProperty volatile$hJNe = MetaAdapterFactory.getProperty(0x61c69711ed614850L, 0x81d97714ff227fb0L, 0x7af69e2e83a1ba36L, 0x28d183d9a4fae02fL, "volatile");
  }
}
