package com.mbeddr.core.expressions.behavior;

/*Generated by MPS */

import com.mbeddr.mpsutil.interpreter.rt.ContextImpl;
import com.mbeddr.mpsutil.interpreter.rt.IConditionalInterpreter;
import org.jetbrains.mps.openapi.model.SNode;
import java.util.Map;
import com.mbeddr.mpsutil.interpreter.rt.INodeTypeCache;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import com.mbeddr.mpsutil.interpreter.rt.NullCoverageAnalyzer;
import com.mbeddr.mpsutil.interpreter.rt.CachedInterpreterFinder;
import com.mbeddr.mpsutil.interpreter.rt.CombinedConditionalInterpreter;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import com.mbeddr.mpsutil.interpreter.rt.InterpreterRegistry;
import com.mbeddr.mpsutil.interpreter.rt.NodeTypeCachePointerImpl;
import org.jetbrains.mps.openapi.language.SConcept;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;

public class StaticInterpreterHelper {
  private static final String INTERPRETER_CATEGORY = "CInterpreter";

  private static StaticInterpreterHelper instance;

  private ContextImpl interpreterContext;
  private boolean interpreterReady = false;
  private int storedHash = 0;
  private IConditionalInterpreter interpreter;

  public static StaticInterpreterHelper getInstance() {
    if (instance == null) {
      instance = new StaticInterpreterHelper();
    }

    return instance;
  }

  private StaticInterpreterHelper() {
  }

  public void reset() {
    interpreterReady = false;
  }

  public boolean isEvaluable(SNode node) {
    setupInterpreter(node);

    return getStaticInterpreter(node).isEvaluable(node, interpreterContext);
  }

  public Object evaluate(SNode node) {
    return evaluate(node, null);
  }

  public Object evaluate(SNode node, Map<SNode, SNode> cachedNodeTypes) {
    setupInterpreter(node);

    if (cachedNodeTypes != null) {
      final INodeTypeCache nodeTypeCache = interpreterContext.getNodeTypeCache();
      MapSequence.fromMap(cachedNodeTypes).visitAll((it) -> nodeTypeCache.set(it.key(), it.value()));
    }

    return getStaticInterpreter(node).evaluate(node, interpreterContext, new NullCoverageAnalyzer(), null, false);
  }

  private void setupInterpreter(SNode node) {
    if (!(interpreterReady)) {
      IConditionalInterpreter staticInterpreter = getStaticInterpreter(node);
      ContextImpl interpreterContext = getInterpreterContext();
      interpreterContext.setRootInterpreter(staticInterpreter);

      interpreterReady = true;
    }
  }

  private IConditionalInterpreter getStaticInterpreter(SNode referenceNode) {
    Iterable<SNode> interpreterNodes = CachedInterpreterFinder.getInstance().findInterpretersForCategory(INTERPRETER_CATEGORY);

    int newHash = ((Object) interpreterNodes).hashCode();
    if (this.interpreter == null || this.storedHash != newHash) {
      this.interpreter = new CombinedConditionalInterpreter(Sequence.fromIterable(SNodeOperations.ofConcept(interpreterNodes, CONCEPTS.ConditionalInterpreter$C4)).select((it) -> ((IConditionalInterpreter) InterpreterRegistry.getInterpreterExecutable(it))).toGenericArray(IConditionalInterpreter.class));

      this.storedHash = newHash;
    }

    return this.interpreter;
  }

  private ContextImpl getInterpreterContext() {
    if (interpreterContext == null) {
      interpreterContext = new ContextImpl();
      interpreterContext.setNodeTypeCache(new NodeTypeCachePointerImpl());

      interpreterContext.setNodeValueCache(null);
    }

    return interpreterContext;
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept ConditionalInterpreter$C4 = MetaAdapterFactory.getConcept(0x47f075a6558e4640L, 0xa6067ce0236c8023L, 0x761e4e6b8ed33e66L, "com.mbeddr.mpsutil.interpreter.structure.ConditionalInterpreter");
  }
}
