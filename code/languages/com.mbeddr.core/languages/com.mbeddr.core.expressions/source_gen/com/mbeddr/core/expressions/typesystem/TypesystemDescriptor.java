package com.mbeddr.core.expressions.typesystem;

/*Generated by MPS */

import jetbrains.mps.lang.typesystem.runtime.BaseHelginsDescriptor;
import jetbrains.mps.lang.typesystem.runtime.InferenceRule_Runtime;
import jetbrains.mps.lang.typesystem.runtime.NonTypesystemRule_Runtime;
import jetbrains.mps.lang.typesystem.runtime.SubtypingRule_Runtime;
import jetbrains.mps.lang.typesystem.runtime.ComparisonRule_Runtime;
import jetbrains.mps.lang.typesystem.runtime.InequationReplacementRule_Runtime;
import jetbrains.mps.lang.typesystem.runtime.OverloadedOperationsTypesProvider;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.typesystem.inference.SubtypingManager;
import jetbrains.mps.errors.IRuleConflictWarningProducer;
import com.mbeddr.core.expressions.behavior.Expression__BehaviorDescriptor;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import com.mbeddr.core.expressions.behavior.NumberEvaluationHelper;
import java.util.Objects;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.typesystem.inference.TypeChecker;
import jetbrains.mps.smodel.builder.SNodeBuilder;
import org.jetbrains.mps.openapi.language.SConcept;
import org.jetbrains.mps.openapi.language.SInterfaceConcept;
import org.jetbrains.mps.openapi.language.SContainmentLink;

public class TypesystemDescriptor extends BaseHelginsDescriptor {
  public TypesystemDescriptor() {
    {
      InferenceRule_Runtime inferenceRule = new typeof_AssignmentExpr_InferenceRule();
      this.myInferenceRules.add(inferenceRule);
    }
    {
      InferenceRule_Runtime inferenceRule = new typeof_BinaryEqualityComparisonExpression_InferenceRule();
      this.myInferenceRules.add(inferenceRule);
    }
    {
      InferenceRule_Runtime inferenceRule = new typeof_BinaryExpression_InferenceRule();
      this.myInferenceRules.add(inferenceRule);
    }
    {
      InferenceRule_Runtime inferenceRule = new typeof_BinaryNumberLiteral_InferenceRule();
      this.myInferenceRules.add(inferenceRule);
    }
    {
      InferenceRule_Runtime inferenceRule = new typeof_BinaryOrderedComparisonExpression_InferenceRule();
      this.myInferenceRules.add(inferenceRule);
    }
    {
      InferenceRule_Runtime inferenceRule = new typeof_BitwiseNotExpression_InferenceRule();
      this.myInferenceRules.add(inferenceRule);
    }
    {
      InferenceRule_Runtime inferenceRule = new typeof_BooleanLiteral_InferenceRule();
      this.myInferenceRules.add(inferenceRule);
    }
    {
      InferenceRule_Runtime inferenceRule = new typeof_CastExpression_InferenceRule();
      this.myInferenceRules.add(inferenceRule);
    }
    {
      InferenceRule_Runtime inferenceRule = new typeof_CharLiteral_InferenceRule();
      this.myInferenceRules.add(inferenceRule);
    }
    {
      InferenceRule_Runtime inferenceRule = new typeof_CommentedContent_InferenceRule();
      this.myInferenceRules.add(inferenceRule);
    }
    {
      InferenceRule_Runtime inferenceRule = new typeof_ExpressionList_InferenceRule();
      this.myInferenceRules.add(inferenceRule);
    }
    {
      InferenceRule_Runtime inferenceRule = new typeof_GenericDotExpression_InferenceRule();
      this.myInferenceRules.add(inferenceRule);
    }
    {
      InferenceRule_Runtime inferenceRule = new typeof_HexNumberLiteral_InferenceRule();
      this.myInferenceRules.add(inferenceRule);
    }
    {
      InferenceRule_Runtime inferenceRule = new typeof_ITyped_InferenceRule();
      this.myInferenceRules.add(inferenceRule);
    }
    {
      InferenceRule_Runtime inferenceRule = new typeof_IntPtrT_InferenceRule();
      this.myInferenceRules.add(inferenceRule);
    }
    {
      InferenceRule_Runtime inferenceRule = new typeof_NotExpression_InferenceRule();
      this.myInferenceRules.add(inferenceRule);
    }
    {
      InferenceRule_Runtime inferenceRule = new typeof_NotParsedExpression_InferenceRule();
      this.myInferenceRules.add(inferenceRule);
    }
    {
      InferenceRule_Runtime inferenceRule = new typeof_NumberLiteral_InferenceRule();
      this.myInferenceRules.add(inferenceRule);
    }
    {
      InferenceRule_Runtime inferenceRule = new typeof_OctalNumberLiteral_InferenceRule();
      this.myInferenceRules.add(inferenceRule);
    }
    {
      InferenceRule_Runtime inferenceRule = new typeof_ParensExpression_InferenceRule();
      this.myInferenceRules.add(inferenceRule);
    }
    {
      InferenceRule_Runtime inferenceRule = new typeof_PrimitiveBasicIntegralType_InferenceRule();
      this.myInferenceRules.add(inferenceRule);
    }
    {
      InferenceRule_Runtime inferenceRule = new typeof_PtrDiffT_InferenceRule();
      this.myInferenceRules.add(inferenceRule);
    }
    {
      InferenceRule_Runtime inferenceRule = new typeof_SSizeT_InferenceRule();
      this.myInferenceRules.add(inferenceRule);
    }
    {
      InferenceRule_Runtime inferenceRule = new typeof_ScientificNumber_InferenceRule();
      this.myInferenceRules.add(inferenceRule);
    }
    {
      InferenceRule_Runtime inferenceRule = new typeof_SizeT_InferenceRule();
      this.myInferenceRules.add(inferenceRule);
    }
    {
      InferenceRule_Runtime inferenceRule = new typeof_StaticValueExpression_InferenceRule();
      this.myInferenceRules.add(inferenceRule);
    }
    {
      InferenceRule_Runtime inferenceRule = new typeof_TernaryExpression_InferenceRule();
      this.myInferenceRules.add(inferenceRule);
    }
    {
      InferenceRule_Runtime inferenceRule = new typeof_Type_InferenceRule();
      this.myInferenceRules.add(inferenceRule);
    }
    {
      InferenceRule_Runtime inferenceRule = new typeof_UIntPtrT_InferenceRule();
      this.myInferenceRules.add(inferenceRule);
    }
    {
      InferenceRule_Runtime inferenceRule = new typeof_UnaryArithmeticExpression_InferenceRule();
      this.myInferenceRules.add(inferenceRule);
    }
    {
      InferenceRule_Runtime inferenceRule = new typeof_UnaryMinusExpression_InferenceRule();
      this.myInferenceRules.add(inferenceRule);
    }
    {
      InferenceRule_Runtime inferenceRule = new typeof_VaArgExpression_InferenceRule();
      this.myInferenceRules.add(inferenceRule);
    }
    {
      InferenceRule_Runtime inferenceRule = new typeof_VaList_InferenceRule();
      this.myInferenceRules.add(inferenceRule);
    }
    {
      NonTypesystemRule_Runtime nonTypesystemRule = new check_AssignmentExpr_NonTypesystemRule();
      this.myNonTypesystemRules.add(nonTypesystemRule);
    }
    {
      NonTypesystemRule_Runtime nonTypesystemRule = new check_BinaryComparisonExpressionSigned_NonTypesystemRule();
      this.myNonTypesystemRules.add(nonTypesystemRule);
    }
    {
      NonTypesystemRule_Runtime nonTypesystemRule = new check_BitwiseNotExpression_NonTypesystemRule();
      this.myNonTypesystemRules.add(nonTypesystemRule);
    }
    {
      NonTypesystemRule_Runtime nonTypesystemRule = new check_DirectAssignmentExpression_NonTypesystemRule();
      this.myNonTypesystemRules.add(nonTypesystemRule);
    }
    {
      NonTypesystemRule_Runtime nonTypesystemRule = new check_DivExpression_NonTypesystemRule();
      this.myNonTypesystemRules.add(nonTypesystemRule);
    }
    {
      NonTypesystemRule_Runtime nonTypesystemRule = new check_ExpressionList_NonTypesystemRule();
      this.myNonTypesystemRules.add(nonTypesystemRule);
    }
    {
      NonTypesystemRule_Runtime nonTypesystemRule = new check_IInitializationContext_NonTypesystemRule();
      this.myNonTypesystemRules.add(nonTypesystemRule);
    }
    {
      NonTypesystemRule_Runtime nonTypesystemRule = new check_INumericLiteral_NonTypesystemRule();
      this.myNonTypesystemRules.add(nonTypesystemRule);
    }
    {
      NonTypesystemRule_Runtime nonTypesystemRule = new check_IOnlyInInitialization_NonTypesystemRule();
      this.myNonTypesystemRules.add(nonTypesystemRule);
    }
    {
      NonTypesystemRule_Runtime nonTypesystemRule = new check_ITyped_NameControlled_NonTypesystemRule();
      this.myNonTypesystemRules.add(nonTypesystemRule);
    }
    {
      NonTypesystemRule_Runtime nonTypesystemRule = new check_IVariableDeclaration_NonTypesystemRule();
      this.myNonTypesystemRules.add(nonTypesystemRule);
    }
    {
      NonTypesystemRule_Runtime nonTypesystemRule = new check_TypeSizeConfiguration_NonTypesystemRule();
      this.myNonTypesystemRules.add(nonTypesystemRule);
    }
    {
      NonTypesystemRule_Runtime nonTypesystemRule = new check_TypeSizeSpecification_NonTypesystemRule();
      this.myNonTypesystemRules.add(nonTypesystemRule);
    }
    {
      NonTypesystemRule_Runtime nonTypesystemRule = new check_UnaryMinusExpression_NonTypesystemRule();
      this.myNonTypesystemRules.add(nonTypesystemRule);
    }
    {
      NonTypesystemRule_Runtime nonTypesystemRule = new check_UnaryPrePosModificationExpression_NonTypesystemRule();
      this.myNonTypesystemRules.add(nonTypesystemRule);
    }
    {
      NonTypesystemRule_Runtime nonTypesystemRule = new check_VolatileConst_NonTypesystemRule();
      this.myNonTypesystemRules.add(nonTypesystemRule);
    }
    {
      NonTypesystemRule_Runtime nonTypesystemRule = new check_numberLiteral_NonTypesystemRule();
      this.myNonTypesystemRules.add(nonTypesystemRule);
    }
    {
      NonTypesystemRule_Runtime nonTypesystemRule = new isTypeSizeAllowed_NonTypesystemRule();
      this.myNonTypesystemRules.add(nonTypesystemRule);
    }
    {
      NonTypesystemRule_Runtime nonTypesystemRule = new unbalancedBinaryExpression_NonTypesystemRule();
      this.myNonTypesystemRules.add(nonTypesystemRule);
    }
    {
      SubtypingRule_Runtime subtypingRule = new SSizeTIsSupertypeOfMappedType_SubtypingRule();
      this.mySubtypingRules.add(subtypingRule);
    }
    {
      SubtypingRule_Runtime subtypingRule = new SizeTIsSupertypeOfMappedType_SubtypingRule();
      this.mySubtypingRules.add(subtypingRule);
    }
    {
      SubtypingRule_Runtime subtypingRule = new constSupertypeOfType_SubtypingRule();
      this.mySubtypingRules.add(subtypingRule);
    }
    {
      SubtypingRule_Runtime subtypingRule = new superTypeOfSSizeT_SubtypingRule();
      this.mySubtypingRules.add(subtypingRule);
    }
    {
      SubtypingRule_Runtime subtypingRule = new superTypeOfSizeT_SubtypingRule();
      this.mySubtypingRules.add(subtypingRule);
    }
    {
      SubtypingRule_Runtime subtypingRule = new supertypeofPtrDiffT_SubtypingRule();
      this.mySubtypingRules.add(subtypingRule);
    }
    {
      SubtypingRule_Runtime subtypingRule = new supertypeof_CharType_SubtypingRule();
      this.mySubtypingRules.add(subtypingRule);
    }
    {
      SubtypingRule_Runtime subtypingRule = new supertypeof_DoubleType_SubtypingRule();
      this.mySubtypingRules.add(subtypingRule);
    }
    {
      SubtypingRule_Runtime subtypingRule = new supertypeof_FloatType_SubtypingRule();
      this.mySubtypingRules.add(subtypingRule);
    }
    {
      SubtypingRule_Runtime subtypingRule = new supertypeof_Int16Type_SubtypingRule();
      this.mySubtypingRules.add(subtypingRule);
    }
    {
      SubtypingRule_Runtime subtypingRule = new supertypeof_Int32tType_SubtypingRule();
      this.mySubtypingRules.add(subtypingRule);
    }
    {
      SubtypingRule_Runtime subtypingRule = new supertypeof_Int64tType_SubtypingRule();
      this.mySubtypingRules.add(subtypingRule);
    }
    {
      SubtypingRule_Runtime subtypingRule = new supertypeof_Int8tType_SubtypingRule();
      this.mySubtypingRules.add(subtypingRule);
    }
    {
      SubtypingRule_Runtime subtypingRule = new supertypeof_LongDoubleType_SubtypingRule();
      this.mySubtypingRules.add(subtypingRule);
    }
    {
      SubtypingRule_Runtime subtypingRule = new supertypeof_UInt16Type_SubtypingRule();
      this.mySubtypingRules.add(subtypingRule);
    }
    {
      SubtypingRule_Runtime subtypingRule = new supertypeof_UInt32Type_SubtypingRule();
      this.mySubtypingRules.add(subtypingRule);
    }
    {
      SubtypingRule_Runtime subtypingRule = new supertypeof_UInt64Type_SubtypingRule();
      this.mySubtypingRules.add(subtypingRule);
    }
    {
      SubtypingRule_Runtime subtypingRule = new supertypeof_UInt8Type_SubtypingRule();
      this.mySubtypingRules.add(subtypingRule);
    }
    {
      SubtypingRule_Runtime subtypingRule = new weakSupertypeOfUInt16Type_SubtypingRule();
      this.mySubtypingRules.add(subtypingRule);
    }
    {
      SubtypingRule_Runtime subtypingRule = new weakSupertypeOfUInt32Type_SubtypingRule();
      this.mySubtypingRules.add(subtypingRule);
    }
    {
      SubtypingRule_Runtime subtypingRule = new weakSupertypeOfUInt8Type_SubtypingRule();
      this.mySubtypingRules.add(subtypingRule);
    }
    {
      ComparisonRule_Runtime comparisonRule = new compareMeetTypeWithMeetType_ComparisonRule();
      this.myComparisonRules.add(comparisonRule);
    }
    {
      ComparisonRule_Runtime comparisonRule = new comparePrimitiveTypeWithMeetType_ComparisonRule();
      this.myComparisonRules.add(comparisonRule);
    }
    {
      ComparisonRule_Runtime comparisonRule = new comparePrimitiveWithPrimitiveType_ComparisonRule();
      this.myComparisonRules.add(comparisonRule);
    }
    {
      ComparisonRule_Runtime comparisonRule = new compareSSizeTWithMeetType_ComparisonRule();
      this.myComparisonRules.add(comparisonRule);
    }
    {
      ComparisonRule_Runtime comparisonRule = new compareSSizeTWithPrimitiveType_ComparisonRule();
      this.myComparisonRules.add(comparisonRule);
    }
    {
      ComparisonRule_Runtime comparisonRule = new compareSizeTWithMeetType_ComparisonRule();
      this.myComparisonRules.add(comparisonRule);
    }
    {
      ComparisonRule_Runtime comparisonRule = new compareSizeTWithPrimitiveType_ComparisonRule();
      this.myComparisonRules.add(comparisonRule);
    }
    {
      InequationReplacementRule_Runtime eliminationRule = new getRidOfConst_InequationReplacementRule();
      this.myInequationReplacementRules.add(eliminationRule);
    }
    {
      InequationReplacementRule_Runtime eliminationRule = new getRidOfVolatile_InequationReplacementRule();
      this.myInequationReplacementRules.add(eliminationRule);
    }
    {
      InequationReplacementRule_Runtime eliminationRule = new replaceCharType_InequationReplacementRule();
      this.myInequationReplacementRules.add(eliminationRule);
    }
    {
      InequationReplacementRule_Runtime eliminationRule = new replaceCharType2_InequationReplacementRule();
      this.myInequationReplacementRules.add(eliminationRule);
    }
    {
      InequationReplacementRule_Runtime eliminationRule = new replacePrimitiveBasicIntegralType_InequationReplacementRule();
      this.myInequationReplacementRules.add(eliminationRule);
    }
    {
      InequationReplacementRule_Runtime eliminationRule = new replacePrimitiveBasicIntegralType2_InequationReplacementRule();
      this.myInequationReplacementRules.add(eliminationRule);
    }
    {
      InequationReplacementRule_Runtime eliminationRule = new replacePtrDiffType_InequationReplacementRule();
      this.myInequationReplacementRules.add(eliminationRule);
    }
    {
      InequationReplacementRule_Runtime eliminationRule = new replacePtrDiffType2_InequationReplacementRule();
      this.myInequationReplacementRules.add(eliminationRule);
    }
    this.myOverloadedOperationsTypesProviders.add(new CustomOverloadedOperationsTypesProvider_e(CONCEPTS.BinaryComparisonExpression$sn));
    this.myOverloadedOperationsTypesProviders.add(new CustomOverloadedOperationsTypesProvider_b(CONCEPTS.BitwiseAndExpression$HN));
    this.myOverloadedOperationsTypesProviders.add(new CustomOverloadedOperationsTypesProvider_b(CONCEPTS.BitwiseLeftShiftExpression$Kh));
    this.myOverloadedOperationsTypesProviders.add(new CustomOverloadedOperationsTypesProvider_b(CONCEPTS.BitwiseORExpression$vE));
    this.myOverloadedOperationsTypesProviders.add(new CustomOverloadedOperationsTypesProvider_b(CONCEPTS.BitwiseRightShiftExpression$hf));
    this.myOverloadedOperationsTypesProviders.add(new CustomOverloadedOperationsTypesProvider_b(CONCEPTS.BitwiseXORExpression$ht));
    this.myOverloadedOperationsTypesProviders.add(new CustomOverloadedOperationsTypesProvider_b(CONCEPTS.ModuloExpression$ia));
    this.myOverloadedOperationsTypesProviders.add(new CustomOverloadedOperationsTypesProvider_c(CONCEPTS.DirectDivAssignmentExpression$yU));
    this.myOverloadedOperationsTypesProviders.add(new CustomOverloadedOperationsTypesProvider_c(CONCEPTS.DirectMinusAssignmentExpression$Wu));
    this.myOverloadedOperationsTypesProviders.add(new CustomOverloadedOperationsTypesProvider_c(CONCEPTS.DirectMultiAssignmentExpression$Xs));
    this.myOverloadedOperationsTypesProviders.add(new CustomOverloadedOperationsTypesProvider_c(CONCEPTS.DirectPlusAssignmentExpression$1h));
    this.myOverloadedOperationsTypesProviders.add(new CustomOverloadedOperationsTypesProvider_d(CONCEPTS.DirectBitwiseANDAssignmentExpression$kL));
    this.myOverloadedOperationsTypesProviders.add(new CustomOverloadedOperationsTypesProvider_d(CONCEPTS.DirectBitwiseLeftShiftAssignmentExpression$iP));
    this.myOverloadedOperationsTypesProviders.add(new CustomOverloadedOperationsTypesProvider_d(CONCEPTS.DirectBitwiseORAssignmentExpression$wS));
    this.myOverloadedOperationsTypesProviders.add(new CustomOverloadedOperationsTypesProvider_d(CONCEPTS.DirectBitwiseRightShiftExpression$jN));
    this.myOverloadedOperationsTypesProviders.add(new CustomOverloadedOperationsTypesProvider_d(CONCEPTS.DirectBitwiseXORAssignmentExpression$lJ));
    this.myOverloadedOperationsTypesProviders.add(new CustomOverloadedOperationsTypesProvider_d(CONCEPTS.DirectModuloAssignmentExpression$hR));
    this.myOverloadedOperationsTypesProviders.add(new CustomOverloadedOperationsTypesProvider_a(CONCEPTS.BinaryLogicalExpression$PG));
    this.myOverloadedOperationsTypesProviders.add(new CustomOverloadedOperationsTypesProvider_a_0(CONCEPTS.DivExpression$WL));
    this.myOverloadedOperationsTypesProviders.add(new CustomOverloadedOperationsTypesProvider_a_0(CONCEPTS.MinusExpression$KE));
    this.myOverloadedOperationsTypesProviders.add(new CustomOverloadedOperationsTypesProvider_a_0(CONCEPTS.MultiExpression$VN));
    this.myOverloadedOperationsTypesProviders.add(new CustomOverloadedOperationsTypesProvider_a_0(CONCEPTS.PlusExpression$If));
  }
  public static class CustomOverloadedOperationsTypesProvider_e extends OverloadedOperationsTypesProvider {
    public CustomOverloadedOperationsTypesProvider_e(SAbstractConcept concept) {
      this.myLeftOperandType = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x10802efe25aL, "jetbrains.mps.lang.core.structure.BaseConcept"));
      this.myRightOperandType = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x10802efe25aL, "jetbrains.mps.lang.core.structure.BaseConcept"));
      this.myOperationConcept = concept;
      this.myLeftTypeIsExact = false;
      this.myRightTypeIsExact = false;
      this.myRightIsStrong = false;
      this.myLeftIsStrong = false;
      this.myRuleModelId = "r:1f4b6c73-0d50-4599-bc8a-9f6948adf243(com.mbeddr.core.expressions.typesystem)";
      this.myRuleNodeId = "1664480272136308574";
    }
    public SNode getOperationType(SNode operation, SNode leftOperandType, SNode rightOperandType) {
      return SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0x61c69711ed614850L, 0x81d97714ff227fb0L, 0x7af69e2e83a1ba3aL, "com.mbeddr.core.expressions.structure.BooleanType"));
    }
    public boolean isApplicable(SubtypingManager subtypingManager, SNode operation, SNode leftOperandType, SNode rightOperandType) {
      if (AssignableSuperTypeHelper.hasComparableSuperTypes(leftOperandType, rightOperandType)) {
        return true;
      }
      return false;
    }
    @Override
    public void reportConflict(IRuleConflictWarningProducer producer) {
      producer.produceWarning(myRuleModelId, myRuleNodeId);
    }
  }
  public static class CustomOverloadedOperationsTypesProvider_b extends OverloadedOperationsTypesProvider {
    public CustomOverloadedOperationsTypesProvider_b(SAbstractConcept concept) {
      this.myLeftOperandType = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0x61c69711ed614850L, 0x81d97714ff227fb0L, 0x7af69e2e83a1ba38L, "com.mbeddr.core.expressions.structure.PrimitiveType"));
      this.myRightOperandType = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0x61c69711ed614850L, 0x81d97714ff227fb0L, 0x7af69e2e83a1ba38L, "com.mbeddr.core.expressions.structure.PrimitiveType"));
      this.myOperationConcept = concept;
      this.myLeftTypeIsExact = false;
      this.myRightTypeIsExact = false;
      this.myRightIsStrong = false;
      this.myLeftIsStrong = false;
      this.myRuleModelId = "r:1f4b6c73-0d50-4599-bc8a-9f6948adf243(com.mbeddr.core.expressions.typesystem)";
      this.myRuleNodeId = "3342324201519061667";
    }
    public SNode getOperationType(SNode operation, SNode leftOperandType, SNode rightOperandType) {
      if ((boolean) Expression__BehaviorDescriptor.isStaticallyEvaluatable_id3ilck8Kr3zN.invoke(SNodeOperations.cast(operation, CONCEPTS.BinaryExpression$cR))) {
        return NumberEvaluationHelper.staticType(leftOperandType, rightOperandType, SNodeOperations.cast(operation, CONCEPTS.BinaryExpression$cR));
      }

      // Check if both operants have the same type
      if (Objects.equals(SNodeOperations.getConcept(leftOperandType), SNodeOperations.getConcept(rightOperandType))) {
        return leftOperandType;
      }

      SNode commenSuperType = AssignableSuperTypeHelper.getCommonSuperType(leftOperandType, rightOperandType);
      return commenSuperType;
    }
    public boolean isApplicable(SubtypingManager subtypingManager, SNode operation, SNode leftOperandType, SNode rightOperandType) {
      // Why is the left and right operand type not importend when "is applicable" = true?
      // I think the "is applicalbe" overrides the operand check
      if (SNodeOperations.isInstanceOf(leftOperandType, CONCEPTS.INumber$C8)) {
        if (SNodeOperations.isInstanceOf(rightOperandType, CONCEPTS.INumber$C8)) {
          return true;
        }
      }
      if (SNodeOperations.isInstanceOf(leftOperandType, CONCEPTS.MeetType$ZG) && (ListSequence.fromList(SLinkOperations.getChildren(SNodeOperations.cast(leftOperandType, CONCEPTS.MeetType$ZG), LINKS.argument$r2cT)).findFirst((it) -> SNodeOperations.isInstanceOf(it, CONCEPTS.INumber$C8)) != null)) {
        if (SNodeOperations.isInstanceOf(rightOperandType, CONCEPTS.INumber$C8)) {
          return true;
        }
      }
      if (SNodeOperations.isInstanceOf(leftOperandType, CONCEPTS.INumber$C8)) {
        if (SNodeOperations.isInstanceOf(rightOperandType, CONCEPTS.MeetType$ZG) && (ListSequence.fromList(SLinkOperations.getChildren(SNodeOperations.cast(rightOperandType, CONCEPTS.MeetType$ZG), LINKS.argument$r2cT)).findFirst((it) -> SNodeOperations.isInstanceOf(it, CONCEPTS.INumber$C8)) != null)) {
          return true;
        }
      }
      if (SNodeOperations.isInstanceOf(leftOperandType, CONCEPTS.MeetType$ZG) && (ListSequence.fromList(SLinkOperations.getChildren(SNodeOperations.cast(leftOperandType, CONCEPTS.MeetType$ZG), LINKS.argument$r2cT)).findFirst((it) -> SNodeOperations.isInstanceOf(it, CONCEPTS.INumber$C8)) != null)) {
        if (SNodeOperations.isInstanceOf(rightOperandType, CONCEPTS.MeetType$ZG) && (ListSequence.fromList(SLinkOperations.getChildren(SNodeOperations.cast(rightOperandType, CONCEPTS.MeetType$ZG), LINKS.argument$r2cT)).findFirst((it) -> SNodeOperations.isInstanceOf(it, CONCEPTS.INumber$C8)) != null)) {
          return true;
        }
      }
      return false;
    }
    @Override
    public void reportConflict(IRuleConflictWarningProducer producer) {
      producer.produceWarning(myRuleModelId, myRuleNodeId);
    }
  }
  public static class CustomOverloadedOperationsTypesProvider_c extends OverloadedOperationsTypesProvider {
    public CustomOverloadedOperationsTypesProvider_c(SAbstractConcept concept) {
      this.myLeftOperandType = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0x61c69711ed614850L, 0x81d97714ff227fb0L, 0x7af69e2e83a1ba38L, "com.mbeddr.core.expressions.structure.PrimitiveType"));
      this.myRightOperandType = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0x61c69711ed614850L, 0x81d97714ff227fb0L, 0x7af69e2e83a1ba38L, "com.mbeddr.core.expressions.structure.PrimitiveType"));
      this.myOperationConcept = concept;
      this.myLeftTypeIsExact = false;
      this.myRightTypeIsExact = false;
      this.myRightIsStrong = false;
      this.myLeftIsStrong = false;
      this.myRuleModelId = "r:1f4b6c73-0d50-4599-bc8a-9f6948adf243(com.mbeddr.core.expressions.typesystem)";
      this.myRuleNodeId = "3820836583575319966";
    }
    public SNode getOperationType(SNode operation, SNode leftOperandType, SNode rightOperandType) {
      if ((boolean) Expression__BehaviorDescriptor.isStaticallyEvaluatable_id3ilck8Kr3zN.invoke(operation)) {
        return NumberEvaluationHelper.staticType(leftOperandType, rightOperandType, operation);
      }

      // Check if both operants have the same type
      if (Objects.equals(SNodeOperations.getConcept(leftOperandType), SNodeOperations.getConcept(rightOperandType))) {
        return leftOperandType;
      }

      // Calculate all supertypes from the right operant and check if the "near" supertype equal to the
      // type of the left operantcon
      SNode superType = AssignableSuperTypeHelper.getAssignableSuperType(leftOperandType, rightOperandType);
      if (superType != null) {
        return superType;
      }

      return null;
    }
    public boolean isApplicable(SubtypingManager subtypingManager, SNode operation, SNode leftOperandType, SNode rightOperandType) {
      return TypeChecker.getInstance().getSubtypingManager().isSubtype(rightOperandType, leftOperandType);
    }
    @Override
    public void reportConflict(IRuleConflictWarningProducer producer) {
      producer.produceWarning(myRuleModelId, myRuleNodeId);
    }
  }
  public static class CustomOverloadedOperationsTypesProvider_d extends OverloadedOperationsTypesProvider {
    public CustomOverloadedOperationsTypesProvider_d(SAbstractConcept concept) {
      this.myLeftOperandType = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0x61c69711ed614850L, 0x81d97714ff227fb0L, 0x7af69e2e83a1ba38L, "com.mbeddr.core.expressions.structure.PrimitiveType"));
      this.myRightOperandType = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0x61c69711ed614850L, 0x81d97714ff227fb0L, 0x7af69e2e83a1ba38L, "com.mbeddr.core.expressions.structure.PrimitiveType"));
      this.myOperationConcept = concept;
      this.myLeftTypeIsExact = false;
      this.myRightTypeIsExact = false;
      this.myRightIsStrong = false;
      this.myLeftIsStrong = false;
      this.myRuleModelId = "r:1f4b6c73-0d50-4599-bc8a-9f6948adf243(com.mbeddr.core.expressions.typesystem)";
      this.myRuleNodeId = "7193082937527768554";
    }
    public SNode getOperationType(SNode operation, SNode leftOperandType, SNode rightOperandType) {
      if ((boolean) Expression__BehaviorDescriptor.isStaticallyEvaluatable_id3ilck8Kr3zN.invoke(operation)) {
        return NumberEvaluationHelper.staticType(leftOperandType, rightOperandType, operation);
      }

      // Check if both operants have the same type
      if (Objects.equals(SNodeOperations.getConcept(leftOperandType), SNodeOperations.getConcept(rightOperandType))) {
        return leftOperandType;
      }

      // Calculate all supertypes from the right operant and check if the "near" supertype equal to the
      // type of the left operantcon
      SNode superType = AssignableSuperTypeHelper.getAssignableSuperType(leftOperandType, rightOperandType);
      if (superType != null) {
        return superType;
      }

      return null;
    }
    public boolean isApplicable(SubtypingManager subtypingManager, SNode operation, SNode leftOperandType, SNode rightOperandType) {
      // Why is the left and right operand type not importend when "is applicable" = true?
      // I think the "is applicalbe" overrides the operand check
      if (SNodeOperations.isInstanceOf(leftOperandType, CONCEPTS.INumber$C8)) {
        if (SNodeOperations.isInstanceOf(rightOperandType, CONCEPTS.INumber$C8)) {
          return true;
        }
      }
      if (SNodeOperations.isInstanceOf(leftOperandType, CONCEPTS.MeetType$ZG) && (ListSequence.fromList(SLinkOperations.getChildren(SNodeOperations.cast(leftOperandType, CONCEPTS.MeetType$ZG), LINKS.argument$r2cT)).findFirst((it) -> SNodeOperations.isInstanceOf(it, CONCEPTS.INumber$C8)) != null)) {
        if (SNodeOperations.isInstanceOf(rightOperandType, CONCEPTS.INumber$C8)) {
          return true;
        }
      }
      if (SNodeOperations.isInstanceOf(leftOperandType, CONCEPTS.INumber$C8)) {
        if (SNodeOperations.isInstanceOf(rightOperandType, CONCEPTS.MeetType$ZG) && (ListSequence.fromList(SLinkOperations.getChildren(SNodeOperations.cast(rightOperandType, CONCEPTS.MeetType$ZG), LINKS.argument$r2cT)).findFirst((it) -> SNodeOperations.isInstanceOf(it, CONCEPTS.INumber$C8)) != null)) {
          return true;
        }
      }
      if (SNodeOperations.isInstanceOf(leftOperandType, CONCEPTS.MeetType$ZG) && (ListSequence.fromList(SLinkOperations.getChildren(SNodeOperations.cast(leftOperandType, CONCEPTS.MeetType$ZG), LINKS.argument$r2cT)).findFirst((it) -> SNodeOperations.isInstanceOf(it, CONCEPTS.INumber$C8)) != null)) {
        if (SNodeOperations.isInstanceOf(rightOperandType, CONCEPTS.MeetType$ZG) && (ListSequence.fromList(SLinkOperations.getChildren(SNodeOperations.cast(rightOperandType, CONCEPTS.MeetType$ZG), LINKS.argument$r2cT)).findFirst((it) -> SNodeOperations.isInstanceOf(it, CONCEPTS.INumber$C8)) != null)) {
          return true;
        }
      }

      return false;
    }
    @Override
    public void reportConflict(IRuleConflictWarningProducer producer) {
      producer.produceWarning(myRuleModelId, myRuleNodeId);
    }
  }
  public static class CustomOverloadedOperationsTypesProvider_a extends OverloadedOperationsTypesProvider {
    public CustomOverloadedOperationsTypesProvider_a(SAbstractConcept concept) {
      this.myLeftOperandType = createBooleanType_3ist9o_a0a0a5();
      this.myRightOperandType = createBooleanType_3ist9o_a0b0a5();
      this.myOperationConcept = concept;
      this.myLeftTypeIsExact = false;
      this.myRightTypeIsExact = false;
      this.myRightIsStrong = false;
      this.myLeftIsStrong = false;
      this.myRuleModelId = "r:1f4b6c73-0d50-4599-bc8a-9f6948adf243(com.mbeddr.core.expressions.typesystem)";
      this.myRuleNodeId = "8399455261460730077";
    }
    public SNode getOperationType(SNode operation, SNode leftOperandType, SNode rightOperandType) {
      return createBooleanType_3ist9o_a0a1f();
    }
    @Override
    public void reportConflict(IRuleConflictWarningProducer producer) {
      producer.produceWarning(myRuleModelId, myRuleNodeId);
    }
    private static SNode createBooleanType_3ist9o_a0a0a5() {
      SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.BooleanType$fL);
      return n0.getResult();
    }
    private static SNode createBooleanType_3ist9o_a0b0a5() {
      SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.BooleanType$fL);
      return n0.getResult();
    }
    private static SNode createBooleanType_3ist9o_a0a1f() {
      SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.BooleanType$fL);
      return n0.getResult();
    }
  }
  public static class CustomOverloadedOperationsTypesProvider_a_0 extends OverloadedOperationsTypesProvider {
    public CustomOverloadedOperationsTypesProvider_a_0(SAbstractConcept concept) {
      this.myLeftOperandType = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0x61c69711ed614850L, 0x81d97714ff227fb0L, 0x7af69e2e83a1ba38L, "com.mbeddr.core.expressions.structure.PrimitiveType"));
      this.myRightOperandType = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0x61c69711ed614850L, 0x81d97714ff227fb0L, 0x7af69e2e83a1ba38L, "com.mbeddr.core.expressions.structure.PrimitiveType"));
      this.myOperationConcept = concept;
      this.myLeftTypeIsExact = false;
      this.myRightTypeIsExact = false;
      this.myRightIsStrong = false;
      this.myLeftIsStrong = false;
      this.myRuleModelId = "r:1f4b6c73-0d50-4599-bc8a-9f6948adf243(com.mbeddr.core.expressions.typesystem)";
      this.myRuleNodeId = "8864856114140206253";
    }
    public SNode getOperationType(SNode operation, SNode leftOperandType, SNode rightOperandType) {
      if ((boolean) Expression__BehaviorDescriptor.isStaticallyEvaluatable_id3ilck8Kr3zN.invoke(operation)) {
        return NumberEvaluationHelper.staticType(leftOperandType, rightOperandType, operation);
      }

      // Check if both operants have the same type
      if (Objects.equals(SNodeOperations.getConcept(leftOperandType), SNodeOperations.getConcept(rightOperandType))) {
        return leftOperandType;
      }
      SNode commenSuperType = AssignableSuperTypeHelper.getCommonSuperType(leftOperandType, rightOperandType);
      return commenSuperType;
    }
    @Override
    public void reportConflict(IRuleConflictWarningProducer producer) {
      producer.produceWarning(myRuleModelId, myRuleNodeId);
    }
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept BinaryComparisonExpression$sn = MetaAdapterFactory.getConcept(0x61c69711ed614850L, 0x81d97714ff227fb0L, 0x7af69e2e83a1ba3fL, "com.mbeddr.core.expressions.structure.BinaryComparisonExpression");
    /*package*/ static final SConcept BitwiseAndExpression$HN = MetaAdapterFactory.getConcept(0x61c69711ed614850L, 0x81d97714ff227fb0L, 0x52bff1066a5caaafL, "com.mbeddr.core.expressions.structure.BitwiseAndExpression");
    /*package*/ static final SConcept BitwiseLeftShiftExpression$Kh = MetaAdapterFactory.getConcept(0x61c69711ed614850L, 0x81d97714ff227fb0L, 0x7d15ed3ba56cbdbfL, "com.mbeddr.core.expressions.structure.BitwiseLeftShiftExpression");
    /*package*/ static final SConcept BitwiseORExpression$vE = MetaAdapterFactory.getConcept(0x61c69711ed614850L, 0x81d97714ff227fb0L, 0xfc5c413252eabc7L, "com.mbeddr.core.expressions.structure.BitwiseORExpression");
    /*package*/ static final SConcept BitwiseRightShiftExpression$hf = MetaAdapterFactory.getConcept(0x61c69711ed614850L, 0x81d97714ff227fb0L, 0x7d15ed3ba569dd50L, "com.mbeddr.core.expressions.structure.BitwiseRightShiftExpression");
    /*package*/ static final SConcept BitwiseXORExpression$ht = MetaAdapterFactory.getConcept(0x61c69711ed614850L, 0x81d97714ff227fb0L, 0x7d15ed3ba56988f4L, "com.mbeddr.core.expressions.structure.BitwiseXORExpression");
    /*package*/ static final SConcept ModuloExpression$ia = MetaAdapterFactory.getConcept(0x61c69711ed614850L, 0x81d97714ff227fb0L, 0x26d9c9de7721b2b0L, "com.mbeddr.core.expressions.structure.ModuloExpression");
    /*package*/ static final SConcept DirectDivAssignmentExpression$yU = MetaAdapterFactory.getConcept(0x61c69711ed614850L, 0x81d97714ff227fb0L, 0x3b4cdae3e3167374L, "com.mbeddr.core.expressions.structure.DirectDivAssignmentExpression");
    /*package*/ static final SConcept DirectMinusAssignmentExpression$Wu = MetaAdapterFactory.getConcept(0x61c69711ed614850L, 0x81d97714ff227fb0L, 0x3b4cdae3e316735aL, "com.mbeddr.core.expressions.structure.DirectMinusAssignmentExpression");
    /*package*/ static final SConcept DirectMultiAssignmentExpression$Xs = MetaAdapterFactory.getConcept(0x61c69711ed614850L, 0x81d97714ff227fb0L, 0x3b4cdae3e316735cL, "com.mbeddr.core.expressions.structure.DirectMultiAssignmentExpression");
    /*package*/ static final SConcept DirectPlusAssignmentExpression$1h = MetaAdapterFactory.getConcept(0x61c69711ed614850L, 0x81d97714ff227fb0L, 0x350656a10cd18bccL, "com.mbeddr.core.expressions.structure.DirectPlusAssignmentExpression");
    /*package*/ static final SConcept DirectBitwiseANDAssignmentExpression$kL = MetaAdapterFactory.getConcept(0x61c69711ed614850L, 0x81d97714ff227fb0L, 0x63d2f6d2334415d9L, "com.mbeddr.core.expressions.structure.DirectBitwiseANDAssignmentExpression");
    /*package*/ static final SConcept DirectBitwiseLeftShiftAssignmentExpression$iP = MetaAdapterFactory.getConcept(0x61c69711ed614850L, 0x81d97714ff227fb0L, 0x63d2f6d2334415d5L, "com.mbeddr.core.expressions.structure.DirectBitwiseLeftShiftAssignmentExpression");
    /*package*/ static final SConcept DirectBitwiseORAssignmentExpression$wS = MetaAdapterFactory.getConcept(0x61c69711ed614850L, 0x81d97714ff227fb0L, 0x63d2f6d2334415ddL, "com.mbeddr.core.expressions.structure.DirectBitwiseORAssignmentExpression");
    /*package*/ static final SConcept DirectBitwiseRightShiftExpression$jN = MetaAdapterFactory.getConcept(0x61c69711ed614850L, 0x81d97714ff227fb0L, 0x63d2f6d2334415d7L, "com.mbeddr.core.expressions.structure.DirectBitwiseRightShiftExpression");
    /*package*/ static final SConcept DirectBitwiseXORAssignmentExpression$lJ = MetaAdapterFactory.getConcept(0x61c69711ed614850L, 0x81d97714ff227fb0L, 0x63d2f6d2334415dbL, "com.mbeddr.core.expressions.structure.DirectBitwiseXORAssignmentExpression");
    /*package*/ static final SConcept DirectModuloAssignmentExpression$hR = MetaAdapterFactory.getConcept(0x61c69711ed614850L, 0x81d97714ff227fb0L, 0x63d2f6d2334415d3L, "com.mbeddr.core.expressions.structure.DirectModuloAssignmentExpression");
    /*package*/ static final SConcept BinaryLogicalExpression$PG = MetaAdapterFactory.getConcept(0x61c69711ed614850L, 0x81d97714ff227fb0L, 0x7490dc0ede26e046L, "com.mbeddr.core.expressions.structure.BinaryLogicalExpression");
    /*package*/ static final SConcept DivExpression$WL = MetaAdapterFactory.getConcept(0x61c69711ed614850L, 0x81d97714ff227fb0L, 0x4ffba68fe82b621eL, "com.mbeddr.core.expressions.structure.DivExpression");
    /*package*/ static final SConcept MinusExpression$KE = MetaAdapterFactory.getConcept(0x61c69711ed614850L, 0x81d97714ff227fb0L, 0x4ffba68fe82b621aL, "com.mbeddr.core.expressions.structure.MinusExpression");
    /*package*/ static final SConcept MultiExpression$VN = MetaAdapterFactory.getConcept(0x61c69711ed614850L, 0x81d97714ff227fb0L, 0x4ffba68fe82b621cL, "com.mbeddr.core.expressions.structure.MultiExpression");
    /*package*/ static final SConcept PlusExpression$If = MetaAdapterFactory.getConcept(0x61c69711ed614850L, 0x81d97714ff227fb0L, 0x4ffba68fe82b6215L, "com.mbeddr.core.expressions.structure.PlusExpression");
    /*package*/ static final SConcept BinaryExpression$cR = MetaAdapterFactory.getConcept(0x61c69711ed614850L, 0x81d97714ff227fb0L, 0x7af69e2e83a1ba34L, "com.mbeddr.core.expressions.structure.BinaryExpression");
    /*package*/ static final SInterfaceConcept INumber$C8 = MetaAdapterFactory.getInterfaceConcept(0x61c69711ed614850L, 0x81d97714ff227fb0L, 0x4ffba68fe82b6206L, "com.mbeddr.core.expressions.structure.INumber");
    /*package*/ static final SConcept MeetType$ZG = MetaAdapterFactory.getConcept(0x7a5dda6291404668L, 0xab76d5ed1746f2b2L, 0x114b68ad132L, "jetbrains.mps.lang.typesystem.structure.MeetType");
    /*package*/ static final SConcept BooleanType$fL = MetaAdapterFactory.getConcept(0x61c69711ed614850L, 0x81d97714ff227fb0L, 0x7af69e2e83a1ba3aL, "com.mbeddr.core.expressions.structure.BooleanType");
  }

  private static final class LINKS {
    /*package*/ static final SContainmentLink argument$r2cT = MetaAdapterFactory.getContainmentLink(0x7a5dda6291404668L, 0xab76d5ed1746f2b2L, 0x114b68ad132L, 0x114b68b040bL, "argument");
  }
}
