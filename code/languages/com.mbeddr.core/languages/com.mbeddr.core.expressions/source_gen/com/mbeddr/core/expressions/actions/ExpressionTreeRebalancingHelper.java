package com.mbeddr.core.expressions.actions;

/*Generated by MPS */

import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import com.mbeddr.core.expressions.behavior.Expression__BehaviorDescriptor;
import java.util.List;
import java.util.ArrayList;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import org.jetbrains.mps.openapi.language.SConcept;
import org.jetbrains.mps.openapi.language.SInterfaceConcept;

public class ExpressionTreeRebalancingHelper {

  /**
   * Performs a left rotation on the expression tree at the given node. 
   * 
   * @param node the node where the roatation should be performed
   * @return true if the rotation was successful, false otherwise
   */
  private static boolean rotateLeft(SNode node) {
    SNode rightChild = SNodeOperations.cast(SLinkOperations.getTarget(node, LINKS.right$Slc$), CONCEPTS.BinaryExpression$cR);
    // backSideExpression may be null at this point
    SNode newChild = SLinkOperations.getTarget(rightChild, LINKS.left$SkXz);
    if (newChild != null) {
      SNodeOperations.deleteNode(rightChild);
      SNodeOperations.replaceWithAnother(node, rightChild);
      SNodeOperations.replaceWithAnother(newChild, node);
      SLinkOperations.setTarget(node, LINKS.right$Slc$, newChild);
      return true;
    } else {
      return false;
    }
  }

  /**
   * Performs a right rotation on the expression tree at the given node. 
   * 
   * @param node the node where the rotation should be performed
   * @return return true if the rotation was successful, false otherwise
   */
  private static boolean rotateRight(SNode node) {
    SNode child = SNodeOperations.cast(SLinkOperations.getTarget(node, LINKS.left$SkXz), CONCEPTS.BinaryExpression$cR);
    // backSideExpression may be null at this point
    SNode newChild = SLinkOperations.getTarget(child, LINKS.right$Slc$);
    if (newChild != null) {
      SNodeOperations.deleteNode(child);
      SNodeOperations.replaceWithAnother(node, child);
      SNodeOperations.replaceWithAnother(newChild, node);
      SLinkOperations.setTarget(node, LINKS.left$SkXz, newChild);
      return true;
    } else {
      return false;
    }
  }

  /**
   * Checks whether the priority is correct in the expression tree within the given child-parent node. 
   * isRight indicates if child is the right child of parent. 
   * The expression tree needs to be rotated, if either one of the two conditions hold
   * (1) the child node's priority is smaller than of the parent's 
   * (2) they have the same priorities but the child is a right child (and we want to have left derivation)
   */
  private static boolean isBadPriority(SNode parent, SNode child, boolean isRight) {
    int childPriority = (int) Expression__BehaviorDescriptor.getPriolevel_id5HxjapwgqKu.invoke(SNodeOperations.asSConcept(SNodeOperations.getConcept(child)));
    int parentPriority = (int) Expression__BehaviorDescriptor.getPriolevel_id5HxjapwgqKu.invoke(SNodeOperations.asSConcept(SNodeOperations.getConcept(parent)));
    return childPriority < parentPriority || (isRight && childPriority == parentPriority);
  }

  /**
   * Rebalances the subtree of the given expression. 
   * Only binary expressions are considered for rebalancing. 
   * 
   * @param expression the expression which will be the root of the rebalancing
   */
  public static void demandRebalanceSubtree(SNode expression) {
    List<SNode> candidates = new ArrayList<SNode>();
    ListSequence.fromList(candidates).addElement(expression);

    while (ListSequence.fromList(candidates).isNotEmpty()) {
      SNode head = ListSequence.fromList(candidates).first();
      if (checkChildPriority(head, false, candidates) && checkChildPriority(head, true, candidates) && checkParentPriority(head, candidates)) {
        ListSequence.fromList(candidates).removeElementAt(0);
      }
    }
  }

  /**
   * Rebalances the whole expression tree of the given expression.
   * This means that the rebalancing will take place on the subtree 
   * of the root of the tree where expression is present. 
   * Only binary expressions are considered for rebalancing. 
   * 
   * @param expression the expression in the tree
   */
  public static void demandRebalanceTree(SNode expression) {
    SNode act = expression;
    while (SNodeOperations.getParent(act) != null && SNodeOperations.isInstanceOf(SNodeOperations.getParent(act), CONCEPTS.Expression$bT)) {
      act = SNodeOperations.cast(SNodeOperations.getParent(act), CONCEPTS.Expression$bT);
    }

    List<SNode> candidates = new ArrayList<SNode>();
    ListSequence.fromList(candidates).addSequence(ListSequence.fromList(SNodeOperations.getNodeDescendants(act, CONCEPTS.BinaryExpression$cR, true, new SAbstractConcept[]{})));

    while (ListSequence.fromList(candidates).isNotEmpty()) {
      SNode head = ListSequence.fromList(candidates).first();
      if (checkChildPriority(head, false, candidates) && checkChildPriority(head, true, candidates) && checkParentPriority(head, candidates)) {
        ListSequence.fromList(candidates).removeElementAt(0);
      }
    }
  }

  private static boolean checkChildPriority(SNode parent, boolean isRight, List<SNode> candidates) {
    SNode child = (isRight ? SLinkOperations.getTarget(parent, LINKS.right$Slc$) : SLinkOperations.getTarget(parent, LINKS.left$SkXz));
    if (SNodeOperations.isInstanceOf(child, CONCEPTS.BinaryExpression$cR)) {
      if (isBadPriority(parent, SNodeOperations.cast(child, CONCEPTS.BinaryExpression$cR), isRight)) {
        if (isRight) {
          rotateLeft(parent);
        } else {
          rotateRight(parent);
        }
        ListSequence.fromList(candidates).addElement(SNodeOperations.cast(child, CONCEPTS.BinaryExpression$cR));
        return false;
      } else {
        return true;
      }
    } else if (SNodeOperations.isInstanceOf(child, CONCEPTS.TernaryExpression$9B)) {
      SNodeOperations.replaceWithAnother(parent, child);
      if (isRight) {
        SLinkOperations.setTarget(parent, LINKS.right$Slc$, SLinkOperations.getTarget(SNodeOperations.cast(child, CONCEPTS.TernaryExpression$9B), LINKS.condition$eFP3));
        SLinkOperations.setTarget(SNodeOperations.cast(child, CONCEPTS.TernaryExpression$9B), LINKS.condition$eFP3, parent);
      } else {
        SLinkOperations.setTarget(parent, LINKS.left$SkXz, SLinkOperations.getTarget(SNodeOperations.cast(child, CONCEPTS.TernaryExpression$9B), LINKS.elseExpr$eGj5));
        SLinkOperations.setTarget(SNodeOperations.cast(child, CONCEPTS.TernaryExpression$9B), LINKS.elseExpr$eGj5, parent);
      }

      if (SNodeOperations.isInstanceOf(SNodeOperations.getParent(child), CONCEPTS.BinaryExpression$cR)) {
        ListSequence.fromList(candidates).addElement(SNodeOperations.cast(SNodeOperations.getParent(child), CONCEPTS.BinaryExpression$cR));
      }

      return false;
    } else {
      return true;
    }
  }

  private static boolean checkParentPriority(SNode child, List<SNode> candidates) {
    if (SNodeOperations.getParent(child) == null) {
      return true;
    } else if (SNodeOperations.isInstanceOf(SNodeOperations.getParent(child), CONCEPTS.BinaryExpression$cR)) {
      boolean isRight = SLinkOperations.getTarget(SNodeOperations.cast(SNodeOperations.getParent(child), CONCEPTS.BinaryExpression$cR), LINKS.right$Slc$) == child;
      if (isBadPriority(SNodeOperations.cast(SNodeOperations.getParent(child), CONCEPTS.BinaryExpression$cR), child, isRight)) {
        if (isRight) {
          rotateLeft(SNodeOperations.cast(SNodeOperations.getParent(child), CONCEPTS.BinaryExpression$cR));
        } else {
          rotateRight(SNodeOperations.cast(SNodeOperations.getParent(child), CONCEPTS.BinaryExpression$cR));
        }
        return false;
      }
      return true;
    } else {
      if (SNodeOperations.isInstanceOf(SNodeOperations.getParent(child), CONCEPTS.UnaryPrePosModificationExpression$g7) || SNodeOperations.isInstanceOf(SNodeOperations.getParent(child), CONCEPTS.NotExpression$pF)) {
        SNode unaryExpression = SNodeOperations.cast(SNodeOperations.getParent(child), CONCEPTS.UnaryExpression$lH);
        SLinkOperations.setTarget(unaryExpression, LINKS.expression$PfNq, SLinkOperations.getTarget(child, LINKS.left$SkXz));
        SNodeOperations.replaceWithAnother(unaryExpression, child);
        SLinkOperations.setTarget(child, LINKS.left$SkXz, unaryExpression);
        return false;
      }
      if (SNodeOperations.isInstanceOf(SNodeOperations.getParent(child), CONCEPTS.GenericDotExpression$uQ)) {
        SNode dotExpression = SNodeOperations.cast(SNodeOperations.getParent(child), CONCEPTS.GenericDotExpression$uQ);
        SLinkOperations.setTarget(dotExpression, LINKS.expression$PfNq, SLinkOperations.getTarget(child, LINKS.right$Slc$));
        SNodeOperations.replaceWithAnother(dotExpression, child);
        SLinkOperations.setTarget(child, LINKS.right$Slc$, dotExpression);
        return false;
      }
      if (SNodeOperations.isInstanceOf(SNodeOperations.getParent(child), CONCEPTS.CastExpression$s_)) {
        SNode castExpression = SNodeOperations.cast(SNodeOperations.getParent(child), CONCEPTS.CastExpression$s_);
        SLinkOperations.setTarget(castExpression, LINKS.expr$3lz4, SLinkOperations.getTarget(child, LINKS.left$SkXz));
        SNodeOperations.replaceWithAnother(castExpression, child);
        SLinkOperations.setTarget(child, LINKS.left$SkXz, castExpression);
        return false;
      }

      return true;
    }
  }

  /**
   * Returns the first binary expression where the given expression is on the given side. 
   * 
   * @param expression the descendant expression
   * @param isRight true - if the expression should be on the right, false - if the expression should be on the left
   * @return the found binary expression
   */
  public static SNode getBinaryExpression(SNode expression, boolean isRight) {
    if (!(SNodeOperations.isInstanceOf(SNodeOperations.getParent(expression), CONCEPTS.BinaryExpression$cR))) {
      return null;
    } else {
      if ((isRight && SLinkOperations.getTarget(SNodeOperations.cast(SNodeOperations.getParent(expression), CONCEPTS.BinaryExpression$cR), LINKS.right$Slc$) == expression) || (!(isRight) && SLinkOperations.getTarget(SNodeOperations.cast(SNodeOperations.getParent(expression), CONCEPTS.BinaryExpression$cR), LINKS.left$SkXz) == expression)) {
        return SNodeOperations.cast(SNodeOperations.getParent(expression), CONCEPTS.BinaryExpression$cR);
      } else {
        return getBinaryExpression(SNodeOperations.cast(SNodeOperations.getParent(expression), CONCEPTS.BinaryExpression$cR), isRight);
      }
    }
  }

  public static void shuffleUnaryExpression(SNode child) {
    SNode p = SNodeOperations.getParent(child);
    if (SNodeOperations.isInstanceOf(p, CONCEPTS.UnaryExpression$lH)) {
      boolean isReshuffle = SNodeOperations.isInstanceOf(p, CONCEPTS.IStopReshuffling$hp);
      if (!(isReshuffle) || (isReshuffle && SNodeOperations.hasRole(child, LINKS.expression$PfNq))) {
        SNode parent = SNodeOperations.cast(p, CONCEPTS.UnaryExpression$lH);
        int ppl = (int) Expression__BehaviorDescriptor.getPriolevel_id5HxjapwgqKu.invoke(SNodeOperations.asSConcept(SNodeOperations.getConcept(parent)));
        int cpl = (int) Expression__BehaviorDescriptor.getPriolevel_id5HxjapwgqKu.invoke(SNodeOperations.asSConcept(SNodeOperations.getConcept(child)));
        if (ppl > cpl) {
          SNode childExpression = SLinkOperations.getTarget(child, LINKS.expression$PfNq);
          SNodeOperations.deleteNode(child);
          SNodeOperations.replaceWithAnother(parent, child);
          SLinkOperations.setTarget(child, LINKS.expression$PfNq, parent);
          SLinkOperations.setTarget(parent, LINKS.expression$PfNq, childExpression);
          shuffleUnaryExpression(child);
        }
      }
    }
  }

  private static final class LINKS {
    /*package*/ static final SContainmentLink right$Slc$ = MetaAdapterFactory.getContainmentLink(0x61c69711ed614850L, 0x81d97714ff227fb0L, 0x7af69e2e83a1ba34L, 0x7af69e2e83a1ba41L, "right");
    /*package*/ static final SContainmentLink left$SkXz = MetaAdapterFactory.getContainmentLink(0x61c69711ed614850L, 0x81d97714ff227fb0L, 0x7af69e2e83a1ba34L, 0x7af69e2e83a1ba40L, "left");
    /*package*/ static final SContainmentLink condition$eFP3 = MetaAdapterFactory.getContainmentLink(0x61c69711ed614850L, 0x81d97714ff227fb0L, 0x79253aa36e3393aeL, 0x79253aa36e3393afL, "condition");
    /*package*/ static final SContainmentLink elseExpr$eGj5 = MetaAdapterFactory.getContainmentLink(0x61c69711ed614850L, 0x81d97714ff227fb0L, 0x79253aa36e3393aeL, 0x79253aa36e3393b1L, "elseExpr");
    /*package*/ static final SContainmentLink expression$PfNq = MetaAdapterFactory.getContainmentLink(0x61c69711ed614850L, 0x81d97714ff227fb0L, 0x29b5b7c4a3763232L, 0x64ae61a4018a9c50L, "expression");
    /*package*/ static final SContainmentLink expr$3lz4 = MetaAdapterFactory.getContainmentLink(0x61c69711ed614850L, 0x81d97714ff227fb0L, 0x5bbe8a6d239d0b54L, 0x5bbe8a6d239d0b56L, "expr");
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept BinaryExpression$cR = MetaAdapterFactory.getConcept(0x61c69711ed614850L, 0x81d97714ff227fb0L, 0x7af69e2e83a1ba34L, "com.mbeddr.core.expressions.structure.BinaryExpression");
    /*package*/ static final SConcept Expression$bT = MetaAdapterFactory.getConcept(0x61c69711ed614850L, 0x81d97714ff227fb0L, 0x7af69e2e83a1ba32L, "com.mbeddr.core.expressions.structure.Expression");
    /*package*/ static final SConcept TernaryExpression$9B = MetaAdapterFactory.getConcept(0x61c69711ed614850L, 0x81d97714ff227fb0L, 0x79253aa36e3393aeL, "com.mbeddr.core.expressions.structure.TernaryExpression");
    /*package*/ static final SConcept UnaryExpression$lH = MetaAdapterFactory.getConcept(0x61c69711ed614850L, 0x81d97714ff227fb0L, 0x29b5b7c4a3763232L, "com.mbeddr.core.expressions.structure.UnaryExpression");
    /*package*/ static final SConcept UnaryPrePosModificationExpression$g7 = MetaAdapterFactory.getConcept(0x61c69711ed614850L, 0x81d97714ff227fb0L, 0x632cdd5acfb8529eL, "com.mbeddr.core.expressions.structure.UnaryPrePosModificationExpression");
    /*package*/ static final SConcept NotExpression$pF = MetaAdapterFactory.getConcept(0x61c69711ed614850L, 0x81d97714ff227fb0L, 0x352a4cc97cbac907L, "com.mbeddr.core.expressions.structure.NotExpression");
    /*package*/ static final SConcept GenericDotExpression$uQ = MetaAdapterFactory.getConcept(0x61c69711ed614850L, 0x81d97714ff227fb0L, 0x401df715da462c0cL, "com.mbeddr.core.expressions.structure.GenericDotExpression");
    /*package*/ static final SConcept CastExpression$s_ = MetaAdapterFactory.getConcept(0x61c69711ed614850L, 0x81d97714ff227fb0L, 0x5bbe8a6d239d0b54L, "com.mbeddr.core.expressions.structure.CastExpression");
    /*package*/ static final SInterfaceConcept IStopReshuffling$hp = MetaAdapterFactory.getInterfaceConcept(0x61c69711ed614850L, 0x81d97714ff227fb0L, 0x7a080c0a8c1380ceL, "com.mbeddr.core.expressions.structure.IStopReshuffling");
  }
}
