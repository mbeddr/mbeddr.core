package com.mbeddr.core.qa.behavior;

/*Generated by MPS */

import jetbrains.mps.core.aspects.behaviour.BaseBHDescriptor;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import jetbrains.mps.core.aspects.behaviour.api.SMethod;
import java.util.List;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.core.aspects.behaviour.SMethodBuilder;
import jetbrains.mps.core.aspects.behaviour.SJavaCompoundTypeImpl;
import jetbrains.mps.core.aspects.behaviour.AccessPrivileges;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.generator.TransientModelsProvider;
import java.util.Arrays;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.smodel.Language;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.smodel.Generator;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.project.Project;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.baseLanguage.logging.rt.LogContext;
import java.util.ArrayList;
import jetbrains.mps.generator.TransientModelsModule;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import jetbrains.mps.generator.GenerationTrace;
import jetbrains.mps.core.aspects.behaviour.api.SConstructor;
import org.jetbrains.annotations.Nullable;
import jetbrains.mps.core.aspects.behaviour.api.BHMethodNotFoundException;
import jetbrains.mps.smodel.builder.SNodeBuilder;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import org.jetbrains.mps.openapi.language.SReferenceLink;
import org.jetbrains.mps.openapi.language.SConcept;

public final class GeneratorCoverageAssessment__BehaviorDescriptor extends BaseBHDescriptor {
  private static final SAbstractConcept CONCEPT = MetaAdapterFactory.getConcept(0xc8e0d19c3cf4b31L, 0xaf77531227edbce8L, 0x6f5413347356d83cL, "com.mbeddr.core.qa.structure.GeneratorCoverageAssessment");

  public static final SMethod<List<SNode>> runQuery_id7hIyKqbFNeu = new SMethodBuilder<List<SNode>>(new SJavaCompoundTypeImpl((Class<List<SNode>>) ((Class) Object.class))).name("runQuery").modifiers(8, AccessPrivileges.PUBLIC).concept(CONCEPT).baseMethodId(8389796016067392414L).languageId(0xaa41d1b2bffa7eb1L, 0xd4280a54f6df4383L).build2();
  /*package*/ static final SMethod<Void> doCollectUsedGeneratorFragments_id6Xk4NhNx02I = new SMethodBuilder<Void>(new SJavaCompoundTypeImpl(Void.class)).name("doCollectUsedGeneratorFragments").modifiers(0, AccessPrivileges.PRIVATE).concept(CONCEPT).baseMethodId(8022057952250953902L).languageId(0xaf77531227edbce8L, 0xc8e0d19c3cf4b31L).build2(SMethodBuilder.createJavaParameter((Class<SModel>) ((Class) Object.class), ""), SMethodBuilder.createJavaParameter(TemplatesCollector.class, ""), SMethodBuilder.createJavaParameter(TransientModelsProvider.class, ""));

  private static final List<SMethod<?>> BH_METHODS = Arrays.<SMethod<?>>asList(runQuery_id7hIyKqbFNeu, doCollectUsedGeneratorFragments_id6Xk4NhNx02I);

  private static void ___init___(@NotNull SNode __thisNode__) {
  }

  /*package*/ static List<SNode> runQuery_id7hIyKqbFNeu(@NotNull SNode __thisNode__) {
    Iterable<Language> allLangs = Utils.collectAllLanguagesStartingWithPrefix(SLinkOperations.getChildren(__thisNode__, LINKS.langs$fTp0));
    Iterable<Generator> allGens = Sequence.fromIterable(allLangs).translate((it) -> it.getGenerators());
    final Iterable<SModel> allTemplateModels = Sequence.fromIterable(allGens).translate((it) -> it.getOwnTemplateModels());

    Project proj = Utils.findFirstOpenProjectContainingModule(SNodeOperations.getModel(__thisNode__));
    TransientModelsProvider tmp = proj.getComponent(TransientModelsProvider.class);
    if (!(tmp.getModules().iterator().hasNext())) {
      LogContext.with(GeneratorCoverageAssessment__BehaviorDescriptor.class, null, null, null).error("Please generate the models for which coverage is to be measured and save the transient models.");
      return new ArrayList<SNode>();
    }

    TemplatesCollector templatesCollector = new TemplatesCollector();
    for (TransientModelsModule m : Sequence.fromIterable(tmp.getModules())) {
      for (SModel tm : ListSequence.fromList(m.getModels())) {
        GeneratorCoverageAssessment__BehaviorDescriptor.doCollectUsedGeneratorFragments_id6Xk4NhNx02I.invokeSpecial(__thisNode__, tm, templatesCollector, tmp);
      }
    }

    Set<SNode> allUsedGeneratorFragments = templatesCollector.allGeneratorGragments;
    Iterable<SNode> usedGenFragmentsInScope;
    usedGenFragmentsInScope = SetSequence.fromSet(allUsedGeneratorFragments).where((it) -> Sequence.fromIterable(allTemplateModels).contains(it.getModel()));

    Set<SNode> allGeneratorFragmentsInScope = SetSequence.fromSet(new HashSet<SNode>());
    for (SNode template : Sequence.fromIterable(usedGenFragmentsInScope)) {
      SNode t = template;
      List<SNode> allRoots = SModelOperations.roots(SNodeOperations.getModel(t), null);
      Iterable<SNode> descs = ListSequence.fromList(allRoots).translate((it) -> SNodeOperations.getNodeDescendants(it, CONCEPTS.BaseConcept$gP, false, new SAbstractConcept[]{}));
      for (SNode desc : Sequence.fromIterable(descs)) {
        if (TemplatesCollector.isRelevantGeneratorFragment(desc)) {
          SetSequence.fromSet(allGeneratorFragmentsInScope).addElement(desc);
        }
      }
    }

    List<SNode> res = new ArrayList<SNode>();
    for (SNode crtTemplate : SetSequence.fromSet(allGeneratorFragmentsInScope)) {
      if (!(Sequence.fromIterable(usedGenFragmentsInScope).contains(crtTemplate))) {
        ListSequence.fromList(res).addElement(createGeneratorCoverageAssessmentResult_lkpb62_a0a0a0a91a0(crtTemplate));
      }
    }

    System.err.println("--- GeneratorCoverageAssessment_Behavior -----");
    System.err.println("- allFragments size " + SetSequence.fromSet(allGeneratorFragmentsInScope).count());
    System.err.println("- usedFragments size " + Sequence.fromIterable(usedGenFragmentsInScope).count());
    System.err.println("- coverage: " + (((double) Sequence.fromIterable(usedGenFragmentsInScope).count()) / SetSequence.fromSet(allGeneratorFragmentsInScope).count()));

    return res;
  }
  /*package*/ static void doCollectUsedGeneratorFragments_id6Xk4NhNx02I(@NotNull SNode __thisNode__, SModel transientModel, TemplatesCollector collector, TransientModelsProvider tmp) {
    List<SNode> allRoots = SModelOperations.roots(transientModel, null);
    Iterable<SNode> allNodes = ListSequence.fromList(allRoots).translate((it) -> SNodeOperations.getNodeDescendants(it, CONCEPTS.BaseConcept$gP, false, new SAbstractConcept[]{}));
    GenerationTrace trace = tmp.getTrace(transientModel.getReference());
    if (trace != null) {
      for (SNode crtNode : Sequence.fromIterable(allNodes)) {
        trace.walkForward(crtNode, collector);
      }
    }
  }

  /*package*/ GeneratorCoverageAssessment__BehaviorDescriptor() {
  }

  @Override
  protected void initNode(@NotNull SNode node, @NotNull SConstructor constructor, @Nullable Object[] parameters) {
    ___init___(node);
  }

  @Override
  protected <T> T invokeSpecial0(@NotNull SNode node, @NotNull SMethod<T> method, @Nullable Object[] parameters) {
    int methodIndex = BH_METHODS.indexOf(method);
    if (methodIndex < 0) {
      throw new BHMethodNotFoundException(this, method);
    }
    switch (methodIndex) {
      case 0:
        return (T) ((List<SNode>) runQuery_id7hIyKqbFNeu(node));
      case 1:
        doCollectUsedGeneratorFragments_id6Xk4NhNx02I(node, (SModel) parameters[0], (TemplatesCollector) parameters[1], (TransientModelsProvider) parameters[2]);
        return null;
      default:
        throw new BHMethodNotFoundException(this, method);
    }
  }

  @Override
  protected <T> T invokeSpecial0(@NotNull SAbstractConcept concept, @NotNull SMethod<T> method, @Nullable Object[] parameters) {
    int methodIndex = BH_METHODS.indexOf(method);
    if (methodIndex < 0) {
      throw new BHMethodNotFoundException(this, method);
    }
    switch (methodIndex) {
      default:
        throw new BHMethodNotFoundException(this, method);
    }
  }

  @NotNull
  @Override
  public List<SMethod<?>> getDeclaredMethods() {
    return BH_METHODS;
  }

  @NotNull
  @Override
  public SAbstractConcept getConcept() {
    return CONCEPT;
  }
  private static SNode createGeneratorCoverageAssessmentResult_lkpb62_a0a0a0a91a0(SNode p0) {
    SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.GeneratorCoverageAssessmentResult$yq);
    n0.setReferenceTarget(LINKS.generatorFragment$ih7B, p0);
    return n0.getResult();
  }

  private static final class LINKS {
    /*package*/ static final SContainmentLink langs$fTp0 = MetaAdapterFactory.getContainmentLink(0xc8e0d19c3cf4b31L, 0xaf77531227edbce8L, 0x6f5413347356d83cL, 0x6f5413347356d878L, "langs");
    /*package*/ static final SReferenceLink generatorFragment$ih7B = MetaAdapterFactory.getReferenceLink(0xc8e0d19c3cf4b31L, 0xaf77531227edbce8L, 0x6f54133473570625L, 0x6f54133473570626L, "generatorFragment");
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept BaseConcept$gP = MetaAdapterFactory.getConcept(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x10802efe25aL, "jetbrains.mps.lang.core.structure.BaseConcept");
    /*package*/ static final SConcept GeneratorCoverageAssessmentResult$yq = MetaAdapterFactory.getConcept(0xc8e0d19c3cf4b31L, 0xaf77531227edbce8L, 0x6f54133473570625L, "com.mbeddr.core.qa.structure.GeneratorCoverageAssessmentResult");
  }
}
