package com.mbeddr.core.interpreterdebugger.rt.runtime;

/*Generated by MPS */

import com.mbeddr.core.base.behavior.IValueSource;
import com.mbeddr.mpsutil.interpreter.rt.IInterpreter;
import com.mbeddr.mpsutil.interpreter.rt.IPersistentContext;
import com.mbeddr.mpsutil.interpreter.rt.PersistentInterpreter;
import org.jetbrains.mps.openapi.model.SNode;
import com.mbeddr.mpsutil.interpreter.rt.IPersistentEnvironment;
import com.mbeddr.mpsutil.interpreter.rt.INodeValueCache;
import com.mbeddr.mpsutil.interpreter.rt.NullCoverageAnalyzer;
import jetbrains.mps.internal.collections.runtime.Sequence;
import java.util.Collections;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.Set;
import com.mbeddr.mpsutil.interpreter.rt.IEnvironmentId;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import com.mbeddr.mpsutil.interpreter.rt.EnvironmentIdImpl;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.internal.collections.runtime.IMapping;
import jetbrains.mps.smodel.SNodeMatcher;
import org.jetbrains.mps.openapi.language.SProperty;
import org.jetbrains.mps.openapi.language.SInterfaceConcept;

public class InterpreterValueSource implements IValueSource {
  private final IInterpreter interpreter;
  private final IPersistentContext context;

  public InterpreterValueSource(IInterpreter interpreter, IPersistentContext context) {
    this.interpreter = new PersistentInterpreter(interpreter);
    this.context = context;

    context.setRootInterpreter(this.interpreter);
  }

  public Object getValue(SNode debuggable) {
    IPersistentEnvironment env = findEnvironment(debuggable);
    INodeValueCache cache = env.getCache();
    if (cache.isCached(debuggable)) {
      return cache.get(debuggable);
    } else {
      IPersistentEnvironment parentEnv = env.getParentEnvironment();
      if (parentEnv != null && parentEnv.getCache().isCached(debuggable)) {
        return parentEnv.getCache().get(debuggable);
      }
    }

    return getInterpreter().evaluate(debuggable, getContext(), new NullCoverageAnalyzer(), null, false);
  }

  public boolean hasKeys(SNode debuggable) {
    return Sequence.fromIterable(listAvailableKeys(debuggable)).isNotEmpty();
  }

  public Iterable<SNode> listAvailableKeys(SNode debuggable) {
    IPersistentEnvironment env = findEnvironment(debuggable);
    if (env == null) {
      return Collections.emptyList();
    }
    Iterable<SNode> keys = SetSequence.fromSet(((Set<IEnvironmentId>) MapSequence.fromMap(MapSequence.fromMap(env.getPushedEnvironments()).get(debuggable)).keySet())).select((it) -> createDebugKey(it));

    return keys;
  }

  public void setKey(SNode debuggable, SNode key) {
    MapSequence.fromMap(findEnvironment(debuggable).getCurrentEnvironmentIds()).put(debuggable, new EnvironmentIdImpl(SPropertyOperations.getString(key, PROPS.value$TL6G)));
  }

  public SNode getKey(SNode debuggable) {
    return createDebugKey(MapSequence.fromMap(findEnvironment(debuggable).getCurrentEnvironmentIds()).get(debuggable));
  }

  protected SNode createDebugKey(IEnvironmentId envId) {
    if (envId == null) {
      return null;
    }
    SNode result = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0xd4280a54f6df4383L, 0xaa41d1b2bffa7eb1L, 0x1d533f492200e4beL, "com.mbeddr.core.base.structure.DebugKey"));
    SPropertyOperations.assign(result, PROPS.value$TL6G, envId.toString());
    return result;
  }

  protected IPersistentEnvironment findEnvironment(SNode debuggable) {
    SNode parent = SNodeOperations.getParent(debuggable);
    if (parent != null && SNodeOperations.isInstanceOf(parent, CONCEPTS.IValueDebuggable$Pw)) {
      IPersistentEnvironment result = findEnvironmentByCurrentKey(((SNode) parent), getContext().getEnvironment());
      if (result != null) {
        return result;
      } else {
        return findEnvironment(((SNode) parent));
      }
    }

    return getContext().getEnvironment();
  }

  protected IPersistentEnvironment findEnvironmentByCurrentKey(SNode debuggable, IPersistentEnvironment baseEnv) {

    for (IMapping<SNode, IEnvironmentId> currentKey : MapSequence.fromMap(baseEnv.getCurrentEnvironmentIds())) {
      IPersistentEnvironment pushedEnv = MapSequence.fromMap(MapSequence.fromMap(baseEnv.getPushedEnvironments()).get(currentKey.key())).get(currentKey.value());

      if (new SNodeMatcher().match(debuggable, currentKey.key())) {
        return pushedEnv;
      }
      IPersistentEnvironment result = findEnvironmentByCurrentKey(debuggable, pushedEnv);
      if (result != null) {
        return result;
      }
    }

    return null;
  }


  private IInterpreter getInterpreter() {
    return interpreter;
  }

  private IPersistentContext getContext() {
    return context;
  }

  private static final class PROPS {
    /*package*/ static final SProperty value$TL6G = MetaAdapterFactory.getProperty(0xd4280a54f6df4383L, 0xaa41d1b2bffa7eb1L, 0x1d533f492200e4beL, 0xabc490912b9b54eL, "value");
  }

  private static final class CONCEPTS {
    /*package*/ static final SInterfaceConcept IValueDebuggable$Pw = MetaAdapterFactory.getInterfaceConcept(0xd4280a54f6df4383L, 0xaa41d1b2bffa7eb1L, 0x90bbc04d0d4e74eL, "com.mbeddr.core.base.structure.IValueDebuggable");
  }
}
