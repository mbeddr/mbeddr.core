package com.mbeddr.ext.components.typesystem;

/*Generated by MPS */

import jetbrains.mps.lang.typesystem.runtime.AbstractNonTypesystemRule_Runtime;
import jetbrains.mps.lang.typesystem.runtime.NonTypesystemRule_Runtime;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.typesystem.inference.TypeCheckingContext;
import jetbrains.mps.lang.typesystem.runtime.IsApplicableStatus;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import com.mbeddr.ext.components.behavior.Component__BehaviorDescriptor;
import jetbrains.mps.errors.messageTargets.MessageTarget;
import jetbrains.mps.errors.messageTargets.NodeMessageTarget;
import jetbrains.mps.errors.IErrorReporter;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import com.mbeddr.ext.components.behavior.RequiredPort__BehaviorDescriptor;
import com.mbeddr.ext.components.behavior.Cardinality__BehaviorDescriptor;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import com.mbeddr.ext.components.behavior.ISatisfiesPort__BehaviorDescriptor;
import jetbrains.mps.errors.messageTargets.PropertyMessageTarget;
import jetbrains.mps.errors.BaseQuickFixProvider;
import com.mbeddr.ext.components.behavior.AbstractInstanceConfiguration__BehaviorDescriptor;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import org.jetbrains.mps.openapi.language.SReferenceLink;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import org.jetbrains.mps.openapi.language.SConcept;
import org.jetbrains.mps.openapi.language.SInterfaceConcept;
import org.jetbrains.mps.openapi.language.SProperty;

public class check_ComponentInstance_NonTypesystemRule extends AbstractNonTypesystemRule_Runtime implements NonTypesystemRule_Runtime {
  public check_ComponentInstance_NonTypesystemRule() {
  }
  public void applyRule(final SNode componentInstance, final TypeCheckingContext typeCheckingContext, IsApplicableStatus status) {
    SNode comp = SLinkOperations.getTarget(componentInstance, LINKS.component$ikVC);
    if ((boolean) Component__BehaviorDescriptor.isAbstract_id3PT6Z48L3oi.invoke(comp)) {
      {
        final MessageTarget errorTarget = new NodeMessageTarget();
        IErrorReporter _reporter_2309309498 = typeCheckingContext.reportTypeError(componentInstance, "cannot instantiate abstract components", "r:c480d4b6-a379-41b5-b76a-c94ccc817c4e(com.mbeddr.ext.components.typesystem)", "4429602430543738402", null, errorTarget);
      }
    }
    SNode config = SNodeOperations.getNodeAncestor(componentInstance, CONCEPTS.AbstractInstanceConfiguration$QD, false, false);
    for (final SNode p : Sequence.fromIterable(Component__BehaviorDescriptor.allRequiredPorts_id71UKpntoZWS.invoke(comp))) {
      if (!(SPropertyOperations.getBoolean(p, PROPS.optional$mTHR))) {
        if ((boolean) RequiredPort__BehaviorDescriptor.isMultiple_id2ZUGF54jY1D.invoke(p)) {
          long maxConnections = (int) Cardinality__BehaviorDescriptor.upperBound_id2ofiXe_sAfm.invoke(SLinkOperations.getTarget(p, LINKS.cardinality$DLq9));
          long minConnections = (int) Cardinality__BehaviorDescriptor.lowerBound_id2rnvR93av0K.invoke(SLinkOperations.getTarget(p, LINKS.cardinality$DLq9));
          int actualConnections = ListSequence.fromList(SLinkOperations.getChildren(config, LINKS.contents$E4B8)).where((it) -> SNodeOperations.isInstanceOf(it, CONCEPTS.ISatisfiesPort$RV)).where((it) -> (boolean) ISatisfiesPort__BehaviorDescriptor.satisfiesPort_id6JVEnxIiSod.invoke(SNodeOperations.cast(it, CONCEPTS.ISatisfiesPort$RV), componentInstance, p)).count();

          if (actualConnections > maxConnections) {
            {
              final MessageTarget errorTarget = new NodeMessageTarget();
              IErrorReporter _reporter_2309309498 = typeCheckingContext.reportTypeError(componentInstance, "found " + actualConnections + " connections for port " + SPropertyOperations.getString(p, PROPS.name$MnvL) + ", but max. " + maxConnections + " allowed", "r:c480d4b6-a379-41b5-b76a-c94ccc817c4e(com.mbeddr.ext.components.typesystem)", "2580867847991067076", null, errorTarget);
            }
          } else if (actualConnections < minConnections) {
            {
              final MessageTarget errorTarget = new NodeMessageTarget();
              IErrorReporter _reporter_2309309498 = typeCheckingContext.reportTypeError(componentInstance, "found " + actualConnections + " connections for port " + SPropertyOperations.getString(p, PROPS.name$MnvL) + ", but min. " + minConnections + " expected", "r:c480d4b6-a379-41b5-b76a-c94ccc817c4e(com.mbeddr.ext.components.typesystem)", "2580867847991067244", null, errorTarget);
            }
          }
        } else {
          if (!(ListSequence.fromList(SLinkOperations.getChildren(config, LINKS.contents$E4B8)).where((it) -> SNodeOperations.isInstanceOf(it, CONCEPTS.ISatisfiesPort$RV)).any((it) -> (boolean) ISatisfiesPort__BehaviorDescriptor.satisfiesPort_id6JVEnxIiSod.invoke(SNodeOperations.cast(it, CONCEPTS.ISatisfiesPort$RV), componentInstance, p)))) {
            {
              final MessageTarget errorTarget = new PropertyMessageTarget(PROPS.name$MnvL);
              IErrorReporter _reporter_2309309498 = typeCheckingContext.reportTypeError(componentInstance, "mandatory required port " + SPropertyOperations.getString(p, PROPS.name$MnvL) + " (" + SPropertyOperations.getString(SLinkOperations.getTarget(p, LINKS.intf$QYND), PROPS.name$MnvL) + ") is not connected", "r:c480d4b6-a379-41b5-b76a-c94ccc817c4e(com.mbeddr.ext.components.typesystem)", "899185318197698661", null, errorTarget);
              {
                BaseQuickFixProvider intentionProvider = new BaseQuickFixProvider("com.mbeddr.ext.components.typesystem.addConnectorForMissingRequiredPort_QuickFix", "172140116792676419", false);
                intentionProvider.putArgument("instance", componentInstance);
                intentionProvider.putArgument("port", p);
                _reporter_2309309498.addIntentionProvider(intentionProvider);
              }
            }
          }
        }

      }
    }

    for (final SNode providedPort : Sequence.fromIterable(Component__BehaviorDescriptor.allProvidedPorts_id71UKpntoZW7.invoke(comp))) {
      if (Sequence.fromIterable(AbstractInstanceConfiguration__BehaviorDescriptor.assemblyConnectors_id6JVEnxIhC2V.invoke(config)).where((it) -> SLinkOperations.getTarget(SLinkOperations.getTarget(it, LINKS.target$iri1), LINKS.port$HUwa) == providedPort).isEmpty() && SNodeOperations.isInstanceOf(config, CONCEPTS.InstanceConfiguration$MO) && SPropertyOperations.getBoolean(providedPort, PROPS.mandatory$ZrUn) && ListSequence.fromList(SModelOperations.nodes(SNodeOperations.getModel(componentInstance), null)).where((it) -> SNodeOperations.isInstanceOf(it, CONCEPTS.PortAdapterOpCallExpr$Ux) && SLinkOperations.getTarget(SLinkOperations.getTarget(SLinkOperations.getTarget(SLinkOperations.getTarget(SNodeOperations.cast(it, CONCEPTS.PortAdapterOpCallExpr$Ux), LINKS.expression$PfNq), LINKS.portAdater$$CH8), LINKS.portRef$g$fy), LINKS.port$8cCY) == providedPort).isEmpty()) {
        {
          final MessageTarget errorTarget = new NodeMessageTarget();
          IErrorReporter _reporter_2309309498 = typeCheckingContext.reportTypeError(componentInstance, "mandatory provided port (" + SPropertyOperations.getString(providedPort, PROPS.name$MnvL) + ") is not connected", "r:c480d4b6-a379-41b5-b76a-c94ccc817c4e(com.mbeddr.ext.components.typesystem)", "3577918739320196098", null, errorTarget);
          {
            BaseQuickFixProvider intentionProvider = new BaseQuickFixProvider("com.mbeddr.ext.components.typesystem.addConnectorForMissingProvidedPort_QuickFix", "5259475464754976074", false);
            intentionProvider.putArgument("instance", componentInstance);
            intentionProvider.putArgument("port", providedPort);
            _reporter_2309309498.addIntentionProvider(intentionProvider);
          }
        }
      }
    }
  }
  public SAbstractConcept getApplicableConcept() {
    return CONCEPTS.ComponentInstance$zN;
  }
  public IsApplicableStatus isApplicableAndPattern(SNode argument) {
    return new IsApplicableStatus(argument.getConcept().isSubConceptOf(getApplicableConcept()), null);
  }
  public boolean overrides() {
    return false;
  }

  private static final class LINKS {
    /*package*/ static final SReferenceLink component$ikVC = MetaAdapterFactory.getReferenceLink(0x97d2424451db4e2eL, 0x97fc7bd73b1f5f40L, 0x3e5659cd94a4de76L, 0x3e5659cd94a4de77L, "component");
    /*package*/ static final SContainmentLink cardinality$DLq9 = MetaAdapterFactory.getContainmentLink(0x97d2424451db4e2eL, 0x97fc7bd73b1f5f40L, 0x3e5659cd94a48fa9L, 0x2ffab2b144517b4dL, "cardinality");
    /*package*/ static final SContainmentLink contents$E4B8 = MetaAdapterFactory.getContainmentLink(0x97d2424451db4e2eL, 0x97fc7bd73b1f5f40L, 0x6bfba9786e466b00L, 0x6bfba9786e467315L, "contents");
    /*package*/ static final SReferenceLink intf$QYND = MetaAdapterFactory.getReferenceLink(0x97d2424451db4e2eL, 0x97fc7bd73b1f5f40L, 0x3e5659cd94a25d82L, 0x3e5659cd94a25d84L, "intf");
    /*package*/ static final SContainmentLink target$iri1 = MetaAdapterFactory.getContainmentLink(0x97d2424451db4e2eL, 0x97fc7bd73b1f5f40L, 0x3e5659cd94a4de78L, 0x3e5659cd94a4de7dL, "target");
    /*package*/ static final SReferenceLink port$HUwa = MetaAdapterFactory.getReferenceLink(0x97d2424451db4e2eL, 0x97fc7bd73b1f5f40L, 0x3e5659cd94a4de79L, 0x2fceca7612fd97fbL, "port");
    /*package*/ static final SContainmentLink expression$PfNq = MetaAdapterFactory.getContainmentLink(0x61c69711ed614850L, 0x81d97714ff227fb0L, 0x29b5b7c4a3763232L, 0x64ae61a4018a9c50L, "expression");
    /*package*/ static final SReferenceLink portAdater$$CH8 = MetaAdapterFactory.getReferenceLink(0x97d2424451db4e2eL, 0x97fc7bd73b1f5f40L, 0x707ac195dd610219L, 0x707ac195dd61021aL, "portAdater");
    /*package*/ static final SContainmentLink portRef$g$fy = MetaAdapterFactory.getContainmentLink(0x97d2424451db4e2eL, 0x97fc7bd73b1f5f40L, 0x47c7455cc68418c2L, 0x5bd0d857daf8089dL, "portRef");
    /*package*/ static final SReferenceLink port$8cCY = MetaAdapterFactory.getReferenceLink(0x97d2424451db4e2eL, 0x97fc7bd73b1f5f40L, 0x5bd0d857daf78a76L, 0x5bd0d857daf78a78L, "port");
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept AbstractInstanceConfiguration$QD = MetaAdapterFactory.getConcept(0x97d2424451db4e2eL, 0x97fc7bd73b1f5f40L, 0x6bfba9786e466b00L, "com.mbeddr.ext.components.structure.AbstractInstanceConfiguration");
    /*package*/ static final SInterfaceConcept ISatisfiesPort$RV = MetaAdapterFactory.getInterfaceConcept(0x97d2424451db4e2eL, 0x97fc7bd73b1f5f40L, 0x6bfba9786e4b8609L, "com.mbeddr.ext.components.structure.ISatisfiesPort");
    /*package*/ static final SConcept InstanceConfiguration$MO = MetaAdapterFactory.getConcept(0x97d2424451db4e2eL, 0x97fc7bd73b1f5f40L, 0x3e5659cd94a4de80L, "com.mbeddr.ext.components.structure.InstanceConfiguration");
    /*package*/ static final SConcept PortAdapterOpCallExpr$Ux = MetaAdapterFactory.getConcept(0x97d2424451db4e2eL, 0x97fc7bd73b1f5f40L, 0x679b5a7c6c34a6dL, "com.mbeddr.ext.components.structure.PortAdapterOpCallExpr");
    /*package*/ static final SConcept ComponentInstance$zN = MetaAdapterFactory.getConcept(0x97d2424451db4e2eL, 0x97fc7bd73b1f5f40L, 0x3e5659cd94a4de76L, "com.mbeddr.ext.components.structure.ComponentInstance");
  }

  private static final class PROPS {
    /*package*/ static final SProperty name$MnvL = MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name");
    /*package*/ static final SProperty optional$mTHR = MetaAdapterFactory.getProperty(0x97d2424451db4e2eL, 0x97fc7bd73b1f5f40L, 0x3e5659cd94a48fa9L, 0x4db287ad754ffcdL, "optional");
    /*package*/ static final SProperty mandatory$ZrUn = MetaAdapterFactory.getProperty(0x97d2424451db4e2eL, 0x97fc7bd73b1f5f40L, 0x3e5659cd94a48fa8L, 0x31a7522304259384L, "mandatory");
  }
}
