package com.mbeddr.ext.compositecomponents.generator.flatteningCompComps.util;

/*Generated by MPS */

import org.jetbrains.mps.openapi.model.SNode;
import java.util.List;
import com.mbeddr.ext.components.behavior.ComponentInstance__BehaviorDescriptor;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.IAttributeDescriptor;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import com.mbeddr.ext.compositecomponents.behavior.CompositeComponent__BehaviorDescriptor;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import com.mbeddr.ext.components.behavior.AbstractInstanceConfiguration__BehaviorDescriptor;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import com.mbeddr.ext.components.behavior.InstanceConfigContentsToBeCopiedIntoFlattenedInstanceConfig__BehaviorDescriptor;
import java.util.Collections;
import com.mbeddr.ext.compositecomponents.behavior.CompositeComponentInstanceConfig__BehaviorDescriptor;
import com.mbeddr.ext.components.behavior.Component__BehaviorDescriptor;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple;
import org.jetbrains.mps.openapi.language.SProperty;
import org.jetbrains.mps.openapi.language.SConcept;
import org.jetbrains.mps.openapi.language.SInterfaceConcept;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import org.jetbrains.mps.openapi.language.SReferenceLink;

public class GeneratorUtil {


  /**
   * Flattens composite components into a list of flat instances, i.e. it resolves the nesting.
   * 
   * @param instance the instance to flatten
   * @param result the result list to wich the flattened components and connectors will be added
   * @param namePrefix the prefix repesents the namespace for all elements which are created in this method
   */
  public static void flattenCompositeInstances(SNode instance, List<SNode> result, String namePrefix) {

    if ((boolean) ComponentInstance__BehaviorDescriptor.isComponentAtomic_id5vJvKD7xsW0.invoke(instance)) {
      // As we do not know here if this instance is results from a compoent inside a composite component or not we first copy it and prefix the name with the current namespace. Next we set the flag to prevent the constructor of this component from being called
      SNode copy = SNodeOperations.copyNode(instance);
      SPropertyOperations.assign(copy, PROPS.name$MnvL, createNamespace(namePrefix, copy));
      new IAttributeDescriptor.NodeAttribute(CONCEPTS.PreventConstructorCall$Kl).setNew(copy);


      // if this instance is a "shadow instance" we need to set the references to the former internal instances. To achieve that we set the new instance name as a property to the field. In a later phase this name will be resolved.
      for (SNode initFieldInit : Sequence.fromIterable(ComponentInstance__BehaviorDescriptor.fieldInitializers_id29JE8qNu0TX.invoke(copy)).where((it) -> (new IAttributeDescriptor.NodeAttribute(CONCEPTS.FieldForInternalInstances$dy).get(SLinkOperations.getTarget(it, LINKS.field$SvlC)) != null))) {
        SNode ci = SLinkOperations.getTarget(SNodeOperations.cast(SLinkOperations.getTarget(initFieldInit, LINKS.value$Sv$D), CONCEPTS.ComponentInstanceRefExpr$_C), LINKS.ci$IlQ8);
        String instanceName = createNamespace(namePrefix, ci);
        if (SNodeOperations.isInstanceOf(SLinkOperations.getTarget(ci, LINKS.component$ikVC), CONCEPTS.CompositeComponent$c8)) {
          instanceName = createNamespace(instanceName, CompositeComponent__BehaviorDescriptor.findShadowInstance_id5vJvKD7xN3Q.invoke(SNodeOperations.cast(SLinkOperations.getTarget(ci, LINKS.component$ikVC), CONCEPTS.CompositeComponent$c8)));
        }
        SNode sourceTin = new IAttributeDescriptor.NodeAttribute(CONCEPTS.TargetInstanceName$mY).setNew(SNodeOperations.cast(SLinkOperations.getTarget(initFieldInit, LINKS.value$Sv$D), CONCEPTS.ComponentInstanceRefExpr$_C));
        SPropertyOperations.assign(sourceTin, PROPS.name$MnvL, instanceName);


      }

      // finally we add the newly created instance to the result list
      ListSequence.fromList(result).addElement(copy);

    } else {
      // In case the component is a composite component we need to make sure that all internal assembly connectors are moved into the result list and their targets are changed accordingly. Finally start a recursive call for all internal instances of this composite component.
      SNode cc = SNodeOperations.cast(SLinkOperations.getTarget(instance, LINKS.component$ikVC), CONCEPTS.CompositeComponent$c8);
      Iterable<SNode> assemblyConnectors = AbstractInstanceConfiguration__BehaviorDescriptor.assemblyConnectors_id6JVEnxIhC2V.invoke(CompositeComponent__BehaviorDescriptor.innerInstanceConfig_id6JVEnxIjbYq.invoke(cc));
      final String initialPrefix = createNamespace(namePrefix, instance);
      GeneratorUtil.handleAssemblyConnectors(assemblyConnectors, initialPrefix, result);

      Iterable<SNode> seq = SNodeOperations.ofConcept(SLinkOperations.getChildren(CompositeComponent__BehaviorDescriptor.innerInstanceConfig_id6JVEnxIjbYq.invoke(cc), LINKS.contents$E4B8), CONCEPTS.InstanceConfigContentsToBeCopiedIntoFlattenedInstanceConfig$xT);
      ListSequence.fromList(result).addSequence(Sequence.fromIterable(seq));
      Sequence.fromIterable(seq).visitAll((it) -> GeneratorUtil.handleInstanceUpdate(it, initialPrefix));

      for (SNode innerInstance : Sequence.fromIterable(AbstractInstanceConfiguration__BehaviorDescriptor.instances_id6JVEnxIhC2$.invoke(CompositeComponent__BehaviorDescriptor.innerInstanceConfig_id6JVEnxIjbYq.invoke(cc)))) {
        flattenCompositeInstances(innerInstance, result, GeneratorUtil.createNamespace(namePrefix, instance));
      }
    }
  }
  /**
   * 
   * 
   * @param assemblyConnectors the list of assembly connectors to correct
   * @param initialPrefix the namespace for resolving the targets
   * @param result the list to which newly created connectors are added
   */
  public static void handleAssemblyConnectors(Iterable<SNode> assemblyConnectors, String initialPrefix, List<SNode> result) {
    for (SNode connector : Sequence.fromIterable(assemblyConnectors)) {
      // first we need to find all "ultimate targets" for the source ...
      for (Tuples._2<String, SNode> ultimateSrc : Sequence.fromIterable(ultimateEndpoint(SLinkOperations.getTarget(SLinkOperations.getTarget(connector, LINKS.source$ir30), LINKS.instance$ilE8), SLinkOperations.getTarget(SLinkOperations.getTarget(connector, LINKS.source$ir30), LINKS.port$HUwa), initialPrefix))) {
        // ... and target side of the assembly connector. As a port might be delegated in a composite component we need to follow this delegation chain until we reach a non-delegated port. This will be the ultimate target. As a result a single assembly connector might be expanded into several connectors. This can be the case if one port is delegated to several instances
        for (Tuples._2<String, SNode> ultimateTarget : Sequence.fromIterable(ultimateEndpoint(SLinkOperations.getTarget(SLinkOperations.getTarget(connector, LINKS.target$iri1), LINKS.instance$ilE8), SLinkOperations.getTarget(SLinkOperations.getTarget(connector, LINKS.target$iri1), LINKS.port$HUwa), initialPrefix))) {

          // we don't set the source/target, we just remember the name for later resolution. In effect we emulate reference macros with deferred resolution.
          SNode newAc = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0x97d2424451db4e2eL, 0x97fc7bd73b1f5f40L, 0x3e5659cd94a4de78L, "com.mbeddr.ext.components.structure.AssemblyConnector"));
          SNode sourceTin = new IAttributeDescriptor.NodeAttribute(CONCEPTS.TargetInstanceName$mY).setNew(SLinkOperations.getTarget(newAc, LINKS.source$ir30));
          SPropertyOperations.assign(sourceTin, PROPS.name$MnvL, ultimateSrc._0());
          SLinkOperations.setTarget(SLinkOperations.getTarget(newAc, LINKS.source$ir30), LINKS.port$HUwa, ultimateSrc._1());

          SNode targetTin = new IAttributeDescriptor.NodeAttribute(CONCEPTS.TargetInstanceName$mY).setNew(SLinkOperations.getTarget(newAc, LINKS.target$iri1));
          SPropertyOperations.assign(targetTin, PROPS.name$MnvL, ultimateTarget._0());
          SLinkOperations.setTarget(SLinkOperations.getTarget(newAc, LINKS.target$iri1), LINKS.port$HUwa, ultimateTarget._1());
          ListSequence.fromList(result).addElement(newAc);
        }
      }
    }
  }
  /**
   * A port adapter always points to a provided port. There can always be only one ultimate target. Thus we can
   * safely get the first element in the list of targets.
   * 
   * @param portAdapter the PortAdaper which needs to be corrected
   * @param initialPrefix the namespace in which this portAdapter lived
   */
  public static void handleAdapterPortRef(SNode portAdapter, String initialPrefix) {
    Tuples._2<String, SNode> ultimateEndpoint = Sequence.fromIterable(ultimateEndpoint(SLinkOperations.getTarget(SLinkOperations.getTarget(portAdapter, LINKS.portRef$g$fy), LINKS.instance$87uC), SLinkOperations.getTarget(SLinkOperations.getTarget(portAdapter, LINKS.portRef$g$fy), LINKS.port$8cCY), initialPrefix)).first();

    // rebind the portAdapter to this one (using "lazy" references as before)
    SNode sourceTin = new IAttributeDescriptor.NodeAttribute(CONCEPTS.TargetInstanceName$mY).setNew(SLinkOperations.getTarget(portAdapter, LINKS.portRef$g$fy));
    SPropertyOperations.assign(sourceTin, PROPS.name$MnvL, ultimateEndpoint._0());
    SLinkOperations.setTarget(SLinkOperations.getTarget(portAdapter, LINKS.portRef$g$fy), LINKS.port$8cCY, SNodeOperations.cast(ultimateEndpoint._1(), CONCEPTS.ProvidedPort$RN));
  }

  public static void handleInstanceUpdate(SNode instRef, String namePrefix) {
    String instanceName = createNamespace(namePrefix, InstanceConfigContentsToBeCopiedIntoFlattenedInstanceConfig__BehaviorDescriptor.referencedInstance_id7mgpfAOt2tP.invoke(instRef));
    if (SNodeOperations.isInstanceOf(SLinkOperations.getTarget(InstanceConfigContentsToBeCopiedIntoFlattenedInstanceConfig__BehaviorDescriptor.referencedInstance_id7mgpfAOt2tP.invoke(instRef), LINKS.component$ikVC), CONCEPTS.CompositeComponent$c8)) {
      instanceName = createNamespace(instanceName, CompositeComponent__BehaviorDescriptor.findShadowInstance_id5vJvKD7xN3Q.invoke(SNodeOperations.cast(SLinkOperations.getTarget(InstanceConfigContentsToBeCopiedIntoFlattenedInstanceConfig__BehaviorDescriptor.referencedInstance_id7mgpfAOt2tP.invoke(instRef), LINKS.component$ikVC), CONCEPTS.CompositeComponent$c8)));
    }
    SNode sourceTin = new IAttributeDescriptor.NodeAttribute(CONCEPTS.TargetInstanceName$mY).setNew(instRef);
    SPropertyOperations.assign(sourceTin, PROPS.name$MnvL, instanceName);


  }
  /**
   * In case if a composite component we find the instance/port pairs to wich the port is delegated to. 
   * In case of an atomic compoent the port cannot be delegated, so we return an empty list
   * 
   * @param comp the (composite) component to search for delegations in
   * @param port the port which is delegated
   * @return All instance/port pairs to wich the port is delegated to.
   */
  private static Iterable<Tuples._2<SNode, SNode>> delegationEndpoints(SNode comp, SNode port) {
    if (SNodeOperations.isInstanceOf(comp, CONCEPTS.CompositeComponent$c8)) {
      return CompositeComponent__BehaviorDescriptor.delegationTarget_id5vJvKD7x92J.invoke(SNodeOperations.cast(comp, CONCEPTS.CompositeComponent$c8), port);
    } else {
      return Sequence.fromIterable(Collections.<Tuples._2<SNode, SNode>>emptyList());
    }
  }
  /**
   * Resolves the ultimate source or target of a port taking into account delegation
   * inside composite componetns. Essentially it follows the chain of delegating instances
   * until a non-delegating instance is found. It builds the qualified name of that instance
   * once it is not part of a composite component anymore ("flachklopfen"). There may be several 
   * endpoints because of potentially several delegations for the same port
   * 
   * @param instance the current instance
   * @param port the port whose ultimate endpoint we try to find
   * @param prefix represents the name prefix built so far
   * @return the sequence of instance name/port pairs resolved (so far)
   */
  private static Iterable<Tuples._2<String, SNode>> ultimateEndpoint(final SNode instance, final SNode port, final String prefix) {
    // In case of a composite compoent...
    if (!((boolean) ComponentInstance__BehaviorDescriptor.isComponentAtomic_id5vJvKD7xsW0.invoke(instance))) {
      SNode cc = SNodeOperations.cast(SLinkOperations.getTarget(instance, LINKS.component$ikVC), CONCEPTS.CompositeComponent$c8);
      Iterable<SNode> delegatingConnectors = CompositeComponentInstanceConfig__BehaviorDescriptor.delegatingConnectors_id3_MZZHrtYLf.invoke(CompositeComponent__BehaviorDescriptor.innerInstanceConfig_id6JVEnxIjbYq.invoke(cc));
      if (Sequence.fromIterable(delegatingConnectors).where((it) -> SLinkOperations.getTarget(it, LINKS.outsidePort$z5z3) == port).isEmpty()) {
        // For an composite component which implements a port itself we return the instance name and the port of the shaddow component
        String createNamespace = createNamespace(prefix, instance);
        Iterable<Tuples._2<String, SNode>> ultimateEndpoint = ultimateEndpoint(CompositeComponent__BehaviorDescriptor.findShadowInstance_id5vJvKD7xN3Q.invoke(cc), Sequence.fromIterable(Component__BehaviorDescriptor.ports_id5fn4FV$aPPc.invoke(CompositeComponent__BehaviorDescriptor.findShadowComponent_id5vJvKD7x8Kk.invoke(cc))).findFirst((it) -> SPropertyOperations.getString(it, PROPS.name$MnvL).equals(SPropertyOperations.getString(port, PROPS.name$MnvL))), createNamespace);
        return ultimateEndpoint;
      } else {
        // ... we find all delegationTarget by recursion
        Iterable<Tuples._2<SNode, SNode>> delegationEndpoints = delegationEndpoints(SLinkOperations.getTarget(instance, LINKS.component$ikVC), port);
        Iterable<Tuples._2<String, SNode>> result = Sequence.fromIterable(delegationEndpoints).translate(new _FunctionTypes._return_P1_E0<Iterable<Tuples._2<String, SNode>>, Tuples._2<SNode, SNode>>() {
          public Iterable<Tuples._2<String, SNode>> invoke(Tuples._2<SNode, SNode> delegationTarget) {
            SNode ci = delegationTarget._0();
            SNode port = delegationTarget._1();
            Iterable<Tuples._2<String, SNode>> ultimateEndpoints = ultimateEndpoint(ci, port, createNamespace(prefix, instance));
            return ultimateEndpoints;
          }
        });
        return result;
      }
    } else {
      // For an atomic component we return the instance name and the port
      Tuples._2<String, SNode> tuple = MultiTuple.<String,SNode>from(createNamespace(prefix, instance), port);
      return Sequence.<Tuples._2<String, SNode>>singleton(tuple);
    }
  }
  public static String createNamespace(String namePrefix, SNode instance) {
    String name = SPropertyOperations.getString(instance, PROPS.name$MnvL);
    return ((namePrefix == null || namePrefix.length() == 0) ? name : namePrefix + "_" + name);
  }

  private static final class PROPS {
    /*package*/ static final SProperty name$MnvL = MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name");
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept PreventConstructorCall$Kl = MetaAdapterFactory.getConcept(0x97d2424451db4e2eL, 0x97fc7bd73b1f5f40L, 0x3c30d7a405ae9de2L, "com.mbeddr.ext.components.structure.PreventConstructorCall");
    /*package*/ static final SConcept ComponentInstanceRefExpr$_C = MetaAdapterFactory.getConcept(0x97d2424451db4e2eL, 0x97fc7bd73b1f5f40L, 0x7f76b5152d3c73ebL, "com.mbeddr.ext.components.structure.ComponentInstanceRefExpr");
    /*package*/ static final SConcept CompositeComponent$c8 = MetaAdapterFactory.getConcept(0x54f2a59b97bb4c09L, 0xaf92928ebf9c5966L, 0x6bfba9786e44b3b0L, "com.mbeddr.ext.compositecomponents.structure.CompositeComponent");
    /*package*/ static final SConcept TargetInstanceName$mY = MetaAdapterFactory.getConcept(0x54f2a59b97bb4c09L, 0xaf92928ebf9c5966L, 0x3c30d7a405991249L, "com.mbeddr.ext.compositecomponents.structure.TargetInstanceName");
    /*package*/ static final SConcept FieldForInternalInstances$dy = MetaAdapterFactory.getConcept(0x54f2a59b97bb4c09L, 0xaf92928ebf9c5966L, 0x3c30d7a4058c4f71L, "com.mbeddr.ext.compositecomponents.structure.FieldForInternalInstances");
    /*package*/ static final SInterfaceConcept InstanceConfigContentsToBeCopiedIntoFlattenedInstanceConfig$xT = MetaAdapterFactory.getInterfaceConcept(0x97d2424451db4e2eL, 0x97fc7bd73b1f5f40L, 0x759064f9b474047fL, "com.mbeddr.ext.components.structure.InstanceConfigContentsToBeCopiedIntoFlattenedInstanceConfig");
    /*package*/ static final SConcept ProvidedPort$RN = MetaAdapterFactory.getConcept(0x97d2424451db4e2eL, 0x97fc7bd73b1f5f40L, 0x3e5659cd94a48fa8L, "com.mbeddr.ext.components.structure.ProvidedPort");
  }

  private static final class LINKS {
    /*package*/ static final SContainmentLink value$Sv$D = MetaAdapterFactory.getContainmentLink(0x97d2424451db4e2eL, 0x97fc7bd73b1f5f40L, 0xae5db91fd71ea1dL, 0xae5db91fd71ea1fL, "value");
    /*package*/ static final SReferenceLink ci$IlQ8 = MetaAdapterFactory.getReferenceLink(0x97d2424451db4e2eL, 0x97fc7bd73b1f5f40L, 0x7f76b5152d3c73ebL, 0x7f76b5152d3c73ecL, "ci");
    /*package*/ static final SReferenceLink component$ikVC = MetaAdapterFactory.getReferenceLink(0x97d2424451db4e2eL, 0x97fc7bd73b1f5f40L, 0x3e5659cd94a4de76L, 0x3e5659cd94a4de77L, "component");
    /*package*/ static final SReferenceLink field$SvlC = MetaAdapterFactory.getReferenceLink(0x97d2424451db4e2eL, 0x97fc7bd73b1f5f40L, 0xae5db91fd71ea1dL, 0xae5db91fd71ea1eL, "field");
    /*package*/ static final SContainmentLink contents$E4B8 = MetaAdapterFactory.getContainmentLink(0x97d2424451db4e2eL, 0x97fc7bd73b1f5f40L, 0x6bfba9786e466b00L, 0x6bfba9786e467315L, "contents");
    /*package*/ static final SContainmentLink source$ir30 = MetaAdapterFactory.getContainmentLink(0x97d2424451db4e2eL, 0x97fc7bd73b1f5f40L, 0x3e5659cd94a4de78L, 0x3e5659cd94a4de7cL, "source");
    /*package*/ static final SReferenceLink port$HUwa = MetaAdapterFactory.getReferenceLink(0x97d2424451db4e2eL, 0x97fc7bd73b1f5f40L, 0x3e5659cd94a4de79L, 0x2fceca7612fd97fbL, "port");
    /*package*/ static final SContainmentLink target$iri1 = MetaAdapterFactory.getContainmentLink(0x97d2424451db4e2eL, 0x97fc7bd73b1f5f40L, 0x3e5659cd94a4de78L, 0x3e5659cd94a4de7dL, "target");
    /*package*/ static final SReferenceLink instance$ilE8 = MetaAdapterFactory.getReferenceLink(0x97d2424451db4e2eL, 0x97fc7bd73b1f5f40L, 0x3e5659cd94a4de79L, 0x3e5659cd94a4de7aL, "instance");
    /*package*/ static final SContainmentLink portRef$g$fy = MetaAdapterFactory.getContainmentLink(0x97d2424451db4e2eL, 0x97fc7bd73b1f5f40L, 0x47c7455cc68418c2L, 0x5bd0d857daf8089dL, "portRef");
    /*package*/ static final SReferenceLink instance$87uC = MetaAdapterFactory.getReferenceLink(0x97d2424451db4e2eL, 0x97fc7bd73b1f5f40L, 0x5bd0d857daf78a76L, 0x5bd0d857daf78a77L, "instance");
    /*package*/ static final SReferenceLink port$8cCY = MetaAdapterFactory.getReferenceLink(0x97d2424451db4e2eL, 0x97fc7bd73b1f5f40L, 0x5bd0d857daf78a76L, 0x5bd0d857daf78a78L, "port");
    /*package*/ static final SReferenceLink outsidePort$z5z3 = MetaAdapterFactory.getReferenceLink(0x54f2a59b97bb4c09L, 0xaf92928ebf9c5966L, 0x6bfba9786e4aa19eL, 0x6bfba9786e4aa1c7L, "outsidePort");
  }
}
