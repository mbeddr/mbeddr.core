package com.mbeddr.ext.compositecomponents.generator.template.main;

/*Generated by MPS */

import jetbrains.mps.generator.runtime.Generated;
import jetbrains.mps.generator.impl.query.QueryProviderBase;
import jetbrains.mps.generator.template.BaseMappingRuleContext;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.generator.template.ReferenceMacroContext;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import org.jetbrains.mps.openapi.model.SNode;
import com.mbeddr.ext.components.behavior.Component__BehaviorDescriptor;
import com.mbeddr.ext.components.behavior.ComponentInstance__BehaviorDescriptor;
import jetbrains.mps.generator.template.SourceSubstituteMacroNodeContext;
import com.mbeddr.ext.compositecomponents.behavior.CompositeComponentInstanceParamRef__BehaviorDescriptor;
import jetbrains.mps.generator.template.SourceSubstituteMacroNodesContext;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.IAttributeDescriptor;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.internal.collections.runtime.Sequence;
import com.mbeddr.ext.components.behavior.AbstractInstanceConfiguration__BehaviorDescriptor;
import com.mbeddr.ext.compositecomponents.behavior.CompositeComponent__BehaviorDescriptor;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import com.mbeddr.ext.components.behavior.Runnable__BehaviorDescriptor;
import jetbrains.mps.generator.template.MappingScriptContext;
import java.util.List;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import java.util.Map;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import jetbrains.mps.internal.collections.runtime.IMapping;
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import java.util.ArrayList;
import com.mbeddr.ext.compositecomponents.generator.flatteningCompComps.util.GeneratorUtil;
import com.mbeddr.ext.components.behavior.InstanceConfiguration__BehaviorDescriptor;
import com.mbeddr.ext.components.behavior.InstanceConfigContentsToBeCopiedIntoFlattenedInstanceConfig__BehaviorDescriptor;
import jetbrains.mps.generator.template.TemplateVarContext;
import jetbrains.mps.generator.impl.query.ReductionRuleCondition;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.generator.impl.query.QueryKey;
import jetbrains.mps.generator.template.ReductionRuleQueryContext;
import jetbrains.mps.generator.impl.GenerationFailureException;
import jetbrains.mps.generator.impl.query.ScriptCodeBlock;
import jetbrains.mps.generator.impl.query.SourceNodeQuery;
import org.jetbrains.annotations.Nullable;
import jetbrains.mps.generator.impl.query.SourceNodesQuery;
import java.util.Collection;
import jetbrains.mps.util.IterableUtil;
import jetbrains.mps.generator.impl.query.ReferenceTargetQuery;
import jetbrains.mps.generator.impl.query.VariableValueQuery;
import jetbrains.mps.smodel.builder.SNodeBuilder;
import org.jetbrains.mps.openapi.language.SConcept;
import org.jetbrains.mps.openapi.language.SInterfaceConcept;
import org.jetbrains.mps.openapi.language.SReferenceLink;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import org.jetbrains.mps.openapi.language.SProperty;

@Generated
public class QueriesGenerated extends QueryProviderBase {
  public QueriesGenerated() {
    super(1);
  }
  public static boolean rule_Condition_1_0(final BaseMappingRuleContext _context) {
    return (SNodeOperations.getNodeAncestor(_context.getNode(), CONCEPTS.AtomicComponent$ym, false, false) != null);
  }
  public static boolean rule_Condition_1_1(final BaseMappingRuleContext _context) {
    return (SNodeOperations.getNodeAncestor(SLinkOperations.getTarget(_context.getNode(), LINKS.var$YUyC), CONCEPTS.CompositeComponent$c8, false, false) != null) && (SNodeOperations.getNodeAncestor(_context.getNode(), CONCEPTS.AtomicComponent$ym, false, false) != null);
  }
  public static boolean rule_Condition_1_2(final BaseMappingRuleContext _context) {
    return (SNodeOperations.getNodeAncestor(SLinkOperations.getTarget(_context.getNode(), LINKS.field$P8O8), CONCEPTS.CompositeComponent$c8, false, false) != null) && (SNodeOperations.getNodeAncestor(_context.getNode(), CONCEPTS.AtomicComponent$ym, false, false) != null);
  }
  public static boolean rule_Condition_1_3(final BaseMappingRuleContext _context) {
    return (SNodeOperations.getNodeAncestor(_context.getNode(), CONCEPTS.AtomicComponent$ym, false, false) != null) && SNodeOperations.isInstanceOf(SLinkOperations.getTarget(_context.getNode(), LINKS.expression$PfNq), CONCEPTS.ComponentRefExpr$k_);
  }
  public static Object referenceMacro_GetReferent_1_0(final ReferenceMacroContext _context) {
    return SPropertyOperations.getString(SNodeOperations.getNodeAncestor(_context.getNode(), CONCEPTS.ComponentInstance$zN, false, false), PROPS.name$MnvL);
  }
  public static Object referenceMacro_GetReferent_1_1(final ReferenceMacroContext _context) {
    return SPropertyOperations.getString(SLinkOperations.getTarget(_context.getNode(), LINKS.field$SvlC), PROPS.name$MnvL);
  }
  public static Object referenceMacro_GetReferent_1_2(final ReferenceMacroContext _context) {
    return _context.getNode();
  }
  public static Object referenceMacro_GetReferent_1_3(final ReferenceMacroContext _context) {
    return (SNode) Component__BehaviorDescriptor.onInitRunnable_id6JVEnxIjpG_.invoke(SLinkOperations.getTarget(SNodeOperations.cast(SLinkOperations.getTarget(_context.getNode(), LINKS.type$sXU3), CONCEPTS.ComponentType$8R), LINKS.component$5BtC));
  }
  public static Object referenceMacro_GetReferent_1_4(final ReferenceMacroContext _context) {
    return SPropertyOperations.getString(_context.getNode(), PROPS.instanceName$PjJE) + "_" + SPropertyOperations.getString(SLinkOperations.getTarget(_context.getNode(), LINKS.providedPort$Pdbe), PROPS.name$MnvL);
  }
  public static Object referenceMacro_GetReferent_1_5(final ReferenceMacroContext _context) {
    return SPropertyOperations.getString(SLinkOperations.getTarget(_context.getNode(), LINKS.var$YUyC), PROPS.name$MnvL);
  }
  public static Object referenceMacro_GetReferent_1_6(final ReferenceMacroContext _context) {
    return SPropertyOperations.getString(SLinkOperations.getTarget(_context.getNode(), LINKS.field$P8O8), PROPS.name$MnvL);
  }
  public static Object referenceMacro_GetReferent_1_7(final ReferenceMacroContext _context) {
    return SPropertyOperations.getString(SLinkOperations.getTarget(SNodeOperations.cast(SLinkOperations.getTarget(_context.getNode(), LINKS.expression$PfNq), CONCEPTS.ComponentRefExpr$k_), LINKS.instance$Oefo), PROPS.name$MnvL);
  }
  public static Object referenceMacro_GetReferent_1_8(final ReferenceMacroContext _context) {
    SNode cre = SNodeOperations.cast(SLinkOperations.getTarget(_context.getNode(), LINKS.expression$PfNq), CONCEPTS.ComponentRefExpr$k_);
    return (SNode) ComponentInstance__BehaviorDescriptor.getEffectiveRunnable_idwOd6nl5fEm.invoke(SLinkOperations.getTarget(cre, LINKS.instance$Oefo), SLinkOperations.getTarget(cre, LINKS.providedPort$C8zD), SLinkOperations.getTarget(_context.getNode(), LINKS.operation$jSaZ));
  }
  public static SNode sourceNodeQuery_1_0(final SourceSubstituteMacroNodeContext _context) {
    SNode value = SLinkOperations.getTarget(_context.getNode(), LINKS.value$Sv$D);
    return value;
  }
  public static SNode sourceNodeQuery_1_1(final SourceSubstituteMacroNodeContext _context) {
    return SNodeOperations.copyNode(CompositeComponentInstanceParamRef__BehaviorDescriptor.value_id2LSSMkCHjBX.invoke(_context.getNode()));
  }
  public static Iterable<SNode> sourceNodesQuery_1_0(final SourceSubstituteMacroNodesContext _context) {
    SNode ac = SNodeOperations.getNodeAncestor(_context.getNode(), CONCEPTS.AtomicComponent$ym, false, false);
    final String property = SPropertyOperations.getString(new IAttributeDescriptor.NodeAttribute(CONCEPTS.CompositeComponentName$Sr).get(ac), PROPS.name$MnvL);
    SNode cc = SNodeOperations.cast(ListSequence.fromList(SNodeOperations.getAllSiblings(ac, false)).findFirst((it) -> SNodeOperations.isInstanceOf(it, CONCEPTS.CompositeComponent$c8) && SPropertyOperations.getString(SNodeOperations.cast(it, CONCEPTS.CompositeComponent$c8), PROPS.name$MnvL).equals(property)), CONCEPTS.CompositeComponent$c8);
    Iterable<SNode> seq = Sequence.fromIterable(AbstractInstanceConfiguration__BehaviorDescriptor.instances_id6JVEnxIhC2$.invoke(CompositeComponent__BehaviorDescriptor.innerInstanceConfig_id6JVEnxIjbYq.invoke(cc))).translate((it) -> {
      return Sequence.fromIterable(ComponentInstance__BehaviorDescriptor.fieldInitializers_id29JE8qNu0TX.invoke(it)).where(new _FunctionTypes._return_P1_E0<Boolean, SNode>() {
        public Boolean invoke(SNode it) {
          return (new IAttributeDescriptor.NodeAttribute(CONCEPTS.FieldForInternalInstances$dy).get(SLinkOperations.getTarget(it, LINKS.field$SvlC)) == null);
        }
      });
    });
    return seq;
  }
  public static Iterable<SNode> sourceNodesQuery_1_1(final SourceSubstituteMacroNodesContext _context) {
    return (Iterable<SNode>) Runnable__BehaviorDescriptor.allReferencedProvidedPortsWithContext_id3LPPE_giCuF.invoke(Component__BehaviorDescriptor.onInitRunnable_id6JVEnxIjpG_.invoke(SLinkOperations.getTarget(SNodeOperations.cast(SLinkOperations.getTarget(_context.getNode(), LINKS.type$sXU3), CONCEPTS.ComponentType$8R), LINKS.component$5BtC)), SPropertyOperations.getString(_context.getNode(), PROPS.name$MnvL));
  }
  public static Iterable<SNode> sourceNodesQuery_1_2(final SourceSubstituteMacroNodesContext _context) {
    return Sequence.fromIterable(Component__BehaviorDescriptor.fields_id6JVEnxIj2nQ.invoke(SNodeOperations.getNodeAncestor(_context.getNode(), CONCEPTS.AtomicComponent$ym, false, false))).where((it) -> {

      return (new IAttributeDescriptor.NodeAttribute(CONCEPTS.FieldForInternalInstances$dy).get(it) != null) && (Component__BehaviorDescriptor.onInitRunnable_id6JVEnxIjpG_.invoke(SLinkOperations.getTarget(SNodeOperations.cast(SLinkOperations.getTarget(it, LINKS.type$sXU3), CONCEPTS.ComponentType$8R), LINKS.component$5BtC)) != null);
    });
  }
  public static Iterable<SNode> sourceNodesQuery_1_3(final SourceSubstituteMacroNodesContext _context) {
    return SLinkOperations.getChildren(_context.getNode(), LINKS.actuals$OVo1);
  }
  public static void mappingScript_CodeBlock_0(final MappingScriptContext _context) {
    // We first add a shadow component for each CompositeComponent. We need that so we can create a componenttype-init field for each internal instance
    List<SNode> compositeComponents = SModelOperations.nodes(_context.getModel(), CONCEPTS.CompositeComponent$c8);
    for (SNode cc : ListSequence.fromList(compositeComponents)) {
      SNode shadow = CompositeComponent__BehaviorDescriptor.createShadowComponent_id5vJvKD7x8K0.invoke(cc);
      SNodeOperations.insertNextSiblingChild(cc, shadow);
    }

    for (SNode cc : ListSequence.fromList(compositeComponents)) {
      final SNode shadowComponent = CompositeComponent__BehaviorDescriptor.findShadowComponent_id5vJvKD7x8Kk.invoke(cc);
      SNode instanceConfig = CompositeComponent__BehaviorDescriptor.innerInstanceConfig_id6JVEnxIjbYq.invoke(cc);

      Map<Tuples._2<SNode, SNode>, SNode> compRef2ReqPort = MapSequence.fromMap(new HashMap<Tuples._2<SNode, SNode>, SNode>());

      for (final SNode compRef : ListSequence.fromList(SNodeOperations.getNodeDescendants(shadowComponent, CONCEPTS.ComponentRefExpr$k_, false, new SAbstractConcept[]{})).where((it) -> SNodeOperations.isInstanceOf(SNodeOperations.getParent(it), CONCEPTS.InterfaceOperationCallExpr$vv))) {
        IMapping<Tuples._2<SNode, SNode>, SNode> mapping = MapSequence.fromMap(compRef2ReqPort).findFirst((it) -> {
          Tuples._2<SNode, SNode> pair = it.key();
          return pair._0() == SLinkOperations.getTarget(compRef, LINKS.instance$Oefo) && pair._1() == SLinkOperations.getTarget(compRef, LINKS.providedPort$C8zD);
        });

        SNode req;

        if (mapping == null) {
          req = createRequiredPort_x583g4_a0a0e0f0e0u(SLinkOperations.getTarget(SLinkOperations.getTarget(compRef, LINKS.providedPort$C8zD), LINKS.intf$QYND), SPropertyOperations.getString(SLinkOperations.getTarget(compRef, LINKS.instance$Oefo), PROPS.name$MnvL) + "_" + SPropertyOperations.getString(SLinkOperations.getTarget(compRef, LINKS.providedPort$C8zD), PROPS.name$MnvL));
          MapSequence.fromMap(compRef2ReqPort).put(MultiTuple.<SNode,SNode>from(SLinkOperations.getTarget(compRef, LINKS.instance$Oefo), SLinkOperations.getTarget(compRef, LINKS.providedPort$C8zD)), req);
          ListSequence.fromList(SLinkOperations.getChildren(shadowComponent, LINKS.contents$Hh35)).addElement(req);
        } else {
          req = mapping.value();
        }

        SNode interfaceOpCall = SNodeOperations.cast(SNodeOperations.getParent(compRef), CONCEPTS.InterfaceOperationCallExpr$vv);
        SNodeOperations.replaceWithAnother(interfaceOpCall, createRequiredPortOpCallExpr_x583g4_a0a7a5a4a02(req, SLinkOperations.getTarget(interfaceOpCall, LINKS.operation$jSaZ), ListSequence.fromList(SLinkOperations.getChildren(interfaceOpCall, LINKS.actuals$OVo1)).select((it) -> SNodeOperations.copyNode(it))));
      }

      // First we need to create an instance for the shadow component. It will be added to the composite component's internal instances.
      SNode shadowInstance = CompositeComponent__BehaviorDescriptor.createShadowInstance_id5vJvKD7xN05.invoke(cc);


      ListSequence.fromList(SLinkOperations.getChildren(instanceConfig, LINKS.contents$E4B8)).addElement(shadowInstance);
      for (IMapping<Tuples._2<SNode, SNode>, SNode> mapping : MapSequence.fromMap(compRef2ReqPort)) {
        ListSequence.fromList(SLinkOperations.getChildren(instanceConfig, LINKS.contents$E4B8)).addElement(createAssemblyConnector_x583g4_a0a0a21a4a02(shadowInstance, mapping.value(), mapping.key()._0(), mapping.key()._1()));
      }

      // all required ports are connected to the respective required ports in the shadow component. A delegating connector is used for that.
      for (final SNode rp : Sequence.fromIterable(Component__BehaviorDescriptor.allRequiredPorts_id71UKpntoZWS.invoke(cc))) {
        SNode dc = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0x54f2a59b97bb4c09L, 0xaf92928ebf9c5966L, 0x6bfba9786e4aa19eL, "com.mbeddr.ext.compositecomponents.structure.DelegatingConnector"));
        SLinkOperations.setTarget(dc, LINKS.outsidePort$z5z3, rp);
        SLinkOperations.setTarget(dc, LINKS.internalInstance$2LQn, shadowInstance);
        SLinkOperations.setTarget(dc, LINKS.internalPort$2M5o, Sequence.fromIterable(Component__BehaviorDescriptor.allRequiredPorts_id71UKpntoZWS.invoke(shadowComponent)).findFirst((it) -> SPropertyOperations.getString(it, PROPS.name$MnvL).equals(SPropertyOperations.getString(rp, PROPS.name$MnvL))));
        SNodeOperations.insertNextSiblingChild(shadowInstance, dc);
      }

      // For each internal instance (except the shadow) we add init field to the shadow component. This field represents the inner instance (using the componenttype type). This is necessary so that the shadow component can later initialize all internal instances.
      for (SNode innerInstance : Sequence.fromIterable(AbstractInstanceConfiguration__BehaviorDescriptor.instances_id6JVEnxIhC2$.invoke(instanceConfig)).where((it) -> SLinkOperations.getTarget(it, LINKS.component$ikVC) != shadowComponent)) {
        SNode fieldForInstance = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0x97d2424451db4e2eL, 0x97fc7bd73b1f5f40L, 0x49ac54536382ded3L, "com.mbeddr.ext.components.structure.Field"));
        SNode ct = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0x97d2424451db4e2eL, 0x97fc7bd73b1f5f40L, 0x7c8320896c8aa448L, "com.mbeddr.ext.components.structure.ComponentType"));
        if (SNodeOperations.isInstanceOf(SLinkOperations.getTarget(innerInstance, LINKS.component$ikVC), CONCEPTS.AtomicComponent$ym)) {
          SLinkOperations.setTarget(ct, LINKS.component$5BtC, SLinkOperations.getTarget(innerInstance, LINKS.component$ikVC));
        } else {
          SLinkOperations.setTarget(ct, LINKS.component$5BtC, CompositeComponent__BehaviorDescriptor.findShadowComponent_id5vJvKD7x8Kk.invoke(SNodeOperations.cast(SLinkOperations.getTarget(innerInstance, LINKS.component$ikVC), CONCEPTS.CompositeComponent$c8)));
        }

        SLinkOperations.setTarget(fieldForInstance, LINKS.type$sXU3, ct);
        SPropertyOperations.assign(fieldForInstance, PROPS.initField$Wgp_, true);
        SPropertyOperations.assign(fieldForInstance, PROPS.name$MnvL, SPropertyOperations.getString(innerInstance, PROPS.name$MnvL));
        new IAttributeDescriptor.NodeAttribute(CONCEPTS.FieldForInternalInstances$dy).setNew(fieldForInstance);
        ListSequence.fromList(SLinkOperations.getChildren(shadowComponent, LINKS.contents$Hh35)).addElement(fieldForInstance);

        SNode ifi = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0x97d2424451db4e2eL, 0x97fc7bd73b1f5f40L, 0xae5db91fd71ea1dL, "com.mbeddr.ext.components.structure.InitFieldInitializer"));
        SLinkOperations.setTarget(ifi, LINKS.field$SvlC, fieldForInstance);
        SNode compInstanceRef = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0x97d2424451db4e2eL, 0x97fc7bd73b1f5f40L, 0x7f76b5152d3c73ebL, "com.mbeddr.ext.components.structure.ComponentInstanceRefExpr"));
        SLinkOperations.setTarget(compInstanceRef, LINKS.ci$IlQ8, innerInstance);
        SLinkOperations.setTarget(ifi, LINKS.value$Sv$D, compInstanceRef);
        ListSequence.fromList(SLinkOperations.getChildren(shadowInstance, LINKS.initializers$gWXm)).addElement(ifi);

      }
    }

  }
  public static void mappingScript_CodeBlock_2(final MappingScriptContext _context) {

    // go through all instance configs in the model and reduce composite components to atomic ones
    for (SNode instanceConfig : ListSequence.fromList(SModelOperations.nodes(_context.getModel(), CONCEPTS.InstanceConfiguration$MO))) {

      // First we collect the names of the instances in the instance configuration (not those inside composite comp instances). For those we need to call the constructor during initialisation later. For the others, the constructor of the CC from which they have been flattened called the constructor.
      final List<String> instancesNotCreatedByFlattening = ListSequence.fromList(new ArrayList<String>());
      for (SNode i : Sequence.fromIterable(AbstractInstanceConfiguration__BehaviorDescriptor.instances_id6JVEnxIhC2$.invoke(instanceConfig))) {
        if ((boolean) ComponentInstance__BehaviorDescriptor.isComponentAtomic_id5vJvKD7xsW0.invoke(i)) {
          ListSequence.fromList(instancesNotCreatedByFlattening).addElement(SPropertyOperations.getString(i, PROPS.name$MnvL));
        } else {
          ListSequence.fromList(instancesNotCreatedByFlattening).addElement(SPropertyOperations.getString(i, PROPS.name$MnvL) + "_" + CompositeComponent__BehaviorDescriptor.shadowInstanceName_id5vJvKD7xPJg.invoke(SNodeOperations.cast(SLinkOperations.getTarget(i, LINKS.component$ikVC), CONCEPTS.CompositeComponent$c8)));
        }
      }

      // All assembly connectors are copied/cloned for internal reasons (see below). For such ass connectors that end on a composite component instance, we resolve their ultimate targets (they may be delegated to more than one internal instance port) and reconnect them.
      List<SNode> collectedConnectors = new ArrayList<SNode>();

      Iterable<SNode> connectors = AbstractInstanceConfiguration__BehaviorDescriptor.assemblyConnectors_id6JVEnxIhC2V.invoke(instanceConfig);
      GeneratorUtil.handleAssemblyConnectors(connectors, "", collectedConnectors);
      // we delete the original ones since at least one new one has been created for each of them
      Sequence.fromIterable(connectors).visitAll((it) -> SNodeOperations.deleteNode(it));
      ListSequence.fromList(SLinkOperations.getChildren(instanceConfig, LINKS.contents$E4B8)).addSequence(ListSequence.fromList(collectedConnectors));


      // Next we need to rewire the PortAdapers to the ultimate delegation endpoint
      Sequence.fromIterable(InstanceConfiguration__BehaviorDescriptor.adapters_id5fn4FV$c8kP.invoke(instanceConfig)).visitAll((it) -> GeneratorUtil.handleAdapterPortRef(it, ""));

      Iterable<SNode> seq = SNodeOperations.ofConcept(SLinkOperations.getChildren(instanceConfig, LINKS.contents$E4B8), CONCEPTS.InstanceConfigContentsToBeCopiedIntoFlattenedInstanceConfig$xT);
      Sequence.fromIterable(seq).visitAll((it) -> GeneratorUtil.handleInstanceUpdate(it, ""));


      // For all instances of composite components we need to ...
      for (final SNode cci : Sequence.fromIterable(AbstractInstanceConfiguration__BehaviorDescriptor.instances_id6JVEnxIhC2$.invoke(instanceConfig)).where((it) -> !((boolean) ComponentInstance__BehaviorDescriptor.isComponentAtomic_id5vJvKD7xsW0.invoke(it)))) {

        // ... expand the composite component and add the result to the original instance config
        List<SNode> flattenedInstances = new ArrayList<SNode>();
        GeneratorUtil.flattenCompositeInstances(cci, flattenedInstances, "");
        for (SNode fi : ListSequence.fromList(flattenedInstances)) {
          SNodeOperations.insertPrevSiblingChild(cci, fi);
        }

        // Next we find the shadow instance for the currently handled composite component...
        SNode shadowInstance = Sequence.fromIterable(AbstractInstanceConfiguration__BehaviorDescriptor.instances_id6JVEnxIhC2$.invoke(instanceConfig)).findFirst((it) -> {
          String shadowInstanceName = GeneratorUtil.createNamespace(SPropertyOperations.getString(cci, PROPS.name$MnvL), CompositeComponent__BehaviorDescriptor.findShadowInstance_id5vJvKD7xN3Q.invoke(SNodeOperations.cast(SLinkOperations.getTarget(cci, LINKS.component$ikVC), CONCEPTS.CompositeComponent$c8)));
          return SPropertyOperations.getString(it, PROPS.name$MnvL).equals(shadowInstanceName);
        });

        // ... and move the init values from the original composite component instance over to the shadow instance
        for (final SNode initializer : Sequence.fromIterable(ComponentInstance__BehaviorDescriptor.fieldInitializers_id29JE8qNu0TX.invoke(cci))) {
          SNode ifi = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0x97d2424451db4e2eL, 0x97fc7bd73b1f5f40L, 0xae5db91fd71ea1dL, "com.mbeddr.ext.components.structure.InitFieldInitializer"));
          SLinkOperations.setTarget(ifi, LINKS.field$SvlC, Sequence.fromIterable(Component__BehaviorDescriptor.fields_id6JVEnxIj2nQ.invoke(SLinkOperations.getTarget(shadowInstance, LINKS.component$ikVC))).findFirst((it) -> SPropertyOperations.getString(it, PROPS.name$MnvL).equals(SPropertyOperations.getString(SLinkOperations.getTarget(initializer, LINKS.field$SvlC), PROPS.name$MnvL))));
          SLinkOperations.setTarget(ifi, LINKS.value$Sv$D, SLinkOperations.getTarget(initializer, LINKS.value$Sv$D));
          ListSequence.fromList(SLinkOperations.getChildren(shadowInstance, LINKS.initializers$gWXm)).addElement(ifi);
        }



        // now we can delete the original instance of the composite component
        SNodeOperations.deleteNode(cci);
      }

      // now we resolve the target instances of the ComponentInstanceRef by name ("lazy" references). The name was stored in a string property during the expansion of the composite components
      for (SNode cir : ListSequence.fromList(SNodeOperations.getNodeDescendants(instanceConfig, CONCEPTS.ComponentInstanceRefExpr$_C, false, new SAbstractConcept[]{})).where((it) -> (new IAttributeDescriptor.NodeAttribute(CONCEPTS.TargetInstanceName$mY).get(it) != null))) {
        String targetInstanceName = SPropertyOperations.getString(new IAttributeDescriptor.NodeAttribute(CONCEPTS.TargetInstanceName$mY).get(cir), PROPS.name$MnvL);
        SLinkOperations.setTarget(cir, LINKS.ci$IlQ8, InstanceConfiguration__BehaviorDescriptor.findInstanceByName_id2LSSMkCIUME.invoke(SNodeOperations.getNodeAncestor(cir, CONCEPTS.InstanceConfiguration$MO, false, false), targetInstanceName));
        SNodeOperations.deleteNode(new IAttributeDescriptor.NodeAttribute(CONCEPTS.TargetInstanceName$mY).get(cir));
      }

      // same procedure for each InstancePortRef...
      for (SNode ipr : ListSequence.fromList(SNodeOperations.getNodeDescendants(instanceConfig, CONCEPTS.ComponentPortRef$_g, false, new SAbstractConcept[]{})).where((it) -> (new IAttributeDescriptor.NodeAttribute(CONCEPTS.TargetInstanceName$mY).get(it) != null))) {
        String targetInstanceName = SPropertyOperations.getString(new IAttributeDescriptor.NodeAttribute(CONCEPTS.TargetInstanceName$mY).get(ipr), PROPS.name$MnvL);
        SLinkOperations.setTarget(ipr, LINKS.instance$ilE8, InstanceConfiguration__BehaviorDescriptor.findInstanceByName_id2LSSMkCIUME.invoke(SNodeOperations.getNodeAncestor(ipr, CONCEPTS.InstanceConfiguration$MO, false, false), targetInstanceName));
        SNodeOperations.deleteNode(new IAttributeDescriptor.NodeAttribute(CONCEPTS.TargetInstanceName$mY).get(ipr));
      }

      // ... and PortAdapter
      for (SNode ipr : ListSequence.fromList(SNodeOperations.getNodeDescendants(instanceConfig, CONCEPTS.AdapterInstancePortRef$8T, false, new SAbstractConcept[]{})).where((it) -> (new IAttributeDescriptor.NodeAttribute(CONCEPTS.TargetInstanceName$mY).get(it) != null))) {
        String targetInstanceName = SPropertyOperations.getString(new IAttributeDescriptor.NodeAttribute(CONCEPTS.TargetInstanceName$mY).get(ipr), PROPS.name$MnvL);
        SNode findInstanceByName = InstanceConfiguration__BehaviorDescriptor.findInstanceByName_id2LSSMkCIUME.invoke(SNodeOperations.getNodeAncestor(ipr, CONCEPTS.InstanceConfiguration$MO, false, false), targetInstanceName);

        // temporary variable needed because of https://youtrack.jetbrains.com/issue/MPS-21211
        SNode port = SLinkOperations.getTarget(ipr, LINKS.port$8cCY);


        // we need to replace the AdapterInstancePortRef with a new one to prevent MPS from trying to resolve the old instance and thus throwing some error messages
        SNode replaceWithNew = SNodeOperations.replaceWithNewChild(ipr, CONCEPTS.AdapterInstancePortRef$8T);
        SLinkOperations.setTarget(replaceWithNew, LINKS.instance$87uC, findInstanceByName);


        SLinkOperations.setTarget(replaceWithNew, LINKS.port$8cCY, port);

      }

      // ... and other stuff that references instances
      for (SNode icc : ListSequence.fromList(SNodeOperations.getNodeDescendants(instanceConfig, CONCEPTS.InstanceConfigContentsToBeCopiedIntoFlattenedInstanceConfig$xT, false, new SAbstractConcept[]{})).where((it) -> (new IAttributeDescriptor.NodeAttribute(CONCEPTS.TargetInstanceName$mY).get(it) != null))) {
        String targetInstanceName = SPropertyOperations.getString(new IAttributeDescriptor.NodeAttribute(CONCEPTS.TargetInstanceName$mY).get(icc), PROPS.name$MnvL);
        SNode findInstanceByName = InstanceConfiguration__BehaviorDescriptor.findInstanceByName_id2LSSMkCIUME.invoke(SNodeOperations.getNodeAncestor(icc, CONCEPTS.InstanceConfiguration$MO, false, false), targetInstanceName);

        // create a copy so that MPS does not complain
        SNode copy = SNodeOperations.cast(SNodeOperations.copyNode(icc), CONCEPTS.InstanceConfigContentsToBeCopiedIntoFlattenedInstanceConfig$xT);
        InstanceConfigContentsToBeCopiedIntoFlattenedInstanceConfig__BehaviorDescriptor.setReferencedInstance_id7mgpfAOv757.invoke(copy, findInstanceByName);
        SNodeOperations.deleteNode(new IAttributeDescriptor.NodeAttribute(CONCEPTS.TargetInstanceName$mY).get(copy));

        SNodeOperations.replaceWithAnother(icc, copy);

      }

      // When calling the constructors for the instances in the instance config we must not call the constructor for those instances that are the result of flattening the composite components. Instead these constructors are called by the constructor of the shadow component created from the CC. This is important to keep the init order consistent. So again, we go over all instances. For each original instance we need to remove the flag which will prevent the constructor from being called. This flag has been added during expansion of composite components. For all other component instances we delete the init parameters. Those will be set by the constructor if the ambient shadow component
      Sequence.fromIterable(AbstractInstanceConfiguration__BehaviorDescriptor.instances_id6JVEnxIhC2$.invoke(instanceConfig)).visitAll((it) -> {
        if (ListSequence.fromList(instancesNotCreatedByFlattening).contains(SPropertyOperations.getString(it, PROPS.name$MnvL))) {
          SNodeOperations.deleteNode(new IAttributeDescriptor.NodeAttribute(CONCEPTS.PreventConstructorCall$Kl).get(it));
        } else {
          // Component instances which were created in the flattening process may have "calculated" init values and hence they have to be set by the constructor of the shadow component that actually performs this calculation. They cannot just be passed in from the instance configuration. Hence we can delete the original init field initializers.
          Sequence.fromIterable(ComponentInstance__BehaviorDescriptor.fieldInitializers_id29JE8qNu0TX.invoke(it)).where(new _FunctionTypes._return_P1_E0<Boolean, SNode>() {
            public Boolean invoke(SNode it) {
              return (new IAttributeDescriptor.NodeAttribute(CONCEPTS.FieldForInternalInstances$dy).get(SLinkOperations.getTarget(it, LINKS.field$SvlC)) == null);
            }
          }).visitAll(new _FunctionTypes._void_P1_E0<SNode>() {
            public void invoke(SNode it) {
              SNodeOperations.deleteNode(it);
            }
          });
        }
      });
    }

    // finally we can delete the composite components.
    for (SNode cc : ListSequence.fromList(SModelOperations.nodes(_context.getModel(), CONCEPTS.CompositeComponent$c8))) {
      SNodeOperations.deleteNode(cc);
    }
  }
  public static Object varMacro_Value_1_0(final TemplateVarContext _context) {
    return _context.getNode();
  }
  private final Map<String, ReductionRuleCondition> rrcMethods = new HashMap<String, ReductionRuleCondition>();
  {
    int i = 0;
    rrcMethods.put("2783362721540572812", new RRC(i++));
    rrcMethods.put("2783362721540573047", new RRC(i++));
    rrcMethods.put("2783362721540573089", new RRC(i++));
    rrcMethods.put("4859596973184784632", new RRC(i++));
  }
  @Override
  @NotNull
  public ReductionRuleCondition getReductionRuleCondition(@NotNull QueryKey identity) {
    ReductionRuleCondition query = identity.forTemplateNode(rrcMethods);
    return (query != null ? query : super.getReductionRuleCondition(identity));
  }
  private static class RRC implements ReductionRuleCondition {
    private final int methodKey;
    public RRC(int methodKey) {
      this.methodKey = methodKey;
    }
    @Override
    public boolean check(ReductionRuleQueryContext ctx) throws GenerationFailureException {
      switch (methodKey) {
        case 0:
          return QueriesGenerated.rule_Condition_1_0(ctx);
        case 1:
          return QueriesGenerated.rule_Condition_1_1(ctx);
        case 2:
          return QueriesGenerated.rule_Condition_1_2(ctx);
        case 3:
          return QueriesGenerated.rule_Condition_1_3(ctx);
        default:
          throw new GenerationFailureException(String.format("Inconsistent QueriesGenerated: there's no condition method for rule %s (key: #%d)", ctx.getTemplateReference(), methodKey));
      }
    }
  }
  private final Map<String, ScriptCodeBlock> mscbMethods = new HashMap<String, ScriptCodeBlock>();
  {
    int i = 0;
    mscbMethods.put("3716489659188527731", new SCB(i++));
    mscbMethods.put("3716489659188528324", new SCB(i++));
  }
  @Override
  @NotNull
  public ScriptCodeBlock getScriptCodeBlock(@NotNull QueryKey identity) {
    ScriptCodeBlock query = identity.forTemplateNode(mscbMethods);
    return (query != null ? query : super.getScriptCodeBlock(identity));
  }
  private static class SCB implements ScriptCodeBlock {
    private final int methodKey;
    public SCB(int methodKey) {
      this.methodKey = methodKey;
    }
    @Override
    public void invoke(MappingScriptContext ctx) throws GenerationFailureException {
      switch (methodKey) {
        case 0:
          QueriesGenerated.mappingScript_CodeBlock_0(ctx);
          return;
        case 1:
          QueriesGenerated.mappingScript_CodeBlock_2(ctx);
          return;
        default:
          throw new GenerationFailureException(String.format("There's no code block with method index %d ", methodKey));
      }
    }
  }
  private final Map<String, SourceNodeQuery> snqMethods = new HashMap<String, SourceNodeQuery>();
  {
    int i = 0;
    snqMethods.put("2783362721540572834", new SNQ(i++));
    snqMethods.put("2783362721540573038", new SNQ(i++));
  }
  @NotNull
  @Override
  public SourceNodeQuery getSourceNodeQuery(@NotNull QueryKey identity) {
    SourceNodeQuery query = identity.forFunctionNode(snqMethods);
    return (query != null ? query : super.getSourceNodeQuery(identity));
  }
  private static class SNQ implements SourceNodeQuery {
    private final int methodKey;
    public SNQ(int methodKey) {
      this.methodKey = methodKey;
    }
    @Nullable
    public SNode evaluate(@NotNull SourceSubstituteMacroNodeContext ctx) throws GenerationFailureException {
      switch (methodKey) {
        case 0:
          return QueriesGenerated.sourceNodeQuery_1_0(ctx);
        case 1:
          return QueriesGenerated.sourceNodeQuery_1_1(ctx);
        default:
          throw new GenerationFailureException(String.format("Inconsistent QueriesGenerated: there's no method for query %s (key: #%d)", ctx.getTemplateReference(), methodKey));
      }
    }
  }
  private final Map<String, SourceNodesQuery> snsqMethods = new HashMap<String, SourceNodesQuery>();
  {
    int i = 0;
    snsqMethods.put("2783362721540572873", new SNsQ(i++));
    snsqMethods.put("4059757252610952689", new SNsQ(i++));
    snsqMethods.put("2783362721540572976", new SNsQ(i++));
    snsqMethods.put("4859596973185759939", new SNsQ(i++));
  }
  @NotNull
  @Override
  public SourceNodesQuery getSourceNodesQuery(@NotNull QueryKey identity) {
    SourceNodesQuery query = identity.forFunctionNode(snsqMethods);
    return (query != null ? query : super.getSourceNodesQuery(identity));
  }
  private static class SNsQ implements SourceNodesQuery {
    private final int methodKey;
    public SNsQ(int methodKey) {
      this.methodKey = methodKey;
    }
    @NotNull
    public Collection<SNode> evaluate(@NotNull SourceSubstituteMacroNodesContext ctx) throws GenerationFailureException {
      switch (methodKey) {
        case 0:
          return IterableUtil.asCollection(QueriesGenerated.sourceNodesQuery_1_0(ctx));
        case 1:
          return IterableUtil.asCollection(QueriesGenerated.sourceNodesQuery_1_1(ctx));
        case 2:
          return IterableUtil.asCollection(QueriesGenerated.sourceNodesQuery_1_2(ctx));
        case 3:
          return IterableUtil.asCollection(QueriesGenerated.sourceNodesQuery_1_3(ctx));
        default:
          throw new GenerationFailureException(String.format("Inconsistent QueriesGenerated: there's no method for query %s (key: #%d)", ctx.getTemplateReference(), methodKey));
      }
    }
  }
  private final Map<String, ReferenceTargetQuery> rtqMethods = new HashMap<String, ReferenceTargetQuery>();
  {
    rtqMethods.put("2783362721540572846", new RTQ(0, "refToAComponent"));
    rtqMethods.put("2783362721540572858", new RTQ(1, "aField"));
    rtqMethods.put("2783362721540572957", new RTQ(2, "refToAComponent"));
    rtqMethods.put("2783362721540572963", new RTQ(3, "setup"));
    rtqMethods.put("4059757252611317344", new RTQ(4, "providedPort"));
    rtqMethods.put("2783362721540573059", new RTQ(5, "aVar"));
    rtqMethods.put("2783362721540573101", new RTQ(6, "aField"));
    rtqMethods.put("4859596973185753750", new RTQ(7, "aComp"));
    rtqMethods.put("4859596973185756747", new RTQ(8, "setup"));
  }
  @NotNull
  @Override
  public ReferenceTargetQuery getReferenceTargetQuery(@NotNull QueryKey queryKey) {
    ReferenceTargetQuery query = queryKey.forTemplateNode(rtqMethods);
    return (query != null ? query : super.getReferenceTargetQuery(queryKey));
  }
  private static class RTQ extends ReferenceTargetQuery.Base {
    private final int methodKey;
    /*package*/ RTQ(int methodKey, String templateValue) {
      super(templateValue);
      this.methodKey = methodKey;
    }
    @Nullable
    public Object evaluate(@NotNull ReferenceMacroContext ctx) throws GenerationFailureException {
      switch (methodKey) {
        case 0:
          return QueriesGenerated.referenceMacro_GetReferent_1_0(ctx);
        case 1:
          return QueriesGenerated.referenceMacro_GetReferent_1_1(ctx);
        case 2:
          return QueriesGenerated.referenceMacro_GetReferent_1_2(ctx);
        case 3:
          return QueriesGenerated.referenceMacro_GetReferent_1_3(ctx);
        case 4:
          return QueriesGenerated.referenceMacro_GetReferent_1_4(ctx);
        case 5:
          return QueriesGenerated.referenceMacro_GetReferent_1_5(ctx);
        case 6:
          return QueriesGenerated.referenceMacro_GetReferent_1_6(ctx);
        case 7:
          return QueriesGenerated.referenceMacro_GetReferent_1_7(ctx);
        case 8:
          return QueriesGenerated.referenceMacro_GetReferent_1_8(ctx);
        default:
          throw new GenerationFailureException(String.format("Inconsistent QueriesGenerated: there's no method for query %s (key: #%d)", ctx.getTemplateReference(), methodKey));
      }
    }
  }
  private final Map<String, VariableValueQuery> vvqMethods = new HashMap<String, VariableValueQuery>();
  {
    vvqMethods.put("3924714377503682123", new VVQ(0));
  }
  @NotNull
  @Override
  public VariableValueQuery getVariableValueQuery(@NotNull QueryKey queryKey) {
    VariableValueQuery query = queryKey.forTemplateNode(vvqMethods);
    return (query != null ? query : super.getVariableValueQuery(queryKey));
  }
  private static class VVQ implements VariableValueQuery {
    private final int methodKey;
    /*package*/ VVQ(int methodKey) {
      this.methodKey = methodKey;
    }
    @Nullable
    public Object evaluate(@NotNull TemplateVarContext ctx) throws GenerationFailureException {
      switch (methodKey) {
        case 0:
          return QueriesGenerated.varMacro_Value_1_0(ctx);
        default:
          throw new GenerationFailureException(String.format("Inconsistent QueriesGenerated: there's no method for query %s (key: #%d)", ctx.getTemplateReference(), methodKey));
      }
    }
  }
  private static SNode createRequiredPort_x583g4_a0a0e0f0e0u(SNode p0, String p1) {
    SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.RequiredPort$Si);
    n0.setReferenceTarget(LINKS.intf$QYND, p0);
    n0.setProperty(PROPS.name$MnvL, p1);
    return n0.getResult();
  }
  private static SNode createRequiredPortOpCallExpr_x583g4_a0a7a5a4a02(SNode p0, SNode p1, Iterable<? extends SNode> p2) {
    SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.RequiredPortOpCallExpr$Xu);
    {
      SNodeBuilder n1 = n0.forChild(LINKS.expression$PfNq).init(CONCEPTS.PortRefExpr$IW);
      n1.setReferenceTarget(LINKS.port$IUw8, p0);
    }
    n0.setReferenceTarget(LINKS.operation$jSaZ, p1);
    n0.forChild(LINKS.actuals$OVo1).initNodeList(p2, CONCEPTS.Expression$bT);
    return n0.getResult();
  }
  private static SNode createAssemblyConnector_x583g4_a0a0a21a4a02(SNode p0, SNode p1, SNode p2, SNode p3) {
    SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.AssemblyConnector$$L);
    {
      SNodeBuilder n1 = n0.forChild(LINKS.source$ir30).init(CONCEPTS.ComponentPortRef$_g);
      n1.setReferenceTarget(LINKS.instance$ilE8, p0);
      n1.setReferenceTarget(LINKS.port$HUwa, p1);
    }
    {
      SNodeBuilder n2 = n0.forChild(LINKS.target$iri1).init(CONCEPTS.ComponentPortRef$_g);
      n2.setReferenceTarget(LINKS.instance$ilE8, p2);
      n2.setReferenceTarget(LINKS.port$HUwa, p3);
    }
    return n0.getResult();
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept AtomicComponent$ym = MetaAdapterFactory.getConcept(0x97d2424451db4e2eL, 0x97fc7bd73b1f5f40L, 0x3e5659cd94a4de73L, "com.mbeddr.ext.components.structure.AtomicComponent");
    /*package*/ static final SConcept CompositeComponent$c8 = MetaAdapterFactory.getConcept(0x54f2a59b97bb4c09L, 0xaf92928ebf9c5966L, 0x6bfba9786e44b3b0L, "com.mbeddr.ext.compositecomponents.structure.CompositeComponent");
    /*package*/ static final SConcept ComponentRefExpr$k_ = MetaAdapterFactory.getConcept(0x54f2a59b97bb4c09L, 0xaf92928ebf9c5966L, 0x4370c1b32a2f2b3dL, "com.mbeddr.ext.compositecomponents.structure.ComponentRefExpr");
    /*package*/ static final SConcept ComponentInstance$zN = MetaAdapterFactory.getConcept(0x97d2424451db4e2eL, 0x97fc7bd73b1f5f40L, 0x3e5659cd94a4de76L, "com.mbeddr.ext.components.structure.ComponentInstance");
    /*package*/ static final SConcept ComponentType$8R = MetaAdapterFactory.getConcept(0x97d2424451db4e2eL, 0x97fc7bd73b1f5f40L, 0x7c8320896c8aa448L, "com.mbeddr.ext.components.structure.ComponentType");
    /*package*/ static final SConcept CompositeComponentName$Sr = MetaAdapterFactory.getConcept(0x54f2a59b97bb4c09L, 0xaf92928ebf9c5966L, 0x3c30d7a406607220L, "com.mbeddr.ext.compositecomponents.structure.CompositeComponentName");
    /*package*/ static final SConcept FieldForInternalInstances$dy = MetaAdapterFactory.getConcept(0x54f2a59b97bb4c09L, 0xaf92928ebf9c5966L, 0x3c30d7a4058c4f71L, "com.mbeddr.ext.compositecomponents.structure.FieldForInternalInstances");
    /*package*/ static final SConcept InterfaceOperationCallExpr$vv = MetaAdapterFactory.getConcept(0x97d2424451db4e2eL, 0x97fc7bd73b1f5f40L, 0x707ac195dd618205L, "com.mbeddr.ext.components.structure.InterfaceOperationCallExpr");
    /*package*/ static final SInterfaceConcept InstanceConfigContentsToBeCopiedIntoFlattenedInstanceConfig$xT = MetaAdapterFactory.getInterfaceConcept(0x97d2424451db4e2eL, 0x97fc7bd73b1f5f40L, 0x759064f9b474047fL, "com.mbeddr.ext.components.structure.InstanceConfigContentsToBeCopiedIntoFlattenedInstanceConfig");
    /*package*/ static final SConcept TargetInstanceName$mY = MetaAdapterFactory.getConcept(0x54f2a59b97bb4c09L, 0xaf92928ebf9c5966L, 0x3c30d7a405991249L, "com.mbeddr.ext.compositecomponents.structure.TargetInstanceName");
    /*package*/ static final SConcept InstanceConfiguration$MO = MetaAdapterFactory.getConcept(0x97d2424451db4e2eL, 0x97fc7bd73b1f5f40L, 0x3e5659cd94a4de80L, "com.mbeddr.ext.components.structure.InstanceConfiguration");
    /*package*/ static final SConcept ComponentInstanceRefExpr$_C = MetaAdapterFactory.getConcept(0x97d2424451db4e2eL, 0x97fc7bd73b1f5f40L, 0x7f76b5152d3c73ebL, "com.mbeddr.ext.components.structure.ComponentInstanceRefExpr");
    /*package*/ static final SConcept ComponentPortRef$_g = MetaAdapterFactory.getConcept(0x97d2424451db4e2eL, 0x97fc7bd73b1f5f40L, 0x3e5659cd94a4de79L, "com.mbeddr.ext.components.structure.ComponentPortRef");
    /*package*/ static final SConcept AdapterInstancePortRef$8T = MetaAdapterFactory.getConcept(0x97d2424451db4e2eL, 0x97fc7bd73b1f5f40L, 0x5bd0d857daf78a76L, "com.mbeddr.ext.components.structure.AdapterInstancePortRef");
    /*package*/ static final SConcept PreventConstructorCall$Kl = MetaAdapterFactory.getConcept(0x97d2424451db4e2eL, 0x97fc7bd73b1f5f40L, 0x3c30d7a405ae9de2L, "com.mbeddr.ext.components.structure.PreventConstructorCall");
    /*package*/ static final SConcept RequiredPort$Si = MetaAdapterFactory.getConcept(0x97d2424451db4e2eL, 0x97fc7bd73b1f5f40L, 0x3e5659cd94a48fa9L, "com.mbeddr.ext.components.structure.RequiredPort");
    /*package*/ static final SConcept RequiredPortOpCallExpr$Xu = MetaAdapterFactory.getConcept(0x97d2424451db4e2eL, 0x97fc7bd73b1f5f40L, 0x679b5a7c6c3c809L, "com.mbeddr.ext.components.structure.RequiredPortOpCallExpr");
    /*package*/ static final SConcept PortRefExpr$IW = MetaAdapterFactory.getConcept(0x97d2424451db4e2eL, 0x97fc7bd73b1f5f40L, 0x707ac195dd6397aaL, "com.mbeddr.ext.components.structure.PortRefExpr");
    /*package*/ static final SConcept Expression$bT = MetaAdapterFactory.getConcept(0x61c69711ed614850L, 0x81d97714ff227fb0L, 0x7af69e2e83a1ba32L, "com.mbeddr.core.expressions.structure.Expression");
    /*package*/ static final SConcept AssemblyConnector$$L = MetaAdapterFactory.getConcept(0x97d2424451db4e2eL, 0x97fc7bd73b1f5f40L, 0x3e5659cd94a4de78L, "com.mbeddr.ext.components.structure.AssemblyConnector");
  }

  private static final class LINKS {
    /*package*/ static final SReferenceLink var$YUyC = MetaAdapterFactory.getReferenceLink(0xa9d696470840491eL, 0xbf392eb0805d2011L, 0x1d0c3765e2e1d67aL, 0x1d0c3765e2e1fe27L, "var");
    /*package*/ static final SReferenceLink field$P8O8 = MetaAdapterFactory.getReferenceLink(0x97d2424451db4e2eL, 0x97fc7bd73b1f5f40L, 0x49ac54536383aff9L, 0x49ac54536383affaL, "field");
    /*package*/ static final SContainmentLink expression$PfNq = MetaAdapterFactory.getContainmentLink(0x61c69711ed614850L, 0x81d97714ff227fb0L, 0x29b5b7c4a3763232L, 0x64ae61a4018a9c50L, "expression");
    /*package*/ static final SReferenceLink field$SvlC = MetaAdapterFactory.getReferenceLink(0x97d2424451db4e2eL, 0x97fc7bd73b1f5f40L, 0xae5db91fd71ea1dL, 0xae5db91fd71ea1eL, "field");
    /*package*/ static final SContainmentLink type$sXU3 = MetaAdapterFactory.getContainmentLink(0x61c69711ed614850L, 0x81d97714ff227fb0L, 0x46a2a92ac61b183L, 0x46a2a92ac61b184L, "type");
    /*package*/ static final SReferenceLink component$5BtC = MetaAdapterFactory.getReferenceLink(0x97d2424451db4e2eL, 0x97fc7bd73b1f5f40L, 0x7c8320896c8aa448L, 0x7c8320896c8aa449L, "component");
    /*package*/ static final SReferenceLink providedPort$Pdbe = MetaAdapterFactory.getReferenceLink(0x97d2424451db4e2eL, 0x97fc7bd73b1f5f40L, 0x2a85aaf6fa57eba2L, 0x2a85aaf6fa58cdefL, "providedPort");
    /*package*/ static final SReferenceLink instance$Oefo = MetaAdapterFactory.getReferenceLink(0x54f2a59b97bb4c09L, 0xaf92928ebf9c5966L, 0x4370c1b32a2f2b3dL, 0x4370c1b32a2f2b71L, "instance");
    /*package*/ static final SReferenceLink providedPort$C8zD = MetaAdapterFactory.getReferenceLink(0x54f2a59b97bb4c09L, 0xaf92928ebf9c5966L, 0x4370c1b32a2f2b3dL, 0x4370c1b32a43207eL, "providedPort");
    /*package*/ static final SReferenceLink operation$jSaZ = MetaAdapterFactory.getReferenceLink(0x97d2424451db4e2eL, 0x97fc7bd73b1f5f40L, 0x707ac195dd618205L, 0x707ac195dd618208L, "operation");
    /*package*/ static final SContainmentLink value$Sv$D = MetaAdapterFactory.getContainmentLink(0x97d2424451db4e2eL, 0x97fc7bd73b1f5f40L, 0xae5db91fd71ea1dL, 0xae5db91fd71ea1fL, "value");
    /*package*/ static final SContainmentLink actuals$OVo1 = MetaAdapterFactory.getContainmentLink(0x97d2424451db4e2eL, 0x97fc7bd73b1f5f40L, 0x707ac195dd618205L, 0x707ac195dd61ce0dL, "actuals");
    /*package*/ static final SReferenceLink intf$QYND = MetaAdapterFactory.getReferenceLink(0x97d2424451db4e2eL, 0x97fc7bd73b1f5f40L, 0x3e5659cd94a25d82L, 0x3e5659cd94a25d84L, "intf");
    /*package*/ static final SContainmentLink contents$Hh35 = MetaAdapterFactory.getContainmentLink(0x97d2424451db4e2eL, 0x97fc7bd73b1f5f40L, 0x3e5659cd94a235c9L, 0x53d712bee4273158L, "contents");
    /*package*/ static final SContainmentLink contents$E4B8 = MetaAdapterFactory.getContainmentLink(0x97d2424451db4e2eL, 0x97fc7bd73b1f5f40L, 0x6bfba9786e466b00L, 0x6bfba9786e467315L, "contents");
    /*package*/ static final SReferenceLink outsidePort$z5z3 = MetaAdapterFactory.getReferenceLink(0x54f2a59b97bb4c09L, 0xaf92928ebf9c5966L, 0x6bfba9786e4aa19eL, 0x6bfba9786e4aa1c7L, "outsidePort");
    /*package*/ static final SReferenceLink internalInstance$2LQn = MetaAdapterFactory.getReferenceLink(0x54f2a59b97bb4c09L, 0xaf92928ebf9c5966L, 0x6bfba9786e4aa19eL, 0x6bfba9786e4b773dL, "internalInstance");
    /*package*/ static final SReferenceLink internalPort$2M5o = MetaAdapterFactory.getReferenceLink(0x54f2a59b97bb4c09L, 0xaf92928ebf9c5966L, 0x6bfba9786e4aa19eL, 0x6bfba9786e4b773eL, "internalPort");
    /*package*/ static final SReferenceLink component$ikVC = MetaAdapterFactory.getReferenceLink(0x97d2424451db4e2eL, 0x97fc7bd73b1f5f40L, 0x3e5659cd94a4de76L, 0x3e5659cd94a4de77L, "component");
    /*package*/ static final SReferenceLink ci$IlQ8 = MetaAdapterFactory.getReferenceLink(0x97d2424451db4e2eL, 0x97fc7bd73b1f5f40L, 0x7f76b5152d3c73ebL, 0x7f76b5152d3c73ecL, "ci");
    /*package*/ static final SContainmentLink initializers$gWXm = MetaAdapterFactory.getContainmentLink(0x97d2424451db4e2eL, 0x97fc7bd73b1f5f40L, 0x3e5659cd94a4de76L, 0xae5db91fd71e9ffL, "initializers");
    /*package*/ static final SReferenceLink instance$ilE8 = MetaAdapterFactory.getReferenceLink(0x97d2424451db4e2eL, 0x97fc7bd73b1f5f40L, 0x3e5659cd94a4de79L, 0x3e5659cd94a4de7aL, "instance");
    /*package*/ static final SReferenceLink port$8cCY = MetaAdapterFactory.getReferenceLink(0x97d2424451db4e2eL, 0x97fc7bd73b1f5f40L, 0x5bd0d857daf78a76L, 0x5bd0d857daf78a78L, "port");
    /*package*/ static final SReferenceLink instance$87uC = MetaAdapterFactory.getReferenceLink(0x97d2424451db4e2eL, 0x97fc7bd73b1f5f40L, 0x5bd0d857daf78a76L, 0x5bd0d857daf78a77L, "instance");
    /*package*/ static final SReferenceLink port$IUw8 = MetaAdapterFactory.getReferenceLink(0x97d2424451db4e2eL, 0x97fc7bd73b1f5f40L, 0x707ac195dd6397aaL, 0x707ac195dd6397abL, "port");
    /*package*/ static final SContainmentLink source$ir30 = MetaAdapterFactory.getContainmentLink(0x97d2424451db4e2eL, 0x97fc7bd73b1f5f40L, 0x3e5659cd94a4de78L, 0x3e5659cd94a4de7cL, "source");
    /*package*/ static final SReferenceLink port$HUwa = MetaAdapterFactory.getReferenceLink(0x97d2424451db4e2eL, 0x97fc7bd73b1f5f40L, 0x3e5659cd94a4de79L, 0x2fceca7612fd97fbL, "port");
    /*package*/ static final SContainmentLink target$iri1 = MetaAdapterFactory.getContainmentLink(0x97d2424451db4e2eL, 0x97fc7bd73b1f5f40L, 0x3e5659cd94a4de78L, 0x3e5659cd94a4de7dL, "target");
  }

  private static final class PROPS {
    /*package*/ static final SProperty name$MnvL = MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name");
    /*package*/ static final SProperty instanceName$PjJE = MetaAdapterFactory.getProperty(0x97d2424451db4e2eL, 0x97fc7bd73b1f5f40L, 0x2a85aaf6fa57eba2L, 0x2a85aaf6fa58cdf6L, "instanceName");
    /*package*/ static final SProperty initField$Wgp_ = MetaAdapterFactory.getProperty(0x97d2424451db4e2eL, 0x97fc7bd73b1f5f40L, 0x49ac54536382ded3L, 0xae5db91fd71e9ccL, "initField");
  }
}
