package com.mbeddr.ext.components.gen_nomw.typesystem;

/*Generated by MPS */

import jetbrains.mps.lang.typesystem.runtime.AbstractNonTypesystemRule_Runtime;
import jetbrains.mps.lang.typesystem.runtime.NonTypesystemRule_Runtime;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.typesystem.inference.TypeCheckingContext;
import jetbrains.mps.lang.typesystem.runtime.IsApplicableStatus;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.errors.messageTargets.MessageTarget;
import jetbrains.mps.errors.messageTargets.ReferenceMessageTarget;
import jetbrains.mps.errors.IErrorReporter;
import com.mbeddr.ext.components.behavior.AbstractInstanceConfiguration__BehaviorDescriptor;
import jetbrains.mps.internal.collections.runtime.Sequence;
import com.mbeddr.ext.components.behavior.Component__BehaviorDescriptor;
import java.util.List;
import java.util.ArrayList;
import com.mbeddr.ext.components.behavior.RequiredPort__BehaviorDescriptor;
import jetbrains.mps.util.Pair;
import com.mbeddr.ext.components.behavior.ComponentInstance__BehaviorDescriptor;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.errors.messageTargets.NodeMessageTarget;
import com.mbeddr.ext.components.behavior.InstanceConfiguration__BehaviorDescriptor;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import org.jetbrains.mps.openapi.language.SReferenceLink;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import org.jetbrains.mps.openapi.language.SProperty;
import org.jetbrains.mps.openapi.language.SConcept;

public class check_NoMwComponentsGenStrategy_NonTypesystemRule extends AbstractNonTypesystemRule_Runtime implements NonTypesystemRule_Runtime {
  public check_NoMwComponentsGenStrategy_NonTypesystemRule() {
  }
  public void applyRule(final SNode s, final TypeCheckingContext typeCheckingContext, IsApplicableStatus status) {
    if ((SPropertyOperations.getBoolean(s, PROPS.wireStatically$6J$b) || SPropertyOperations.getBoolean(s, PROPS.removeUnusedRequiredPorts$uRN_)) && SLinkOperations.getTarget(s, LINKS.instanceConfig$6K2d) == null) {
      {
        final MessageTarget errorTarget = new ReferenceMessageTarget(LINKS.instanceConfig$6K2d);
        IErrorReporter _reporter_2309309498 = typeCheckingContext.reportTypeError(s, "instance config must be specified if wireStatically or removeUnusedRequiredPorts is selected", "r:1ff0a2e1-cb01-42b4-88e2-1a5bc0b655f8(com.mbeddr.ext.components.gen_nomw.typesystem)", "1553713790141527478", null, errorTarget);
      }
    }
    if (SPropertyOperations.getBoolean(s, PROPS.wireStatically$6J$b)) {
      SNode instanceConfig = SLinkOperations.getTarget(s, LINKS.instanceConfig$6K2d);
      Iterable<SNode> instances = AbstractInstanceConfiguration__BehaviorDescriptor.instances_id6JVEnxIhC2$.invoke(instanceConfig);
      Iterable<SNode> components = Sequence.fromIterable(instances).select((it) -> SLinkOperations.getTarget(it, LINKS.component$ikVC)).distinct();
      for (final SNode comp : Sequence.fromIterable(components)) {
        Iterable<SNode> instOfSameComp = Sequence.fromIterable(instances).where((it) -> SLinkOperations.getTarget(it, LINKS.component$ikVC) == comp);
        for (SNode rp : Sequence.fromIterable(Component__BehaviorDescriptor.allRequiredPorts_id71UKpntoZWS.invoke(comp))) {
          List<SNode> targetComps = new ArrayList<SNode>();
          List<SNode> targetPorts = new ArrayList<SNode>();
          for (SNode ci : Sequence.fromIterable(instOfSameComp)) {
            if ((boolean) RequiredPort__BehaviorDescriptor.isMultiple_id2ZUGF54jY1D.invoke(rp)) {
              List<Pair<SNode, SNode>> pairs = ComponentInstance__BehaviorDescriptor.getMultiConnectedInstanceAndProvidedPort_id2ZUGF54lpvh.invoke(ci, rp, instanceConfig);
              for (Pair<SNode, SNode> p : ListSequence.fromList(pairs)) {
                ListSequence.fromList(targetComps).addElement(SLinkOperations.getTarget(p.o1, LINKS.component$ikVC));
                ListSequence.fromList(targetPorts).addElement(p.o2);
              }
            } else {
              Pair<SNode, SNode> pair = ComponentInstance__BehaviorDescriptor.getConnectedInstanceAndProvidedPort_idwOd6nl53E$.invoke(ci, rp, instanceConfig);
              if (pair != null) {
                ListSequence.fromList(targetComps).addElement(SLinkOperations.getTarget(pair.o1, LINKS.component$ikVC));
                ListSequence.fromList(targetPorts).addElement(pair.o2);
              } else {
                if (!(SPropertyOperations.getBoolean(rp, PROPS.optional$mTHR))) {
                  {
                    final MessageTarget errorTarget = new NodeMessageTarget();
                    IErrorReporter _reporter_2309309498 = typeCheckingContext.reportTypeError(s, "invalid instance configuration; no connected port found for " + SPropertyOperations.getString(ci, PROPS.name$MnvL) + "/" + SPropertyOperations.getString(rp, PROPS.name$MnvL), "r:1ff0a2e1-cb01-42b4-88e2-1a5bc0b655f8(com.mbeddr.ext.components.gen_nomw.typesystem)", "5915274679057245723", null, errorTarget);
                  }
                  return;
                }
              }
            }
          }
          Iterable<SNode> distinctTargets = ListSequence.fromList(targetComps).distinct();
          if (Sequence.fromIterable(distinctTargets).count() > 1) {
            {
              final MessageTarget errorTarget = new NodeMessageTarget();
              IErrorReporter _reporter_2309309498 = typeCheckingContext.reportTypeError(s, "instances of component " + SPropertyOperations.getString(comp, PROPS.name$MnvL) + " are connected to more than one target component (" + Sequence.fromIterable(distinctTargets).skip(1).foldLeft(SPropertyOperations.getString(Sequence.fromIterable(distinctTargets).first(), PROPS.name$MnvL), (String st, SNode it) -> st + ", " + SPropertyOperations.getString(it, PROPS.name$MnvL)) + ")", "r:1ff0a2e1-cb01-42b4-88e2-1a5bc0b655f8(com.mbeddr.ext.components.gen_nomw.typesystem)", "9016194309503229061", null, errorTarget);
            }
          } else {
            Iterable<SNode> distinctPorts = ListSequence.fromList(targetPorts).distinct();
            if (Sequence.fromIterable(distinctPorts).count() > 1) {
              {
                final MessageTarget errorTarget = new NodeMessageTarget();
                IErrorReporter _reporter_2309309498 = typeCheckingContext.reportTypeError(s, "required port " + SPropertyOperations.getString(rp, PROPS.name$MnvL) + " is connected to more than one provided port (" + Sequence.fromIterable(distinctPorts).skip(1).foldLeft(SPropertyOperations.getString(Sequence.fromIterable(distinctPorts).first(), PROPS.name$MnvL), (String st, SNode it) -> st + ", " + SPropertyOperations.getString(it, PROPS.name$MnvL)) + ")", "r:1ff0a2e1-cb01-42b4-88e2-1a5bc0b655f8(com.mbeddr.ext.components.gen_nomw.typesystem)", "9016194309503229104", null, errorTarget);
              }
            }
          }
        }

      }

      if (Sequence.fromIterable(InstanceConfiguration__BehaviorDescriptor.adapters_id5fn4FV$c8kP.invoke(SLinkOperations.getTarget(s, LINKS.instanceConfig$6K2d))).any((it) -> SPropertyOperations.getBoolean(it, PROPS.reconnectable$DIVG))) {
        {
          final MessageTarget errorTarget = new ReferenceMessageTarget(LINKS.instanceConfig$6K2d);
          IErrorReporter _reporter_2309309498 = typeCheckingContext.reportTypeError(s, "cannot wire statically; the instance configuration contains reconnectable adapters", "r:1ff0a2e1-cb01-42b4-88e2-1a5bc0b655f8(com.mbeddr.ext.components.gen_nomw.typesystem)", "1482737808881500716", null, errorTarget);
        }
      }

    }
  }
  public SAbstractConcept getApplicableConcept() {
    return CONCEPTS.NoMwComponentsGenStrategy$VR;
  }
  public IsApplicableStatus isApplicableAndPattern(SNode argument) {
    return new IsApplicableStatus(argument.getConcept().isSubConceptOf(getApplicableConcept()), null);
  }
  public boolean overrides() {
    return false;
  }

  private static final class LINKS {
    /*package*/ static final SReferenceLink instanceConfig$6K2d = MetaAdapterFactory.getReferenceLink(0xbd640b8f4be442b6L, 0x8dc02c94d1ddf606L, 0x1d31b29ecf3e58afL, 0x158fe675d002f56fL, "instanceConfig");
    /*package*/ static final SReferenceLink component$ikVC = MetaAdapterFactory.getReferenceLink(0x97d2424451db4e2eL, 0x97fc7bd73b1f5f40L, 0x3e5659cd94a4de76L, 0x3e5659cd94a4de77L, "component");
  }

  private static final class PROPS {
    /*package*/ static final SProperty removeUnusedRequiredPorts$uRN_ = MetaAdapterFactory.getProperty(0xbd640b8f4be442b6L, 0x8dc02c94d1ddf606L, 0x1d31b29ecf3e58afL, 0x6d66b098c9ee5fc3L, "removeUnusedRequiredPorts");
    /*package*/ static final SProperty wireStatically$6J$b = MetaAdapterFactory.getProperty(0xbd640b8f4be442b6L, 0x8dc02c94d1ddf606L, 0x1d31b29ecf3e58afL, 0x158fe675d002f56dL, "wireStatically");
    /*package*/ static final SProperty name$MnvL = MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name");
    /*package*/ static final SProperty optional$mTHR = MetaAdapterFactory.getProperty(0x97d2424451db4e2eL, 0x97fc7bd73b1f5f40L, 0x3e5659cd94a48fa9L, 0x4db287ad754ffcdL, "optional");
    /*package*/ static final SProperty reconnectable$DIVG = MetaAdapterFactory.getProperty(0x97d2424451db4e2eL, 0x97fc7bd73b1f5f40L, 0x47c7455cc68418c2L, 0x1493be2e6966a2a5L, "reconnectable");
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept NoMwComponentsGenStrategy$VR = MetaAdapterFactory.getConcept(0xbd640b8f4be442b6L, 0x8dc02c94d1ddf606L, 0x1d31b29ecf3e58afL, "com.mbeddr.ext.components.gen_nomw.structure.NoMwComponentsGenStrategy");
  }
}
