package com.mbeddr.ext.units.typesystem;

/*Generated by MPS */

import jetbrains.mps.lang.typesystem.runtime.AbstractNonTypesystemRule_Runtime;
import jetbrains.mps.lang.typesystem.runtime.NonTypesystemRule_Runtime;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.typesystem.inference.TypeCheckingContext;
import jetbrains.mps.lang.typesystem.runtime.IsApplicableStatus;
import java.util.List;
import com.mbeddr.ext.units.behavior.ConvertExpression__BehaviorDescriptor;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.errors.messageTargets.MessageTarget;
import jetbrains.mps.errors.messageTargets.NodeMessageTarget;
import jetbrains.mps.errors.IErrorReporter;
import java.util.Map;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import com.mbeddr.ext.units.runtime.plugin.UnitConversionUtil;
import jetbrains.mps.typechecking.TypecheckingFacade;
import jetbrains.mps.errors.BaseQuickFixProvider;
import jetbrains.mps.lang.core.behavior.BaseConcept__BehaviorDescriptor;
import com.mbeddr.ext.units.runtime.plugin.Fraction;
import com.mbeddr.ext.units.behavior.ConversionSpecifier__BehaviorDescriptor;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import org.jetbrains.mps.openapi.language.SConcept;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import org.jetbrains.mps.openapi.language.SReferenceLink;

public class check_ConvertExpression_NonTypesystemRule extends AbstractNonTypesystemRule_Runtime implements NonTypesystemRule_Runtime {
  public check_ConvertExpression_NonTypesystemRule() {
  }
  public void applyRule(final SNode convertExpression, final TypeCheckingContext typeCheckingContext, IsApplicableStatus status) {
    List<SNode> specifiers = ConvertExpression__BehaviorDescriptor.getApplicableConversionSpecifiers_id3_TFq$0_vSx.invoke(convertExpression);

    if (ListSequence.fromList(specifiers).isEmpty()) {
      {
        final MessageTarget errorTarget = new NodeMessageTarget();
        IErrorReporter _reporter_2309309498 = typeCheckingContext.reportTypeError(convertExpression, "No matching conversion specifier can be found!", "r:f5260afd-8327-4c3e-bf02-c81ea8a33729(com.mbeddr.ext.units.typesystem)", "624957442818656662", null, errorTarget);
      }
    } else if (ListSequence.fromList(specifiers).count() > 1) {
      // We need to group the conversion specifiers by their given types
      // It can happen that we want to convert a simple number which
      // can actually fit into an int8 or a float too, but we should prefer
      // the specifiers with non-floating point types.
      // Float types by default will not cause any problem during the selection
      // because specifiers with non-floating point types will not be considered
      // as applicable ones.

      Map<SNode, Set<SNode>> specifierMap = MapSequence.fromMap(new HashMap<SNode, Set<SNode>>());
      MapSequence.fromMap(specifierMap).put(CONCEPTS.PrimitiveBasicIntegralType$$2.getDeclarationNode(), SetSequence.fromSet(new HashSet<SNode>()));
      MapSequence.fromMap(specifierMap).put(CONCEPTS.PrimitiveC99IntegralType$E_.getDeclarationNode(), SetSequence.fromSet(new HashSet<SNode>()));
      MapSequence.fromMap(specifierMap).put(CONCEPTS.PrimitiveIEEE754Type$WK.getDeclarationNode(), SetSequence.fromSet(new HashSet<SNode>()));

      for (SNode specifier : ListSequence.fromList(specifiers)) {
        SNode concept = null;
        if (SNodeOperations.isInstanceOf(SLinkOperations.getTarget(specifier, LINKS.type$1sSg), CONCEPTS.PrimitiveBasicIntegralType$$2)) {
          SetSequence.fromSet(MapSequence.fromMap(specifierMap).get(CONCEPTS.PrimitiveBasicIntegralType$$2.getDeclarationNode())).addElement(specifier);
        } else if (SNodeOperations.isInstanceOf(SLinkOperations.getTarget(specifier, LINKS.type$1sSg), CONCEPTS.PrimitiveC99IntegralType$E_)) {
          SetSequence.fromSet(MapSequence.fromMap(specifierMap).get(CONCEPTS.PrimitiveC99IntegralType$E_.getDeclarationNode())).addElement(specifier);
        } else if (SNodeOperations.isInstanceOf(SLinkOperations.getTarget(specifier, LINKS.type$1sSg), CONCEPTS.PrimitiveIEEE754Type$WK)) {
          SetSequence.fromSet(MapSequence.fromMap(specifierMap).get(CONCEPTS.PrimitiveIEEE754Type$WK.getDeclarationNode())).addElement(specifier);
        } else if (SLinkOperations.getTarget(specifier, LINKS.type$1sSg) == null) {
          // this is the aLoadIny case - add it only to one of the integer types
          SetSequence.fromSet(MapSequence.fromMap(specifierMap).get(CONCEPTS.PrimitiveBasicIntegralType$$2.getDeclarationNode())).addElement(specifier);
          SetSequence.fromSet(MapSequence.fromMap(specifierMap).get(CONCEPTS.PrimitiveIEEE754Type$WK.getDeclarationNode())).addElement(specifier);
        } else {
          throw new RuntimeException("Type of " + SNodeOperations.getConcept(specifier).getName() + " is not covered by the check " + SLinkOperations.getTarget(specifier, LINKS.type$1sSg) + "!");
        }
      }

      boolean needsWarning = false;
      if (UnitConversionUtil.isIntegerType(TypecheckingFacade.getFromContext().getTypeOf(SLinkOperations.getTarget(convertExpression, LINKS.expression$LDUH)))) {
        Set<SNode> set1 = MapSequence.fromMap(specifierMap).get(CONCEPTS.PrimitiveBasicIntegralType$$2.getDeclarationNode());
        Set<SNode> set2 = MapSequence.fromMap(specifierMap).get(CONCEPTS.PrimitiveC99IntegralType$E_.getDeclarationNode());
        int sumCount = SetSequence.fromSet(set1).count() + SetSequence.fromSet(set2).count();

        if (sumCount == 1) {
          SNode specifier = (SetSequence.fromSet(set1).count() == 1 ? SetSequence.fromSet(set1).first() : SetSequence.fromSet(set2).first());
          if (SLinkOperations.getTarget(convertExpression, LINKS.conversionSpecifier$TvLX) == null) {
            {
              final MessageTarget errorTarget = new NodeMessageTarget();
              IErrorReporter _reporter_2309309498 = typeCheckingContext.reportTypeError(convertExpression, "The conversion specifier must be set!", "r:f5260afd-8327-4c3e-bf02-c81ea8a33729(com.mbeddr.ext.units.typesystem)", "4360657994631251484", null, errorTarget);
              {
                BaseQuickFixProvider intentionProvider = new BaseQuickFixProvider("com.mbeddr.ext.units.typesystem.quickfix_SetConversionRule_QuickFix", "4360657994631251487", true);
                intentionProvider.putArgument("exp", convertExpression);
                intentionProvider.putArgument("specifier", specifier);
                _reporter_2309309498.addIntentionProvider(intentionProvider);
              }
            }
          }
        } else {
          needsWarning = true;
        }
      } else {
        needsWarning = true;
      }

      if (needsWarning) {
        StringBuilder builder = new StringBuilder();
        builder.append("Multiple matching conversion specifiers have been found!");

        for (SNode specifier : ListSequence.fromList(specifiers)) {
          builder.append("\n");
          builder.append(BaseConcept__BehaviorDescriptor.getPresentation_idhEwIMiw.invoke(specifier) + " in " + SNodeOperations.getNodeAncestor(specifier, CONCEPTS.Chunk$sT, true, false));
        }

        {
          final MessageTarget errorTarget = new NodeMessageTarget();
          IErrorReporter _reporter_2309309498 = typeCheckingContext.reportWarning(convertExpression, builder.toString(), "r:f5260afd-8327-4c3e-bf02-c81ea8a33729(com.mbeddr.ext.units.typesystem)", "624957442818704732", null, errorTarget);
        }
      }
    } else if (SLinkOperations.getTarget(convertExpression, LINKS.conversionSpecifier$TvLX) == null && ListSequence.fromList(specifiers).count() == 1) {
      {
        final MessageTarget errorTarget = new NodeMessageTarget();
        IErrorReporter _reporter_2309309498 = typeCheckingContext.reportTypeError(convertExpression, "The conversion specifier must be set!", "r:f5260afd-8327-4c3e-bf02-c81ea8a33729(com.mbeddr.ext.units.typesystem)", "1197174311014856570", null, errorTarget);
        {
          BaseQuickFixProvider intentionProvider = new BaseQuickFixProvider("com.mbeddr.ext.units.typesystem.quickfix_SetConversionRule_QuickFix", "1197174311014862547", true);
          intentionProvider.putArgument("exp", convertExpression);
          intentionProvider.putArgument("specifier", ListSequence.fromList(specifiers).first());
          _reporter_2309309498.addIntentionProvider(intentionProvider);
        }
      }
    }

    if (SLinkOperations.getTarget(convertExpression, LINKS.conversionSpecifier$TvLX) != null) {
      if (SLinkOperations.getTarget(SLinkOperations.getTarget(convertExpression, LINKS.conversionSpecifier$TvLX), LINKS.type$1sSg) == null || TypecheckingFacade.getFromContext().isSubtype(UnitConversionUtil.getInnerType(TypecheckingFacade.getFromContext().getTypeOf(SLinkOperations.getTarget(convertExpression, LINKS.expression$LDUH))), SLinkOperations.getTarget(SLinkOperations.getTarget(convertExpression, LINKS.conversionSpecifier$TvLX), LINKS.type$1sSg))) {
        // the type of the to-be-converted expression must match the source unit
        Map<SNode, Fraction> convertExpressionSourceUnitMap = UnitConversionUtil.getUnitMap_Type(TypecheckingFacade.getFromContext().getTypeOf(SLinkOperations.getTarget(convertExpression, LINKS.expression$LDUH)));
        Map<SNode, Fraction> ruleSourceUnitMap = UnitConversionUtil.getUnitMap_IUnit(SLinkOperations.getTarget(ConversionSpecifier__BehaviorDescriptor.getConversionRule_id1wGuEUvYk55.invoke(SLinkOperations.getTarget(convertExpression, LINKS.conversionSpecifier$TvLX)), LINKS.sourceUnit$2DOV), 1);
        Map<SNode, Fraction> convertExpressionTargetUnitMap = UnitConversionUtil.getUnitMap_IUnit(SLinkOperations.getTarget(convertExpression, LINKS.targetUnit$LEoJ), 1);
        Map<SNode, Fraction> ruleTargetUnitMap = UnitConversionUtil.getUnitMap_IUnit(SLinkOperations.getTarget(ConversionSpecifier__BehaviorDescriptor.getConversionRule_id1wGuEUvYk55.invoke(SLinkOperations.getTarget(convertExpression, LINKS.conversionSpecifier$TvLX)), LINKS.targetUnit$2E3W), 1);

        if (!(UnitConversionUtil.matchingUnits(convertExpressionSourceUnitMap, ruleSourceUnitMap, true) && UnitConversionUtil.matchingUnits(convertExpressionTargetUnitMap, ruleTargetUnitMap, true))) {
          {
            final MessageTarget errorTarget = new NodeMessageTarget();
            IErrorReporter _reporter_2309309498 = typeCheckingContext.reportTypeError(SLinkOperations.getTarget(convertExpression, LINKS.expression$LDUH), "Expression must evaluate to an annotated type with the defined source unit!", "r:f5260afd-8327-4c3e-bf02-c81ea8a33729(com.mbeddr.ext.units.typesystem)", "624957442818447421", null, errorTarget);
          }
        }
      } else {
        {
          final MessageTarget errorTarget = new NodeMessageTarget();
          IErrorReporter _reporter_2309309498 = typeCheckingContext.reportTypeError(SLinkOperations.getTarget(convertExpression, LINKS.expression$LDUH), "The expression's type is not applicable for the specifier!", "r:f5260afd-8327-4c3e-bf02-c81ea8a33729(com.mbeddr.ext.units.typesystem)", "7644849806582182026", null, errorTarget);
        }
      }
    }
  }
  public SAbstractConcept getApplicableConcept() {
    return CONCEPTS.ConvertExpression$ff;
  }
  public IsApplicableStatus isApplicableAndPattern(SNode argument) {
    return new IsApplicableStatus(argument.getConcept().isSubConceptOf(getApplicableConcept()), null);
  }
  public boolean overrides() {
    return false;
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept PrimitiveBasicIntegralType$$2 = MetaAdapterFactory.getConcept(0x61c69711ed614850L, 0x81d97714ff227fb0L, 0x4d4a3140e3e01fdaL, "com.mbeddr.core.expressions.structure.PrimitiveBasicIntegralType");
    /*package*/ static final SConcept PrimitiveC99IntegralType$E_ = MetaAdapterFactory.getConcept(0x61c69711ed614850L, 0x81d97714ff227fb0L, 0x75739ed9f39c4635L, "com.mbeddr.core.expressions.structure.PrimitiveC99IntegralType");
    /*package*/ static final SConcept PrimitiveIEEE754Type$WK = MetaAdapterFactory.getConcept(0x61c69711ed614850L, 0x81d97714ff227fb0L, 0x7efa919be7fb2073L, "com.mbeddr.core.expressions.structure.PrimitiveIEEE754Type");
    /*package*/ static final SConcept Chunk$sT = MetaAdapterFactory.getConcept(0xd4280a54f6df4383L, 0xaa41d1b2bffa7eb1L, 0x6315bcc6effb4ea6L, "com.mbeddr.core.base.structure.Chunk");
    /*package*/ static final SConcept ConvertExpression$ff = MetaAdapterFactory.getConcept(0xd04a6cc773e4069L, 0xb9b011884b2ff1c8L, 0x3930d8ab4c0e6285L, "com.mbeddr.ext.units.structure.ConvertExpression");
  }

  private static final class LINKS {
    /*package*/ static final SContainmentLink type$1sSg = MetaAdapterFactory.getContainmentLink(0xd04a6cc773e4069L, 0xb9b011884b2ff1c8L, 0x182c7aae9fea4574L, 0x182c7aaea0320b8dL, "type");
    /*package*/ static final SReferenceLink conversionSpecifier$TvLX = MetaAdapterFactory.getReferenceLink(0xd04a6cc773e4069L, 0xb9b011884b2ff1c8L, 0x3930d8ab4c0e6285L, 0x8ac4b7baaeabc73L, "conversionSpecifier");
    /*package*/ static final SContainmentLink expression$LDUH = MetaAdapterFactory.getContainmentLink(0xd04a6cc773e4069L, 0xb9b011884b2ff1c8L, 0x3930d8ab4c0e6285L, 0x3930d8ab4c0edbeaL, "expression");
    /*package*/ static final SReferenceLink sourceUnit$2DOV = MetaAdapterFactory.getReferenceLink(0xd04a6cc773e4069L, 0xb9b011884b2ff1c8L, 0xed6abcb370b28cbL, 0x182c7aae9ff63558L, "sourceUnit");
    /*package*/ static final SReferenceLink targetUnit$LEoJ = MetaAdapterFactory.getReferenceLink(0xd04a6cc773e4069L, 0xb9b011884b2ff1c8L, 0x3930d8ab4c0e6285L, 0x3930d8ab4c0edbecL, "targetUnit");
    /*package*/ static final SReferenceLink targetUnit$2E3W = MetaAdapterFactory.getReferenceLink(0xd04a6cc773e4069L, 0xb9b011884b2ff1c8L, 0xed6abcb370b28cbL, 0x182c7aae9ff63559L, "targetUnit");
  }
}
