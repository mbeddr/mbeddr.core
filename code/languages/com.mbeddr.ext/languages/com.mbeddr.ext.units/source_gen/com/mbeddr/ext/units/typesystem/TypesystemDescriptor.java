package com.mbeddr.ext.units.typesystem;

/*Generated by MPS */

import jetbrains.mps.lang.typesystem.runtime.BaseHelginsDescriptor;
import jetbrains.mps.lang.typesystem.runtime.InferenceRule_Runtime;
import jetbrains.mps.lang.typesystem.runtime.NonTypesystemRule_Runtime;
import jetbrains.mps.lang.typesystem.runtime.SubtypingRule_Runtime;
import jetbrains.mps.lang.typesystem.runtime.InequationReplacementRule_Runtime;
import jetbrains.mps.lang.typesystem.runtime.OverloadedOpsProvider_OneTypeSpecified;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.typesystem.inference.TypeChecker;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import com.mbeddr.ext.units.runtime.plugin.UnitConversionUtil;
import jetbrains.mps.typesystem.inference.SubtypingManager;
import jetbrains.mps.errors.IRuleConflictWarningProducer;
import java.util.Map;
import com.mbeddr.ext.units.runtime.plugin.Fraction;
import java.util.List;
import jetbrains.mps.lang.typesystem.runtime.OverloadedOperationsTypesProvider;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import jetbrains.mps.smodel.builder.SNodeBuilder;
import org.jetbrains.mps.openapi.language.SConcept;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import org.jetbrains.mps.openapi.language.SProperty;

public class TypesystemDescriptor extends BaseHelginsDescriptor {
  public TypesystemDescriptor() {
    {
      InferenceRule_Runtime inferenceRule = new typeof_AnnotatedExpression_InferenceRule();
      this.myInferenceRules.add(inferenceRule);
    }
    {
      InferenceRule_Runtime inferenceRule = new typeof_ConvertExpression_InferenceRule();
      this.myInferenceRules.add(inferenceRule);
    }
    {
      InferenceRule_Runtime inferenceRule = new typeof_ICallLike_InferenceRule();
      this.myInferenceRules.add(inferenceRule);
    }
    {
      InferenceRule_Runtime inferenceRule = new typeof_StripUnitExpression_InferenceRule();
      this.myInferenceRules.add(inferenceRule);
    }
    {
      InferenceRule_Runtime inferenceRule = new typeof_ValExpression_InferenceRule();
      this.myInferenceRules.add(inferenceRule);
    }
    {
      NonTypesystemRule_Runtime nonTypesystemRule = new Check_ArrayTypeUnit_NonTypesystemRule();
      this.myNonTypesystemRules.add(nonTypesystemRule);
    }
    {
      NonTypesystemRule_Runtime nonTypesystemRule = new check_AnnotatedExpression_NonTypesystemRule();
      this.myNonTypesystemRules.add(nonTypesystemRule);
    }
    {
      NonTypesystemRule_Runtime nonTypesystemRule = new check_ArithmeticOperators_NonTypesystemRule();
      this.myNonTypesystemRules.add(nonTypesystemRule);
    }
    {
      NonTypesystemRule_Runtime nonTypesystemRule = new check_AssignmentExpr_NonTypesystemRule();
      this.myNonTypesystemRules.add(nonTypesystemRule);
    }
    {
      NonTypesystemRule_Runtime nonTypesystemRule = new check_BinaryComparisonExpression_NonTypesystemRule();
      this.myNonTypesystemRules.add(nonTypesystemRule);
    }
    {
      NonTypesystemRule_Runtime nonTypesystemRule = new check_ConversionRule_NonTypesystemRule();
      this.myNonTypesystemRules.add(nonTypesystemRule);
    }
    {
      NonTypesystemRule_Runtime nonTypesystemRule = new check_ConversionSpecifier_NonTypesystemRule();
      this.myNonTypesystemRules.add(nonTypesystemRule);
    }
    {
      NonTypesystemRule_Runtime nonTypesystemRule = new check_ConvertExpression_NonTypesystemRule();
      this.myNonTypesystemRules.add(nonTypesystemRule);
    }
    {
      NonTypesystemRule_Runtime nonTypesystemRule = new check_DirectAssignmentExpression_NonTypesystemRule();
      this.myNonTypesystemRules.add(nonTypesystemRule);
    }
    {
      NonTypesystemRule_Runtime nonTypesystemRule = new check_FractionalExponent_NonTypesystemRule();
      this.myNonTypesystemRules.add(nonTypesystemRule);
    }
    {
      NonTypesystemRule_Runtime nonTypesystemRule = new check_IArgumentLike_AnnotatedType_NonTypesystemRule();
      this.myNonTypesystemRules.add(nonTypesystemRule);
    }
    {
      NonTypesystemRule_Runtime nonTypesystemRule = new check_IFunctionLike_NonTypesystemRule();
      this.myNonTypesystemRules.add(nonTypesystemRule);
    }
    {
      NonTypesystemRule_Runtime nonTypesystemRule = new check_IMetaUnitMappingProvider_NonTypesystemRule();
      this.myNonTypesystemRules.add(nonTypesystemRule);
    }
    {
      NonTypesystemRule_Runtime nonTypesystemRule = new check_IVariableDeclaration_NonTypesystemRule();
      this.myNonTypesystemRules.add(nonTypesystemRule);
    }
    {
      NonTypesystemRule_Runtime nonTypesystemRule = new check_MetaUnit_NonTypesystemRule();
      this.myNonTypesystemRules.add(nonTypesystemRule);
    }
    {
      NonTypesystemRule_Runtime nonTypesystemRule = new check_MetaUnitMapping_NonTypesystemRule();
      this.myNonTypesystemRules.add(nonTypesystemRule);
    }
    {
      NonTypesystemRule_Runtime nonTypesystemRule = new check_Unit_NonTypesystemRule();
      this.myNonTypesystemRules.add(nonTypesystemRule);
    }
    {
      SubtypingRule_Runtime subtypingRule = new supertypesOf_AnnotatedType_InferredAttribute_SubtypingRule();
      this.mySubtypingRules.add(subtypingRule);
    }
    {
      InequationReplacementRule_Runtime eliminationRule = new subtype_AnnotatedType_AbstractAnnotatedType_InequationReplacementRule();
      this.myInequationReplacementRules.add(eliminationRule);
    }
    {
      InequationReplacementRule_Runtime eliminationRule = new subtype_AnnotatedType_AnnotatedType_Reduced_InequationReplacementRule();
      this.myInequationReplacementRules.add(eliminationRule);
    }
    {
      InequationReplacementRule_Runtime eliminationRule = new subtype_AnnotatedType_Existential_AnnotatedType_Universal_InequationReplacementRule();
      this.myInequationReplacementRules.add(eliminationRule);
    }
    {
      InequationReplacementRule_Runtime eliminationRule = new subtype_AnnotatedType_Inferred_AnnotatedType_Universal_InequationReplacementRule();
      this.myInequationReplacementRules.add(eliminationRule);
    }
    {
      InequationReplacementRule_Runtime eliminationRule = new subtype_AnnotatedType_MetaUnit_AnnotatedType_MetaUnit_InequationReplacementRule();
      this.myInequationReplacementRules.add(eliminationRule);
    }
    {
      InequationReplacementRule_Runtime eliminationRule = new subtype_AnnotatedType_PrimitiveBasicIntegralType_InequationReplacementRule();
      this.myInequationReplacementRules.add(eliminationRule);
    }
    {
      InequationReplacementRule_Runtime eliminationRule = new subtype_AnnotatedType_PrimitiveC99IntegralType_InequationReplacementRule();
      this.myInequationReplacementRules.add(eliminationRule);
    }
    {
      InequationReplacementRule_Runtime eliminationRule = new subtype_AnnotatedType_PrimitiveIEEE754Type_InequationReplacementRule();
      this.myInequationReplacementRules.add(eliminationRule);
    }
    {
      InequationReplacementRule_Runtime eliminationRule = new subtype_AnnotatedType_Universal_AnnotatedType_Inferred_InequationReplacementRule();
      this.myInequationReplacementRules.add(eliminationRule);
    }
    {
      InequationReplacementRule_Runtime eliminationRule = new subtype_PointerType_PointerType_InequationReplacementRule();
      this.myInequationReplacementRules.add(eliminationRule);
    }
    {
      InequationReplacementRule_Runtime eliminationRule = new subtype_PrimitiveBasicIntegralType_AnnotatedType_InequationReplacementRule();
      this.myInequationReplacementRules.add(eliminationRule);
    }
    {
      InequationReplacementRule_Runtime eliminationRule = new subtype_PrimitiveC99IntegralType_AnnotatedType_InequationReplacementRule();
      this.myInequationReplacementRules.add(eliminationRule);
    }
    {
      InequationReplacementRule_Runtime eliminationRule = new subtype_PrimitiveIEEE754Type_AnnotatedType_InequationReplacementRule();
      this.myInequationReplacementRules.add(eliminationRule);
    }
    this.myOverloadedOperationsTypesProviders.add(new CustomOverloadedOperationsTypesProvider_f(CONCEPTS.BitwiseLeftShiftExpression$Kh));
    this.myOverloadedOperationsTypesProviders.add(new CustomOverloadedOperationsTypesProvider_f(CONCEPTS.BitwiseRightShiftExpression$hf));
    this.myOverloadedOperationsTypesProviders.add(new CustomOverloadedOperationsTypesProvider_f(CONCEPTS.DirectAssignmentExpression$Q8));
    this.myOverloadedOperationsTypesProviders.add(new CustomOverloadedOperationsTypesProvider_g(CONCEPTS.ModuloExpression$ia));
    this.myOverloadedOperationsTypesProviders.add(new CustomOverloadedOperationsTypesProvider_a(CONCEPTS.BitwiseAndExpression$HN));
    this.myOverloadedOperationsTypesProviders.add(new CustomOverloadedOperationsTypesProvider_a(CONCEPTS.BitwiseORExpression$vE));
    this.myOverloadedOperationsTypesProviders.add(new CustomOverloadedOperationsTypesProvider_a(CONCEPTS.BitwiseXORExpression$ht));
    this.myOverloadedOperationsTypesProviders.add(new CustomOverloadedOperationsTypesProvider_a(CONCEPTS.DirectMinusAssignmentExpression$Wu));
    this.myOverloadedOperationsTypesProviders.add(new CustomOverloadedOperationsTypesProvider_a(CONCEPTS.DirectPlusAssignmentExpression$1h));
    this.myOverloadedOperationsTypesProviders.add(new CustomOverloadedOperationsTypesProvider_a(CONCEPTS.MinusExpression$KE));
    this.myOverloadedOperationsTypesProviders.add(new CustomOverloadedOperationsTypesProvider_a(CONCEPTS.PlusExpression$If));
    this.myOverloadedOperationsTypesProviders.add(new CustomOverloadedOperationsTypesProvider_c(CONCEPTS.DivExpression$WL));
    this.myOverloadedOperationsTypesProviders.add(new CustomOverloadedOperationsTypesProvider_c(CONCEPTS.MultiExpression$VN));
    {
      OverloadedOpsProvider_OneTypeSpecified provider = new OverloadedOpsProvider_OneTypeSpecified() {
        {
          this.myOperandType = createAbstractAnnotatedType_3ist9o_a0a0a0a0a0a0a04a0();
          this.myOperationConcept = CONCEPTS.BitwiseLeftShiftExpression$Kh;
          this.myTypeIsExact = false;
          this.myIsStrong = true;
          this.myRuleModelId = "r:f5260afd-8327-4c3e-bf02-c81ea8a33729(com.mbeddr.ext.units.typesystem)";
          this.myRuleNodeId = "2943235651223503051";
        }
        public SNode getOperationType(SNode operation, SNode leftOperandType, SNode rightOperandType) {
          SNode operationPrimitiveType = TypeChecker.getInstance().getRulesManager().getOperationType(operation, SLinkOperations.getTarget(SNodeOperations.cast(leftOperandType, CONCEPTS.AnnotatedType$I9), LINKS.valueType$2o7e), rightOperandType);
          return UnitConversionUtil.createAnnotatedType(operationPrimitiveType, SLinkOperations.getTarget(SNodeOperations.cast(leftOperandType, CONCEPTS.AnnotatedType$I9), LINKS.specification$Q3Ej));
        }
        public boolean isApplicable(SubtypingManager subtypingManager, SNode operation, SNode leftOperandType, SNode rightOperandType) {
          return !(SNodeOperations.isInstanceOf(operation, CONCEPTS.DirectPlusAssignmentExpression$1h)) && !(SNodeOperations.isInstanceOf(operation, CONCEPTS.DirectMinusAssignmentExpression$Wu)) && SNodeOperations.isInstanceOf(leftOperandType, CONCEPTS.AnnotatedType$I9) && !(SNodeOperations.isInstanceOf(rightOperandType, CONCEPTS.AnnotatedType$I9));
        }
        @Override
        public void reportConflict(IRuleConflictWarningProducer producer) {
          producer.produceWarning(myRuleModelId, myRuleNodeId);
        }
      };
      this.myOverloadedOperationsTypesProviders.add(provider);
    }
    {
      OverloadedOpsProvider_OneTypeSpecified provider = new OverloadedOpsProvider_OneTypeSpecified() {
        {
          this.myOperandType = createAbstractAnnotatedType_3ist9o_a0a0a0a0a0a1a04a0();
          this.myOperationConcept = CONCEPTS.BitwiseRightShiftExpression$hf;
          this.myTypeIsExact = false;
          this.myIsStrong = true;
          this.myRuleModelId = "r:f5260afd-8327-4c3e-bf02-c81ea8a33729(com.mbeddr.ext.units.typesystem)";
          this.myRuleNodeId = "2943235651223503051";
        }
        public SNode getOperationType(SNode operation, SNode leftOperandType, SNode rightOperandType) {
          SNode operationPrimitiveType = TypeChecker.getInstance().getRulesManager().getOperationType(operation, SLinkOperations.getTarget(SNodeOperations.cast(leftOperandType, CONCEPTS.AnnotatedType$I9), LINKS.valueType$2o7e), rightOperandType);
          return UnitConversionUtil.createAnnotatedType(operationPrimitiveType, SLinkOperations.getTarget(SNodeOperations.cast(leftOperandType, CONCEPTS.AnnotatedType$I9), LINKS.specification$Q3Ej));
        }
        public boolean isApplicable(SubtypingManager subtypingManager, SNode operation, SNode leftOperandType, SNode rightOperandType) {
          return !(SNodeOperations.isInstanceOf(operation, CONCEPTS.DirectPlusAssignmentExpression$1h)) && !(SNodeOperations.isInstanceOf(operation, CONCEPTS.DirectMinusAssignmentExpression$Wu)) && SNodeOperations.isInstanceOf(leftOperandType, CONCEPTS.AnnotatedType$I9) && !(SNodeOperations.isInstanceOf(rightOperandType, CONCEPTS.AnnotatedType$I9));
        }
        @Override
        public void reportConflict(IRuleConflictWarningProducer producer) {
          producer.produceWarning(myRuleModelId, myRuleNodeId);
        }
      };
      this.myOverloadedOperationsTypesProviders.add(provider);
    }
    {
      OverloadedOpsProvider_OneTypeSpecified provider = new OverloadedOpsProvider_OneTypeSpecified() {
        {
          this.myOperandType = createAbstractAnnotatedType_3ist9o_a0a0a0a0a0a2a04a0();
          this.myOperationConcept = CONCEPTS.DirectAssignmentExpression$Q8;
          this.myTypeIsExact = false;
          this.myIsStrong = true;
          this.myRuleModelId = "r:f5260afd-8327-4c3e-bf02-c81ea8a33729(com.mbeddr.ext.units.typesystem)";
          this.myRuleNodeId = "2943235651223503051";
        }
        public SNode getOperationType(SNode operation, SNode leftOperandType, SNode rightOperandType) {
          SNode operationPrimitiveType = TypeChecker.getInstance().getRulesManager().getOperationType(operation, SLinkOperations.getTarget(SNodeOperations.cast(leftOperandType, CONCEPTS.AnnotatedType$I9), LINKS.valueType$2o7e), rightOperandType);
          return UnitConversionUtil.createAnnotatedType(operationPrimitiveType, SLinkOperations.getTarget(SNodeOperations.cast(leftOperandType, CONCEPTS.AnnotatedType$I9), LINKS.specification$Q3Ej));
        }
        public boolean isApplicable(SubtypingManager subtypingManager, SNode operation, SNode leftOperandType, SNode rightOperandType) {
          return !(SNodeOperations.isInstanceOf(operation, CONCEPTS.DirectPlusAssignmentExpression$1h)) && !(SNodeOperations.isInstanceOf(operation, CONCEPTS.DirectMinusAssignmentExpression$Wu)) && SNodeOperations.isInstanceOf(leftOperandType, CONCEPTS.AnnotatedType$I9) && !(SNodeOperations.isInstanceOf(rightOperandType, CONCEPTS.AnnotatedType$I9));
        }
        @Override
        public void reportConflict(IRuleConflictWarningProducer producer) {
          producer.produceWarning(myRuleModelId, myRuleNodeId);
        }
      };
      this.myOverloadedOperationsTypesProviders.add(provider);
    }
    {
      OverloadedOpsProvider_OneTypeSpecified provider = new OverloadedOpsProvider_OneTypeSpecified() {
        {
          this.myOperandType = createAbstractAnnotatedType_3ist9o_a0a0a0a0a0a3a04a0();
          this.myOperationConcept = CONCEPTS.ModuloExpression$ia;
          this.myTypeIsExact = false;
          this.myIsStrong = true;
          this.myRuleModelId = "r:f5260afd-8327-4c3e-bf02-c81ea8a33729(com.mbeddr.ext.units.typesystem)";
          this.myRuleNodeId = "2943235651223503051";
        }
        public SNode getOperationType(SNode operation, SNode leftOperandType, SNode rightOperandType) {
          SNode operationPrimitiveType = TypeChecker.getInstance().getRulesManager().getOperationType(operation, SLinkOperations.getTarget(SNodeOperations.cast(leftOperandType, CONCEPTS.AnnotatedType$I9), LINKS.valueType$2o7e), rightOperandType);
          return UnitConversionUtil.createAnnotatedType(operationPrimitiveType, SLinkOperations.getTarget(SNodeOperations.cast(leftOperandType, CONCEPTS.AnnotatedType$I9), LINKS.specification$Q3Ej));
        }
        public boolean isApplicable(SubtypingManager subtypingManager, SNode operation, SNode leftOperandType, SNode rightOperandType) {
          return !(SNodeOperations.isInstanceOf(operation, CONCEPTS.DirectPlusAssignmentExpression$1h)) && !(SNodeOperations.isInstanceOf(operation, CONCEPTS.DirectMinusAssignmentExpression$Wu)) && SNodeOperations.isInstanceOf(leftOperandType, CONCEPTS.AnnotatedType$I9) && !(SNodeOperations.isInstanceOf(rightOperandType, CONCEPTS.AnnotatedType$I9));
        }
        @Override
        public void reportConflict(IRuleConflictWarningProducer producer) {
          producer.produceWarning(myRuleModelId, myRuleNodeId);
        }
      };
      this.myOverloadedOperationsTypesProviders.add(provider);
    }
    {
      OverloadedOpsProvider_OneTypeSpecified provider = new OverloadedOpsProvider_OneTypeSpecified() {
        {
          this.myOperandType = createAbstractAnnotatedType_3ist9o_a0a0a0a0a0a0a14a0();
          this.myOperationConcept = CONCEPTS.BitwiseAndExpression$HN;
          this.myTypeIsExact = false;
          this.myIsStrong = true;
          this.myRuleModelId = "r:f5260afd-8327-4c3e-bf02-c81ea8a33729(com.mbeddr.ext.units.typesystem)";
          this.myRuleNodeId = "4959640877385499723";
        }
        public SNode getOperationType(SNode operation, SNode leftOperandType, SNode rightOperandType) {
          Map<SNode, Fraction> leftSpec = UnitConversionUtil.getUnitMap_Type(leftOperandType);
          Map<SNode, Fraction> rightSpec = UnitConversionUtil.getUnitMap_Type(rightOperandType);

          // matching between these two types can only happen if the annotated one evaluates to no unit
          if (UnitConversionUtil.matchingUnits(leftSpec, rightSpec, true)) {
            SNode leftPrimitiveType = (SNodeOperations.isInstanceOf(leftOperandType, CONCEPTS.AnnotatedType$I9) ? SLinkOperations.getTarget(SNodeOperations.cast(leftOperandType, CONCEPTS.AnnotatedType$I9), LINKS.valueType$2o7e) : leftOperandType);
            SNode rightPrimitiveType = (SNodeOperations.isInstanceOf(rightOperandType, CONCEPTS.AnnotatedType$I9) ? SLinkOperations.getTarget(SNodeOperations.cast(rightOperandType, CONCEPTS.AnnotatedType$I9), LINKS.valueType$2o7e) : rightOperandType);
            SNode operationPrimitiveType = TypeChecker.getInstance().getRulesManager().getOperationType(operation, leftPrimitiveType, rightPrimitiveType);

            return operationPrimitiveType;
          } else {
            return createRuntimeErrorType_3ist9o_a0a0e0b0a0a0a0a14a0("Mismatched units: " + SNodeOperations.present(leftOperandType) + " and " + rightOperandType);
          }
        }
        public boolean isApplicable(SubtypingManager subtypingManager, SNode operation, SNode leftOperandType, SNode rightOperandType) {
          return SNodeOperations.isInstanceOf(leftOperandType, CONCEPTS.AnnotatedType$I9) ^ SNodeOperations.isInstanceOf(rightOperandType, CONCEPTS.AnnotatedType$I9);
        }
        @Override
        public void reportConflict(IRuleConflictWarningProducer producer) {
          producer.produceWarning(myRuleModelId, myRuleNodeId);
        }
      };
      this.myOverloadedOperationsTypesProviders.add(provider);
    }
    {
      OverloadedOpsProvider_OneTypeSpecified provider = new OverloadedOpsProvider_OneTypeSpecified() {
        {
          this.myOperandType = createAbstractAnnotatedType_3ist9o_a0a0a0a0a0a1a14a0();
          this.myOperationConcept = CONCEPTS.BitwiseORExpression$vE;
          this.myTypeIsExact = false;
          this.myIsStrong = true;
          this.myRuleModelId = "r:f5260afd-8327-4c3e-bf02-c81ea8a33729(com.mbeddr.ext.units.typesystem)";
          this.myRuleNodeId = "4959640877385499723";
        }
        public SNode getOperationType(SNode operation, SNode leftOperandType, SNode rightOperandType) {
          Map<SNode, Fraction> leftSpec = UnitConversionUtil.getUnitMap_Type(leftOperandType);
          Map<SNode, Fraction> rightSpec = UnitConversionUtil.getUnitMap_Type(rightOperandType);

          // matching between these two types can only happen if the annotated one evaluates to no unit
          if (UnitConversionUtil.matchingUnits(leftSpec, rightSpec, true)) {
            SNode leftPrimitiveType = (SNodeOperations.isInstanceOf(leftOperandType, CONCEPTS.AnnotatedType$I9) ? SLinkOperations.getTarget(SNodeOperations.cast(leftOperandType, CONCEPTS.AnnotatedType$I9), LINKS.valueType$2o7e) : leftOperandType);
            SNode rightPrimitiveType = (SNodeOperations.isInstanceOf(rightOperandType, CONCEPTS.AnnotatedType$I9) ? SLinkOperations.getTarget(SNodeOperations.cast(rightOperandType, CONCEPTS.AnnotatedType$I9), LINKS.valueType$2o7e) : rightOperandType);
            SNode operationPrimitiveType = TypeChecker.getInstance().getRulesManager().getOperationType(operation, leftPrimitiveType, rightPrimitiveType);

            return operationPrimitiveType;
          } else {
            return createRuntimeErrorType_3ist9o_a0a0e0b0a0a0a1a14a0("Mismatched units: " + SNodeOperations.present(leftOperandType) + " and " + rightOperandType);
          }
        }
        public boolean isApplicable(SubtypingManager subtypingManager, SNode operation, SNode leftOperandType, SNode rightOperandType) {
          return SNodeOperations.isInstanceOf(leftOperandType, CONCEPTS.AnnotatedType$I9) ^ SNodeOperations.isInstanceOf(rightOperandType, CONCEPTS.AnnotatedType$I9);
        }
        @Override
        public void reportConflict(IRuleConflictWarningProducer producer) {
          producer.produceWarning(myRuleModelId, myRuleNodeId);
        }
      };
      this.myOverloadedOperationsTypesProviders.add(provider);
    }
    {
      OverloadedOpsProvider_OneTypeSpecified provider = new OverloadedOpsProvider_OneTypeSpecified() {
        {
          this.myOperandType = createAbstractAnnotatedType_3ist9o_a0a0a0a0a0a2a14a0();
          this.myOperationConcept = CONCEPTS.BitwiseXORExpression$ht;
          this.myTypeIsExact = false;
          this.myIsStrong = true;
          this.myRuleModelId = "r:f5260afd-8327-4c3e-bf02-c81ea8a33729(com.mbeddr.ext.units.typesystem)";
          this.myRuleNodeId = "4959640877385499723";
        }
        public SNode getOperationType(SNode operation, SNode leftOperandType, SNode rightOperandType) {
          Map<SNode, Fraction> leftSpec = UnitConversionUtil.getUnitMap_Type(leftOperandType);
          Map<SNode, Fraction> rightSpec = UnitConversionUtil.getUnitMap_Type(rightOperandType);

          // matching between these two types can only happen if the annotated one evaluates to no unit
          if (UnitConversionUtil.matchingUnits(leftSpec, rightSpec, true)) {
            SNode leftPrimitiveType = (SNodeOperations.isInstanceOf(leftOperandType, CONCEPTS.AnnotatedType$I9) ? SLinkOperations.getTarget(SNodeOperations.cast(leftOperandType, CONCEPTS.AnnotatedType$I9), LINKS.valueType$2o7e) : leftOperandType);
            SNode rightPrimitiveType = (SNodeOperations.isInstanceOf(rightOperandType, CONCEPTS.AnnotatedType$I9) ? SLinkOperations.getTarget(SNodeOperations.cast(rightOperandType, CONCEPTS.AnnotatedType$I9), LINKS.valueType$2o7e) : rightOperandType);
            SNode operationPrimitiveType = TypeChecker.getInstance().getRulesManager().getOperationType(operation, leftPrimitiveType, rightPrimitiveType);

            return operationPrimitiveType;
          } else {
            return createRuntimeErrorType_3ist9o_a0a0e0b0a0a0a2a14a0("Mismatched units: " + SNodeOperations.present(leftOperandType) + " and " + rightOperandType);
          }
        }
        public boolean isApplicable(SubtypingManager subtypingManager, SNode operation, SNode leftOperandType, SNode rightOperandType) {
          return SNodeOperations.isInstanceOf(leftOperandType, CONCEPTS.AnnotatedType$I9) ^ SNodeOperations.isInstanceOf(rightOperandType, CONCEPTS.AnnotatedType$I9);
        }
        @Override
        public void reportConflict(IRuleConflictWarningProducer producer) {
          producer.produceWarning(myRuleModelId, myRuleNodeId);
        }
      };
      this.myOverloadedOperationsTypesProviders.add(provider);
    }
    {
      OverloadedOpsProvider_OneTypeSpecified provider = new OverloadedOpsProvider_OneTypeSpecified() {
        {
          this.myOperandType = createAbstractAnnotatedType_3ist9o_a0a0a0a0a0a3a14a0();
          this.myOperationConcept = CONCEPTS.DirectMinusAssignmentExpression$Wu;
          this.myTypeIsExact = false;
          this.myIsStrong = true;
          this.myRuleModelId = "r:f5260afd-8327-4c3e-bf02-c81ea8a33729(com.mbeddr.ext.units.typesystem)";
          this.myRuleNodeId = "4959640877385499723";
        }
        public SNode getOperationType(SNode operation, SNode leftOperandType, SNode rightOperandType) {
          Map<SNode, Fraction> leftSpec = UnitConversionUtil.getUnitMap_Type(leftOperandType);
          Map<SNode, Fraction> rightSpec = UnitConversionUtil.getUnitMap_Type(rightOperandType);

          // matching between these two types can only happen if the annotated one evaluates to no unit
          if (UnitConversionUtil.matchingUnits(leftSpec, rightSpec, true)) {
            SNode leftPrimitiveType = (SNodeOperations.isInstanceOf(leftOperandType, CONCEPTS.AnnotatedType$I9) ? SLinkOperations.getTarget(SNodeOperations.cast(leftOperandType, CONCEPTS.AnnotatedType$I9), LINKS.valueType$2o7e) : leftOperandType);
            SNode rightPrimitiveType = (SNodeOperations.isInstanceOf(rightOperandType, CONCEPTS.AnnotatedType$I9) ? SLinkOperations.getTarget(SNodeOperations.cast(rightOperandType, CONCEPTS.AnnotatedType$I9), LINKS.valueType$2o7e) : rightOperandType);
            SNode operationPrimitiveType = TypeChecker.getInstance().getRulesManager().getOperationType(operation, leftPrimitiveType, rightPrimitiveType);

            return operationPrimitiveType;
          } else {
            return createRuntimeErrorType_3ist9o_a0a0e0b0a0a0a3a14a0("Mismatched units: " + SNodeOperations.present(leftOperandType) + " and " + rightOperandType);
          }
        }
        public boolean isApplicable(SubtypingManager subtypingManager, SNode operation, SNode leftOperandType, SNode rightOperandType) {
          return SNodeOperations.isInstanceOf(leftOperandType, CONCEPTS.AnnotatedType$I9) ^ SNodeOperations.isInstanceOf(rightOperandType, CONCEPTS.AnnotatedType$I9);
        }
        @Override
        public void reportConflict(IRuleConflictWarningProducer producer) {
          producer.produceWarning(myRuleModelId, myRuleNodeId);
        }
      };
      this.myOverloadedOperationsTypesProviders.add(provider);
    }
    {
      OverloadedOpsProvider_OneTypeSpecified provider = new OverloadedOpsProvider_OneTypeSpecified() {
        {
          this.myOperandType = createAbstractAnnotatedType_3ist9o_a0a0a0a0a0a4a14a0();
          this.myOperationConcept = CONCEPTS.DirectPlusAssignmentExpression$1h;
          this.myTypeIsExact = false;
          this.myIsStrong = true;
          this.myRuleModelId = "r:f5260afd-8327-4c3e-bf02-c81ea8a33729(com.mbeddr.ext.units.typesystem)";
          this.myRuleNodeId = "4959640877385499723";
        }
        public SNode getOperationType(SNode operation, SNode leftOperandType, SNode rightOperandType) {
          Map<SNode, Fraction> leftSpec = UnitConversionUtil.getUnitMap_Type(leftOperandType);
          Map<SNode, Fraction> rightSpec = UnitConversionUtil.getUnitMap_Type(rightOperandType);

          // matching between these two types can only happen if the annotated one evaluates to no unit
          if (UnitConversionUtil.matchingUnits(leftSpec, rightSpec, true)) {
            SNode leftPrimitiveType = (SNodeOperations.isInstanceOf(leftOperandType, CONCEPTS.AnnotatedType$I9) ? SLinkOperations.getTarget(SNodeOperations.cast(leftOperandType, CONCEPTS.AnnotatedType$I9), LINKS.valueType$2o7e) : leftOperandType);
            SNode rightPrimitiveType = (SNodeOperations.isInstanceOf(rightOperandType, CONCEPTS.AnnotatedType$I9) ? SLinkOperations.getTarget(SNodeOperations.cast(rightOperandType, CONCEPTS.AnnotatedType$I9), LINKS.valueType$2o7e) : rightOperandType);
            SNode operationPrimitiveType = TypeChecker.getInstance().getRulesManager().getOperationType(operation, leftPrimitiveType, rightPrimitiveType);

            return operationPrimitiveType;
          } else {
            return createRuntimeErrorType_3ist9o_a0a0e0b0a0a0a4a14a0("Mismatched units: " + SNodeOperations.present(leftOperandType) + " and " + rightOperandType);
          }
        }
        public boolean isApplicable(SubtypingManager subtypingManager, SNode operation, SNode leftOperandType, SNode rightOperandType) {
          return SNodeOperations.isInstanceOf(leftOperandType, CONCEPTS.AnnotatedType$I9) ^ SNodeOperations.isInstanceOf(rightOperandType, CONCEPTS.AnnotatedType$I9);
        }
        @Override
        public void reportConflict(IRuleConflictWarningProducer producer) {
          producer.produceWarning(myRuleModelId, myRuleNodeId);
        }
      };
      this.myOverloadedOperationsTypesProviders.add(provider);
    }
    {
      OverloadedOpsProvider_OneTypeSpecified provider = new OverloadedOpsProvider_OneTypeSpecified() {
        {
          this.myOperandType = createAbstractAnnotatedType_3ist9o_a0a0a0a0a0a5a14a0();
          this.myOperationConcept = CONCEPTS.MinusExpression$KE;
          this.myTypeIsExact = false;
          this.myIsStrong = true;
          this.myRuleModelId = "r:f5260afd-8327-4c3e-bf02-c81ea8a33729(com.mbeddr.ext.units.typesystem)";
          this.myRuleNodeId = "4959640877385499723";
        }
        public SNode getOperationType(SNode operation, SNode leftOperandType, SNode rightOperandType) {
          Map<SNode, Fraction> leftSpec = UnitConversionUtil.getUnitMap_Type(leftOperandType);
          Map<SNode, Fraction> rightSpec = UnitConversionUtil.getUnitMap_Type(rightOperandType);

          // matching between these two types can only happen if the annotated one evaluates to no unit
          if (UnitConversionUtil.matchingUnits(leftSpec, rightSpec, true)) {
            SNode leftPrimitiveType = (SNodeOperations.isInstanceOf(leftOperandType, CONCEPTS.AnnotatedType$I9) ? SLinkOperations.getTarget(SNodeOperations.cast(leftOperandType, CONCEPTS.AnnotatedType$I9), LINKS.valueType$2o7e) : leftOperandType);
            SNode rightPrimitiveType = (SNodeOperations.isInstanceOf(rightOperandType, CONCEPTS.AnnotatedType$I9) ? SLinkOperations.getTarget(SNodeOperations.cast(rightOperandType, CONCEPTS.AnnotatedType$I9), LINKS.valueType$2o7e) : rightOperandType);
            SNode operationPrimitiveType = TypeChecker.getInstance().getRulesManager().getOperationType(operation, leftPrimitiveType, rightPrimitiveType);

            return operationPrimitiveType;
          } else {
            return createRuntimeErrorType_3ist9o_a0a0e0b0a0a0a5a14a0("Mismatched units: " + SNodeOperations.present(leftOperandType) + " and " + rightOperandType);
          }
        }
        public boolean isApplicable(SubtypingManager subtypingManager, SNode operation, SNode leftOperandType, SNode rightOperandType) {
          return SNodeOperations.isInstanceOf(leftOperandType, CONCEPTS.AnnotatedType$I9) ^ SNodeOperations.isInstanceOf(rightOperandType, CONCEPTS.AnnotatedType$I9);
        }
        @Override
        public void reportConflict(IRuleConflictWarningProducer producer) {
          producer.produceWarning(myRuleModelId, myRuleNodeId);
        }
      };
      this.myOverloadedOperationsTypesProviders.add(provider);
    }
    {
      OverloadedOpsProvider_OneTypeSpecified provider = new OverloadedOpsProvider_OneTypeSpecified() {
        {
          this.myOperandType = createAbstractAnnotatedType_3ist9o_a0a0a0a0a0a6a14a0();
          this.myOperationConcept = CONCEPTS.PlusExpression$If;
          this.myTypeIsExact = false;
          this.myIsStrong = true;
          this.myRuleModelId = "r:f5260afd-8327-4c3e-bf02-c81ea8a33729(com.mbeddr.ext.units.typesystem)";
          this.myRuleNodeId = "4959640877385499723";
        }
        public SNode getOperationType(SNode operation, SNode leftOperandType, SNode rightOperandType) {
          Map<SNode, Fraction> leftSpec = UnitConversionUtil.getUnitMap_Type(leftOperandType);
          Map<SNode, Fraction> rightSpec = UnitConversionUtil.getUnitMap_Type(rightOperandType);

          // matching between these two types can only happen if the annotated one evaluates to no unit
          if (UnitConversionUtil.matchingUnits(leftSpec, rightSpec, true)) {
            SNode leftPrimitiveType = (SNodeOperations.isInstanceOf(leftOperandType, CONCEPTS.AnnotatedType$I9) ? SLinkOperations.getTarget(SNodeOperations.cast(leftOperandType, CONCEPTS.AnnotatedType$I9), LINKS.valueType$2o7e) : leftOperandType);
            SNode rightPrimitiveType = (SNodeOperations.isInstanceOf(rightOperandType, CONCEPTS.AnnotatedType$I9) ? SLinkOperations.getTarget(SNodeOperations.cast(rightOperandType, CONCEPTS.AnnotatedType$I9), LINKS.valueType$2o7e) : rightOperandType);
            SNode operationPrimitiveType = TypeChecker.getInstance().getRulesManager().getOperationType(operation, leftPrimitiveType, rightPrimitiveType);

            return operationPrimitiveType;
          } else {
            return createRuntimeErrorType_3ist9o_a0a0e0b0a0a0a6a14a0("Mismatched units: " + SNodeOperations.present(leftOperandType) + " and " + rightOperandType);
          }
        }
        public boolean isApplicable(SubtypingManager subtypingManager, SNode operation, SNode leftOperandType, SNode rightOperandType) {
          return SNodeOperations.isInstanceOf(leftOperandType, CONCEPTS.AnnotatedType$I9) ^ SNodeOperations.isInstanceOf(rightOperandType, CONCEPTS.AnnotatedType$I9);
        }
        @Override
        public void reportConflict(IRuleConflictWarningProducer producer) {
          producer.produceWarning(myRuleModelId, myRuleNodeId);
        }
      };
      this.myOverloadedOperationsTypesProviders.add(provider);
    }
    {
      OverloadedOpsProvider_OneTypeSpecified provider = new OverloadedOpsProvider_OneTypeSpecified() {
        {
          this.myOperandType = createAbstractAnnotatedType_3ist9o_a0a0a0a0a0a0a24a0();
          this.myOperationConcept = CONCEPTS.DivExpression$WL;
          this.myTypeIsExact = false;
          this.myIsStrong = true;
          this.myRuleModelId = "r:f5260afd-8327-4c3e-bf02-c81ea8a33729(com.mbeddr.ext.units.typesystem)";
          this.myRuleNodeId = "4959640877385862869";
        }
        public SNode getOperationType(SNode operation, SNode leftOperandType, SNode rightOperandType) {
          SNode resultType = (SNodeOperations.isInstanceOf(leftOperandType, CONCEPTS.AnnotatedType$I9) ? leftOperandType : rightOperandType);
          Map<SNode, Fraction> resultSpec = UnitConversionUtil.getUnitMap_UnitSpecification(SLinkOperations.getTarget(SNodeOperations.cast(resultType, CONCEPTS.AnnotatedType$I9), LINKS.specification$Q3Ej));

          // if the right operand is the annotated expression and it is a divide expression,
          // then we apply the reciprocal of the type annotation
          if (SNodeOperations.isInstanceOf(operation, CONCEPTS.DivExpression$WL) && SNodeOperations.isInstanceOf(rightOperandType, CONCEPTS.AnnotatedType$I9)) {
            resultSpec = UnitConversionUtil.negate(resultSpec);
          }

          SNode leftPrimitiveType = (SNodeOperations.isInstanceOf(leftOperandType, CONCEPTS.AnnotatedType$I9) ? SLinkOperations.getTarget(SNodeOperations.cast(leftOperandType, CONCEPTS.AnnotatedType$I9), LINKS.valueType$2o7e) : leftOperandType);
          SNode rightPrimitiveType = (SNodeOperations.isInstanceOf(rightOperandType, CONCEPTS.AnnotatedType$I9) ? SLinkOperations.getTarget(SNodeOperations.cast(rightOperandType, CONCEPTS.AnnotatedType$I9), LINKS.valueType$2o7e) : rightOperandType);
          SNode operationPrimitiveType = TypeChecker.getInstance().getRulesManager().getOperationType(operation, leftPrimitiveType, rightPrimitiveType);

          List<SNode> references = UnitConversionUtil.createUnitReferences(resultSpec);

          return UnitConversionUtil.createAnnotatedType(operationPrimitiveType, references);
        }
        public boolean isApplicable(SubtypingManager subtypingManager, SNode operation, SNode leftOperandType, SNode rightOperandType) {
          return SNodeOperations.isInstanceOf(leftOperandType, CONCEPTS.AnnotatedType$I9) ^ SNodeOperations.isInstanceOf(rightOperandType, CONCEPTS.AnnotatedType$I9);
        }
        @Override
        public void reportConflict(IRuleConflictWarningProducer producer) {
          producer.produceWarning(myRuleModelId, myRuleNodeId);
        }
      };
      this.myOverloadedOperationsTypesProviders.add(provider);
    }
    {
      OverloadedOpsProvider_OneTypeSpecified provider = new OverloadedOpsProvider_OneTypeSpecified() {
        {
          this.myOperandType = createAbstractAnnotatedType_3ist9o_a0a0a0a0a0a1a24a0();
          this.myOperationConcept = CONCEPTS.MultiExpression$VN;
          this.myTypeIsExact = false;
          this.myIsStrong = true;
          this.myRuleModelId = "r:f5260afd-8327-4c3e-bf02-c81ea8a33729(com.mbeddr.ext.units.typesystem)";
          this.myRuleNodeId = "4959640877385862869";
        }
        public SNode getOperationType(SNode operation, SNode leftOperandType, SNode rightOperandType) {
          SNode resultType = (SNodeOperations.isInstanceOf(leftOperandType, CONCEPTS.AnnotatedType$I9) ? leftOperandType : rightOperandType);
          Map<SNode, Fraction> resultSpec = UnitConversionUtil.getUnitMap_UnitSpecification(SLinkOperations.getTarget(SNodeOperations.cast(resultType, CONCEPTS.AnnotatedType$I9), LINKS.specification$Q3Ej));

          // if the right operand is the annotated expression and it is a divide expression,
          // then we apply the reciprocal of the type annotation
          if (SNodeOperations.isInstanceOf(operation, CONCEPTS.DivExpression$WL) && SNodeOperations.isInstanceOf(rightOperandType, CONCEPTS.AnnotatedType$I9)) {
            resultSpec = UnitConversionUtil.negate(resultSpec);
          }

          SNode leftPrimitiveType = (SNodeOperations.isInstanceOf(leftOperandType, CONCEPTS.AnnotatedType$I9) ? SLinkOperations.getTarget(SNodeOperations.cast(leftOperandType, CONCEPTS.AnnotatedType$I9), LINKS.valueType$2o7e) : leftOperandType);
          SNode rightPrimitiveType = (SNodeOperations.isInstanceOf(rightOperandType, CONCEPTS.AnnotatedType$I9) ? SLinkOperations.getTarget(SNodeOperations.cast(rightOperandType, CONCEPTS.AnnotatedType$I9), LINKS.valueType$2o7e) : rightOperandType);
          SNode operationPrimitiveType = TypeChecker.getInstance().getRulesManager().getOperationType(operation, leftPrimitiveType, rightPrimitiveType);

          List<SNode> references = UnitConversionUtil.createUnitReferences(resultSpec);

          return UnitConversionUtil.createAnnotatedType(operationPrimitiveType, references);
        }
        public boolean isApplicable(SubtypingManager subtypingManager, SNode operation, SNode leftOperandType, SNode rightOperandType) {
          return SNodeOperations.isInstanceOf(leftOperandType, CONCEPTS.AnnotatedType$I9) ^ SNodeOperations.isInstanceOf(rightOperandType, CONCEPTS.AnnotatedType$I9);
        }
        @Override
        public void reportConflict(IRuleConflictWarningProducer producer) {
          producer.produceWarning(myRuleModelId, myRuleNodeId);
        }
      };
      this.myOverloadedOperationsTypesProviders.add(provider);
    }
  }
  public static class CustomOverloadedOperationsTypesProvider_f extends OverloadedOperationsTypesProvider {
    public CustomOverloadedOperationsTypesProvider_f(SAbstractConcept concept) {
      this.myLeftOperandType = createAbstractAnnotatedType_3ist9o_a0a0a1();
      this.myRightOperandType = createAbstractAnnotatedType_3ist9o_a0b0a1();
      this.myOperationConcept = concept;
      this.myLeftTypeIsExact = false;
      this.myRightTypeIsExact = false;
      this.myRightIsStrong = false;
      this.myLeftIsStrong = false;
      this.myRuleModelId = "r:f5260afd-8327-4c3e-bf02-c81ea8a33729(com.mbeddr.ext.units.typesystem)";
      this.myRuleNodeId = "2418981108296339795";
    }
    public SNode getOperationType(SNode operation, SNode leftOperandType, SNode rightOperandType) {
      // this is only valid if the right unit is no unit
      SNode operationPrimitiveType = TypeChecker.getInstance().getRulesManager().getOperationType(operation, SLinkOperations.getTarget(SNodeOperations.cast(leftOperandType, CONCEPTS.AnnotatedType$I9), LINKS.valueType$2o7e), SLinkOperations.getTarget(SNodeOperations.cast(rightOperandType, CONCEPTS.AnnotatedType$I9), LINKS.valueType$2o7e));
      if (UnitConversionUtil.isUnitLessType(rightOperandType)) {
        return UnitConversionUtil.createAnnotatedType(operationPrimitiveType, SLinkOperations.getTarget(SNodeOperations.cast(leftOperandType, CONCEPTS.AnnotatedType$I9), LINKS.specification$Q3Ej));
      } else {
        return createRuntimeErrorType_3ist9o_a0a0c0b1("Mismatched units: " + SNodeOperations.present(leftOperandType) + " and " + rightOperandType);
      }
    }
    public boolean isApplicable(SubtypingManager subtypingManager, SNode operation, SNode leftOperandType, SNode rightOperandType) {
      return !(SNodeOperations.isInstanceOf(operation, CONCEPTS.DirectPlusAssignmentExpression$1h)) && !(SNodeOperations.isInstanceOf(operation, CONCEPTS.DirectMinusAssignmentExpression$Wu));
    }
    @Override
    public void reportConflict(IRuleConflictWarningProducer producer) {
      producer.produceWarning(myRuleModelId, myRuleNodeId);
    }
    private static SNode createAbstractAnnotatedType_3ist9o_a0a0a1() {
      SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.AbstractAnnotatedType$LZ);
      return n0.getResult();
    }
    private static SNode createAbstractAnnotatedType_3ist9o_a0b0a1() {
      SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.AbstractAnnotatedType$LZ);
      return n0.getResult();
    }
    private static SNode createRuntimeErrorType_3ist9o_a0a0c0b1(String p0) {
      SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.RuntimeErrorType$3c);
      n0.setProperty(PROPS.errorText$leWQ, p0);
      return n0.getResult();
    }
  }
  public static class CustomOverloadedOperationsTypesProvider_g extends OverloadedOperationsTypesProvider {
    public CustomOverloadedOperationsTypesProvider_g(SAbstractConcept concept) {
      this.myLeftOperandType = createAbstractAnnotatedType_3ist9o_a0a0a2();
      this.myRightOperandType = createAbstractAnnotatedType_3ist9o_a0b0a2();
      this.myOperationConcept = concept;
      this.myLeftTypeIsExact = false;
      this.myRightTypeIsExact = false;
      this.myRightIsStrong = true;
      this.myLeftIsStrong = true;
      this.myRuleModelId = "r:f5260afd-8327-4c3e-bf02-c81ea8a33729(com.mbeddr.ext.units.typesystem)";
      this.myRuleNodeId = "2943235651226033245";
    }
    public SNode getOperationType(SNode operation, SNode leftOperandType, SNode rightOperandType) {
      Map<SNode, Fraction> leftSpec = UnitConversionUtil.getUnitMap_UnitSpecification(SLinkOperations.getTarget(SNodeOperations.cast(leftOperandType, CONCEPTS.AnnotatedType$I9), LINKS.specification$Q3Ej));
      Map<SNode, Fraction> rightSpec = UnitConversionUtil.getUnitMap_UnitSpecification(SLinkOperations.getTarget(SNodeOperations.cast(rightOperandType, CONCEPTS.AnnotatedType$I9), LINKS.specification$Q3Ej));

      if (UnitConversionUtil.matchingUnits(leftSpec, rightSpec, true)) {
        SNode leftPrimitiveType = SLinkOperations.getTarget(SNodeOperations.cast(leftOperandType, CONCEPTS.AnnotatedType$I9), LINKS.valueType$2o7e);
        SNode rightPrimitiveType = SLinkOperations.getTarget(SNodeOperations.cast(rightOperandType, CONCEPTS.AnnotatedType$I9), LINKS.valueType$2o7e);
        SNode operationPrimitiveType = TypeChecker.getInstance().getRulesManager().getOperationType(operation, leftPrimitiveType, rightPrimitiveType);
        return SNodeOperations.copyNode(operationPrimitiveType);
      } else {
        return createRuntimeErrorType_3ist9o_a0a0d0b2("Mismatched units: " + SNodeOperations.present(leftOperandType) + " and " + rightOperandType);
      }
    }
    @Override
    public void reportConflict(IRuleConflictWarningProducer producer) {
      producer.produceWarning(myRuleModelId, myRuleNodeId);
    }
    private static SNode createAbstractAnnotatedType_3ist9o_a0a0a2() {
      SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.AbstractAnnotatedType$LZ);
      return n0.getResult();
    }
    private static SNode createAbstractAnnotatedType_3ist9o_a0b0a2() {
      SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.AbstractAnnotatedType$LZ);
      return n0.getResult();
    }
    private static SNode createRuntimeErrorType_3ist9o_a0a0d0b2(String p0) {
      SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.RuntimeErrorType$3c);
      n0.setProperty(PROPS.errorText$leWQ, p0);
      return n0.getResult();
    }
  }
  public static class CustomOverloadedOperationsTypesProvider_a extends OverloadedOperationsTypesProvider {
    public CustomOverloadedOperationsTypesProvider_a(SAbstractConcept concept) {
      this.myLeftOperandType = createAbstractAnnotatedType_3ist9o_a0a0a3();
      this.myRightOperandType = createAbstractAnnotatedType_3ist9o_a0b0a3();
      this.myOperationConcept = concept;
      this.myLeftTypeIsExact = false;
      this.myRightTypeIsExact = false;
      this.myRightIsStrong = true;
      this.myLeftIsStrong = true;
      this.myRuleModelId = "r:f5260afd-8327-4c3e-bf02-c81ea8a33729(com.mbeddr.ext.units.typesystem)";
      this.myRuleNodeId = "4959640877382136412";
    }
    public SNode getOperationType(SNode operation, SNode leftOperandType, SNode rightOperandType) {
      Map<SNode, Fraction> leftSpec = UnitConversionUtil.getUnitMap_Type(leftOperandType);
      Map<SNode, Fraction> rightSpec = UnitConversionUtil.getUnitMap_Type(rightOperandType);

      if (UnitConversionUtil.matchingUnits(leftSpec, rightSpec, true)) {
        SNode leftPrimitiveType = SLinkOperations.getTarget(SNodeOperations.cast(leftOperandType, CONCEPTS.AnnotatedType$I9), LINKS.valueType$2o7e);
        SNode rightPrimitiveType = SLinkOperations.getTarget(SNodeOperations.cast(rightOperandType, CONCEPTS.AnnotatedType$I9), LINKS.valueType$2o7e);
        SNode operationPrimitiveType = TypeChecker.getInstance().getRulesManager().getOperationType(operation, leftPrimitiveType, rightPrimitiveType);

        List<SNode> references = UnitConversionUtil.createUnitReferences(leftSpec);
        return UnitConversionUtil.createAnnotatedType(operationPrimitiveType, references);
      } else {
        return createRuntimeErrorType_3ist9o_a0a0d0b3("Mismatched units: " + SNodeOperations.present(leftOperandType) + " and " + rightOperandType);
      }
    }
    @Override
    public void reportConflict(IRuleConflictWarningProducer producer) {
      producer.produceWarning(myRuleModelId, myRuleNodeId);
    }
    private static SNode createAbstractAnnotatedType_3ist9o_a0a0a3() {
      SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.AbstractAnnotatedType$LZ);
      return n0.getResult();
    }
    private static SNode createAbstractAnnotatedType_3ist9o_a0b0a3() {
      SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.AbstractAnnotatedType$LZ);
      return n0.getResult();
    }
    private static SNode createRuntimeErrorType_3ist9o_a0a0d0b3(String p0) {
      SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.RuntimeErrorType$3c);
      n0.setProperty(PROPS.errorText$leWQ, p0);
      return n0.getResult();
    }
  }
  public static class CustomOverloadedOperationsTypesProvider_c extends OverloadedOperationsTypesProvider {
    public CustomOverloadedOperationsTypesProvider_c(SAbstractConcept concept) {
      this.myLeftOperandType = createAbstractAnnotatedType_3ist9o_a0a0a4();
      this.myRightOperandType = createAbstractAnnotatedType_3ist9o_a0b0a4();
      this.myOperationConcept = concept;
      this.myLeftTypeIsExact = false;
      this.myRightTypeIsExact = false;
      this.myRightIsStrong = true;
      this.myLeftIsStrong = true;
      this.myRuleModelId = "r:f5260afd-8327-4c3e-bf02-c81ea8a33729(com.mbeddr.ext.units.typesystem)";
      this.myRuleNodeId = "4959640877385581794";
    }
    public SNode getOperationType(SNode operation, SNode leftOperandType, SNode rightOperandType) {
      Map<SNode, Fraction> leftSpec = UnitConversionUtil.getUnitMap_UnitSpecification(SLinkOperations.getTarget(SNodeOperations.cast(leftOperandType, CONCEPTS.AnnotatedType$I9), LINKS.specification$Q3Ej));
      Map<SNode, Fraction> rightSpec = UnitConversionUtil.getUnitMap_UnitSpecification(SLinkOperations.getTarget(SNodeOperations.cast(rightOperandType, CONCEPTS.AnnotatedType$I9), LINKS.specification$Q3Ej));

      SNode leftPrimitiveType = SLinkOperations.getTarget(SNodeOperations.cast(leftOperandType, CONCEPTS.AnnotatedType$I9), LINKS.valueType$2o7e);
      SNode rightPrimitiveType = SLinkOperations.getTarget(SNodeOperations.cast(rightOperandType, CONCEPTS.AnnotatedType$I9), LINKS.valueType$2o7e);
      SNode operationPrimitiveType = TypeChecker.getInstance().getRulesManager().getOperationType(operation, leftPrimitiveType, rightPrimitiveType);

      List<SNode> references = UnitConversionUtil.createUnitReferences(UnitConversionUtil.unify(leftSpec, (SNodeOperations.isInstanceOf(operation, CONCEPTS.MultiExpression$VN) ? rightSpec : UnitConversionUtil.negate(rightSpec))));

      return UnitConversionUtil.createAnnotatedType(operationPrimitiveType, references);
    }
    @Override
    public void reportConflict(IRuleConflictWarningProducer producer) {
      producer.produceWarning(myRuleModelId, myRuleNodeId);
    }
    private static SNode createAbstractAnnotatedType_3ist9o_a0a0a4() {
      SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.AbstractAnnotatedType$LZ);
      return n0.getResult();
    }
    private static SNode createAbstractAnnotatedType_3ist9o_a0b0a4() {
      SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.AbstractAnnotatedType$LZ);
      return n0.getResult();
    }
  }
  private static SNode createAbstractAnnotatedType_3ist9o_a0a0a0a0a0a0a04a0() {
    SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.AbstractAnnotatedType$LZ);
    return n0.getResult();
  }
  private static SNode createAbstractAnnotatedType_3ist9o_a0a0a0a0a0a1a04a0() {
    SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.AbstractAnnotatedType$LZ);
    return n0.getResult();
  }
  private static SNode createAbstractAnnotatedType_3ist9o_a0a0a0a0a0a2a04a0() {
    SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.AbstractAnnotatedType$LZ);
    return n0.getResult();
  }
  private static SNode createAbstractAnnotatedType_3ist9o_a0a0a0a0a0a3a04a0() {
    SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.AbstractAnnotatedType$LZ);
    return n0.getResult();
  }
  private static SNode createAbstractAnnotatedType_3ist9o_a0a0a0a0a0a0a14a0() {
    SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.AbstractAnnotatedType$LZ);
    return n0.getResult();
  }
  private static SNode createRuntimeErrorType_3ist9o_a0a0e0b0a0a0a0a14a0(String p0) {
    SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.RuntimeErrorType$3c);
    n0.setProperty(PROPS.errorText$leWQ, p0);
    return n0.getResult();
  }
  private static SNode createAbstractAnnotatedType_3ist9o_a0a0a0a0a0a1a14a0() {
    SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.AbstractAnnotatedType$LZ);
    return n0.getResult();
  }
  private static SNode createRuntimeErrorType_3ist9o_a0a0e0b0a0a0a1a14a0(String p0) {
    SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.RuntimeErrorType$3c);
    n0.setProperty(PROPS.errorText$leWQ, p0);
    return n0.getResult();
  }
  private static SNode createAbstractAnnotatedType_3ist9o_a0a0a0a0a0a2a14a0() {
    SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.AbstractAnnotatedType$LZ);
    return n0.getResult();
  }
  private static SNode createRuntimeErrorType_3ist9o_a0a0e0b0a0a0a2a14a0(String p0) {
    SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.RuntimeErrorType$3c);
    n0.setProperty(PROPS.errorText$leWQ, p0);
    return n0.getResult();
  }
  private static SNode createAbstractAnnotatedType_3ist9o_a0a0a0a0a0a3a14a0() {
    SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.AbstractAnnotatedType$LZ);
    return n0.getResult();
  }
  private static SNode createRuntimeErrorType_3ist9o_a0a0e0b0a0a0a3a14a0(String p0) {
    SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.RuntimeErrorType$3c);
    n0.setProperty(PROPS.errorText$leWQ, p0);
    return n0.getResult();
  }
  private static SNode createAbstractAnnotatedType_3ist9o_a0a0a0a0a0a4a14a0() {
    SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.AbstractAnnotatedType$LZ);
    return n0.getResult();
  }
  private static SNode createRuntimeErrorType_3ist9o_a0a0e0b0a0a0a4a14a0(String p0) {
    SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.RuntimeErrorType$3c);
    n0.setProperty(PROPS.errorText$leWQ, p0);
    return n0.getResult();
  }
  private static SNode createAbstractAnnotatedType_3ist9o_a0a0a0a0a0a5a14a0() {
    SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.AbstractAnnotatedType$LZ);
    return n0.getResult();
  }
  private static SNode createRuntimeErrorType_3ist9o_a0a0e0b0a0a0a5a14a0(String p0) {
    SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.RuntimeErrorType$3c);
    n0.setProperty(PROPS.errorText$leWQ, p0);
    return n0.getResult();
  }
  private static SNode createAbstractAnnotatedType_3ist9o_a0a0a0a0a0a6a14a0() {
    SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.AbstractAnnotatedType$LZ);
    return n0.getResult();
  }
  private static SNode createRuntimeErrorType_3ist9o_a0a0e0b0a0a0a6a14a0(String p0) {
    SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.RuntimeErrorType$3c);
    n0.setProperty(PROPS.errorText$leWQ, p0);
    return n0.getResult();
  }
  private static SNode createAbstractAnnotatedType_3ist9o_a0a0a0a0a0a0a24a0() {
    SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.AbstractAnnotatedType$LZ);
    return n0.getResult();
  }
  private static SNode createAbstractAnnotatedType_3ist9o_a0a0a0a0a0a1a24a0() {
    SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.AbstractAnnotatedType$LZ);
    return n0.getResult();
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept BitwiseLeftShiftExpression$Kh = MetaAdapterFactory.getConcept(0x61c69711ed614850L, 0x81d97714ff227fb0L, 0x7d15ed3ba56cbdbfL, "com.mbeddr.core.expressions.structure.BitwiseLeftShiftExpression");
    /*package*/ static final SConcept BitwiseRightShiftExpression$hf = MetaAdapterFactory.getConcept(0x61c69711ed614850L, 0x81d97714ff227fb0L, 0x7d15ed3ba569dd50L, "com.mbeddr.core.expressions.structure.BitwiseRightShiftExpression");
    /*package*/ static final SConcept DirectAssignmentExpression$Q8 = MetaAdapterFactory.getConcept(0x61c69711ed614850L, 0x81d97714ff227fb0L, 0x350656a10cd18bcaL, "com.mbeddr.core.expressions.structure.DirectAssignmentExpression");
    /*package*/ static final SConcept ModuloExpression$ia = MetaAdapterFactory.getConcept(0x61c69711ed614850L, 0x81d97714ff227fb0L, 0x26d9c9de7721b2b0L, "com.mbeddr.core.expressions.structure.ModuloExpression");
    /*package*/ static final SConcept BitwiseAndExpression$HN = MetaAdapterFactory.getConcept(0x61c69711ed614850L, 0x81d97714ff227fb0L, 0x52bff1066a5caaafL, "com.mbeddr.core.expressions.structure.BitwiseAndExpression");
    /*package*/ static final SConcept BitwiseORExpression$vE = MetaAdapterFactory.getConcept(0x61c69711ed614850L, 0x81d97714ff227fb0L, 0xfc5c413252eabc7L, "com.mbeddr.core.expressions.structure.BitwiseORExpression");
    /*package*/ static final SConcept BitwiseXORExpression$ht = MetaAdapterFactory.getConcept(0x61c69711ed614850L, 0x81d97714ff227fb0L, 0x7d15ed3ba56988f4L, "com.mbeddr.core.expressions.structure.BitwiseXORExpression");
    /*package*/ static final SConcept DirectMinusAssignmentExpression$Wu = MetaAdapterFactory.getConcept(0x61c69711ed614850L, 0x81d97714ff227fb0L, 0x3b4cdae3e316735aL, "com.mbeddr.core.expressions.structure.DirectMinusAssignmentExpression");
    /*package*/ static final SConcept DirectPlusAssignmentExpression$1h = MetaAdapterFactory.getConcept(0x61c69711ed614850L, 0x81d97714ff227fb0L, 0x350656a10cd18bccL, "com.mbeddr.core.expressions.structure.DirectPlusAssignmentExpression");
    /*package*/ static final SConcept MinusExpression$KE = MetaAdapterFactory.getConcept(0x61c69711ed614850L, 0x81d97714ff227fb0L, 0x4ffba68fe82b621aL, "com.mbeddr.core.expressions.structure.MinusExpression");
    /*package*/ static final SConcept PlusExpression$If = MetaAdapterFactory.getConcept(0x61c69711ed614850L, 0x81d97714ff227fb0L, 0x4ffba68fe82b6215L, "com.mbeddr.core.expressions.structure.PlusExpression");
    /*package*/ static final SConcept DivExpression$WL = MetaAdapterFactory.getConcept(0x61c69711ed614850L, 0x81d97714ff227fb0L, 0x4ffba68fe82b621eL, "com.mbeddr.core.expressions.structure.DivExpression");
    /*package*/ static final SConcept MultiExpression$VN = MetaAdapterFactory.getConcept(0x61c69711ed614850L, 0x81d97714ff227fb0L, 0x4ffba68fe82b621cL, "com.mbeddr.core.expressions.structure.MultiExpression");
    /*package*/ static final SConcept AnnotatedType$I9 = MetaAdapterFactory.getConcept(0xd04a6cc773e4069L, 0xb9b011884b2ff1c8L, 0x73b48a125b0f3f14L, "com.mbeddr.ext.units.structure.AnnotatedType");
    /*package*/ static final SConcept AbstractAnnotatedType$LZ = MetaAdapterFactory.getConcept(0xd04a6cc773e4069L, 0xb9b011884b2ff1c8L, 0x73b48a125b28a061L, "com.mbeddr.ext.units.structure.AbstractAnnotatedType");
    /*package*/ static final SConcept RuntimeErrorType$3c = MetaAdapterFactory.getConcept(0x7a5dda6291404668L, 0xab76d5ed1746f2b2L, 0x113f84956f9L, "jetbrains.mps.lang.typesystem.structure.RuntimeErrorType");
  }

  private static final class LINKS {
    /*package*/ static final SContainmentLink valueType$2o7e = MetaAdapterFactory.getContainmentLink(0x61c69711ed614850L, 0x81d97714ff227fb0L, 0xa526fcd7806eb53L, 0x65d0a4755f54174cL, "valueType");
    /*package*/ static final SContainmentLink specification$Q3Ej = MetaAdapterFactory.getContainmentLink(0xd04a6cc773e4069L, 0xb9b011884b2ff1c8L, 0x73b48a125b0f3f14L, 0x73b48a125b0f3f48L, "specification");
  }

  private static final class PROPS {
    /*package*/ static final SProperty errorText$leWQ = MetaAdapterFactory.getProperty(0x7a5dda6291404668L, 0xab76d5ed1746f2b2L, 0x113f84956f9L, 0x113f84956faL, "errorText");
  }
}
