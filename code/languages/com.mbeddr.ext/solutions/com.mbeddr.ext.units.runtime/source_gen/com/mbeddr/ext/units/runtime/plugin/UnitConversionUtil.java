package com.mbeddr.ext.units.runtime.plugin;

/*Generated by MPS */

import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.Map;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.Collections;
import java.util.HashMap;
import java.util.Queue;
import jetbrains.mps.internal.collections.runtime.QueueSequence;
import java.util.LinkedList;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple;
import java.util.List;
import com.mbeddr.ext.units.behavior.Exponent__BehaviorDescriptor;
import java.util.ArrayList;
import jetbrains.mps.internal.collections.runtime.IMapping;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.smodel.builder.SNodeBuilder;
import org.jetbrains.mps.openapi.language.SConcept;
import org.jetbrains.mps.openapi.language.SInterfaceConcept;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import org.jetbrains.mps.openapi.language.SReferenceLink;
import org.jetbrains.mps.openapi.language.SProperty;

public class UnitConversionUtil {

  public static boolean isAtomicUnit(SNode unit) {
    if (SNodeOperations.isInstanceOf(unit, CONCEPTS.MetaUnit$gm)) {
      return true;
    } else {
      return SLinkOperations.getChildren(SLinkOperations.getTarget(SNodeOperations.cast(unit, CONCEPTS.Unit$Yt), LINKS.spec$HWtV), LINKS.components$PbgL) == null || ListSequence.fromList(SLinkOperations.getChildren(SLinkOperations.getTarget(SNodeOperations.cast(unit, CONCEPTS.Unit$Yt), LINKS.spec$HWtV), LINKS.components$PbgL)).isEmpty();
    }
  }

  public static boolean isIntegerType(SNode type) {
    SNode innerType = getInnerType(type);
    if (SNodeOperations.isInstanceOf(innerType, CONCEPTS.MeetType$ZG)) {
      return ListSequence.fromList(SLinkOperations.getChildren(SNodeOperations.cast(innerType, CONCEPTS.MeetType$ZG), LINKS.argument$r2cT)).any((it) -> isIntegerType(it));
    } else {
      return SNodeOperations.isInstanceOf(innerType, CONCEPTS.PrimitiveBasicIntegralType$$2) || SNodeOperations.isInstanceOf(innerType, CONCEPTS.PrimitiveC99IntegralType$E_);
    }
  }

  public static SNode getInnerType(SNode type) {
    if (SNodeOperations.isInstanceOf(type, CONCEPTS.AnnotatedType$I9)) {
      return SNodeOperations.copyNode(SLinkOperations.getTarget(SNodeOperations.cast(type, CONCEPTS.AnnotatedType$I9), LINKS.valueType$2o7e));
    } else {
      return SNodeOperations.copyNode(type);
    }
  }

  /**
   * Returns true if the given map represents a unitless mapping, 
   * meaning the map is empty or null. 
   * 
   * @param unitMap the unit mapping
   * @return true if the mapping represents a unitless mapping, false otherwise
   */
  public static boolean isUnitLessType(Map<SNode, Fraction> unitMap) {
    if (unitMap == null || MapSequence.fromMap(unitMap).isEmpty()) {
      return true;
    } else {
      return false;
    }
  }

  /**
   * Returns true of the given type is a unitless type. 
   * 
   * @param type the type
   * @return true if the type has no unit annotation, false otherwise
   */
  public static boolean isUnitLessType(SNode type) {
    if (SNodeOperations.isInstanceOf(type, CONCEPTS.AnnotatedType$I9)) {
      Map<SNode, Fraction> spec = getUnitMap_UnitSpecification(SLinkOperations.getTarget(SNodeOperations.cast(type, CONCEPTS.AnnotatedType$I9), LINKS.specification$Q3Ej));
      return MapSequence.fromMap(spec).isEmpty();
    } else {
      return true;
    }
  }

  /**
   * Returns the unit mapping for the given type. 
   * If the given type is not an annotated type then an empty map will be returned. 
   * 
   * @param type the type
   * @return the unit mapping
   */
  public static Map<SNode, Fraction> getUnitMap_Type(SNode type) {
    if (SNodeOperations.isInstanceOf(type, CONCEPTS.AnnotatedType$I9)) {
      return getUnitMap_UnitSpecification(SLinkOperations.getTarget(SNodeOperations.cast(type, CONCEPTS.AnnotatedType$I9), LINKS.specification$Q3Ej));
    } else {
      return Collections.emptyMap();
    }
  }

  /**
   * Generates the unit mapping from the given unit specification and inferred attributes. 
   * If a given meta unit cannot be found among the inferred ones, then it will simply be omitted. 
   * Composite units are always broken down to atomic units. 
   * 
   * This method returns a new unit mapping. 
   */
  public static Map<SNode, Fraction> getUnitMap_UnitSpecification(SNode specification, SNode attribute) {
    Map<SNode, Fraction> unitMap = MapSequence.fromMap(new HashMap<SNode, Fraction>());

    for (SNode component : ListSequence.fromList(SLinkOperations.getChildren(specification, LINKS.components$PbgL))) {
      Map<SNode, Fraction> componentUnitMap = null;
      if (attribute != null && SNodeOperations.isInstanceOf(SLinkOperations.getTarget(component, LINKS.unit$ZXwJ), CONCEPTS.MetaUnit$gm)) {
        SNode substitution = null;

        for (SNode s : ListSequence.fromList(SLinkOperations.getChildren(attribute, LINKS.substitutions$69eS))) {
          if (SLinkOperations.getTarget(s, LINKS.metaUnit$5OO2).equals(SLinkOperations.getTarget(component, LINKS.unit$ZXwJ))) {
            substitution = s;
            break;
          }
        }

        // this check guarantees that the meta units that are not present in the substitutions
        // will simply not be used for the unit map computation
        if (substitution != null) {
          componentUnitMap = multiply(getUnitMap_UnitSpecification(SLinkOperations.getTarget(substitution, LINKS.realUnit$5NRY)), getExponent(component));
        }
      } else {
        componentUnitMap = getUnitMap_UnitReference(component, getExponent(component));
      }

      if (componentUnitMap != null) {
        unitMap = unify(unitMap, componentUnitMap);
      }
    }

    return unitMap;
  }

  public static boolean isSelfReferencingUnit(SNode unit) {
    final Queue<SNode> queue = QueueSequence.fromQueue(new LinkedList<SNode>());
    ListSequence.fromList(SLinkOperations.getChildren(SLinkOperations.getTarget(unit, LINKS.spec$HWtV), LINKS.components$PbgL)).visitAll((it) -> QueueSequence.fromQueue(queue).addLastElement(SLinkOperations.getTarget(it, LINKS.unit$ZXwJ)));

    // it is better to collect all the seen units instead of checking at the place of addition
    // whether the unit is the same as the to-be-added one, because
    // there may be a circular dependency between other units and then we will end up in an infinite loop
    // nevertheless we can apply early-exit when we have found the match
    Set<SNode> seenUnits = SetSequence.fromSet(new HashSet<SNode>());

    while (QueueSequence.fromQueue(queue).isNotEmpty()) {
      SNode head = QueueSequence.fromQueue(queue).removeFirstElement();
      if (head == unit) {
        return true;
      }
      SetSequence.fromSet(seenUnits).addElement(head);

      if (SNodeOperations.isInstanceOf(head, CONCEPTS.Unit$Yt) && SLinkOperations.getChildren(SLinkOperations.getTarget(SNodeOperations.cast(head, CONCEPTS.Unit$Yt), LINKS.spec$HWtV), LINKS.components$PbgL) != null) {
        for (SNode component : ListSequence.fromList(SLinkOperations.getChildren(SLinkOperations.getTarget(SNodeOperations.cast(head, CONCEPTS.Unit$Yt), LINKS.spec$HWtV), LINKS.components$PbgL))) {
          // this check is needed to handle circular unit specifications
          if (!(SetSequence.fromSet(seenUnits).contains(SLinkOperations.getTarget(component, LINKS.unit$ZXwJ))) || isAtomicUnit(SLinkOperations.getTarget(component, LINKS.unit$ZXwJ))) {
            QueueSequence.fromQueue(queue).addLastElement(SLinkOperations.getTarget(component, LINKS.unit$ZXwJ));
          }
        }
      }
    }

    return SetSequence.fromSet(seenUnits).contains(unit);
  }

  /**
   * Generates the unit mapping from the given unit specification, no meta unit resolving is applied. 
   * Composite units are always broken down to atomic units. 
   * 
   * This method returns a new unit mapping. 
   */
  public static Map<SNode, Fraction> getUnitMap_UnitSpecification(SNode specification) {
    Map<SNode, Fraction> result = MapSequence.fromMap(new HashMap<SNode, Fraction>());
    for (SNode reference : ListSequence.fromList(SLinkOperations.getChildren(specification, LINKS.components$PbgL))) {
      result = unify(result, getUnitMap_UnitReference(reference, getExponent(reference)));
    }
    return result;
  }

  /**
   * Generates the unit mapping from the given unit reference and multiplies all the exponents with the given one. 
   * Composite units are always broken down to atomic units. 
   * 
   * This method returns a new unit mapping. 
   */
  public static Map<SNode, Fraction> getUnitMap_UnitReference(SNode reference, Fraction exponent) {
    Map<SNode, Fraction> result = MapSequence.fromMap(new HashMap<SNode, Fraction>());
    Set<SNode> seenUnits = SetSequence.fromSet(new HashSet<SNode>());

    Queue<Tuples._2<SNode, Fraction>> queue = QueueSequence.fromQueue(new LinkedList<Tuples._2<SNode, Fraction>>());
    QueueSequence.fromQueue(queue).addLastElement(MultiTuple.<SNode,Fraction>from(reference, exponent));

    while (QueueSequence.fromQueue(queue).isNotEmpty()) {
      Tuples._2<SNode, Fraction> headPair = QueueSequence.fromQueue(queue).removeFirstElement();
      SNode headReference = headPair._0();
      Fraction headExponent = headPair._1();
      SetSequence.fromSet(seenUnits).addElement(SLinkOperations.getTarget(headReference, LINKS.unit$ZXwJ));

      if (SNodeOperations.isInstanceOf(SLinkOperations.getTarget(headReference, LINKS.unit$ZXwJ), CONCEPTS.MetaUnit$gm)) {
        result = unify_inplace(result, SLinkOperations.getTarget(headReference, LINKS.unit$ZXwJ), headExponent);
      } else {
        List<SNode> components = SLinkOperations.getChildren(SLinkOperations.getTarget(SNodeOperations.cast(SLinkOperations.getTarget(headReference, LINKS.unit$ZXwJ), CONCEPTS.Unit$Yt), LINKS.spec$HWtV), LINKS.components$PbgL);
        if (components == null || ListSequence.fromList(components).isEmpty()) {
          result = unify_inplace(result, SLinkOperations.getTarget(headReference, LINKS.unit$ZXwJ), headExponent);
        } else {
          for (SNode component : ListSequence.fromList(components)) {
            QueueSequence.fromQueue(queue).addLastElement(MultiTuple.<SNode,Fraction>from(component, getExponent(component).multiply(headExponent)));
          }
        }
      }
    }

    return result;
  }

  /**
   * Generates the unit mapping from the given unit and multiplies all the exponents with the given one. 
   * Composite units are always broken down to atomic units. 
   * 
   * This method returns a new unit mapping. 
   */
  public static Map<SNode, Fraction> getUnitMap_IUnit(SNode unit, Fraction exponent) {
    Map<SNode, Fraction> result = MapSequence.fromMap(new HashMap<SNode, Fraction>());
    if (SNodeOperations.isInstanceOf(unit, CONCEPTS.MetaUnit$gm)) {
      MapSequence.fromMap(result).put(unit, exponent);
    } else {
      List<SNode> components = SLinkOperations.getChildren(SLinkOperations.getTarget(SNodeOperations.cast(unit, CONCEPTS.Unit$Yt), LINKS.spec$HWtV), LINKS.components$PbgL);
      if (components == null || ListSequence.fromList(components).isEmpty()) {
        MapSequence.fromMap(result).put(unit, exponent);
      } else {
        for (SNode component : ListSequence.fromList(components)) {
          result = unify(result, getUnitMap_UnitReference(component, getExponent(component).multiply(exponent)));
        }
      }
    }
    return result;
  }

  public static Map<SNode, Fraction> getUnitMap_IUnit(SNode unit, int exponent) {
    return getUnitMap_IUnit(unit, new Fraction(exponent));
  }


  public static Fraction getExponent(SNode reference) {
    if (SLinkOperations.getTarget(reference, LINKS.exponent$ZXYL) == null) {
      return new Fraction(1);
    } else {
      return new Fraction((int) Exponent__BehaviorDescriptor.getNumerator_id3j3yk3guAC3.invoke(SLinkOperations.getTarget(reference, LINKS.exponent$ZXYL)), (int) Exponent__BehaviorDescriptor.getDenumerator_id3j3yk3guABz.invoke(SLinkOperations.getTarget(reference, LINKS.exponent$ZXYL)));
    }
  }

  /**
   * Divides all of the exponents in the unit mapping with the given value if it is possible.
   * As fractions are used in their minimal form this can only be possible if two fractions 
   * have the exact same denumerator and the modulo check should be performed with their numerators. 
   * 
   * This method returns a new unit mapping. 
   */
  public static Map<SNode, Fraction> rootBy(Map<SNode, Fraction> unitMap, SNode root) {
    Map<SNode, Fraction> result = MapSequence.fromMap(new HashMap<SNode, Fraction>());
    Fraction rootFraction = new Fraction((int) Exponent__BehaviorDescriptor.getNumerator_id3j3yk3guAC3.invoke(root), (int) Exponent__BehaviorDescriptor.getDenumerator_id3j3yk3guABz.invoke(root));

    for (SNode key : SetSequence.fromSet(MapSequence.fromMap(unitMap).keySet())) {
      MapSequence.fromMap(result).put(key, MapSequence.fromMap(unitMap).get(key).divide(rootFraction));
    }

    return result;
  }

  /**
   * Reduces the given unit mapping with an other unit mapping. This means that all of the exponents will be 
   * substracted in the unit mapping with the corresponding exponent from the other mapping. If a unit is 
   * not present in the original mapping, then the inverse exponent of the other mapping's unit will be inserted. 
   * Units with zero exponents are eliminated from the resuling unit mapping. 
   * 
   * This method returns a new unit mapping. 
   */
  public static Map<SNode, Fraction> reduceBy(Map<SNode, Fraction> unitMap, Map<SNode, Fraction> withWhom) {
    Map<SNode, Fraction> result = MapSequence.fromMap(new HashMap<SNode, Fraction>());
    MapSequence.fromMap(result).putAll(unitMap);

    for (SNode key : SetSequence.fromSet(MapSequence.fromMap(withWhom).keySet())) {
      if (MapSequence.fromMap(result).containsKey(key)) {
        // rule out zero exponents
        if (MapSequence.fromMap(result).get(key).equals(MapSequence.fromMap(withWhom).get(key))) {
          MapSequence.fromMap(result).removeKey(key);
        } else {
          MapSequence.fromMap(result).put(key, MapSequence.fromMap(result).get(key).subtract(MapSequence.fromMap(withWhom).get(key)));
        }
      } else if (MapSequence.fromMap(withWhom).get(key).isNonZero()) {
        MapSequence.fromMap(result).put(key, MapSequence.fromMap(withWhom).get(key).multiply(-1));
      }
    }

    return result;
  }

  /**
   * Unifies the given unit mapping with an other unit mapping. This means that all of the exponents will be 
   * summed in the unit mapping with the corresponding exponent from the other mapping. If a unit is not 
   * present in the original mapping, then the exponent of the other mapping's unit will be inserted. 
   * Units with zero exponents are eliminated from the resuling unit mapping. 
   * 
   * This method returns a new unit mapping. 
   */
  public static Map<SNode, Fraction> unify(Map<SNode, Fraction> m1, Map<SNode, Fraction> m2) {
    Map<SNode, Fraction> res = MapSequence.fromMap(new HashMap<SNode, Fraction>());
    MapSequence.fromMap(res).putAll(m1);
    for (SNode key : SetSequence.fromSet(MapSequence.fromMap(m2).keySet())) {
      res = unify_inplace(res, key, MapSequence.fromMap(m2).get(key));
    }
    return res;
  }

  private static Map<SNode, Fraction> unify_inplace(Map<SNode, Fraction> mapping, SNode key, Fraction exponent) {
    if (MapSequence.fromMap(mapping).containsKey(key)) {
      // rule out zero exponents
      if (MapSequence.fromMap(mapping).get(key).equals(exponent.multiply(-1))) {
        MapSequence.fromMap(mapping).removeKey(key);
      } else {
        MapSequence.fromMap(mapping).put(key, MapSequence.fromMap(mapping).get(key).add(exponent));
      }
    } else if (exponent.isNonZero()) {
      MapSequence.fromMap(mapping).put(key, exponent);
    }
    return mapping;
  }

  /**
   * It is expected that the passed map is already broken down to atomic units. 
   */
  public static List<SNode> createUnitReferences(Map<SNode, Fraction> unitMap) {
    List<SNode> references = ListSequence.fromList(new ArrayList<SNode>());
    for (IMapping<SNode, Fraction> entry : MapSequence.fromMap(unitMap)) {
      ListSequence.fromList(references).addElement(createUnitReference(entry.key(), entry.value()));
    }
    return references;
  }

  public static SNode createUnitReference(SNode unit, Fraction exp) {
    SNode reference = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0xd04a6cc773e4069L, 0xb9b011884b2ff1c8L, 0x73b48a125b0d4dc5L, "com.mbeddr.ext.units.structure.UnitReference"));
    SLinkOperations.setTarget(reference, LINKS.unit$ZXwJ, unit);

    // only insert the exponent if it does not equal to 1
    if (!(exp.equals(Fraction.ONE))) {
      if (exp.denumerator == 1) {
        SLinkOperations.setTarget(reference, LINKS.exponent$ZXYL, createIntegerExponent_5ohk72_a0a0a0e0mb(exp.numerator));
      } else {
        SLinkOperations.setTarget(reference, LINKS.exponent$ZXYL, createFractionalExponent_5ohk72_a0a0a0a4a83("" + exp.numerator, "" + exp.denumerator));
      }
    }
    return reference;
  }

  /**
   * Flips all the exponents to the reciprocal with modifying the given unit mapping in place. 
   */
  public static Map<SNode, Fraction> negate(Map<SNode, Fraction> unitMap) {
    for (SNode key : SetSequence.fromSet(MapSequence.fromMap(unitMap).keySet())) {
      MapSequence.fromMap(unitMap).put(key, MapSequence.fromMap(unitMap).get(key).multiply(-1));
    }
    return unitMap;
  }

  /**
   * This method modifies the original unit mapping. 
   */
  public static Map<SNode, Fraction> multiply(Map<SNode, Fraction> unitMap, Fraction m) {
    for (SNode key : SetSequence.fromSet(MapSequence.fromMap(unitMap).keySet())) {
      MapSequence.fromMap(unitMap).put(key, MapSequence.fromMap(unitMap).get(key).multiply(m));
    }
    return unitMap;
  }

  /**
   * Checks wether two unit mappings can be possibly matched / exactly matched. 
   * 
   * In case of exact match check the unit mappings must be entirely the same.
   * In case of possible match check:
   * (1) if either one of them (or both) contains 2 or more meta units -> false
   * (2) if both of them contain exactly 1 meta unit then they can be matched if these meta units are not the same ones
   * (3) if either one of them contains a meta unit (but not both) then the exponents must be checked. In this case
   * there must not be any other unit in the mapping which contains the meta unit. 
   * (4) if they do not contain meta units then the unit mappings must be exactly the same
   */
  public static boolean matchingUnits(Map<SNode, Fraction> leftUnitMap, Map<SNode, Fraction> rightUnitMap, boolean exactMatchCheck) {
    if (leftUnitMap == null && rightUnitMap == null) {
      return true;
    }

    // remove units with zero exponents
    Map<UnitWrapper, Fraction> leftNonMatched = MapSequence.fromMap(new HashMap<UnitWrapper, Fraction>());
    Set<UnitWrapper> keys = SetSequence.fromSet(new HashSet<UnitWrapper>());

    for (SNode key : SetSequence.fromSet(MapSequence.fromMap(leftUnitMap).keySet())) {
      if (MapSequence.fromMap(leftUnitMap).get(key).isNonZero()) {
        UnitWrapper wrapper = new UnitWrapper(key);
        MapSequence.fromMap(leftNonMatched).put(wrapper, MapSequence.fromMap(leftUnitMap).get(key));
        SetSequence.fromSet(keys).addElement(wrapper);
      }
    }

    Map<UnitWrapper, Fraction> rightNonMatched = MapSequence.fromMap(new HashMap<UnitWrapper, Fraction>());
    for (SNode key : SetSequence.fromSet(MapSequence.fromMap(rightUnitMap).keySet())) {
      if (MapSequence.fromMap(rightUnitMap).get(key).isNonZero()) {
        MapSequence.fromMap(rightNonMatched).put(new UnitWrapper(key), MapSequence.fromMap(rightUnitMap).get(key));
      }
    }

    for (UnitWrapper key : SetSequence.fromSet(keys)) {
      if (MapSequence.fromMap(leftNonMatched).containsKey(key) && MapSequence.fromMap(rightNonMatched).containsKey(key)) {
        Fraction le = MapSequence.fromMap(leftNonMatched).get(key);
        Fraction re = MapSequence.fromMap(rightNonMatched).get(key);
        int c = le.compareTo(re);

        if (c == 0) {
          MapSequence.fromMap(leftNonMatched).removeKey(key);
          MapSequence.fromMap(rightNonMatched).removeKey(key);
        } else if (c < 0) {
          MapSequence.fromMap(leftNonMatched).removeKey(key);
          MapSequence.fromMap(rightNonMatched).put(key, re.subtract(le));
        } else {
          MapSequence.fromMap(rightNonMatched).removeKey(key);
          MapSequence.fromMap(leftNonMatched).put(key, le.subtract(re));
        }
      }
    }

    if (exactMatchCheck) {
      return MapSequence.fromMap(leftNonMatched).isEmpty() && MapSequence.fromMap(rightNonMatched).isEmpty();
    } else {
      Iterable<UnitWrapper> leftMetas = SetSequence.fromSet(MapSequence.fromMap(leftNonMatched).keySet()).where((it) -> SNodeOperations.isInstanceOf(it.unit, CONCEPTS.MetaUnit$gm));
      Iterable<UnitWrapper> rightMetas = SetSequence.fromSet(MapSequence.fromMap(rightNonMatched).keySet()).where((it) -> SNodeOperations.isInstanceOf(it.unit, CONCEPTS.MetaUnit$gm));

      // Case 1
      if (Sequence.fromIterable(leftMetas).count() > 1 || Sequence.fromIterable(rightMetas).count() > 1) {
        return false;
      }

      UnitWrapper leftMeta = Sequence.fromIterable(leftMetas).first();
      UnitWrapper rightMeta = Sequence.fromIterable(rightMetas).first();

      if (leftMeta != null && rightMeta != null) {
        // Case 2
        return true;
      } else if (leftMeta != null && MapSequence.fromMap(leftNonMatched).count() == 1 && MapSequence.fromMap(rightNonMatched).isNotEmpty()) {
        // Case 3
        return true;
      } else if (rightMeta != null && MapSequence.fromMap(rightNonMatched).count() == 1 && MapSequence.fromMap(leftNonMatched).isNotEmpty()) {
        // Case 3
        return true;
      } else {
        // Case 4
        return MapSequence.fromMap(leftNonMatched).isEmpty() && MapSequence.fromMap(rightNonMatched).isEmpty();
      }
    }
  }

  public static SNode createAnnotatedType(SNode operationType, SNode specification) {
    if (operationType == null) {
      return createRuntimeErrorType_5ohk72_a0a0a64();
    } else if (ListSequence.fromList(SLinkOperations.getChildren(specification, LINKS.components$PbgL)).isEmpty()) {
      return SNodeOperations.copyNode(operationType);
    } else {
      return createAnnotatedType_5ohk72_a0a0a0ub(SNodeOperations.cast(SNodeOperations.copyNode(operationType), CONCEPTS.IType$a9), SNodeOperations.copyNode(specification));
    }
  }

  public static SNode createAnnotatedType(SNode operationType, List<SNode> references) {
    if (operationType == null) {
      return createRuntimeErrorType_5ohk72_a0a0a84();
    } else if (ListSequence.fromList(references).isEmpty()) {
      return SNodeOperations.copyNode(operationType);
    } else {
      return createAnnotatedType_5ohk72_a0a0a0wb(SNodeOperations.cast(SNodeOperations.copyNode(operationType), CONCEPTS.IType$a9), references);
    }
  }
  private static SNode createIntegerExponent_5ohk72_a0a0a0e0mb(int p0) {
    SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.IntegerExponent$s5);
    n0.setProperty(PROPS.value$rYsn, "" + (p0));
    return n0.getResult();
  }
  private static SNode createFractionalExponent_5ohk72_a0a0a0a4a83(String p0, String p1) {
    SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.FractionalExponent$7);
    {
      SNodeBuilder n1 = n0.forChild(LINKS.fraction$rjOT).init(CONCEPTS.FractionExpression$bq);
      {
        SNodeBuilder n2 = n1.forChild(LINKS.left$RMpx).init(CONCEPTS.NumberLiteral$jK);
        n2.setProperty(PROPS.value$qZmE, p0);
      }
      {
        SNodeBuilder n3 = n1.forChild(LINKS.right$UBZB).init(CONCEPTS.NumberLiteral$jK);
        n3.setProperty(PROPS.value$qZmE, p1);
      }
    }
    return n0.getResult();
  }
  private static SNode createRuntimeErrorType_5ohk72_a0a0a64() {
    SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.RuntimeErrorType$3c);
    n0.setProperty(PROPS.errorText$leWQ, "Operation is not defined!");
    return n0.getResult();
  }
  private static SNode createAnnotatedType_5ohk72_a0a0a0ub(SNode p0, SNode p1) {
    SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.AnnotatedType$I9);
    n0.forChild(LINKS.valueType$2o7e).initNode(p0, CONCEPTS.IType$a9, true);
    n0.forChild(LINKS.specification$Q3Ej).initNode(p1, CONCEPTS.UnitSpecification$om, true);
    return n0.getResult();
  }
  private static SNode createRuntimeErrorType_5ohk72_a0a0a84() {
    SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.RuntimeErrorType$3c);
    n0.setProperty(PROPS.errorText$leWQ, "Operation is not defined!");
    return n0.getResult();
  }
  private static SNode createAnnotatedType_5ohk72_a0a0a0wb(SNode p0, Iterable<? extends SNode> p1) {
    SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.AnnotatedType$I9);
    n0.forChild(LINKS.valueType$2o7e).initNode(p0, CONCEPTS.IType$a9, true);
    {
      SNodeBuilder n1 = n0.forChild(LINKS.specification$Q3Ej).init(CONCEPTS.UnitSpecification$om);
      n1.forChild(LINKS.components$PbgL).initNodeList(p1, CONCEPTS.UnitReference$hr);
    }
    return n0.getResult();
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept MetaUnit$gm = MetaAdapterFactory.getConcept(0xd04a6cc773e4069L, 0xb9b011884b2ff1c8L, 0x73b48a125b28a2ddL, "com.mbeddr.ext.units.structure.MetaUnit");
    /*package*/ static final SConcept Unit$Yt = MetaAdapterFactory.getConcept(0xd04a6cc773e4069L, 0xb9b011884b2ff1c8L, 0x73b48a125b0d373fL, "com.mbeddr.ext.units.structure.Unit");
    /*package*/ static final SConcept MeetType$ZG = MetaAdapterFactory.getConcept(0x7a5dda6291404668L, 0xab76d5ed1746f2b2L, 0x114b68ad132L, "jetbrains.mps.lang.typesystem.structure.MeetType");
    /*package*/ static final SConcept PrimitiveC99IntegralType$E_ = MetaAdapterFactory.getConcept(0x61c69711ed614850L, 0x81d97714ff227fb0L, 0x75739ed9f39c4635L, "com.mbeddr.core.expressions.structure.PrimitiveC99IntegralType");
    /*package*/ static final SConcept PrimitiveBasicIntegralType$$2 = MetaAdapterFactory.getConcept(0x61c69711ed614850L, 0x81d97714ff227fb0L, 0x4d4a3140e3e01fdaL, "com.mbeddr.core.expressions.structure.PrimitiveBasicIntegralType");
    /*package*/ static final SConcept AnnotatedType$I9 = MetaAdapterFactory.getConcept(0xd04a6cc773e4069L, 0xb9b011884b2ff1c8L, 0x73b48a125b0f3f14L, "com.mbeddr.ext.units.structure.AnnotatedType");
    /*package*/ static final SInterfaceConcept IType$a9 = MetaAdapterFactory.getInterfaceConcept(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x11f8a0774f2L, "jetbrains.mps.lang.core.structure.IType");
    /*package*/ static final SConcept IntegerExponent$s5 = MetaAdapterFactory.getConcept(0xd04a6cc773e4069L, 0xb9b011884b2ff1c8L, 0x73b48a125b0d4dc6L, "com.mbeddr.ext.units.structure.IntegerExponent");
    /*package*/ static final SConcept FractionalExponent$7 = MetaAdapterFactory.getConcept(0xd04a6cc773e4069L, 0xb9b011884b2ff1c8L, 0x34c38940d09904b9L, "com.mbeddr.ext.units.structure.FractionalExponent");
    /*package*/ static final SConcept FractionExpression$bq = MetaAdapterFactory.getConcept(0xb574d547b77e4fedL, 0x9f60c349c4410765L, 0x46c15b39e580b7bfL, "com.mbeddr.ext.math.structure.FractionExpression");
    /*package*/ static final SConcept NumberLiteral$jK = MetaAdapterFactory.getConcept(0x61c69711ed614850L, 0x81d97714ff227fb0L, 0x7af69e2e83a1ba67L, "com.mbeddr.core.expressions.structure.NumberLiteral");
    /*package*/ static final SConcept RuntimeErrorType$3c = MetaAdapterFactory.getConcept(0x7a5dda6291404668L, 0xab76d5ed1746f2b2L, 0x113f84956f9L, "jetbrains.mps.lang.typesystem.structure.RuntimeErrorType");
    /*package*/ static final SConcept UnitSpecification$om = MetaAdapterFactory.getConcept(0xd04a6cc773e4069L, 0xb9b011884b2ff1c8L, 0x73b48a125b0d411dL, "com.mbeddr.ext.units.structure.UnitSpecification");
    /*package*/ static final SConcept UnitReference$hr = MetaAdapterFactory.getConcept(0xd04a6cc773e4069L, 0xb9b011884b2ff1c8L, 0x73b48a125b0d4dc5L, "com.mbeddr.ext.units.structure.UnitReference");
  }

  private static final class LINKS {
    /*package*/ static final SContainmentLink spec$HWtV = MetaAdapterFactory.getContainmentLink(0xd04a6cc773e4069L, 0xb9b011884b2ff1c8L, 0x73b48a125b0d373fL, 0x73b48a125b0d411bL, "spec");
    /*package*/ static final SContainmentLink components$PbgL = MetaAdapterFactory.getContainmentLink(0xd04a6cc773e4069L, 0xb9b011884b2ff1c8L, 0x73b48a125b0d411dL, 0x73b48a125b0dab03L, "components");
    /*package*/ static final SContainmentLink argument$r2cT = MetaAdapterFactory.getContainmentLink(0x7a5dda6291404668L, 0xab76d5ed1746f2b2L, 0x114b68ad132L, 0x114b68b040bL, "argument");
    /*package*/ static final SContainmentLink valueType$2o7e = MetaAdapterFactory.getContainmentLink(0x61c69711ed614850L, 0x81d97714ff227fb0L, 0xa526fcd7806eb53L, 0x65d0a4755f54174cL, "valueType");
    /*package*/ static final SContainmentLink specification$Q3Ej = MetaAdapterFactory.getContainmentLink(0xd04a6cc773e4069L, 0xb9b011884b2ff1c8L, 0x73b48a125b0f3f14L, 0x73b48a125b0f3f48L, "specification");
    /*package*/ static final SReferenceLink metaUnit$5OO2 = MetaAdapterFactory.getReferenceLink(0xd04a6cc773e4069L, 0xb9b011884b2ff1c8L, 0x55aa7381f5dffb6L, 0x55aa7381f5dffd8L, "metaUnit");
    /*package*/ static final SReferenceLink unit$ZXwJ = MetaAdapterFactory.getReferenceLink(0xd04a6cc773e4069L, 0xb9b011884b2ff1c8L, 0x73b48a125b0d4dc5L, 0x73b48a125b0daafcL, "unit");
    /*package*/ static final SContainmentLink substitutions$69eS = MetaAdapterFactory.getContainmentLink(0xd04a6cc773e4069L, 0xb9b011884b2ff1c8L, 0x55aa7381f5dffdfL, 0x55aa7381f5dffecL, "substitutions");
    /*package*/ static final SContainmentLink realUnit$5NRY = MetaAdapterFactory.getContainmentLink(0xd04a6cc773e4069L, 0xb9b011884b2ff1c8L, 0x55aa7381f5dffb6L, 0x55aa7381f5dffd4L, "realUnit");
    /*package*/ static final SContainmentLink exponent$ZXYL = MetaAdapterFactory.getContainmentLink(0xd04a6cc773e4069L, 0xb9b011884b2ff1c8L, 0x73b48a125b0d4dc5L, 0x73b48a125b0daafeL, "exponent");
    /*package*/ static final SContainmentLink fraction$rjOT = MetaAdapterFactory.getContainmentLink(0xd04a6cc773e4069L, 0xb9b011884b2ff1c8L, 0x34c38940d09904b9L, 0x34c38940d09979deL, "fraction");
    /*package*/ static final SContainmentLink left$RMpx = MetaAdapterFactory.getContainmentLink(0xb574d547b77e4fedL, 0x9f60c349c4410765L, 0x46c15b39e580b7bfL, 0x46c15b39e583f740L, "left");
    /*package*/ static final SContainmentLink right$UBZB = MetaAdapterFactory.getContainmentLink(0xb574d547b77e4fedL, 0x9f60c349c4410765L, 0x46c15b39e580b7bfL, 0x46c15b39e583f767L, "right");
  }

  private static final class PROPS {
    /*package*/ static final SProperty value$rYsn = MetaAdapterFactory.getProperty(0xd04a6cc773e4069L, 0xb9b011884b2ff1c8L, 0x73b48a125b0d4dc6L, 0x73b48a125b0d4dc7L, "value");
    /*package*/ static final SProperty value$qZmE = MetaAdapterFactory.getProperty(0x61c69711ed614850L, 0x81d97714ff227fb0L, 0x1eb611a68febd3e5L, 0x1eb611a68fec38b0L, "value");
    /*package*/ static final SProperty errorText$leWQ = MetaAdapterFactory.getProperty(0x7a5dda6291404668L, 0xab76d5ed1746f2b2L, 0x113f84956f9L, 0x113f84956faL, "errorText");
  }
}
