package com.mbeddr.ext.units.runtime.plugin;

/*Generated by MPS */


public class Fraction implements Comparable<Fraction> {

  public int numerator;
  public int denumerator;

  public static final Fraction ZERO = new Fraction(0);
  public static final Fraction ONE = new Fraction(1);

  public Fraction(int numerator) {
    this(numerator, 1);
  }

  public Fraction(int numerator, int denumerator) {
    this.numerator = numerator;
    this.denumerator = denumerator;
  }

  public Fraction reciprocal() {
    return new Fraction(this.denumerator, this.numerator);
  }

  public boolean isNonZero() {
    return this.numerator != 0;
  }

  public boolean isPositive() {
    return (this.numerator >= 0 && this.denumerator > 0) || (this.numerator < 0 && this.denumerator < 0);
  }

  public boolean isNegative() {
    return !(isPositive());
  }

  public boolean isMultipleOf(Fraction that) {
    return (this.numerator * that.denumerator) % (this.denumerator * that.numerator) == 0;
  }

  @Override
  public String toString() {
    return "(" + this.numerator + "/" + this.denumerator + ")";
  }

  @Override
  public boolean equals(Object obj) {
    if (obj == this) {
      return true;
    } else if (obj == null || obj.getClass() != this.getClass()) {
      return false;
    } else {
      Fraction that = ((Fraction) obj);
      return this.numerator == that.numerator && this.denumerator == that.denumerator;
    }
  }

  @Override
  public int hashCode() {
    int hash = 1;
    hash = hash * 17 + numerator;
    hash = hash * 31 + denumerator;
    return hash;
  }

  private Fraction simplify() {
    int g = gcd(this.numerator, this.denumerator);
    return new Fraction(this.numerator / g, this.denumerator / g);
  }

  public Fraction multiply(int numerator) {
    return multiply(new Fraction(numerator));
  }

  public Fraction multiply(Fraction that) {
    return new Fraction(this.numerator * that.numerator, this.denumerator * that.denumerator).simplify();
  }

  public Fraction divide(Fraction that) {
    return this.multiply(that.reciprocal());
  }

  public Fraction add(Fraction that) {
    return new Fraction(this.numerator * that.denumerator + this.denumerator * that.numerator, this.denumerator * that.denumerator).simplify();
  }

  public Fraction subtract(Fraction that) {
    return new Fraction(this.numerator * that.denumerator - this.denumerator * that.numerator, this.denumerator * that.denumerator).simplify();
  }

  public int gcd(int a, int b) {
    if (b == 0) {
      return a;
    } else {
      return gcd(b, a % b);
    }
  }

  public int compareTo(Fraction that) {
    // a/b < c/d -> we want to decide whether ad < bc holds
    // however, need to pay attention that if b or d (or both of them) are negative then the operator flips

    int flip = 0;
    if (this.denumerator < 0) {
      flip += 1;
    }
    if (that.denumerator < 0) {
      flip += 1;
    }

    Integer o1 = this.numerator * that.denumerator;
    Integer o2 = this.denumerator * that.numerator;

    if (flip == 1) {
      // this is the case that the operator has flipped and it is >
      return o1.compareTo(o2) * -1;
    } else {
      return o1.compareTo(o2);
    }
  }

}
