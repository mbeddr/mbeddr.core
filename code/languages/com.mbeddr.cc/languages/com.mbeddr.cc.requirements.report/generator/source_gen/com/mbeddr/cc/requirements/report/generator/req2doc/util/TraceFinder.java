package com.mbeddr.cc.requirements.report.generator.req2doc.util;

/*Generated by MPS */

import org.jetbrains.mps.openapi.model.SNode;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import org.jetbrains.mps.openapi.module.SearchScope;
import jetbrains.mps.project.AbstractModule;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import org.jetbrains.mps.openapi.model.SReference;
import org.jetbrains.mps.openapi.module.FindUsagesFacade;
import jetbrains.mps.progress.EmptyProgressMonitor;
import org.jetbrains.mps.openapi.module.SModule;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.internal.collections.runtime.Sequence;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.project.Solution;
import org.jetbrains.mps.openapi.model.SModelReference;
import org.jetbrains.mps.openapi.module.SModuleReference;
import org.jetbrains.mps.openapi.language.SConcept;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;

public class TraceFinder {
  public static Iterable<SNode> findTracesForRequirement(SNode r) {
    Set<SNode> s = SetSequence.fromSet(new HashSet<SNode>());
    SetSequence.fromSet(s).addElement(r);
    SearchScope scope = new FilteredScope(((AbstractModule) SNodeOperations.getModel(r).getModule()).getScope());


    Set<SReference> resRefs = FindUsagesFacade.getInstance().findUsages(scope, s, new EmptyProgressMonitor());
    return SetSequence.fromSet(resRefs).where((it) -> {
      SNode sourceNode = it.getSourceNode();
      return SNodeOperations.getNodeAncestor(sourceNode, CONCEPTS.TraceAnnotation$ho, false, false) != null;
    }).select((it) -> {
      SNode sourceNode = it.getSourceNode();
      return SNodeOperations.getNodeAncestor(sourceNode, CONCEPTS.TraceAnnotation$ho, false, false);
    });
  }
  private static class FilteredScope implements SearchScope {
    private SearchScope parent;

    public FilteredScope(SearchScope parent) {
      this.parent = parent;
    }

    public Iterable<SModule> getModules() {
      List<SModule> modules = ListSequence.fromList(new ArrayList<SModule>());
      ListSequence.fromList(modules).addSequence(Sequence.fromIterable(parent.getModules()));

      return ListSequence.fromList(modules).where((it) -> !(it.isPackaged()));
    }
    public Iterable<SModel> getModels() {
      Iterable<SModel> models = ((Iterable<SModel>) parent.getModels());
      return Sequence.fromIterable(models).where((it) -> {
        SModule module = it.getModule();
        return module instanceof Solution;
      });

    }
    /**
     * 
     * @deprecated 
     */
    @Deprecated
    public SModel resolve(SModelReference reference) {
      return parent.resolve(reference);
    }
    /**
     * 
     * @deprecated 
     */
    @Deprecated
    public SModule resolve(SModuleReference reference) {
      return parent.resolve(reference);
    }

  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept TraceAnnotation$ho = MetaAdapterFactory.getConcept(0x53bab999e9c3428aL, 0x80befef5bed08f55L, 0x619a854eb408b62L, "com.mbeddr.cc.trace.structure.TraceAnnotation");
  }
}
