package com.mbeddr.cc.requirements.intentions;

/*Generated by MPS */

import de.itemis.mps.selection.runtime.intentions.AbstractSelectionIntentionFactory;
import java.util.List;
import de.itemis.mps.selection.runtime.intentions.ISelectionIntentionExecutable;
import jetbrains.mps.nodeEditor.selection.NodeRangeSelection;
import de.itemis.mps.selection.runtime.intentions.AbstractSelectionIntentionExecutable;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import com.mbeddr.mpsutil.targetchooser.TargetChooserOptions;
import com.mbeddr.mpsutil.targetchooser.FilteringModuleScope;
import com.mbeddr.mpsutil.targetchooser.DefaultModuleScope;
import com.mbeddr.mpsutil.targetchooser.Filter;
import org.jetbrains.mps.openapi.module.SModule;
import com.mbeddr.mpsutil.targetchooser.SelectionValidator;
import org.jetbrains.annotations.Nullable;
import com.mbeddr.mpsutil.targetchooser.SelectedTarget;
import com.mbeddr.mpsutil.targetchooser.SNodeFilter;
import jetbrains.mps.openapi.editor.EditorContext;
import com.mbeddr.mpsutil.targetchooser.TargetChooserDialog;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.internal.collections.runtime.Sequence;
import java.util.Collections;
import org.jetbrains.mps.openapi.language.SConcept;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import org.jetbrains.mps.openapi.language.SContainmentLink;

public class moveToOtherModule extends AbstractSelectionIntentionFactory {
  public moveToOtherModule() {
  }

  @Override
  public List<ISelectionIntentionExecutable> getInstances(Object selection) {
    if (selection instanceof NodeRangeSelection) {
      ISelectionIntentionExecutable intention = new AbstractSelectionIntentionExecutable<NodeRangeSelection>() {
        @Override
        public void execute(NodeRangeSelection selection) {
          List<SNode> nodes = selection.getSelectedNodes();
          final SNode currentModule = SNodeOperations.getNodeAncestor(ListSequence.fromList(nodes).first(), CONCEPTS.RequirementsModule$Vm, false, false);

          TargetChooserOptions options = new TargetChooserOptions();
          options.setInitial(currentModule);
          options.setModuleScope(new FilteringModuleScope(new DefaultModuleScope(), new Filter<SModule>() {
            public boolean keep(SModule candidate) {
              return candidate == SNodeOperations.getModel(currentModule).getModule();
            }
          }));
          options.setSelectionValidator(new SelectionValidator() {
            /**
             * 
             * @return The error message or null if valid
             */
            @Nullable
            public String validate(SelectedTarget selection) {
              SNode n = selection.getNode();
              if (!(SNodeOperations.isInstanceOf(n, CONCEPTS.RequirementsModule$Vm) || SNodeOperations.isInstanceOf(n, CONCEPTS.Requirement$sS))) {
                return "only requirements or requirements modules are valid targets";
              }
              return null;
            }
          });
          options.setSNodeFilter(new SNodeFilter() {
            /**
             * To show a node you also have to return true for the root node, but not for all ancestors.
             */
            public boolean keep(SNode candidate) {
              return SNodeOperations.isInstanceOf(candidate, CONCEPTS.RequirementsModule$Vm) || (SNodeOperations.isInstanceOf(candidate, CONCEPTS.Requirement$sS));
            }
          });

          EditorContext edCtx = selection.getEditorComponent().getEditorContext();
          SelectedTarget result = TargetChooserDialog.chooseTarget(edCtx.getOperationContext().getProject(), options);

          SNode n = result.getNode();
          if (SNodeOperations.isInstanceOf(n, CONCEPTS.Requirement$sS)) {
            ListSequence.fromList(SLinkOperations.getChildren(SNodeOperations.cast(n, CONCEPTS.Requirement$sS), LINKS.details$fIea)).addSequence(Sequence.fromIterable(SNodeOperations.ofConcept(nodes, CONCEPTS.Requirement$sS)));
          } else if (SNodeOperations.isInstanceOf(n, CONCEPTS.RequirementsModule$Vm)) {
            ListSequence.fromList(SLinkOperations.getChildren(SNodeOperations.cast(n, CONCEPTS.RequirementsModule$Vm), LINKS.requirements$sBol)).addSequence(Sequence.fromIterable(SNodeOperations.ofConcept(nodes, CONCEPTS.Requirement$sS)));
          }
        }
        @Override
        public String getDescription(NodeRangeSelection selection) {
          return "Move to other Module";
        }
        @Override
        public boolean isApplicable(NodeRangeSelection selection) {
          List<SNode> nodes = selection.getSelectedNodes();
          return ListSequence.fromList(nodes).all((it) -> SNodeOperations.isInstanceOf(it, CONCEPTS.RequirementsModule$Vm));
        }
      };
      return Collections.singletonList(intention);
    } else {
      return Collections.<ISelectionIntentionExecutable>emptyList();
    }
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept RequirementsModule$Vm = MetaAdapterFactory.getConcept(0xe865cad27cc8437aL, 0x951a665bcbcb8b1aL, 0x795de87bb672b3e1L, "com.mbeddr.cc.requirements.structure.RequirementsModule");
    /*package*/ static final SConcept Requirement$sS = MetaAdapterFactory.getConcept(0xe865cad27cc8437aL, 0x951a665bcbcb8b1aL, 0x795de87bb67288a5L, "com.mbeddr.cc.requirements.structure.Requirement");
  }

  private static final class LINKS {
    /*package*/ static final SContainmentLink details$fIea = MetaAdapterFactory.getContainmentLink(0xe865cad27cc8437aL, 0x951a665bcbcb8b1aL, 0x795de87bb67288a5L, 0x795de87bb672b1c5L, "details");
    /*package*/ static final SContainmentLink requirements$sBol = MetaAdapterFactory.getContainmentLink(0xe865cad27cc8437aL, 0x951a665bcbcb8b1aL, 0x795de87bb672b3e1L, 0x795de87bb672b3e3L, "requirements");
  }
}
