package com.mbeddr.cc.requirements.intentions;

/*Generated by MPS */

import de.itemis.mps.selection.runtime.intentions.AbstractSelectionIntentionFactory;
import java.util.List;
import de.itemis.mps.selection.runtime.intentions.ISelectionIntentionExecutable;
import jetbrains.mps.nodeEditor.selection.NodeRangeSelection;
import de.itemis.mps.selection.runtime.intentions.AbstractSelectionIntentionExecutable;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import java.util.Collections;
import org.jetbrains.mps.openapi.language.SConcept;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import org.jetbrains.mps.openapi.language.SContainmentLink;

public class wrapSeveralInNewparent extends AbstractSelectionIntentionFactory {
  public wrapSeveralInNewparent() {
  }

  @Override
  public List<ISelectionIntentionExecutable> getInstances(Object selection) {
    if (selection instanceof NodeRangeSelection) {
      ISelectionIntentionExecutable intention = new AbstractSelectionIntentionExecutable<NodeRangeSelection>() {
        @Override
        public void execute(NodeRangeSelection selection) {
          List<SNode> nodes = ((List<SNode>) selection.getSelectedNodes());
          SNode f = ListSequence.fromList(nodes).first();
          final SNode parent = SNodeOperations.replaceWithNewChild(f, CONCEPTS.Requirement$sS);
          SLinkOperations.setTarget(parent, LINKS.kind$XKhf, SNodeOperations.copyNode(SLinkOperations.getTarget(f, LINKS.kind$XKhf)));
          ListSequence.fromList(nodes).visitAll((it) -> ListSequence.fromList(SLinkOperations.getChildren(parent, LINKS.details$fIea)).addElement(it));
        }
        @Override
        public String getDescription(NodeRangeSelection selection) {
          return "Introduce Parent";
        }
        @Override
        public boolean isApplicable(NodeRangeSelection selection) {
          List<SNode> nodes = selection.getSelectedNodes();
          return ListSequence.fromList(nodes).select((it) -> SNodeOperations.getParent(it)).distinct().count() == 1 && ListSequence.fromList(nodes).all((it) -> SNodeOperations.isInstanceOf(it, CONCEPTS.Requirement$sS));
        }
      };
      return Collections.singletonList(intention);
    } else {
      return Collections.<ISelectionIntentionExecutable>emptyList();
    }
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept Requirement$sS = MetaAdapterFactory.getConcept(0xe865cad27cc8437aL, 0x951a665bcbcb8b1aL, 0x795de87bb67288a5L, "com.mbeddr.cc.requirements.structure.Requirement");
  }

  private static final class LINKS {
    /*package*/ static final SContainmentLink kind$XKhf = MetaAdapterFactory.getContainmentLink(0xe865cad27cc8437aL, 0x951a665bcbcb8b1aL, 0x795de87bb67288a5L, 0x7bceab23f9071900L, "kind");
    /*package*/ static final SContainmentLink details$fIea = MetaAdapterFactory.getContainmentLink(0xe865cad27cc8437aL, 0x951a665bcbcb8b1aL, 0x795de87bb67288a5L, 0x795de87bb672b1c5L, "details");
  }
}
