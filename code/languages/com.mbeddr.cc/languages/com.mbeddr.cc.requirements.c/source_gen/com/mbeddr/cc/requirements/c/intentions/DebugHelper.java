package com.mbeddr.cc.requirements.c.intentions;

/*Generated by MPS */

import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.openapi.editor.EditorContext;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import com.mbeddr.core.base.behavior.IValueDebuggable__BehaviorDescriptor;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import com.mbeddr.cc.requirements.c.behavior.RTestCase__BehaviorDescriptor;
import org.jetbrains.mps.openapi.model.SModel;
import org.jetbrains.mps.openapi.model.SNodeChangeListenerAdapter;
import org.jetbrains.mps.openapi.event.SPropertyChangeEvent;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.nodeEditor.EditorComponent;
import com.mbeddr.mpsutil.interpreter.rt.IInterpreter;
import com.mbeddr.mpsutil.interpreter.rt.PersistentInterpreter;
import com.mbeddr.mpsutil.interpreter.rt.CombinedInterpreter;
import jetbrains.mps.internal.collections.runtime.Sequence;
import com.mbeddr.mpsutil.interpreter.rt.InterpreterRegistry;
import com.mbeddr.core.interpreterdebugger.rt.runtime.InterpreterValueSource;
import com.mbeddr.mpsutil.interpreter.rt.IPersistentContext;
import com.mbeddr.core.base.behavior.IValueSourcePresentation;
import com.mbeddr.core.interpreterdebugger.rt.runtime.InterpreterValueSourcePresentation;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import com.mbeddr.mpsutil.interpreter.rt.PersistentContextImpl;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import org.jetbrains.mps.openapi.language.SConcept;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import org.jetbrains.mps.openapi.language.SInterfaceConcept;
import org.jetbrains.mps.openapi.language.SContainmentLink;

public class DebugHelper {

  public static int originalValue = 0;
  public static int sliderValue = 0;

  public static DebuggedTest debug(final SNode tc, boolean expanded, final EditorContext editorContext) {
    System.out.println("debug");
    final SNode calc = SNodeOperations.cast(SNodeOperations.getParent(tc), CONCEPTS.RCalculation$ih);
    clear(calc, editorContext);

    IValueDebuggable__BehaviorDescriptor.debugAll_id3$DH87aJHKz.invoke(SLinkOperations.getTarget(calc, LINKS.expr$l4qu), createValueSource(tc), createValueSourcePresentation(tc, expanded));
    DebuggedTest result = new DebuggedTest();
    RTestCase__BehaviorDescriptor.setDebuggedTest_iddfV14BYish.invoke(tc, result);
    if (editorContext != null) {
      editorContext.getEditorComponent().update();
    }
    final SModel testModel = SNodeOperations.getModel(tc);

    final SNodeChangeListenerAdapter adapter = new SNodeChangeListenerAdapter() {
      @Override
      public void propertyChanged(SPropertyChangeEvent event) {
        SNode node = (SNode) event.getNode();
        if (ListSequence.fromList(SNodeOperations.getNodeAncestors(node, null, false)).contains(calc) || ListSequence.fromList(SNodeOperations.getNodeAncestors(node, CONCEPTS.RConstant$YS, true)).isNotEmpty()) {
          System.out.println("UPDATING");
          update(tc);
        } else {
          System.out.println("__NOT__ UPDATING");
        }
      }
    };
    testModel.addChangeListener(adapter);

    if (editorContext != null) {
      EditorComponent.EditorDisposeListener listener = new EditorComponent.EditorDisposeListener() {
        public void editorWillBeDisposed(EditorComponent editorComponent) {
          testModel.removeChangeListener(adapter);
        }
      };
      ((EditorComponent) editorContext.getEditorComponent()).addDisposeListener(listener);
    }

    return result;
  }

  public static void update(SNode tc) {
    SNode calc = SNodeOperations.getNodeAncestor(tc, CONCEPTS.RCalculation$ih, false, false);
    IValueDebuggable__BehaviorDescriptor.updateDebugger_id6KLCBzCTpEk.invoke(SLinkOperations.getTarget(calc, LINKS.expr$l4qu), createValueSource(tc), ((boolean) true));
  }

  public static IInterpreter createInterpreter() {
    return new PersistentInterpreter(new CombinedInterpreter(Sequence.fromIterable(InterpreterRegistry.findAllInterpreterExecutables()).toGenericArray(IInterpreter.class)));
  }

  public static InterpreterValueSource createValueSource(SNode tc) {
    IInterpreter interpreter = createInterpreter();
    IPersistentContext context = createContextWithEnv(tc);
    System.out.println("created env: " + context.getEnvironment());
    InterpreterValueSource source = new InterpreterValueSource(interpreter, context);

    return source;
  }

  public static IValueSourcePresentation createValueSourcePresentation(SNode tc, final boolean expanded) {
    final InterpreterValueSourcePresentation result = new InterpreterValueSourcePresentation();
    SNode calc = SNodeOperations.cast(SNodeOperations.getParent(tc), CONCEPTS.RCalculation$ih);

    final Iterable<SNode> values = ListSequence.fromList(SNodeOperations.getNodeDescendants(SNodeOperations.getContainingRoot(tc), CONCEPTS.RConstant$YS, false, new SAbstractConcept[]{})).translate((it) -> SNodeOperations.getNodeDescendants(it, null, false, new SAbstractConcept[]{})).concat(ListSequence.fromList(SNodeOperations.getNodeDescendants(tc, null, false, new SAbstractConcept[]{}))).where((it) -> it.hasProperty("value"));
    ListSequence.fromList(SNodeOperations.getNodeDescendants(SLinkOperations.getTarget(calc, LINKS.expr$l4qu), CONCEPTS.IValueDebuggable$Pw, true, new SAbstractConcept[]{})).visitAll((final SNode debuggable) -> {
      result.clearDependentNodes(debuggable);
      Sequence.fromIterable(values).visitAll((dependency) -> {
        System.out.println("registering debuggable " + SNodeOperations.present(debuggable) + " with " + dependency);
        result.registerDependentNode(debuggable, dependency);
        result.setShowDebugger(debuggable, expanded);
      });
    });
    return result;
  }

  public static IPersistentContext createContextWithEnv(SNode tc) {
    SNode calc = SNodeOperations.getNodeAncestor(tc, CONCEPTS.RCalculation$ih, false, false);
    IPersistentContext ctx = new PersistentContextImpl();
    for (SNode iv : ListSequence.fromList(SLinkOperations.getChildren(tc, LINKS.params$IazE))) {
      SNode node = ListSequence.fromList(SLinkOperations.getChildren(calc, LINKS.params$l3Ws)).getElement(SNodeOperations.getIndexInParent(iv));
      MapSequence.fromMap(ctx.getEnvironment()).put(node, iv);
    }
    return ctx;
  }

  public static void clear(SNode calc, final EditorContext editorContext) {
    ListSequence.fromList(SNodeOperations.getNodeDescendants(calc, CONCEPTS.RTestCase$rN, false, new SAbstractConcept[]{})).visitAll((it) -> RTestCase__BehaviorDescriptor.setDebuggedTest_iddfV14BYish.invoke(it, null));
    IValueDebuggable__BehaviorDescriptor.clearAllDebuggers_id$bJ0jh_6s5.invoke(SLinkOperations.getTarget(calc, LINKS.expr$l4qu));
    if (editorContext != null) {
      editorContext.getEditorComponent().update();
    }
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept RCalculation$ih = MetaAdapterFactory.getConcept(0xf3ed62ca349040d0L, 0x890b9b3133cc2eadL, 0x310d0e4ce1f521c3L, "com.mbeddr.cc.requirements.c.structure.RCalculation");
    /*package*/ static final SConcept RConstant$YS = MetaAdapterFactory.getConcept(0xf3ed62ca349040d0L, 0x890b9b3133cc2eadL, 0x310d0e4ce1f36c0eL, "com.mbeddr.cc.requirements.c.structure.RConstant");
    /*package*/ static final SInterfaceConcept IValueDebuggable$Pw = MetaAdapterFactory.getInterfaceConcept(0xd4280a54f6df4383L, 0xaa41d1b2bffa7eb1L, 0x90bbc04d0d4e74eL, "com.mbeddr.core.base.structure.IValueDebuggable");
    /*package*/ static final SConcept RTestCase$rN = MetaAdapterFactory.getConcept(0xf3ed62ca349040d0L, 0x890b9b3133cc2eadL, 0x3170448c7c6f6badL, "com.mbeddr.cc.requirements.c.structure.RTestCase");
  }

  private static final class LINKS {
    /*package*/ static final SContainmentLink expr$l4qu = MetaAdapterFactory.getContainmentLink(0xf3ed62ca349040d0L, 0x890b9b3133cc2eadL, 0x310d0e4ce1f521c3L, 0x310d0e4ce1f521d8L, "expr");
    /*package*/ static final SContainmentLink params$l3Ws = MetaAdapterFactory.getContainmentLink(0xf3ed62ca349040d0L, 0x890b9b3133cc2eadL, 0x310d0e4ce1f521c3L, 0x310d0e4ce1f521d6L, "params");
    /*package*/ static final SContainmentLink params$IazE = MetaAdapterFactory.getContainmentLink(0xf3ed62ca349040d0L, 0x890b9b3133cc2eadL, 0x3170448c7c6f6badL, 0x3170448c7c6f945eL, "params");
  }
}
