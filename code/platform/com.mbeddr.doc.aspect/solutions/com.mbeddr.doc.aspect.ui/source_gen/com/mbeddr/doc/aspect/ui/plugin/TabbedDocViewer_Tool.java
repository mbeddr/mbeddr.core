package com.mbeddr.doc.aspect.ui.plugin;

/*Generated by MPS */

import jetbrains.mps.ide.tools.BaseTabbedProjectTool;
import jetbrains.mps.logging.Logger;
import javax.swing.Icon;
import com.intellij.icons.AllIcons;
import jetbrains.mps.nodeEditor.EditorComponent;
import javax.swing.JPanel;
import jetbrains.mps.project.Project;
import com.intellij.openapi.wm.ToolWindowAnchor;
import jetbrains.mps.ide.project.ProjectHelper;
import java.awt.CardLayout;
import javax.swing.event.AncestorListener;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.mps.openapi.model.SNode;
import com.intellij.openapi.application.ApplicationManager;
import java.awt.BorderLayout;
import jetbrains.mps.nodeEditor.UIEditorComponent;
import jetbrains.mps.openapi.editor.extensions.EditorExtensionRegistry;
import de.slisson.mps.reflection.runtime.ReflectionUtil;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.RuntimeFlags;
import jetbrains.mps.TestMode;
import jetbrains.mps.nodeEditor.cells.EditorCell;
import com.intellij.ui.content.ContentManager;
import jetbrains.mps.ide.tools.BaseTool;
import com.intellij.ui.content.Content;
import org.jetbrains.mps.openapi.language.SLanguage;
import org.jetbrains.mps.openapi.module.SRepository;
import jetbrains.mps.smodel.language.LanguageRuntime;
import jetbrains.mps.smodel.language.LanguageRegistry;
import com.mbeddr.doc.aspect.runtime.IDocumentationAspectDescriptor;
import com.mbeddr.doc.aspect.runtime.DocumentationAspectHelper;
import org.jetbrains.mps.openapi.language.SProperty;
import jetbrains.mps.ide.icons.GlobalIconManager;
import com.mbeddr.core.base.behavior.IDocumentable__BehaviorDescriptor;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import jetbrains.mps.lang.core.behavior.BaseConcept__BehaviorDescriptor;
import com.intellij.openapi.wm.ToolWindowManager;
import jetbrains.mps.ide.MPSCoreComponents;
import jetbrains.mps.smodel.MPSModuleRepository;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import org.jetbrains.mps.openapi.model.SModel;
import org.jetbrains.mps.openapi.language.SInterfaceConcept;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;

public class TabbedDocViewer_Tool extends BaseTabbedProjectTool {
  private static final Logger LOG = Logger.getLogger(TabbedDocViewer_Tool.class);
  private static final Icon ICON = AllIcons.Toolwindows.Documentation;
  private EditorComponent conceptDocEditor;
  private EditorComponent nodeDocEditor;
  private JPanel conceptDocPanel;
  private JPanel nodeDocPanel;
  private String CONCEPT_DOC_TITLE = "Concept";
  private String NODE_DOC_TITLE = "Node";
  private String PANEL_EDITOR = "Editor Panel";
  private String PANEL_EMPTY = "Empty Panel";
  private Project currentProject;
  private com.intellij.openapi.project.Project ideaProject;
  public TabbedDocViewer_Tool(com.intellij.openapi.project.Project project) {
    super(project, "Documentation", null, ICON, ToolWindowAnchor.BOTTOM, true);
  }
  public void init(com.intellij.openapi.project.Project project) {
    super.init(project);
    TabbedDocViewer_Tool.this.ideaProject = project;
    TabbedDocViewer_Tool.this.currentProject = ProjectHelper.fromIdeaProject(project);

    TabbedDocViewer_Tool.this.conceptDocPanel = new JPanel(new CardLayout());
    TabbedDocViewer_Tool.this.conceptDocEditor = TabbedDocViewer_Tool.this.createEditorTab(TabbedDocViewer_Tool.this.conceptDocPanel);
    TabbedDocViewer_Tool.this.enableNecessaryEditorHints(TabbedDocViewer_Tool.this.conceptDocEditor);

    TabbedDocViewer_Tool.this.nodeDocPanel = new JPanel(new CardLayout());
    TabbedDocViewer_Tool.this.nodeDocEditor = TabbedDocViewer_Tool.this.createEditorTab(TabbedDocViewer_Tool.this.nodeDocPanel);
    TabbedDocViewer_Tool.this.enableNecessaryEditorHints(TabbedDocViewer_Tool.this.nodeDocEditor);

    TabbedDocViewer_Tool.this.showNodeOrConceptContent(null);
  }
  @Override
  protected boolean isInitiallyAvailable() {
    return true;
  }
  public void addOnShowListener(final AncestorListener onShow) {
    TabbedDocViewer_Tool.this.nodeDocPanel.addAncestorListener(onShow);
    TabbedDocViewer_Tool.this.conceptDocPanel.addAncestorListener(onShow);
  }
  public void removeOnShowListener(final AncestorListener onShow) {
    TabbedDocViewer_Tool.this.nodeDocPanel.removeAncestorListener(onShow);
    TabbedDocViewer_Tool.this.conceptDocPanel.removeAncestorListener(onShow);
  }
  public void initializeTabsForSelection(@Nullable final SNode selectedNode) {
    final boolean wasOpen = TabbedDocViewer_Tool.this.toolIsOpened();

    TabbedDocViewer_Tool.this.showNodeOrConceptContent(selectedNode);

    // make sure that we preserve the state of the tool
    if (wasOpen) {
      ApplicationManager.getApplication().invokeLater(() -> TabbedDocViewer_Tool.this.openTool(false));
    }
  }
  private EditorComponent createEditorTab(final JPanel parentPanel) {
    final JPanel editorPanel = new JPanel(new BorderLayout());
    final EditorComponent editorComponent = new UIEditorComponent(TabbedDocViewer_Tool.this.currentProject.getRepository(), null) {
      @Override
      public boolean isReadOnly() {
        return true;
      }
    };

    Project project = TabbedDocViewer_Tool.this.currentProject;
    EditorExtensionRegistry registry = ((Project) project).getComponent(EditorExtensionRegistry.class);
    try {
      registry.extend(editorComponent);
    } catch (LinkageError le) {
    }
    // The following call is need to emit an event for EditorComponentCreateListener.EDITOR_COMPONENT_CREATION. It is need, for example for hyperlink references.
    ReflectionUtil.callVoidMethod(EditorComponent.class, editorComponent, "notifyCreation", new Class[]{}, new Object[]{});

    editorPanel.add(editorComponent.getExternalComponent(), BorderLayout.CENTER);
    parentPanel.add(editorPanel, TabbedDocViewer_Tool.this.PANEL_EDITOR);
    parentPanel.add(new JPanel(), TabbedDocViewer_Tool.this.PANEL_EMPTY);
    return editorComponent;
  }
  private void enableNecessaryEditorHints(final jetbrains.mps.openapi.editor.EditorComponent component) {
    final String[] initialHints = new String[]{"com.mbeddr.core.base.editor.presentationMode.presentationMode", "com.mbeddr.doc.aspect.editor.documentationModeHints.documentationMode", "de.slisson.mps.conditionalEditor.hints.editor.conditionalEditorHints.conditionalEditor"};
    final boolean rebuildRequired = component.getUpdater().setInitialEditorHints(initialHints);
    if (rebuildRequired) {
      component.getEditorContext().getRepository().getModelAccess().runReadAction(() -> component.rebuildEditorContent());
    }
  }
  private void showConceptDoc(final SNode docNode) {
    if (docNode == null) {
      TabbedDocViewer_Tool.this.showEmptyPanel(TabbedDocViewer_Tool.this.conceptDocPanel);
    } else {
      TabbedDocViewer_Tool.this.showEditorPanel(TabbedDocViewer_Tool.this.conceptDocPanel);
      final SNode rootNode = SNodeOperations.getContainingRoot(docNode);
      // do not show the documentation in test mode
      // it leads to all kinds of problems with editor tests
      if (TabbedDocViewer_Tool.this.conceptDocEditor.getEditedNode() != rootNode && RuntimeFlags.getTestMode() == TestMode.NONE) {
        TabbedDocViewer_Tool.this.conceptDocEditor.editNode(rootNode);
      }
      TabbedDocViewer_Tool.this.conceptDocEditor.scrollToNode(docNode);
      EditorCell cell = TabbedDocViewer_Tool.this.conceptDocEditor.findNodeCell(docNode);
      if (cell != null) {
        TabbedDocViewer_Tool.this.conceptDocEditor.changeSelectionWRTFocusPolicy(cell);
      }
    }
  }
  private void showNodeDoc(final SNode docNode) {
    if (docNode == null) {
      TabbedDocViewer_Tool.this.showEmptyPanel(TabbedDocViewer_Tool.this.nodeDocPanel);
    } else {
      TabbedDocViewer_Tool.this.showEditorPanel(TabbedDocViewer_Tool.this.nodeDocPanel);
      // do not show the documentation in test mode
      // it leads to all kinds of problems with editor tests
      if (TabbedDocViewer_Tool.this.nodeDocEditor.getEditedNode() != docNode && RuntimeFlags.getTestMode() == TestMode.NONE) {
        TabbedDocViewer_Tool.this.nodeDocEditor.editNode(docNode);
      }
    }
  }
  private void showEmptyPanel(final JPanel containerPanel) {
    final CardLayout cardLayout = (CardLayout) containerPanel.getLayout();
    cardLayout.show(containerPanel, TabbedDocViewer_Tool.this.PANEL_EMPTY);
  }
  private void showEditorPanel(final JPanel containerPanel) {
    final CardLayout cardLayout = (CardLayout) containerPanel.getLayout();
    cardLayout.show(containerPanel, TabbedDocViewer_Tool.this.PANEL_EDITOR);
  }
  private void reset() {
    TabbedDocViewer_Tool.this.showNodeDoc(null);
    TabbedDocViewer_Tool.this.showConceptDoc(null);

    final ContentManager contentManager = ((ContentManager) ReflectionUtil.callMethod(BaseTool.class, TabbedDocViewer_Tool.this, "getContentManager", new Class[]{}, new Object[]{}));

    Content content = contentManager.getContent(TabbedDocViewer_Tool.this.conceptDocPanel);
    if (content != null) {
      content.setDisplayName(TabbedDocViewer_Tool.this.CONCEPT_DOC_TITLE);
      content.setIcon(AllIcons.Toolwindows.Documentation);
      content.setCloseable(false);
    }

    content = contentManager.getContent(TabbedDocViewer_Tool.this.nodeDocPanel);
    if (content != null) {
      content.setDisplayName(TabbedDocViewer_Tool.this.NODE_DOC_TITLE);
      content.setIcon(IconContainer.ICON_a0a1a9a32);
      content.setCloseable(false);
    }
  }
  private boolean hasDocAspect(final SLanguage language, @Nullable final SRepository repository) {
    if (repository == null) {
      return false;
    } else {
      final LanguageRuntime languageRuntime = LanguageRegistry.getInstance(repository).getLanguage(language);
      if (languageRuntime == null) {
        return false;
      } else {
        IDocumentationAspectDescriptor aspect = null;
        try {
          aspect = languageRuntime.getAspect(IDocumentationAspectDescriptor.class);
        } catch (NoClassDefFoundError error) {
          if (LOG.isErrorLevel()) {
            LOG.error("Failed to get editor aspect descriptor for language: " + languageRuntime, error);
          }
        }
        return aspect != null;
      }
    }
  }
  private boolean hasDoc(final SNode selectedNode, final SRepository repository) {
    return DocumentationAspectHelper.getDocumentation(repository, selectedNode, null) != null;
  }
  public void showDocumentation(final jetbrains.mps.openapi.editor.cells.EditorCell editorCell) {
    final SNode selectedNode = DocumentationAspectHelper.getNodeUnderCursor(editorCell);
    final SProperty property = DocumentationAspectHelper.getPropertyUnderCursor(editorCell);
    TabbedDocViewer_Tool.this.showDocumentation(selectedNode, property, editorCell);
  }
  private void showDocumentation(final SNode selectedNode, final SProperty property, final jetbrains.mps.openapi.editor.cells.EditorCell editorCell) {
    TabbedDocViewer_Tool.this.initializeTabsForSelection(selectedNode);

    if (selectedNode == null) {
      TabbedDocViewer_Tool.this.reset();
    } else {
      final GlobalIconManager iconManager = ApplicationManager.getApplication().getService(GlobalIconManager.class);
      final ContentManager contentManager = ((ContentManager) ReflectionUtil.callMethod(BaseTool.class, TabbedDocViewer_Tool.this, "getContentManager", new Class[]{}, new Object[]{}));

      // show documentation for node
      final SNode nodeDoc = (SNodeOperations.isInstanceOf(selectedNode, CONCEPTS.IDocumentable$NV) ? IDocumentable__BehaviorDescriptor.getDocNodeOrNull_id11K_5nNeRli.invoke(SNodeOperations.cast(selectedNode, CONCEPTS.IDocumentable$NV), editorCell) : null);
      TabbedDocViewer_Tool.this.showNodeDoc(nodeDoc);
      final boolean hasNodeDoc = nodeDoc != null;
      final Content nodeDocContent = contentManager.getContent(TabbedDocViewer_Tool.this.nodeDocPanel);
      if (nodeDocContent != null) {
        nodeDocContent.setDisplayName(TabbedDocViewer_Tool.this.getPresentationSafe(selectedNode));
        nodeDocContent.setIcon(iconManager.getIconFor(selectedNode));
      }

      // show documentation for concept
      SAbstractConcept selectedConcept = SNodeOperations.getConcept(selectedNode);
      final SNode conceptDoc = DocumentationAspectHelper.getDocumentation(TabbedDocViewer_Tool.this.currentProject.getRepository(), selectedNode, property);
      TabbedDocViewer_Tool.this.showConceptDoc(conceptDoc);
      final boolean hasConceptDoc = conceptDoc != null;
      final Content conceptDocContent = contentManager.getContent(TabbedDocViewer_Tool.this.conceptDocPanel);
      if (conceptDocContent != null) {
        conceptDocContent.setDisplayName(TabbedDocViewer_Tool.this.getPresentationSafe(conceptDoc));
        conceptDocContent.setIcon(iconManager.getIconFor(SNodeOperations.asNode(selectedConcept)));
      }
      boolean shouldAddConceptDoc = hasConceptDoc && conceptDocContent != null;
      boolean shouldAddNodeDoc = hasNodeDoc && nodeDocContent != null;

      int contentsNo = contentManager.getContents().length;
      // Special logic necessary if both contents are available. ContentManger.setContent()
      // caused infinite recursion as both contents were seen as ancestor of each other triggering TabOnShowListenerAdapter until a StackOverflow happened.
      if (shouldAddConceptDoc) {
        contentManager.addContent(conceptDocContent, 0);
      }
      if (shouldAddNodeDoc) {
        contentManager.addContent(nodeDocContent, (contentsNo > 1 ? 1 : 0));
      }
    }
  }
  private String getPresentationSafe(final SNode node) {
    if (node == null || SNodeOperations.getConcept(node) == null) {
      // Workaround for MPS-30286 where getPresentation() throws a NPE for nodes with null concept.
      return null;
    }
    return BaseConcept__BehaviorDescriptor.getPresentation_idhEwIMiw.invoke(node);
  }
  /**
   * Use showDocumentation(node slectedNode, string selectedProperty, EditorCell editorCell).
   */
  @Deprecated
  public void showDocumentation(final SNode node, final SProperty property) {
    TabbedDocViewer_Tool.this.showDocumentation(node, property, null);
  }
  private void showNodeOrConceptContent(final SNode selectedNode) {
    ToolWindowManager.getInstance(TabbedDocViewer_Tool.this.ideaProject).invokeLater(new Runnable() {
      @Override
      public void run() {
        final ContentManager contentManager = ((ContentManager) ReflectionUtil.callMethod(BaseTool.class, TabbedDocViewer_Tool.this, "getContentManager", new Class[]{}, new Object[]{}));
        // show the concept doc content if no node is selected
        // or if the language of the selected node's concept has doc aspec
        SRepository repository = MPSCoreComponents.getInstance().getPlatform().findComponent(MPSModuleRepository.class);
        final Wrappers._boolean showConceptContent = new Wrappers._boolean(false);
        repository.getModelAccess().runReadAction(() -> showConceptContent.value = selectedNode == null || TabbedDocViewer_Tool.this.hasDoc(selectedNode, check_y802y7_b0a0a0a0f0a0a0a0a0q(selectedNode.getModel())));

        if (showConceptContent.value && contentManager != null) {
          final Content conceptContent = contentManager.getContent(TabbedDocViewer_Tool.this.conceptDocPanel);
          if (conceptContent == null) {
            // use the low-level API (and ignore the type system error) because this is the only way to set the open flag
            ((BaseTabbedProjectTool) TabbedDocViewer_Tool.this).addTab(TabbedDocViewer_Tool.this.conceptDocPanel, TabbedDocViewer_Tool.this.CONCEPT_DOC_TITLE, AllIcons.Toolwindows.Documentation, null, false);
            contentManager.getContent(TabbedDocViewer_Tool.this.conceptDocPanel).setCloseable(false);
            TabbedDocViewer_Tool.this.pinTab(TabbedDocViewer_Tool.this.conceptDocPanel);
            contentManager.setSelectedContent(contentManager.getContent(TabbedDocViewer_Tool.this.conceptDocPanel));
          }
        }
        if (contentManager != null) {
          // always show the node doc content
          final Content nodeContent = contentManager.getContent(TabbedDocViewer_Tool.this.nodeDocPanel);
          if (nodeContent == null) {
            ((BaseTabbedProjectTool) TabbedDocViewer_Tool.this).addTab(TabbedDocViewer_Tool.this.nodeDocPanel, TabbedDocViewer_Tool.this.NODE_DOC_TITLE, AllIcons.Toolwindows.Documentation, null, false);
            contentManager.getContent(TabbedDocViewer_Tool.this.nodeDocPanel).setCloseable(false);
          }

          if (showConceptContent.value) {
            contentManager.setSelectedContent(contentManager.getContent(TabbedDocViewer_Tool.this.conceptDocPanel));
          }
        }
      }
    });
  }
  private static SRepository check_y802y7_b0a0a0a0f0a0a0a0a0q(SModel checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getRepository();
    }
    return null;
  }

  private static final class CONCEPTS {
    /*package*/ static final SInterfaceConcept IDocumentable$NV = MetaAdapterFactory.getInterfaceConcept(0xd4280a54f6df4383L, 0xaa41d1b2bffa7eb1L, 0x3588b64556af2180L, "com.mbeddr.core.base.structure.IDocumentable");
  }
}
