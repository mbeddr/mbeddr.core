package com.mbeddr.doc.aspect.ui.plugin;

/*Generated by MPS */

import jetbrains.mps.project.MPSProject;
import java.util.Map;
import jetbrains.mps.nodeEditor.EditorComponent;
import java.util.Collections;
import java.util.HashMap;
import com.intellij.openapi.project.Project;
import jetbrains.mps.plugins.projectplugins.ProjectPluginManager;
import jetbrains.mps.openapi.editor.selection.SingularSelection;
import jetbrains.mps.internal.collections.runtime.Sequence;
import java.util.Iterator;

/*package*/ class DocumentationHandler implements IDocumentationHandler {

  private final MPSProject project;
  private final Map<EditorComponent, TabOnShowListenerAdapter> onShowListeners;

  /*package*/ DocumentationHandler(final MPSProject project) {
    this.project = project;
    this.onShowListeners = Collections.synchronizedMap(new HashMap<EditorComponent, TabOnShowListenerAdapter>());
  }

  private TabbedDocViewer_Tool getTool() {
    final Project ideaProject = this.project.getProject();
    return ProjectPluginManager.getInstance(ideaProject).getTool(TabbedDocViewer_Tool.class);
  }

  @Override
  public void showDoc(final jetbrains.mps.openapi.editor.EditorComponent cmp, final SingularSelection selection) {
    final String[] initialEditorHints = cmp.getUpdater().getInitialEditorHints();
    if (initialEditorHints != null && Sequence.fromIterable(Sequence.fromArray(initialEditorHints)).contains("com.mbeddr.doc.aspect.editor.documentationModeHints.documentationMode")) {
      return;
    }

    final TabbedDocViewer_Tool tool = getTool();
    if (tool == null) {
      return;
    }

    // onShow listeners can only be attached when the tool is created
    final Map<EditorComponent, TabOnShowListenerAdapter> newOnShowListeners = new HashMap<EditorComponent, TabOnShowListenerAdapter>();
    for (final Map.Entry<EditorComponent, TabOnShowListenerAdapter> e : this.onShowListeners.entrySet()) {
      // Create on-show listeners for newly created components.
      if (e.getValue() == null) {
        final EditorComponent currentCmp = e.getKey();
        newOnShowListeners.put(currentCmp, new TabOnShowListenerAdapter(currentCmp, this));
      }
    }
    // Attach listeners for newly created components.
    if (tool.getToolWindow() != null && !(tool.isAvailable())) {
      tool.register();
    }
    for (final TabOnShowListenerAdapter onShowListener : newOnShowListeners.values()) {
      tool.addOnShowListener(onShowListener);
    }
    this.onShowListeners.putAll(newOnShowListeners);

    // Don't load the content if the tab is closed.
    if (tool.getToolWindow() == null || !(tool.toolIsOpened())) {
      return;
    }

    this.project.getRepository().getModelAccess().runReadAction(() -> tool.showDocumentation(selection.getEditorCell()));
  }

  /*package*/ void addOnShowDocTabListenerForComponent(final EditorComponent cmp) {
    if (this.onShowListeners.containsKey(cmp)) {
      throw new IllegalStateException("On-show listener for component " + cmp + " already exists");
    }
    this.onShowListeners.put(cmp, null);
  }

  private void removeOnShowDocTabListenerForComponentInternal(final EditorComponent cmp) {
    final TabbedDocViewer_Tool tool = getTool();
    if (tool != null) {
      final TabOnShowListenerAdapter onShowListener = this.onShowListeners.get(cmp);
      if (onShowListener != null) {
        tool.removeOnShowListener(onShowListener);
      }
    }
  }

  /*package*/ void removeOnShowDocTabListenerForComponent(final EditorComponent cmp) {
    removeOnShowDocTabListenerForComponentInternal(cmp);
    this.onShowListeners.remove(cmp);
  }

  /*package*/ void removeAllOnShowDocTabListeners() {
    final Iterator<EditorComponent> iterator = this.onShowListeners.keySet().iterator();
    while (iterator.hasNext()) {
      final EditorComponent cmp = iterator.next();
      removeOnShowDocTabListenerForComponentInternal(cmp);
      iterator.remove();
    }
  }
}
