package com.mbeddr.doc.aspect.runtime;

/*Generated by MPS */

import jetbrains.mps.logging.Logger;
import org.jetbrains.mps.openapi.model.SNode;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.mps.openapi.module.SRepository;
import org.jetbrains.mps.openapi.language.SProperty;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import java.util.Objects;
import com.github.benmanes.caffeine.cache.Cache;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import java.util.Optional;
import com.github.benmanes.caffeine.cache.Caffeine;
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.smodel.language.LanguageRuntime;
import jetbrains.mps.smodel.language.LanguageRegistry;
import jetbrains.mps.internal.collections.runtime.Sequence;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.LinkedList;
import org.jetbrains.mps.openapi.module.SModule;
import org.jetbrains.mps.openapi.module.SDependency;
import org.jetbrains.mps.openapi.model.SModel;
import java.util.ArrayList;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import com.mbeddr.doc.behavior.IDocumentLike__BehaviorDescriptor;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.IAttributeDescriptor;
import jetbrains.mps.lang.structure.behavior.AbstractConceptDeclaration__BehaviorDescriptor;
import jetbrains.mps.lang.structure.behavior.PropertyDeclaration__BehaviorDescriptor;
import jetbrains.mps.openapi.editor.cells.EditorCell;
import org.jetbrains.mps.openapi.language.SConceptFeature;
import org.jetbrains.mps.openapi.language.SReferenceLink;
import com.mbeddr.doc.aspect.plugin.IDocumentationAspectConfiguration;
import jetbrains.mps.smodel.structure.ExtensionPoint;
import jetbrains.mps.internal.collections.runtime.NotNullWhereFilter;
import com.mbeddr.doc.aspect.plugin.DefaultDocAspectConfiguration;
import jetbrains.mps.nodeEditor.cells.EditorCell_Property;
import jetbrains.mps.nodeEditor.cells.ModelAccessor;
import jetbrains.mps.nodeEditor.cells.PropertyAccessor;
import jetbrains.mps.nodeEditor.cells.SPropertyAccessor;
import de.slisson.mps.reflection.runtime.ReflectionUtil;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import org.jetbrains.mps.openapi.language.SConcept;
import org.jetbrains.mps.openapi.language.SContainmentLink;

public class DocumentationAspectHelper {
  private static final Logger LOG = Logger.getLogger(DocumentationAspectHelper.class);

  /**
   * Get the documentation node for a given selected node/property.
   * 
   * This will take into account the following settings of the documentation annotations:
   * - priority: if there is more than one documentation annotation for the given node,
   *   the one with the higher priority will be returned
   * - overrideChildren: the documentation node for the given selected node will only be 
   *   returned if there is no ancestor of the selected node which has a documentation node
   *   with the override-flag set. If there is such an ancestor, its documentation will be shown
   *   instead of the selected node's documentation.
   * 
   * Note that the retrieval of documentation nodes uses caching, as searching through the 
   * ancestors might be expensive.
   * 
   * @param repository the current repository (opened with IDE)
   * @param selectedNode the node at the cursor
   * @param property the property at the cursor (or null)
   * @return a documentation node, if any
   */
  public static SNode getDocumentation(@NotNull final SRepository repository, final SNode selectedNode, final SProperty property) {
    SNode localDocNode = getDocForConceptCached(repository, SNodeOperations.getConcept(selectedNode), property);

    if (config().allowOverrideChildren() && !(isBlacklistedForOverride(selectedNode))) {
      // check the chain of ancestors of the selected node if there is one with 
      // a DocumentedConceptAnnotation where the overrideChildren flag is set.
      // this might have an impact on IDE performance when the documentation view is opened
      // and cache misses occur (i.e., the user never selected the node before).
      SNode n = SNodeOperations.getParent(selectedNode);
      while ((n != null)) {
        SNode ancestorDocNode = getDocForConceptCached(repository, SNodeOperations.getConcept(n), null);
        if ((ancestorDocNode != null)) {
          // the ancestor's documentation node should have an annotation, retrieve it
          SNode dca = getAnnotation(ancestorDocNode);
          if ((dca != null)) {
            // check override flag
            boolean override = SPropertyOperations.getBoolean(dca, PROPS.overrideChildren$KPv9);
            if (override) {
              // we found an ancestor whose concept-documentation has its overrideChild flag set
              // show the ancestors concept-documentation instead of the selectedNode's documentation
              return ancestorDocNode;
            }
          }
        }
        n = SNodeOperations.getParent(n);
      }
    }

    // no ancestor with overrideFlag set, just show documentation for selected node
    return localDocNode;
  }

  /**
   * Usually there is no mbeddr-doc documentation for baselang, blacklist the corresponding roots.
   * 
   * Note: The idea here is to do a quick check which can be done without much overhead.
   */
  private static boolean isBlacklistedForOverride(SNode n) {
    SAbstractConcept rootConcept = SNodeOperations.getConcept(SNodeOperations.getContainingRoot(n));
    return Objects.equals(rootConcept, CONCEPTS.ClassConcept$bK) || Objects.equals(rootConcept, CONCEPTS.Interface$db) || Objects.equals(rootConcept, CONCEPTS.ConceptBehavior$2);
  }

  /**
   * Cache for concept/property to corresponding node in documentation.
   */
  private static Cache<Tuples._2<SAbstractConcept, SProperty>, Optional<SNode>> cache = Caffeine.newBuilder().maximumSize(5000).<Tuples._2<SAbstractConcept, SProperty>,Optional<SNode>>build();

  private static SNode getDocForConceptCached(@NotNull final SRepository repository, final SAbstractConcept concept, final SProperty property) {
    // get documentation node from cache
    Tuples._2<SAbstractConcept, SProperty> key = MultiTuple.<SAbstractConcept,SProperty>from(concept, property);
    Optional<SNode> result = cache.getIfPresent(key);
    if (result == null || !(isValidCacheEntry(result, concept))) {
      // not in cache or outdated, compute it and put in cache
      result = Optional.ofNullable(getDocumentationAux(repository, concept, property));
      cache.put(key, result);
    }
    return (result.isEmpty() ? null : result.get());
  }

  /**
   * Check if a given cache entry (i.e., a documentation node) is still valid.
   * 
   * If the documentation annotation has been moved to a different location or 
   * the documented concept has been changed, this will be detected here.
   * 
   * Note: If the cache stores the information that there is no documentation node
   * for a given concept, this cannot be checked here. Thus, if a documentation annotation
   * is being added after this null-entry has been stored in the cache, only reloading all
   * classes or restarting MPS will fix this.
   */
  private static boolean isValidCacheEntry(Optional<SNode> docNode, SAbstractConcept concept) {
    if (docNode.isEmpty()) {
      // the cache entry is "no documentation node", we cannot check if this is still valid
      return true;
    } else {
      // this will check two properties:
      // 1. the docNode must have a documentation annotation
      // 2. the annotation must match the concept we are looking for
      SNode dca = getAnnotation(docNode.get());
      return (dca != null) && Objects.equals(SLinkOperations.getTarget(dca, LINKS.concept$eE0d), SNodeOperations.asNode(concept));
    }
  }

  /**
   * This method does not handle the override-child logic, so it is deprecated now and will be deleted.
   * 
   * @deprecated Use getDocumentation(node) instead.
   */
  @Deprecated
  public static SNode getDocumentationOld(@NotNull final SRepository repository, final SAbstractConcept concept, final SProperty property) {
    return getDocumentationAux(repository, concept, property);
  }

  /**
   * Retrieves the documentation node for the given concept by searching first in the documentation aspect of the concept 
   * language and subsequently in the documentation aspects of all extending languages and finally in any available 
   * solution that depends on the concept's language.
   */
  private static SNode getDocumentationAux(@NotNull final SRepository repository, final SAbstractConcept concept, final SProperty property) {
    final LanguageRuntime language = LanguageRegistry.getInstance(repository).getLanguage(concept.getLanguage());
    if (language == null) {
      return null;
    }

    final Iterable<LanguageRuntime> languagesIncludingExtending = Sequence.fromIterable(Sequence.<LanguageRuntime>singleton(language)).concat(Sequence.fromIterable(language.getExtendingLanguages()));
    for (LanguageRuntime nextLanguage : Sequence.fromIterable(languagesIncludingExtending)) {
      IDocumentationAspectDescriptor docAspect = null;
      try {
        docAspect = nextLanguage.getAspect(IDocumentationAspectDescriptor.class);
      } catch (NoClassDefFoundError error) {
        if (LOG.isErrorLevel()) {
          LOG.error("Failed to get editor aspect descriptor for language: " + nextLanguage, error);
        }
      }
      if (docAspect != null) {
        final SNode docElement = docAspect.getDocumentation(concept, property);
        if ((docElement != null)) {
          return docElement;
        }
      }
    }

    // next search through included models
    List<Tuples._2<SNode, Integer>> results = findSolutionDoc(repository, concept, property);

    if (ListSequence.fromList(results).isNotEmpty()) {
      Iterable<Tuples._2<SNode, Integer>> seq = ListSequence.fromList(results).sort((a, b) -> (int) a._1() - (int) b._1(), false);
      if (Sequence.fromIterable(seq).isNotEmpty()) {
        return Sequence.fromIterable(seq).first()._0();
      }
    }
    return null;
  }

  /**
   * Find documentation in solutions, search through available modules in repository, filtering by those including the
   * language of the concept.
   */
  public static List<Tuples._2<SNode, Integer>> findSolutionDoc(@NotNull SRepository repository, SAbstractConcept concept, SProperty property) {
    List<Tuples._2<SNode, Integer>> results = ListSequence.fromList(new LinkedList<Tuples._2<SNode, Integer>>());
    for (SModule module : Sequence.fromIterable(repository.getModules())) {
      for (SDependency dep : Sequence.fromIterable(module.getDeclaredDependencies())) {
        SModule resolve = dep.getTargetModule().resolve(repository);
        // only search for documentation if the language is included in the module dependencies
        if (Objects.equals(resolve, concept.getLanguage().getSourceModule())) {
          for (SModel model : Sequence.fromIterable(module.getModels())) {
            ListSequence.fromList(results).addSequence(ListSequence.fromList(findDocumentationElements(model, concept, property)));
          }
        }
      }
    }
    return results;
  }

  public static List<Tuples._2<SNode, Integer>> findDocumentationElements(final SModel model, final SAbstractConcept concept, final SProperty property) {
    List<Tuples._2<SNode, Integer>> availableSections = ListSequence.fromList(new ArrayList<Tuples._2<SNode, Integer>>());
    for (SAbstractConcept nextConcept : ListSequence.fromList(SConceptOperations.getAllSuperConcepts(concept, true))) {
      final Tuples._2<SNode, Integer> sectionPlusPriority = findDocumentationElementSingle(model, nextConcept, property);
      if (sectionPlusPriority != null) {
        ListSequence.fromList(availableSections).addElement(sectionPlusPriority);
      }
    }
    return availableSections;
  }

  private static Set<SNode> collectDocuments(final SModel model) {
    final Set<SNode> documents = SetSequence.fromSet(new HashSet<SNode>());
    SetSequence.fromSet(documents).addSequence(ListSequence.fromList(SModelOperations.nodes(model, CONCEPTS.Document$4G)));
    SetSequence.fromSet(documents).addSequence(ListSequence.fromList(SModelOperations.nodes(model, CONCEPTS.DocumentReference$n9)).select((it) -> SLinkOperations.getTarget(it, LINKS.document$$T5i)));

    final Set<SNode> allIncludedDocuments = SetSequence.fromSet(new HashSet<SNode>());
    SetSequence.fromSet(documents).visitAll((it) -> IDocumentLike__BehaviorDescriptor.collectTransitivelyIncludedDocuments_id5mf_X_LbzMD.invoke(it, allIncludedDocuments));

    final Set<SNode> res = SetSequence.fromSet(new HashSet<SNode>());
    SetSequence.fromSet(res).addSequence(Sequence.fromIterable(SNodeOperations.ofConcept(allIncludedDocuments, CONCEPTS.Document$4G)));
    return res;
  }

  private static Tuples._2<SNode, Integer> findDocumentationElementSingle(final SModel model, final SAbstractConcept concept, final SProperty property) {
    Set<SNode> documents = collectDocuments(model);
    if (property != null) {
      for (SNode item : SetSequence.fromSet(documents).translate((it) -> SNodeOperations.getNodeDescendants(it, CONCEPTS.Item$k4, false, new SAbstractConcept[]{}))) {
        for (SNode annotation : ListSequence.fromList(new IAttributeDescriptor.NodeAttribute(CONCEPTS.DocumentedPropertyItemAnnotation$D6).list(item))) {
          if (annotation != null && (boolean) AbstractConceptDeclaration__BehaviorDescriptor.is_id4MKjpUYmGW0.invoke(SLinkOperations.getTarget(annotation, LINKS.concept$eE0d), concept) && (boolean) PropertyDeclaration__BehaviorDescriptor.is_id4MKjpUYnih4.invoke(SLinkOperations.getTarget(annotation, LINKS.property$SoFM), property)) {
            return MultiTuple.<SNode,Integer>from(item, SPropertyOperations.getInteger(annotation, PROPS.priority$zmMk));
          }
        }
      }

      for (SNode section : SetSequence.fromSet(documents).translate((it) -> SNodeOperations.getNodeDescendants(it, CONCEPTS.Section$pO, false, new SAbstractConcept[]{}))) {
        for (SNode annotation : ListSequence.fromList(new IAttributeDescriptor.NodeAttribute(CONCEPTS.DocumentedPropertyAnnotation$aN).list(section))) {
          if (annotation != null && (boolean) AbstractConceptDeclaration__BehaviorDescriptor.is_id4MKjpUYmGW0.invoke(SLinkOperations.getTarget(annotation, LINKS.concept$eE0d), concept) && (boolean) PropertyDeclaration__BehaviorDescriptor.is_id4MKjpUYnih4.invoke(SLinkOperations.getTarget(annotation, LINKS.property$SoFM), property)) {
            return MultiTuple.<SNode,Integer>from(section, SPropertyOperations.getInteger(annotation, PROPS.priority$zmMk));
          }
        }
      }
    }
    for (SNode section : SetSequence.fromSet(documents).translate((it) -> SNodeOperations.getNodeDescendants(it, CONCEPTS.Section$pO, false, new SAbstractConcept[]{}))) {
      for (SNode annotation : ListSequence.fromList(new IAttributeDescriptor.NodeAttribute(CONCEPTS.DocumentedConceptAnnotation$KS).list(section))) {
        if (annotation != null && (boolean) AbstractConceptDeclaration__BehaviorDescriptor.is_id4MKjpUYmGW0.invoke(SLinkOperations.getTarget(annotation, LINKS.concept$eE0d), concept)) {
          return MultiTuple.<SNode,Integer>from(section, SPropertyOperations.getInteger(annotation, PROPS.priority$zmMk));
        }
      }
    }
    return null;
  }

  public static SNode getNodeUnderCursor(final EditorCell editorCell) {
    final SNode cellNode = editorCell.getSNode();
    final SConceptFeature feature = editorCell.getSRole();
    if (feature != null && feature instanceof SReferenceLink) {
      SNode n = cellNode;
      if (config().showReferenceConceptDocumentation()) {
        // don't follow the reference at the cursor, but show documentation for the reference node itself
        final SNode conceptDoc = getDocumentation(editorCell.getContext().getRepository(), n, null);
        if ((conceptDoc != null)) {
          return cellNode;
        }
        // if the reference concept doesn't have a documentation annotation, fall through and
        // show the target's documentation anyway
      }

      // follow the reference and show the documentation of the target node
      final SNode referenceTarget = cellNode.getReferenceTarget((SReferenceLink) feature);
      if (referenceTarget != null) {
        return referenceTarget;
      }
    }
    return cellNode;
  }

  private static IDocumentationAspectConfiguration config() {
    // one day, we might implement a more elaborated scheme of choosing the proper extension point
    Iterable<IDocumentationAspectConfiguration> extensions = Sequence.fromIterable(new ExtensionPoint<IDocumentationAspectConfiguration>("com.mbeddr.doc.aspect.documentationAspectConfiguration").getObjects()).where(new NotNullWhereFilter());
    IDocumentationAspectConfiguration config = Sequence.fromIterable(extensions).first();
    return (config != null ? config : new DefaultDocAspectConfiguration());
  }

  public static SProperty getPropertyUnderCursor(final EditorCell cell) {
    SProperty property = null;
    if (cell instanceof EditorCell_Property) {
      final EditorCell_Property propertyCell = (EditorCell_Property) cell;
      final ModelAccessor accessor = propertyCell.getModelAccessor();
      if (accessor instanceof PropertyAccessor) {
        property = ((PropertyAccessor) accessor).getProperty();
      } else if (accessor instanceof SPropertyAccessor) {
        property = ((SProperty) ReflectionUtil.readField(SPropertyAccessor.class, ((SPropertyAccessor) accessor), "myProperty"));
      }
    }
    return property;
  }

  /**
   * Retrieve annotation for a given documentationNode (e.g., a section or an item).
   */
  private static SNode getAnnotation(SNode documentationNode) {
    return Sequence.fromIterable(SNodeOperations.ofConcept(SLinkOperations.getChildren(documentationNode, LINKS.smodelAttribute$KJ43), CONCEPTS.DocumentedConceptAnnotation$KS)).first();
  }

  private static final class PROPS {
    /*package*/ static final SProperty overrideChildren$KPv9 = MetaAdapterFactory.getProperty(0x38a074ede5ad4b2dL, 0xbe31ca436911b8aaL, 0xeb09589d997ab9eL, 0x1f7086dfdce757f6L, "overrideChildren");
    /*package*/ static final SProperty priority$zmMk = MetaAdapterFactory.getProperty(0x38a074ede5ad4b2dL, 0xbe31ca436911b8aaL, 0xeb09589d997ab9eL, 0x1a1ca8925d972380L, "priority");
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept ConceptBehavior$2 = MetaAdapterFactory.getConcept(0xaf65afd8f0dd4942L, 0x87d963a55f2a9db1L, 0x11d43447b1aL, "jetbrains.mps.lang.behavior.structure.ConceptBehavior");
    /*package*/ static final SConcept ClassConcept$bK = MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c108ca66L, "jetbrains.mps.baseLanguage.structure.ClassConcept");
    /*package*/ static final SConcept Interface$db = MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101edd46144L, "jetbrains.mps.baseLanguage.structure.Interface");
    /*package*/ static final SConcept Document$4G = MetaAdapterFactory.getConcept(0x2374bc907e3741f1L, 0xa9c4c2e35194c36aL, 0x2e7fd03a4b7a1830L, "com.mbeddr.doc.structure.Document");
    /*package*/ static final SConcept DocumentReference$n9 = MetaAdapterFactory.getConcept(0x2374bc907e3741f1L, 0xa9c4c2e35194c36aL, 0x2cf291a887e8bf83L, "com.mbeddr.doc.structure.DocumentReference");
    /*package*/ static final SConcept DocumentedPropertyItemAnnotation$D6 = MetaAdapterFactory.getConcept(0x38a074ede5ad4b2dL, 0xbe31ca436911b8aaL, 0x6c647e6763ff4043L, "com.mbeddr.doc.aspect.structure.DocumentedPropertyItemAnnotation");
    /*package*/ static final SConcept Item$k4 = MetaAdapterFactory.getConcept(0x2374bc907e3741f1L, 0xa9c4c2e35194c36aL, 0x4aa4d574b7bf4724L, "com.mbeddr.doc.structure.Item");
    /*package*/ static final SConcept DocumentedPropertyAnnotation$aN = MetaAdapterFactory.getConcept(0x38a074ede5ad4b2dL, 0xbe31ca436911b8aaL, 0x1606a93812e307e0L, "com.mbeddr.doc.aspect.structure.DocumentedPropertyAnnotation");
    /*package*/ static final SConcept Section$pO = MetaAdapterFactory.getConcept(0x2374bc907e3741f1L, 0xa9c4c2e35194c36aL, 0x2e7fd03a4b7c6cc7L, "com.mbeddr.doc.structure.Section");
    /*package*/ static final SConcept DocumentedConceptAnnotation$KS = MetaAdapterFactory.getConcept(0x38a074ede5ad4b2dL, 0xbe31ca436911b8aaL, 0xeb09589d997ab9eL, "com.mbeddr.doc.aspect.structure.DocumentedConceptAnnotation");
  }

  private static final class LINKS {
    /*package*/ static final SReferenceLink concept$eE0d = MetaAdapterFactory.getReferenceLink(0x38a074ede5ad4b2dL, 0xbe31ca436911b8aaL, 0xeb09589d997ab9eL, 0xeb09589d9984aacL, "concept");
    /*package*/ static final SReferenceLink document$$T5i = MetaAdapterFactory.getReferenceLink(0x2374bc907e3741f1L, 0xa9c4c2e35194c36aL, 0x2cf291a887e8bf83L, 0x2cf291a887e8bf84L, "document");
    /*package*/ static final SReferenceLink property$SoFM = MetaAdapterFactory.getReferenceLink(0x38a074ede5ad4b2dL, 0xbe31ca436911b8aaL, 0x1606a93812e307e0L, 0x1606a93812e307ecL, "property");
    /*package*/ static final SContainmentLink smodelAttribute$KJ43 = MetaAdapterFactory.getContainmentLink(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x10802efe25aL, 0x47bf8397520e5942L, "smodelAttribute");
  }
}
