package com.mbeddr.doc.generator.template.main;

/*Generated by MPS */

import jetbrains.mps.generator.runtime.Generated;
import jetbrains.mps.generator.impl.query.QueryProviderBase;
import jetbrains.mps.generator.template.BaseMappingRuleContext;
import com.mbeddr.doc.behavior.AbstractTableParagraph__BehaviorDescriptor;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.generator.template.PropertyMacroContext;
import com.mbeddr.doc.behavior.ModelContentAsImageParagraph__BehaviorDescriptor;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import com.mbeddr.doc.behavior.Visualization__BehaviorDescriptor;
import jetbrains.mps.generator.template.ReferenceMacroContext;
import org.jetbrains.mps.openapi.model.SNode;
import com.mbeddr.doc.behavior.AbstractModelContentParagraph__BehaviorDescriptor;
import com.mbeddr.doc.behavior.IUsesExternalPath__BehaviorDescriptor;
import jetbrains.mps.generator.template.SourceSubstituteMacroNodeContext;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.generator.template.SourceSubstituteMacroNodesContext;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import jetbrains.mps.generator.template.MappingScriptContext;
import org.jetbrains.mps.openapi.module.SModule;
import jetbrains.mps.project.AbstractModule;
import com.mbeddr.mpsutil.plantuml.node.behavior.VisGraph;
import com.mbeddr.mpsutil.plantuml.node.behavior.IVisualizable__BehaviorDescriptor;
import net.sourceforge.plantuml.SourceStringReader;
import com.mbeddr.doc.behavior.PathDefinition__BehaviorDescriptor;
import java.io.File;
import com.mbeddr.doc.plugin.GenerationHelper;
import java.io.FileOutputStream;
import java.io.IOException;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.IAttributeDescriptor;
import com.mbeddr.doc.behavior.StableIdHelper;
import java.util.ArrayList;
import com.mbeddr.doc.generator.template.utils.CopyDependentDocumentsUtils;
import java.util.Objects;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import jetbrains.mps.internal.collections.runtime.Sequence;
import com.mbeddr.doc.behavior.IDocumentLike__BehaviorDescriptor;
import jetbrains.mps.textgen.trace.TracingUtil;
import org.jetbrains.mps.openapi.model.SReference;
import org.jetbrains.mps.openapi.module.SRepository;
import java.util.Map;
import java.util.stream.Collectors;
import java.util.function.Function;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import jetbrains.mps.smodel.StaticReference;
import jetbrains.mps.generator.template.InsertMacroContext;
import jetbrains.mps.generator.impl.query.ReductionRuleCondition;
import java.util.HashMap;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.generator.impl.query.QueryKey;
import jetbrains.mps.generator.template.ReductionRuleQueryContext;
import jetbrains.mps.generator.impl.GenerationFailureException;
import jetbrains.mps.generator.impl.query.MapRootRuleCondition;
import jetbrains.mps.generator.template.MapRootRuleContext;
import jetbrains.mps.generator.impl.query.ScriptCodeBlock;
import jetbrains.mps.generator.impl.query.SourceNodeQuery;
import org.jetbrains.annotations.Nullable;
import jetbrains.mps.generator.impl.query.SourceNodesQuery;
import java.util.Collection;
import jetbrains.mps.util.IterableUtil;
import jetbrains.mps.generator.impl.query.PropertyValueQuery;
import org.jetbrains.mps.openapi.language.SProperty;
import jetbrains.mps.generator.impl.query.ReferenceTargetQuery;
import jetbrains.mps.generator.impl.query.InsertMacroQuery;
import jetbrains.mps.smodel.builder.SNodeBuilder;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import org.jetbrains.mps.openapi.language.SReferenceLink;
import org.jetbrains.mps.openapi.language.SConcept;
import org.jetbrains.mps.openapi.language.SInterfaceConcept;

@Generated
public class QueriesGenerated extends QueryProviderBase {
  public QueriesGenerated() {
    super(1);
  }
  public static boolean rule_Condition_0_0(final BaseMappingRuleContext _context) {
    return (boolean) AbstractTableParagraph__BehaviorDescriptor.isEmpty_id519ky_So70O.invoke(_context.getNode());
  }
  public static boolean rule_Condition_0_1(final BaseMappingRuleContext _context) {
    return (SNodeOperations.getParent(_context.getNode()) != null);
  }
  public static boolean rule_Condition_1_0(final BaseMappingRuleContext _context) {
    return SPropertyOperations.getBoolean(_context.getNode(), PROPS.referenceOnly$1c6H);
  }
  public static boolean rule_Condition_1_1(final BaseMappingRuleContext _context) {
    return SPropertyOperations.getBoolean(_context.getNode(), PROPS.referenceOnly$1c6H);
  }
  public static Object propertyMacro_GetValue_0_0(final PropertyMacroContext _context) {
    return SPropertyOperations.getString(_context.getNode(), PROPS.text$VGzk);
  }
  public static Object propertyMacro_GetValue_0_1(final PropertyMacroContext _context) {
    return SPropertyOperations.getString(_context.getNode(), PROPS.language$VGkj);
  }
  public static Object propertyMacro_GetValue_0_2(final PropertyMacroContext _context) {
    return SPropertyOperations.getString(_context.getNode(), PROPS.language$c4tN);
  }
  public static Object propertyMacro_GetValue_0_3(final PropertyMacroContext _context) {
    return SPropertyOperations.getString(_context.getNode(), PROPS.text$c4eM);
  }
  public static Object propertyMacro_GetValue_0_4(final PropertyMacroContext _context) {
    return ModelContentAsImageParagraph__BehaviorDescriptor.uniqueName_id627_yy34GmM.invoke(_context.getNode()) + ".png";
  }
  public static Object propertyMacro_GetValue_0_5(final PropertyMacroContext _context) {
    return SPropertyOperations.getString(_context.getNode(), PROPS.name$MnvL);
  }
  public static Object propertyMacro_GetValue_1_0(final PropertyMacroContext _context) {
    return SPropertyOperations.getString(SLinkOperations.getTarget(SLinkOperations.getTarget(_context.getNode(), LINKS.ref$ki8k), LINKS.doc$bvgi), PROPS.name$MnvL);
  }
  public static Object propertyMacro_GetValue_1_1(final PropertyMacroContext _context) {
    return SPropertyOperations.getString(SLinkOperations.getTarget(SLinkOperations.getTarget(_context.getNode(), LINKS.ref$ki8k), LINKS.doc$bvgi), PROPS.name$MnvL);
  }
  public static Object propertyMacro_GetValue_3_0(final PropertyMacroContext _context) {
    return Visualization__BehaviorDescriptor.filenameWithoutExtension_id2fGuOSYbw1y.invoke(_context.getNode()) + ".png";
  }
  public static Object propertyMacro_GetValue_3_1(final PropertyMacroContext _context) {
    return SPropertyOperations.getString(_context.getNode(), PROPS.name$MnvL);
  }
  public static Object propertyMacro_GetValue_7_0(final PropertyMacroContext _context) {
    return SPropertyOperations.getString(SLinkOperations.getTarget(SLinkOperations.getTarget(_context.getNode(), LINKS.ref$ki8k), LINKS.doc$bvgi), PROPS.name$MnvL);
  }
  public static Object referenceMacro_GetReferent_0_0(final ReferenceMacroContext _context) {
    return (SNode) AbstractModelContentParagraph__BehaviorDescriptor.targetNode_id627_yy34GnC.invoke(_context.getNode());
  }
  public static Object referenceMacro_GetReferent_0_1(final ReferenceMacroContext _context) {
    return (SNode) IUsesExternalPath__BehaviorDescriptor.getPath_id3UlEobTHU0G.invoke(_context.getNode());
  }
  public static Object referenceMacro_GetReferent_0_2(final ReferenceMacroContext _context) {
    return _context.getOriginalCopiedInputNode(AbstractModelContentParagraph__BehaviorDescriptor.targetNode_id627_yy34GnC.invoke(_context.getNode()));
  }
  public static Object referenceMacro_GetReferent_1_0(final ReferenceMacroContext _context) {
    return _context.getOutputNodeByInputNodeAndMappingLabel(_context.getNode(), "exportedDoc");
  }
  public static Object referenceMacro_GetReferent_3_0(final ReferenceMacroContext _context) {
    return (SNode) IUsesExternalPath__BehaviorDescriptor.getPath_id3UlEobTHU0G.invoke(_context.getNode());
  }
  public static Object referenceMacro_GetReferent_7_0(final ReferenceMacroContext _context) {
    return SLinkOperations.getTarget(SLinkOperations.getTarget(_context.getNode(), LINKS.ref$ki8k), LINKS.doc$bvgi);
  }
  public static SNode sourceNodeQuery_0_0(final SourceSubstituteMacroNodeContext _context) {
    SNode w = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0x2374bc907e3741f1L, 0xa9c4c2e35194c36aL, 0x3ddc39046e39ec19L, "com.mbeddr.doc.structure.CompositeWord"));
    List<SNode> originalWords = SLinkOperations.getChildren(SLinkOperations.getTarget(SLinkOperations.getTarget(SLinkOperations.getTarget(_context.getNode(), LINKS.shortcut$25ai), LINKS.text$5l1C), LINKS.text$ls7a), LINKS.words$C8QZ);
    for (SNode ow : ListSequence.fromList(originalWords)) {
      if (SNodeOperations.isInstanceOf(ow, CONCEPTS.ShortcutArgRef$g8)) {
        int i = SNodeOperations.getIndexInParent(SLinkOperations.getTarget(SNodeOperations.cast(ow, CONCEPTS.ShortcutArgRef$g8), LINKS.arg$yPNN));
        SNode replacement = ListSequence.fromList(SLinkOperations.getChildren(_context.getNode(), LINKS.args$tEuU)).getElement(i);
        ListSequence.fromList(SLinkOperations.getChildren(w, LINKS.words$urNi)).addElement(SNodeOperations.copyNode(replacement));
      } else {
        ListSequence.fromList(SLinkOperations.getChildren(w, LINKS.words$urNi)).addElement(SNodeOperations.copyNode(ow));
      }
    }
    return w;
  }
  public static SNode sourceNodeQuery_0_1(final SourceSubstituteMacroNodeContext _context) {
    return SLinkOperations.getTarget(_context.getNode(), LINKS.description$c3kb);
  }
  public static SNode sourceNodeQuery_0_2(final SourceSubstituteMacroNodeContext _context) {
    return SLinkOperations.getTarget(_context.getNode(), LINKS.sizeSpec$c3zc);
  }
  public static SNode sourceNodeQuery_3_0(final SourceSubstituteMacroNodeContext _context) {
    return SLinkOperations.getTarget(_context.getNode(), LINKS.description$OSkU);
  }
  public static SNode sourceNodeQuery_3_1(final SourceSubstituteMacroNodeContext _context) {
    return SLinkOperations.getTarget(_context.getNode(), LINKS.sizeSpec$Rmer);
  }
  public static Iterable<SNode> sourceNodesQuery_7_0(final SourceSubstituteMacroNodesContext _context) {
    SNode docExport = ListSequence.fromList(SModelOperations.nodes(_context.getInputModel(), CONCEPTS.DocumentExport$bq)).first();
    return SLinkOperations.getChildren(docExport, LINKS.mappings$1cg0);
  }
  public static void mappingScript_CodeBlock_2(final MappingScriptContext _context) {
    SModule module = _context.getOriginalInputModel().getModule();
    AbstractModule m = (AbstractModule) module;

    for (SNode v : ListSequence.fromList(SModelOperations.nodes(_context.getOriginalInputModel(), CONCEPTS.Visualization$hS))) {
      VisGraph g = new VisGraph();
      IVisualizable__BehaviorDescriptor.getVisualization_id2N1CSrzPN_f.invoke(Visualization__BehaviorDescriptor.getVisualizableElement_id5MdJlxzHH5Y.invoke(v), SPropertyOperations.getString(v, PROPS.category$ORQS), g);
      if (g != null) {
        try {
          SNode path = IUsesExternalPath__BehaviorDescriptor.getPath_id3UlEobTHU0G.invoke(v);
          SourceStringReader reader = new SourceStringReader(g.toString());
          PathDefinition__BehaviorDescriptor.ensurePathExists_id3$JYbdolVFS.invoke(path);
          File docGenFolder = GenerationHelper.getDocGenFolder(m);
          if (docGenFolder != null) {
            File fullPath = new File(docGenFolder, SPropertyOperations.getString(SLinkOperations.getTarget(path, LINKS.pathPicker$QPZE), PROPS.path$VaYg));
            fullPath.mkdirs();
            File outputFile = new File(fullPath, Visualization__BehaviorDescriptor.filenameWithoutExtension_id2fGuOSYbw1y.invoke(v) + ".png");
            reader.generateImage(new FileOutputStream(outputFile));
          }
        } catch (IOException ex) {
          ex.printStackTrace();
        }
      }
    }
  }
  public static void mappingScript_CodeBlock_5(final MappingScriptContext _context) {

    SModule module = _context.getOriginalInputModel().getModule();
    if (module instanceof AbstractModule) {
      AbstractModule m = (AbstractModule) module;
      for (SNode doc : ListSequence.fromList(SModelOperations.nodes(_context.getModel(), CONCEPTS.Document$4G)).where((it) -> (new IAttributeDescriptor.NodeAttribute(CONCEPTS.PlaceInFolder$Xz).get(it) == null))) {
        File outputLocation = GenerationHelper.getOutputLocation(m, doc);
        if (outputLocation != null) {
          new IAttributeDescriptor.NodeAttribute(CONCEPTS.PlaceInFolder$Xz).set(doc, createPlaceInFolder_x583g4_a0a0b0b0c0db(outputLocation.getAbsolutePath()));
        }
      }
      for (SNode refWord : ListSequence.fromList(SModelOperations.nodes(_context.getModel(), CONCEPTS.AbstractRefWord$4E)).where((it) -> (new IAttributeDescriptor.NodeAttribute(CONCEPTS.PlaceInFolder$Xz).get(it) == null))) {
        File outputLocation = GenerationHelper.getOutputLocation(m, refWord);
        if (outputLocation != null) {
          new IAttributeDescriptor.NodeAttribute(CONCEPTS.PlaceInFolder$Xz).set(refWord, createPlaceInFolder_x583g4_a0a0b0c0c0db(outputLocation.getAbsolutePath()));
        }
      }
      File docGenFolder = GenerationHelper.getDocGenFolder(m);
      if (docGenFolder != null) {
        for (SNode imgParagraph : ListSequence.fromList(SModelOperations.nodes(_context.getModel(), CONCEPTS.ImageParagraph$7j))) {
          if ((new IAttributeDescriptor.NodeAttribute(CONCEPTS.PlaceInFolder$Xz).get(imgParagraph) == null)) {
            String subpath = SPropertyOperations.getString(SLinkOperations.getTarget(IUsesExternalPath__BehaviorDescriptor.getPath_id3UlEobTHU0G.invoke(imgParagraph), LINKS.pathPicker$QPZE), PROPS.path$VaYg);
            if (subpath == null) {
              throw new IllegalStateException("null path for image " + SNodeOperations.getPointer(imgParagraph));
            }
            File imgPath = new File(docGenFolder, subpath);
            new IAttributeDescriptor.NodeAttribute(CONCEPTS.PlaceInFolder$Xz).set(imgParagraph, createPlaceInFolder_x583g4_a0d0a0a0e0c0db(imgPath.getAbsolutePath()));
          }
        }
      }
    } else {
      _context.showErrorMessage(null, "Module is not a AbstractModule");
    }

    for (SNode cc : ListSequence.fromList(SModelOperations.nodes(_context.getModel(), CONCEPTS.ModelContentAsImageParagraph$vS))) {

      if (isEmptyString(SPropertyOperations.getString(SLinkOperations.getTarget(IUsesExternalPath__BehaviorDescriptor.getPath_id3UlEobTHU0G.invoke(cc), LINKS.pathPicker$QPZE), PROPS.path$VaYg))) {
        _context.showErrorMessage(_context.getOriginalCopiedInputNode(SLinkOperations.getTarget(SNodeOperations.getNodeAncestor(cc, CONCEPTS.IDocumentLike$h$, false, false), LINKS.config$bNXi)), "Configuration for default temp path is missing");
        continue;
      }
      if (module instanceof AbstractModule) {
        AbstractModule m = (AbstractModule) module;
        File docGenFolder = GenerationHelper.getDocGenFolder(m);
        if (docGenFolder != null) {
          File defaultImages = new File(docGenFolder, SPropertyOperations.getString(SLinkOperations.getTarget(IUsesExternalPath__BehaviorDescriptor.getPath_id3UlEobTHU0G.invoke(cc), LINKS.pathPicker$QPZE), PROPS.path$VaYg));
          new IAttributeDescriptor.NodeAttribute(CONCEPTS.PlaceInFolder$Xz).set(cc, createPlaceInFolder_x583g4_a0b0c0c0e0db(defaultImages.getAbsolutePath()));
          SNode ccCopy = SNodeOperations.copyNode(cc);
          SPropertyOperations.assign(ccCopy, PROPS.name$MnvL, ModelContentAsImageParagraph__BehaviorDescriptor.uniqueName_id627_yy34GmM.invoke(cc));
          SModelOperations.addRootNode(_context.getModel(), ccCopy);
        }
      } else {
        _context.showErrorMessage(cc, "Module is not a AbstractModule");
      }
    }
  }
  public static void mappingScript_CodeBlock_6(final MappingScriptContext _context) {
    ListSequence.fromList(SModelOperations.nodesIncludingImported(_context.getModel(), CONCEPTS.IDocReferencable$kt)).visitAll((it) -> StableIdHelper.setStableId(it));
  }
  public static void mappingScript_CodeBlock_9(final MappingScriptContext _context) {
    List<SNode> dependentDocuments = new ArrayList<SNode>();
    CopyDependentDocumentsUtils.collectDependentDocuments(SModelOperations.roots(_context.getModel(), CONCEPTS.Document$4G), dependentDocuments);

    List<SNode> copiedDocuments = _context.copyWithTrace(ListSequence.fromList(dependentDocuments).where((it) -> !(ListSequence.fromList(SModelOperations.roots(_context.getModel(), CONCEPTS.Document$4G)).contains(it))).toList());
    for (SNode d : ListSequence.fromList(copiedDocuments)) {
      SModelOperations.addRootNode(_context.getModel(), d);
    }

    // fix references to sections
    for (SNode sr : ListSequence.fromList(SModelOperations.nodes(_context.getModel(), CONCEPTS.SectRefWord$rj))) {
      if (!(Objects.equals(SNodeOperations.getModel(SLinkOperations.getTarget(sr, LINKS.target$G2cK)), _context.getModel()))) {
        final String nameOfReferencedSection = SPropertyOperations.getString(SLinkOperations.getTarget(sr, LINKS.target$G2cK), PROPS.name$MnvL);
        final String nameOfReferencedDoc = SPropertyOperations.getString(SNodeOperations.getNodeAncestor(SLinkOperations.getTarget(sr, LINKS.target$G2cK), CONCEPTS.Document$4G, false, false), PROPS.name$MnvL);
        SNode doc = ListSequence.fromList(SModelOperations.roots(_context.getModel(), CONCEPTS.Document$4G)).findFirst((it) -> SPropertyOperations.getString(it, PROPS.name$MnvL).equals(nameOfReferencedDoc));
        SNode sec;
        sec = ListSequence.fromList(SNodeOperations.getNodeDescendants(doc, CONCEPTS.AbstractSection$8m, false, new SAbstractConcept[]{})).findFirst((it) -> SPropertyOperations.getString(it, PROPS.name$MnvL).equals(nameOfReferencedSection));
        SLinkOperations.setTarget(sr, LINKS.target$G2cK, sec);
      }
    }

    // fix references to docs
    Set<SNode> docs = SetSequence.fromSet(new HashSet<SNode>());
    for (final SNode sr : ListSequence.fromList(SModelOperations.nodes(_context.getModel(), CONCEPTS.DocRefWord$1F))) {
      if (!(Objects.equals(SNodeOperations.getModel(SLinkOperations.getTarget(sr, LINKS.target$aemi)), _context.getModel()))) {
        SLinkOperations.setTarget(sr, LINKS.target$aemi, ListSequence.fromList(SModelOperations.roots(_context.getModel(), CONCEPTS.Document$4G)).findFirst((it) -> SPropertyOperations.getString(it, PROPS.name$MnvL).equals(SPropertyOperations.getString(SLinkOperations.getTarget(sr, LINKS.target$aemi), PROPS.name$MnvL))));
        SetSequence.fromSet(docs).addElement(SLinkOperations.getTarget(sr, LINKS.target$aemi));
      }
    }
    for (final SNode doc : SetSequence.fromSet(docs)) {
      if (!(ListSequence.fromList(SModelOperations.roots(_context.getModel(), CONCEPTS.AbstractExport$TZ)).any((it) -> Objects.equals(SLinkOperations.getTarget(SLinkOperations.getTarget(it, LINKS.root$175E), LINKS.doc$bvgi), doc)))) {
        SNode ie = createIncludableExport_x583g4_a0a0a0m0fb(SPropertyOperations.getString(doc, PROPS.name$MnvL), doc, SNodeOperations.copyNode(SLinkOperations.getTarget(ListSequence.fromList(SModelOperations.nodes(_context.getInputModel(), CONCEPTS.DocumentExport$bq)).first(), LINKS.renderer$16BC)), ListSequence.fromList(SLinkOperations.getChildren(ListSequence.fromList(SModelOperations.nodes(_context.getInputModel(), CONCEPTS.DocumentExport$bq)).first(), LINKS.mappings$1cg0)).select((it) -> SNodeOperations.copyNode(it)));
        SModelOperations.addRootNode(_context.getModel(), ie);
      }
    }

    // fix references to documents
    for (SNode dr : ListSequence.fromList(SModelOperations.nodes(_context.getModel(), CONCEPTS.DocumentRef$zv))) {
      if (!(Objects.equals(SNodeOperations.getModel(SLinkOperations.getTarget(dr, LINKS.doc$bvgi)), _context.getModel()))) {
        final String nameOfReferencedDoc = SPropertyOperations.getString(SLinkOperations.getTarget(dr, LINKS.doc$bvgi), PROPS.name$MnvL);
        SNode doc = ListSequence.fromList(SModelOperations.roots(_context.getModel(), CONCEPTS.Document$4G)).findFirst((it) -> SPropertyOperations.getString(it, PROPS.name$MnvL).equals(nameOfReferencedDoc));
        SLinkOperations.setTarget(dr, LINKS.doc$bvgi, doc);
      }
    }
  }
  public static void mappingScript_CodeBlock_10(final MappingScriptContext _context) {
    /*
      Inverse topologically sorted iteration is imported here. We want to start including from the 
      leaf towards the root to be able to include a document multiple times.

    */

    ListSequence.fromList(SModelOperations.nodes(_context.getModel(), CONCEPTS.AbstractExport$TZ)).visitAll((export) -> Sequence.fromIterable(SNodeOperations.ofConcept(ListSequence.fromList(IDocumentLike__BehaviorDescriptor.getTopologicalSortedDocuments_id3lxJBjijN4E.invoke(SLinkOperations.getTarget(SLinkOperations.getTarget(export, LINKS.root$175E), LINKS.doc$bvgi))).reversedList(), CONCEPTS.Document$4G)).visitAll((final SNode document) -> ListSequence.fromList(SNodeOperations.getNodeDescendants(document, CONCEPTS.DocumentInclude$8j, false, new SAbstractConcept[]{})).visitAll((final SNode include) -> {
      List<SNode> inlcudedContent = SLinkOperations.getChildren(SLinkOperations.getTarget(SLinkOperations.getTarget(include, LINKS.ref$ki8k), LINKS.doc$bvgi), LINKS.contents$e7kB);
      List<SNode> includedContentCopy = TracingUtil.copyWithTrace(inlcudedContent);
      ListSequence.fromList(includedContentCopy).visitAll((newContent) -> SNodeOperations.insertPrevSiblingChild(include, newContent));

      /*
        The part below is responsible for updating references. 
        
        Copy with trace takes care of updating the references in the nodes that part of the copy operation. 
        This means that when we copy content of the included document into the including document
        all reference internally are updated. For instance if we copy two sections where one references the 
        other the references in the copy point to copy as well. 
        In some scenarios this isn't enough because the document we are including into might have references 
        into the included document as well. 
        For instance a section of the included document is referenced inside of text in the including document. 
        This code takes care of updating these.
        
        To do so it uses the generator trace api.
        First we collect all references in the current document, then we collect all referencable content 
        (everything extending AbstractSection) in the included document as well as the copy of if. 
        To identify if a reference needs an update the generator trace api is used. If a in the
        including document points to something we included the generator trace api is used to
        identify the copy. 
        The copy is identified as such when its original node (the one in the input model) is the same 
        as the input node for included content.
        This way we don't depend on any naming schema or scopes from the language itself. 
        
        The only limitation is that if one document is included twice into an including document
        this code will point all references to first include.

      */



      Iterable<SReference> allReferencesIntoOtherDocs = ListSequence.fromList(SNodeOperations.getNodeDescendants(document, null, true, new SAbstractConcept[]{})).translate((it) -> SNodeOperations.getReferences(it)).where((it) -> SNodeOperations.isInstanceOf(SNodeOperations.getContainingRoot(SLinkOperations.getTargetNode(it)), CONCEPTS.Document$4G) && !(Objects.equals(SNodeOperations.getContainingRoot(SLinkOperations.getTargetNode(it)), document)));

      final SRepository repository = _context.getOriginalInputModel().getRepository();

      final Map<SNode, SNode> documentContentByOriginalNode = SNodeOperations.getNodeDescendants(document, CONCEPTS.AbstractSection$8m, false, new SAbstractConcept[]{}).stream().collect(Collectors.<SNode,SNode,SNode>toMap((SNode n) -> ((SNode) TracingUtil.getInputNode(n, repository)), Function.<SNode>identity()));
      Sequence.fromIterable(allReferencesIntoOtherDocs).visitAll((reference) -> {
        SNode inputOfReference = TracingUtil.getInputNode(SLinkOperations.getTargetNode(reference), repository);
        SNode copyInDoc = MapSequence.fromMap(documentContentByOriginalNode).get(inputOfReference);
        if ((copyInDoc != null)) {
          as_x583g4_a0a0a2a0a0m0a0a0a0a0a0a0a1a23(reference, StaticReference.class).setTargetNodeId(copyInDoc.getNodeId());
        }
      });
      SNodeOperations.deleteNode(include);
    })));

    /*
      Documents that aren't used in any export and not listed in the dependent documents are considered obsolete and deleted as well
      as their depends on references.

    */

    final List<SNode> dependentDocuments = new ArrayList<SNode>();
    CopyDependentDocumentsUtils.collectDependentDocuments(SModelOperations.roots(_context.getModel(), CONCEPTS.Document$4G), dependentDocuments);

    ListSequence.fromList(SModelOperations.roots(_context.getModel(), CONCEPTS.Document$4G)).where((final SNode document) -> !(ListSequence.fromList(SModelOperations.nodes(_context.getModel(), CONCEPTS.AbstractExport$TZ)).any((export) -> Objects.equals(SLinkOperations.getTarget(SLinkOperations.getTarget(export, LINKS.root$175E), LINKS.doc$bvgi), document)))).visitAll((final SNode document) -> {
      Iterable<SNode> dependsRefs = ListSequence.fromList(SModelOperations.nodes(_context.getModel(), CONCEPTS.DocumentRef$zv)).where((ref) -> (Objects.equals(SLinkOperations.getTarget(ref, LINKS.doc$bvgi), document)) && (Objects.equals(SNodeOperations.getContainingLink(ref), LINKS.dependsOn$QZv7)));
      Sequence.fromIterable(dependsRefs).visitAll((ref) -> SNodeOperations.deleteNode(ref));
      if (!(ListSequence.fromList(dependentDocuments).contains(document))) {
        SNodeOperations.deleteNode(document);
      }
    });
  }
  public static SNode insertMacro_Query_7_0(final InsertMacroContext _context) {
    SNode documentExport = ListSequence.fromList(SModelOperations.nodes(_context.getInputModel(), CONCEPTS.DocumentExport$bq)).first();
    return SNodeOperations.copyNode(SLinkOperations.getTarget(documentExport, LINKS.renderer$16BC));
  }
  public static SNode insertMacro_Query_7_1(final InsertMacroContext _context) {
    SNode documentExport = ListSequence.fromList(SModelOperations.nodes(_context.getInputModel(), CONCEPTS.DocumentExport$bq)).first();
    return SNodeOperations.copyNode(SLinkOperations.getTarget(documentExport, LINKS.renderer$16BC));
  }
  private final Map<String, ReductionRuleCondition> rrcMethods = new HashMap<String, ReductionRuleCondition>();
  {
    int i = 0;
    rrcMethods.put("5785245534400832627", new RRC(i++));
    rrcMethods.put("2726240646375887014", new RRC(i++));
    rrcMethods.put("3041989355253122955", new RRC(i++));
  }
  @Override
  @NotNull
  public ReductionRuleCondition getReductionRuleCondition(@NotNull QueryKey identity) {
    ReductionRuleCondition query = identity.forTemplateNode(rrcMethods);
    return (query != null ? query : super.getReductionRuleCondition(identity));
  }
  private static class RRC implements ReductionRuleCondition {
    private final int methodKey;
    public RRC(int methodKey) {
      this.methodKey = methodKey;
    }
    @Override
    public boolean check(ReductionRuleQueryContext ctx) throws GenerationFailureException {
      switch (methodKey) {
        case 0:
          return QueriesGenerated.rule_Condition_0_0(ctx);
        case 1:
          return QueriesGenerated.rule_Condition_0_1(ctx);
        case 2:
          return QueriesGenerated.rule_Condition_1_1(ctx);
        default:
          throw new GenerationFailureException(String.format("Inconsistent QueriesGenerated: there's no condition method for rule %s (key: #%d)", ctx.getTemplateReference(), methodKey));
      }
    }
  }
  private final Map<String, MapRootRuleCondition> mrrcMethods = new HashMap<String, MapRootRuleCondition>();
  {
    int i = 0;
    mrrcMethods.put("3041989355253018084", new MRRC(i++));
  }
  @Override
  @NotNull
  public MapRootRuleCondition getMapRootRuleCondition(@NotNull QueryKey identity) {
    MapRootRuleCondition query = identity.forTemplateNode(mrrcMethods);
    return (query != null ? query : super.getMapRootRuleCondition(identity));
  }
  private static class MRRC implements MapRootRuleCondition {
    private final int methodKey;
    public MRRC(int methodKey) {
      this.methodKey = methodKey;
    }
    @Override
    public boolean check(@NotNull MapRootRuleContext ctx) throws GenerationFailureException {
      switch (methodKey) {
        case 0:
          return QueriesGenerated.rule_Condition_1_0(ctx);
        default:
          throw new GenerationFailureException(String.format("Inconsistent QueriesGenerated: there's no condition method for rule %s (key: #%d)", ctx.getTemplateReference(), methodKey));
      }
    }
  }
  private final Map<String, ScriptCodeBlock> mscbMethods = new HashMap<String, ScriptCodeBlock>();
  {
    int i = 0;
    mscbMethods.put("2588579461812124644", new SCB(i++));
    mscbMethods.put("6416473402306272609", new SCB(i++));
    mscbMethods.put("7265063483910856998", new SCB(i++));
    mscbMethods.put("5577575444494019699", new SCB(i++));
    mscbMethods.put("7842584090752203339", new SCB(i++));
  }
  @Override
  @NotNull
  public ScriptCodeBlock getScriptCodeBlock(@NotNull QueryKey identity) {
    ScriptCodeBlock query = identity.forTemplateNode(mscbMethods);
    return (query != null ? query : super.getScriptCodeBlock(identity));
  }
  private static class SCB implements ScriptCodeBlock {
    private final int methodKey;
    public SCB(int methodKey) {
      this.methodKey = methodKey;
    }
    @Override
    public void invoke(MappingScriptContext ctx) throws GenerationFailureException {
      switch (methodKey) {
        case 0:
          QueriesGenerated.mappingScript_CodeBlock_2(ctx);
          return;
        case 1:
          QueriesGenerated.mappingScript_CodeBlock_5(ctx);
          return;
        case 2:
          QueriesGenerated.mappingScript_CodeBlock_6(ctx);
          return;
        case 3:
          QueriesGenerated.mappingScript_CodeBlock_9(ctx);
          return;
        case 4:
          QueriesGenerated.mappingScript_CodeBlock_10(ctx);
          return;
        default:
          throw new GenerationFailureException(String.format("There's no code block with method index %d ", methodKey));
      }
    }
  }
  private final Map<String, SourceNodeQuery> snqMethods = new HashMap<String, SourceNodeQuery>();
  {
    int i = 0;
    snqMethods.put("4457500422381876105", new SNQ(i++));
    snqMethods.put("2726240646375887120", new SNQ(i++));
    snqMethods.put("1373401575436372259", new SNQ(i++));
    snqMethods.put("4755612053022500283", new SNQ(i++));
    snqMethods.put("4317007310193518793", new SNQ(i++));
  }
  @NotNull
  @Override
  public SourceNodeQuery getSourceNodeQuery(@NotNull QueryKey identity) {
    SourceNodeQuery query = identity.forFunctionNode(snqMethods);
    return (query != null ? query : super.getSourceNodeQuery(identity));
  }
  private static class SNQ implements SourceNodeQuery {
    private final int methodKey;
    public SNQ(int methodKey) {
      this.methodKey = methodKey;
    }
    @Nullable
    public SNode evaluate(@NotNull SourceSubstituteMacroNodeContext ctx) throws GenerationFailureException {
      switch (methodKey) {
        case 0:
          return QueriesGenerated.sourceNodeQuery_0_0(ctx);
        case 1:
          return QueriesGenerated.sourceNodeQuery_0_1(ctx);
        case 2:
          return QueriesGenerated.sourceNodeQuery_0_2(ctx);
        case 3:
          return QueriesGenerated.sourceNodeQuery_3_0(ctx);
        case 4:
          return QueriesGenerated.sourceNodeQuery_3_1(ctx);
        default:
          throw new GenerationFailureException(String.format("Inconsistent QueriesGenerated: there's no method for query %s (key: #%d)", ctx.getTemplateReference(), methodKey));
      }
    }
  }
  private final Map<String, SourceNodesQuery> snsqMethods = new HashMap<String, SourceNodesQuery>();
  {
    int i = 0;
    snsqMethods.put("7065386739685267010", new SNsQ(i++));
  }
  @NotNull
  @Override
  public SourceNodesQuery getSourceNodesQuery(@NotNull QueryKey identity) {
    SourceNodesQuery query = identity.forFunctionNode(snsqMethods);
    return (query != null ? query : super.getSourceNodesQuery(identity));
  }
  private static class SNsQ implements SourceNodesQuery {
    private final int methodKey;
    public SNsQ(int methodKey) {
      this.methodKey = methodKey;
    }
    @NotNull
    public Collection<SNode> evaluate(@NotNull SourceSubstituteMacroNodesContext ctx) throws GenerationFailureException {
      switch (methodKey) {
        case 0:
          return IterableUtil.asCollection(QueriesGenerated.sourceNodesQuery_7_0(ctx));
        default:
          throw new GenerationFailureException(String.format("Inconsistent QueriesGenerated: there's no method for query %s (key: #%d)", ctx.getTemplateReference(), methodKey));
      }
    }
  }
  private final Map<String, PropertyValueQuery> pvqMethods = new HashMap<String, PropertyValueQuery>();
  {
    int i = 0;
    pvqMethods.put("4755612053022284362", new PVQ(i++, MetaAdapterFactory.getProperty(0x2374bc907e3741f1L, 0xa9c4c2e35194c36aL, 0x558f97d9712f45d3L, 0x558f97d9712f45d4L, "text"), "code"));
    pvqMethods.put("4755612053022284369", new PVQ(i++, MetaAdapterFactory.getProperty(0x2374bc907e3741f1L, 0xa9c4c2e35194c36aL, 0x558f97d9712f45d3L, 0x558f97d9712f45d5L, "language"), "mbeddr"));
    pvqMethods.put("4640492444886553894", new PVQ(i++, MetaAdapterFactory.getProperty(0x2374bc907e3741f1L, 0xa9c4c2e35194c36aL, 0x558f97d9712f45d3L, 0x558f97d9712f45d5L, "language"), "mbeddr"));
    pvqMethods.put("4640492444886554751", new PVQ(i++, MetaAdapterFactory.getProperty(0x2374bc907e3741f1L, 0xa9c4c2e35194c36aL, 0x558f97d9712f45d3L, 0x558f97d9712f45d4L, "text"), "text"));
    pvqMethods.put("2726240646375887083", new PVQ(i++, MetaAdapterFactory.getProperty(0x2374bc907e3741f1L, 0xa9c4c2e35194c36aL, 0x58a16bfbe08f3ebfL, 0x58a16bfbe08f3ec0L, "fileName"), "var"));
    pvqMethods.put("2726240646375887103", new PVQ(i++, MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name"), "img"));
    pvqMethods.put("3041989355253879527", new PVQ(i++, MetaAdapterFactory.getProperty(0x2374bc907e3741f1L, 0xa9c4c2e35194c36aL, 0x2e7fd03a4b7c6bdeL, 0x2e7fd03a4b7c6be1L, "text"), "docName"));
    pvqMethods.put("3041989355253891528", new PVQ(i++, MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name"), "docName"));
    pvqMethods.put("4755612053022495346", new PVQ(i++, MetaAdapterFactory.getProperty(0x2374bc907e3741f1L, 0xa9c4c2e35194c36aL, 0x58a16bfbe08f3ebfL, 0x58a16bfbe08f3ec0L, "fileName"), "var"));
    pvqMethods.put("4755612053022495296", new PVQ(i++, MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name"), "img"));
    pvqMethods.put("3041989355254006096", new PVQ(i++, MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name"), "IncludedDocument"));
  }
  @NotNull
  @Override
  public PropertyValueQuery getPropertyValueQuery(@NotNull QueryKey identity) {
    PropertyValueQuery query = identity.forTemplateNode(pvqMethods);
    return (query != null ? query : super.getPropertyValueQuery(identity));
  }
  private static class PVQ extends PropertyValueQuery.Base {
    private final int methodKey;
    /*package*/ PVQ(int methodKey, SProperty property, String templateValue) {
      super(property, templateValue);
      this.methodKey = methodKey;
    }
    @Nullable
    public Object evaluate(@NotNull PropertyMacroContext ctx) throws GenerationFailureException {
      switch (methodKey) {
        case 0:
          return QueriesGenerated.propertyMacro_GetValue_0_0(ctx);
        case 1:
          return QueriesGenerated.propertyMacro_GetValue_0_1(ctx);
        case 2:
          return QueriesGenerated.propertyMacro_GetValue_0_2(ctx);
        case 3:
          return QueriesGenerated.propertyMacro_GetValue_0_3(ctx);
        case 4:
          return QueriesGenerated.propertyMacro_GetValue_0_4(ctx);
        case 5:
          return QueriesGenerated.propertyMacro_GetValue_0_5(ctx);
        case 6:
          return QueriesGenerated.propertyMacro_GetValue_1_0(ctx);
        case 7:
          return QueriesGenerated.propertyMacro_GetValue_1_1(ctx);
        case 8:
          return QueriesGenerated.propertyMacro_GetValue_3_0(ctx);
        case 9:
          return QueriesGenerated.propertyMacro_GetValue_3_1(ctx);
        case 10:
          return QueriesGenerated.propertyMacro_GetValue_7_0(ctx);
        default:
          throw new GenerationFailureException(String.format("Inconsistent QueriesGenerated: there's no method for query %s (key: #%d)", ctx.getTemplateReference(), methodKey));
      }
    }
  }
  private final Map<String, ReferenceTargetQuery> rtqMethods = new HashMap<String, ReferenceTargetQuery>();
  {
    rtqMethods.put("2587259889031988989", new RTQ(0, null));
    rtqMethods.put("2726240646375887076", new RTQ(1, "p"));
    rtqMethods.put("2587259889034491533", new RTQ(2, null));
    rtqMethods.put("3041989355253515562", new RTQ(3, null));
    rtqMethods.put("4755612053022495314", new RTQ(4, "p"));
    rtqMethods.put("3041989355253070721", new RTQ(5, null));
  }
  @NotNull
  @Override
  public ReferenceTargetQuery getReferenceTargetQuery(@NotNull QueryKey queryKey) {
    ReferenceTargetQuery query = queryKey.forTemplateNode(rtqMethods);
    return (query != null ? query : super.getReferenceTargetQuery(queryKey));
  }
  private static class RTQ extends ReferenceTargetQuery.Base {
    private final int methodKey;
    /*package*/ RTQ(int methodKey, String templateValue) {
      super(templateValue);
      this.methodKey = methodKey;
    }
    @Nullable
    public Object evaluate(@NotNull ReferenceMacroContext ctx) throws GenerationFailureException {
      switch (methodKey) {
        case 0:
          return QueriesGenerated.referenceMacro_GetReferent_0_0(ctx);
        case 1:
          return QueriesGenerated.referenceMacro_GetReferent_0_1(ctx);
        case 2:
          return QueriesGenerated.referenceMacro_GetReferent_0_2(ctx);
        case 3:
          return QueriesGenerated.referenceMacro_GetReferent_1_0(ctx);
        case 4:
          return QueriesGenerated.referenceMacro_GetReferent_3_0(ctx);
        case 5:
          return QueriesGenerated.referenceMacro_GetReferent_7_0(ctx);
        default:
          throw new GenerationFailureException(String.format("Inconsistent QueriesGenerated: there's no method for query %s (key: #%d)", ctx.getTemplateReference(), methodKey));
      }
    }
  }
  private final Map<String, InsertMacroQuery> imqMethods = new HashMap<String, InsertMacroQuery>();
  {
    imqMethods.put("3041989355253027214", new IMQ(0));
    imqMethods.put("3041989355253069916", new IMQ(1));
  }
  @NotNull
  @Override
  public InsertMacroQuery getInsertMacroQuery(@NotNull QueryKey queryKey) {
    InsertMacroQuery query = queryKey.forTemplateNode(imqMethods);
    return (query != null ? query : super.getInsertMacroQuery(queryKey));
  }
  private static class IMQ implements InsertMacroQuery {
    private final int methodKey;
    /*package*/ IMQ(int methodKey) {
      this.methodKey = methodKey;
    }
    @Nullable
    public SNode evaluate(@NotNull InsertMacroContext ctx) throws GenerationFailureException {
      switch (methodKey) {
        case 0:
          return QueriesGenerated.insertMacro_Query_7_0(ctx);
        case 1:
          return QueriesGenerated.insertMacro_Query_7_1(ctx);
        default:
          throw new GenerationFailureException(String.format("Inconsistent QueriesGenerated: there's no method for query %s (key: #%d)", ctx.getTemplateReference(), methodKey));
      }
    }
  }
  private static SNode createPlaceInFolder_x583g4_a0a0b0b0c0db(String p0) {
    SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.PlaceInFolder$Xz);
    n0.setProperty(PROPS.location$9iBH, p0);
    return n0.getResult();
  }
  private static SNode createPlaceInFolder_x583g4_a0a0b0c0c0db(String p0) {
    SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.PlaceInFolder$Xz);
    n0.setProperty(PROPS.location$9iBH, p0);
    return n0.getResult();
  }
  private static SNode createPlaceInFolder_x583g4_a0d0a0a0e0c0db(String p0) {
    SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.PlaceInFolder$Xz);
    n0.setProperty(PROPS.location$9iBH, p0);
    return n0.getResult();
  }
  private static SNode createPlaceInFolder_x583g4_a0b0c0c0e0db(String p0) {
    SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.PlaceInFolder$Xz);
    n0.setProperty(PROPS.location$9iBH, p0);
    return n0.getResult();
  }
  private static SNode createIncludableExport_x583g4_a0a0a0m0fb(String p0, SNode p1, SNode p2, Iterable<? extends SNode> p3) {
    SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.IncludableExport$Pd);
    n0.setProperty(PROPS.name$MnvL, p0);
    {
      SNodeBuilder n1 = n0.forChild(LINKS.root$175E).init(CONCEPTS.DocumentRef$zv);
      n1.setReferenceTarget(LINKS.doc$bvgi, p1);
    }
    n0.forChild(LINKS.renderer$16BC).initNode(p2, CONCEPTS.DocumentRenderer$L$, true);
    n0.forChild(LINKS.mappings$1cg0).initNodeList(p3, CONCEPTS.PathMapping$PL);
    return n0.getResult();
  }
  private static boolean isEmptyString(String str) {
    return str == null || str.isEmpty();
  }
  private static <T> T as_x583g4_a0a0a2a0a0m0a0a0a0a0a0a0a1a23(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }

  private static final class PROPS {
    /*package*/ static final SProperty referenceOnly$1c6H = MetaAdapterFactory.getProperty(0x2374bc907e3741f1L, 0xa9c4c2e35194c36aL, 0x558f97d9712da4e0L, 0x47f3f9c716eaf0dL, "referenceOnly");
    /*package*/ static final SProperty text$VGzk = MetaAdapterFactory.getProperty(0x2374bc907e3741f1L, 0xa9c4c2e35194c36aL, 0x79297e8110e9a1e7L, 0x79297e8110e9a1eaL, "text");
    /*package*/ static final SProperty language$VGkj = MetaAdapterFactory.getProperty(0x2374bc907e3741f1L, 0xa9c4c2e35194c36aL, 0x79297e8110e9a1e7L, 0x79297e8110e9a1e9L, "language");
    /*package*/ static final SProperty language$c4tN = MetaAdapterFactory.getProperty(0x2374bc907e3741f1L, 0xa9c4c2e35194c36aL, 0x608796288312c052L, 0x608796288312c054L, "language");
    /*package*/ static final SProperty text$c4eM = MetaAdapterFactory.getProperty(0x2374bc907e3741f1L, 0xa9c4c2e35194c36aL, 0x608796288312c052L, 0x608796288312c053L, "text");
    /*package*/ static final SProperty name$MnvL = MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name");
    /*package*/ static final SProperty category$ORQS = MetaAdapterFactory.getProperty(0x2374bc907e3741f1L, 0xa9c4c2e35194c36aL, 0x23ec7b4e3e2dffbaL, 0x23ec7b4e3e2dffc1L, "category");
    /*package*/ static final SProperty path$VaYg = MetaAdapterFactory.getProperty(0xd3a0fd26445a466cL, 0x900e10444ddfed52L, 0x55705e73a6773808L, 0x55705e73a6774a6eL, "path");
    /*package*/ static final SProperty location$9iBH = MetaAdapterFactory.getProperty(0x2374bc907e3741f1L, 0xa9c4c2e35194c36aL, 0x231350fa086ffc77L, 0x231350fa086ffc7eL, "location");
  }

  private static final class LINKS {
    /*package*/ static final SContainmentLink ref$ki8k = MetaAdapterFactory.getContainmentLink(0x2374bc907e3741f1L, 0xa9c4c2e35194c36aL, 0x558f97d9712da4e0L, 0x558f97d9712da4e3L, "ref");
    /*package*/ static final SReferenceLink doc$bvgi = MetaAdapterFactory.getReferenceLink(0x2374bc907e3741f1L, 0xa9c4c2e35194c36aL, 0x2e7fd03a4b7ee169L, 0x2e7fd03a4b7ee16aL, "doc");
    /*package*/ static final SReferenceLink shortcut$25ai = MetaAdapterFactory.getReferenceLink(0x2374bc907e3741f1L, 0xa9c4c2e35194c36aL, 0x3ddc39046e396e5cL, 0x3ddc39046e396e5dL, "shortcut");
    /*package*/ static final SContainmentLink text$5l1C = MetaAdapterFactory.getContainmentLink(0x2374bc907e3741f1L, 0xa9c4c2e35194c36aL, 0x3ddc39046e393b1fL, 0x3ddc39046e393b21L, "text");
    /*package*/ static final SContainmentLink text$ls7a = MetaAdapterFactory.getContainmentLink(0xd4280a54f6df4383L, 0xaa41d1b2bffa7eb1L, 0x743b6d0940760196L, 0x743b6d0940760197L, "text");
    /*package*/ static final SContainmentLink words$C8QZ = MetaAdapterFactory.getContainmentLink(0x92d2ea165a424fdfL, 0xa676c7604efe3504L, 0x237c8da86a9e4e61L, 0x237c8da86a9e7aeeL, "words");
    /*package*/ static final SReferenceLink arg$yPNN = MetaAdapterFactory.getReferenceLink(0x2374bc907e3741f1L, 0xa9c4c2e35194c36aL, 0x3ddc39046e3a8d43L, 0x3ddc39046e3a8d45L, "arg");
    /*package*/ static final SContainmentLink args$tEuU = MetaAdapterFactory.getContainmentLink(0x2374bc907e3741f1L, 0xa9c4c2e35194c36aL, 0x3ddc39046e396e5cL, 0x3ddc39046e3b4739L, "args");
    /*package*/ static final SContainmentLink words$urNi = MetaAdapterFactory.getContainmentLink(0x2374bc907e3741f1L, 0xa9c4c2e35194c36aL, 0x3ddc39046e39ec19L, 0x3ddc39046e39ec1aL, "words");
    /*package*/ static final SContainmentLink description$c3kb = MetaAdapterFactory.getContainmentLink(0x2374bc907e3741f1L, 0xa9c4c2e35194c36aL, 0x608796288312c04bL, 0x608796288312c050L, "description");
    /*package*/ static final SContainmentLink sizeSpec$c3zc = MetaAdapterFactory.getContainmentLink(0x2374bc907e3741f1L, 0xa9c4c2e35194c36aL, 0x608796288312c04bL, 0x608796288312c051L, "sizeSpec");
    /*package*/ static final SContainmentLink description$OSkU = MetaAdapterFactory.getContainmentLink(0x2374bc907e3741f1L, 0xa9c4c2e35194c36aL, 0x23ec7b4e3e2dffbaL, 0x23ec7b4e3e2dffc3L, "description");
    /*package*/ static final SContainmentLink sizeSpec$Rmer = MetaAdapterFactory.getContainmentLink(0x2374bc907e3741f1L, 0xa9c4c2e35194c36aL, 0x23ec7b4e3e2dffbaL, 0x23ec7b4e3e2dffc4L, "sizeSpec");
    /*package*/ static final SContainmentLink mappings$1cg0 = MetaAdapterFactory.getContainmentLink(0x2374bc907e3741f1L, 0xa9c4c2e35194c36aL, 0x5439559294885429L, 0x5439559294886742L, "mappings");
    /*package*/ static final SContainmentLink pathPicker$QPZE = MetaAdapterFactory.getContainmentLink(0x2374bc907e3741f1L, 0xa9c4c2e35194c36aL, 0x58a16bfbe08e80dbL, 0x24acfda72d7b4682L, "pathPicker");
    /*package*/ static final SReferenceLink config$bNXi = MetaAdapterFactory.getReferenceLink(0x2374bc907e3741f1L, 0xa9c4c2e35194c36aL, 0x5c64b4307041a0cfL, 0x5c64b4307041a0d0L, "config");
    /*package*/ static final SReferenceLink target$G2cK = MetaAdapterFactory.getReferenceLink(0x2374bc907e3741f1L, 0xa9c4c2e35194c36aL, 0x2e7fd03a4b7d19a5L, 0x2e7fd03a4b7d19afL, "target");
    /*package*/ static final SReferenceLink target$aemi = MetaAdapterFactory.getReferenceLink(0x2374bc907e3741f1L, 0xa9c4c2e35194c36aL, 0xb912ac5dfece88L, 0xb912ac5dfece89L, "target");
    /*package*/ static final SContainmentLink root$175E = MetaAdapterFactory.getContainmentLink(0x2374bc907e3741f1L, 0xa9c4c2e35194c36aL, 0x5439559294885429L, 0x5439559294886741L, "root");
    /*package*/ static final SContainmentLink renderer$16BC = MetaAdapterFactory.getContainmentLink(0x2374bc907e3741f1L, 0xa9c4c2e35194c36aL, 0x5439559294885429L, 0x543955929488673fL, "renderer");
    /*package*/ static final SContainmentLink contents$e7kB = MetaAdapterFactory.getContainmentLink(0x2374bc907e3741f1L, 0xa9c4c2e35194c36aL, 0x2e7fd03a4b7c6bf9L, 0x2e7fd03a4b7c6bfaL, "contents");
    /*package*/ static final SContainmentLink dependsOn$QZv7 = MetaAdapterFactory.getContainmentLink(0x2374bc907e3741f1L, 0xa9c4c2e35194c36aL, 0x5c64b4307041a0cfL, 0x79297e8110de1fc6L, "dependsOn");
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept ShortcutArgRef$g8 = MetaAdapterFactory.getConcept(0x2374bc907e3741f1L, 0xa9c4c2e35194c36aL, 0x3ddc39046e3a8d43L, "com.mbeddr.doc.structure.ShortcutArgRef");
    /*package*/ static final SConcept DocumentExport$bq = MetaAdapterFactory.getConcept(0x2374bc907e3741f1L, 0xa9c4c2e35194c36aL, 0x2e7fd03a4b7f5a6eL, "com.mbeddr.doc.structure.DocumentExport");
    /*package*/ static final SConcept Visualization$hS = MetaAdapterFactory.getConcept(0x2374bc907e3741f1L, 0xa9c4c2e35194c36aL, 0x23ec7b4e3e2dffbaL, "com.mbeddr.doc.structure.Visualization");
    /*package*/ static final SConcept PlaceInFolder$Xz = MetaAdapterFactory.getConcept(0x2374bc907e3741f1L, 0xa9c4c2e35194c36aL, 0x231350fa086ffc77L, "com.mbeddr.doc.structure.PlaceInFolder");
    /*package*/ static final SConcept Document$4G = MetaAdapterFactory.getConcept(0x2374bc907e3741f1L, 0xa9c4c2e35194c36aL, 0x2e7fd03a4b7a1830L, "com.mbeddr.doc.structure.Document");
    /*package*/ static final SConcept AbstractRefWord$4E = MetaAdapterFactory.getConcept(0x2374bc907e3741f1L, 0xa9c4c2e35194c36aL, 0x3597103b3543abf5L, "com.mbeddr.doc.structure.AbstractRefWord");
    /*package*/ static final SConcept ImageParagraph$7j = MetaAdapterFactory.getConcept(0x2374bc907e3741f1L, 0xa9c4c2e35194c36aL, 0x58a16bfbe08b4e13L, "com.mbeddr.doc.structure.ImageParagraph");
    /*package*/ static final SInterfaceConcept IDocumentLike$h$ = MetaAdapterFactory.getInterfaceConcept(0x2374bc907e3741f1L, 0xa9c4c2e35194c36aL, 0x5c64b4307041a0cfL, "com.mbeddr.doc.structure.IDocumentLike");
    /*package*/ static final SConcept ModelContentAsImageParagraph$vS = MetaAdapterFactory.getConcept(0x2374bc907e3741f1L, 0xa9c4c2e35194c36aL, 0x608796288312c04bL, "com.mbeddr.doc.structure.ModelContentAsImageParagraph");
    /*package*/ static final SInterfaceConcept IDocReferencable$kt = MetaAdapterFactory.getInterfaceConcept(0x2374bc907e3741f1L, 0xa9c4c2e35194c36aL, 0x64d2b0bf25be7b65L, "com.mbeddr.doc.structure.IDocReferencable");
    /*package*/ static final SConcept AbstractSection$8m = MetaAdapterFactory.getConcept(0x2374bc907e3741f1L, 0xa9c4c2e35194c36aL, 0x2e7fd03a4b7c6bdeL, "com.mbeddr.doc.structure.AbstractSection");
    /*package*/ static final SConcept SectRefWord$rj = MetaAdapterFactory.getConcept(0x2374bc907e3741f1L, 0xa9c4c2e35194c36aL, 0x2e7fd03a4b7d19a5L, "com.mbeddr.doc.structure.SectRefWord");
    /*package*/ static final SConcept DocRefWord$1F = MetaAdapterFactory.getConcept(0x2374bc907e3741f1L, 0xa9c4c2e35194c36aL, 0xb912ac5dfece88L, "com.mbeddr.doc.structure.DocRefWord");
    /*package*/ static final SConcept AbstractExport$TZ = MetaAdapterFactory.getConcept(0x2374bc907e3741f1L, 0xa9c4c2e35194c36aL, 0x5439559294885429L, "com.mbeddr.doc.structure.AbstractExport");
    /*package*/ static final SConcept DocumentRef$zv = MetaAdapterFactory.getConcept(0x2374bc907e3741f1L, 0xa9c4c2e35194c36aL, 0x2e7fd03a4b7ee169L, "com.mbeddr.doc.structure.DocumentRef");
    /*package*/ static final SConcept DocumentInclude$8j = MetaAdapterFactory.getConcept(0x2374bc907e3741f1L, 0xa9c4c2e35194c36aL, 0x558f97d9712da4e0L, "com.mbeddr.doc.structure.DocumentInclude");
    /*package*/ static final SConcept IncludableExport$Pd = MetaAdapterFactory.getConcept(0x2374bc907e3741f1L, 0xa9c4c2e35194c36aL, 0x5439559294886745L, "com.mbeddr.doc.structure.IncludableExport");
    /*package*/ static final SConcept DocumentRenderer$L$ = MetaAdapterFactory.getConcept(0x2374bc907e3741f1L, 0xa9c4c2e35194c36aL, 0x2e7fd03a4b7f8c73L, "com.mbeddr.doc.structure.DocumentRenderer");
    /*package*/ static final SConcept PathMapping$PL = MetaAdapterFactory.getConcept(0x2374bc907e3741f1L, 0xa9c4c2e35194c36aL, 0x58a16bfbe08fc074L, "com.mbeddr.doc.structure.PathMapping");
  }
}
