package com.mbeddr.doc.editor;

/*Generated by MPS */

import jetbrains.mps.logging.Logger;
import java.util.Map;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.LinkedHashMap;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple;
import org.jetbrains.annotations.Nullable;
import java.util.Collection;

public class CodeParagraphManager {
  private static final Logger LOG = Logger.getLogger(CodeParagraphManager.class);
  private static final String HINT_SEPARATOR = ":";

  private static CodeParagraphManager instance;

  private final Map<String, Tuples._2<Integer, ICodeParagraphDecider>> deciders = MapSequence.fromMap(new LinkedHashMap<String, Tuples._2<Integer, ICodeParagraphDecider>>(16, (float) 0.75, false));

  @NotNull
  public static CodeParagraphManager getInstance() {
    if (instance == null) {
      instance = new CodeParagraphManager();
    }

    return instance;
  }

  @NotNull
  public static String concatHint(@NotNull SNode keyNode) {
    return getHint() + HINT_SEPARATOR + concatKey(keyNode);
  }
  @NotNull
  protected static String getHint() {
    return "com.mbeddr.doc.editor.CodeHint.codeHint";
  }
  @NotNull
  protected static String concatKey(@NotNull SNode keyNode) {
    return SNodeOperations.getModel(keyNode).getModelId().toString() + keyNode.getNodeId().toString();
  }

  public void registerDecider(@NotNull SNode keyNode, @NotNull ICodeParagraphDecider decider) {
    registerDecider(concatKey(keyNode), decider);
  }
  protected void registerDecider(@NotNull String key, @NotNull ICodeParagraphDecider decider) {
    if (!(MapSequence.fromMap(this.deciders).containsKey(key))) {
      MapSequence.fromMap(this.deciders).put(key, MultiTuple.<Integer,ICodeParagraphDecider>from(0, null));
    }
    Tuples._2<Integer, ICodeParagraphDecider> value = MapSequence.fromMap(this.deciders).get(key);
    value._0((int) value._0() + 1);
    value._1(decider);
  }

  public void unregisterDecider(@NotNull SNode keyNode) {
    unregisterDecider(concatKey(keyNode));
  }
  protected void unregisterDecider(@NotNull String key) {
    if (MapSequence.fromMap(this.deciders).containsKey(key)) {
      Tuples._2<Integer, ICodeParagraphDecider> value = MapSequence.fromMap(this.deciders).get(key);
      value._0((int) value._0() - 1);
      if ((int) value._0() <= 0) {
        MapSequence.fromMap(this.deciders).removeKey(key);
      }
    }
  }

  @Nullable
  public ICodeParagraphDecider getDecider(@NotNull Collection<String> hints) {
    String hintPrefix = getHint() + HINT_SEPARATOR;
    for (String hint : hints) {
      if (hint.startsWith(hintPrefix)) {
        String hintPostfix = hint.substring(hintPrefix.length());
        ICodeParagraphDecider decider = getDecider(hintPostfix);
        if (decider != null) {
          return decider;
        }
        if (LOG.isWarningLevel()) {
          LOG.warning("did not find decider for node id: " + hintPostfix);
        }
      }
    }

    return null;
  }
  @Nullable
  public ICodeParagraphDecider getDecider(@NotNull SNode keyNode) {
    return getDecider(concatKey(keyNode));
  }
  @Nullable
  protected ICodeParagraphDecider getDecider(@NotNull String key) {
    if (MapSequence.fromMap(this.deciders).containsKey(key)) {
      return MapSequence.fromMap(this.deciders).get(key)._1();
    } else {
      return null;
    }
  }
}
