package com.mbeddr.doc.plugin;

/*Generated by MPS */

import jetbrains.mps.make.facet.IFacet;
import java.util.List;
import jetbrains.mps.make.facet.ITarget;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.make.resources.IPropertiesPersistence;
import jetbrains.mps.make.facet.ITargetEx;
import jetbrains.mps.make.script.IJob;
import jetbrains.mps.make.script.IResult;
import jetbrains.mps.make.resources.IResource;
import jetbrains.mps.make.script.IJobMonitor;
import jetbrains.mps.make.resources.IPropertiesAccessor;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.mps.openapi.util.ProgressMonitor;
import jetbrains.mps.smodel.resources.GResource;
import jetbrains.mps.core.tool.environment.util.FileMPSProject;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import org.jetbrains.mps.openapi.module.SRepository;
import java.util.Map;
import jetbrains.mps.vfs.IFile;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.smodel.SModelOperations;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple;
import jetbrains.mps.make.facets.Make_Facet.Target_make;
import jetbrains.mps.internal.make.runtime.util.DeltaKey;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.make.script.IFeedback;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.textgen.trace.TracingUtil;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.lang.editor.behavior.ConceptEditorHintDeclaration__BehaviorDescriptor;
import com.mbeddr.doc.editor.CodeParagraphHelper;
import com.mbeddr.doc.behavior.AbstractModelContentParagraph__BehaviorDescriptor;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.make.delta.IDelta;
import jetbrains.mps.internal.make.runtime.java.FileProcessor;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import jetbrains.mps.ide.ThreadUtils;
import jetbrains.mps.internal.make.runtime.util.FilesDelta;
import jetbrains.mps.smodel.resources.DResource;
import jetbrains.mps.vfs.FileSystem;
import jetbrains.mps.make.script.IConfig;
import jetbrains.mps.make.script.IPropertiesPool;
import org.jetbrains.mps.openapi.language.SConcept;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import org.jetbrains.mps.openapi.language.SReferenceLink;
import org.jetbrains.mps.openapi.language.SProperty;

public class generateScreenshots_Facet extends IFacet.Stub {
  private List<ITarget> targets = ListSequence.fromList(new ArrayList<ITarget>());
  private IFacet.Name name = new IFacet.Name("com.mbeddr.doc.generateScreenshots");
  public generateScreenshots_Facet() {
    ListSequence.fromList(targets).addElement(new Target_generateDocImages());
  }
  public Iterable<ITarget> targets() {
    return targets;
  }
  public Iterable<IFacet.Name> optional() {
    return null;
  }
  public Iterable<IFacet.Name> required() {
    return Sequence.fromArray(new IFacet.Name[]{new IFacet.Name("jetbrains.mps.make.facets.Make"), new IFacet.Name("jetbrains.mps.make.facets.TextGen"), new IFacet.Name("jetbrains.mps.make.facets.Generate")});
  }
  public Iterable<IFacet.Name> extended() {
    return null;
  }
  public IFacet.Name getName() {
    return this.name;
  }
  public IPropertiesPersistence propertiesPersistence() {
    return new TargetProperties();
  }
  public static class Target_generateDocImages implements ITargetEx {
    private static final ITarget.Name name = new ITarget.Name("com.mbeddr.doc.generateScreenshots.generateDocImages");
    public Target_generateDocImages() {
    }
    public IJob createJob() {
      return new IJob.Stub() {
        @Override
        public IResult execute(final Iterable<IResource> rawInput, final IJobMonitor monitor, final IPropertiesAccessor pa, @NotNull final ProgressMonitor progressMonitor) {
          Iterable<IResource> _output_1msyh8_a0a = null;
          final Iterable<GResource> input = (Iterable<GResource>) (Iterable) rawInput;
          switch (0) {
            case 0:
              // Make sure we only warn about MPS Environment if screenshots are actually used, and only do it once.
              final boolean isMpsEnvironment = monitor.getSession().getProject() instanceof FileMPSProject;
              final String mpsEnvironmentWarning = "Screenshots cannot be taken in MpsEnvironment (Ant <generate> task). " + "Use mps-gradle-plugin, mps-build-backends, MPS tests, or other means to run the MPS make process in an IDEA environment.";
              final Wrappers._boolean reportMpsEnvironment = new Wrappers._boolean(true);

              progressMonitor.start("Generating Screenshots", 4);

              try {
                final SRepository repository = monitor.getSession().getProject().getRepository();

                final Map<IFile, List<MakeScreenshotRunnable>> runnablesByFolder = MapSequence.fromMap(new HashMap<IFile, List<MakeScreenshotRunnable>>());

                repository.getModelAccess().runReadAction(() -> {
                  progressMonitor.step("Collecting models for creating screenshots");
                  Iterable<GResource> resourcesWithOutput = Sequence.fromIterable(input).where((it) -> SModelOperations.getOutputLocation(it.model()) != null && it.status().getOutputModel() != null);
                  Iterable<Tuples._2<SModel, SModel>> allModels = Sequence.fromIterable(resourcesWithOutput).translate((gResource) -> {
                    final SModel inputModel = gResource.model();
                    Iterable<SModel> outputModels = gResource.status().getOutputModels();
                    return Sequence.fromIterable(outputModels).select((it) -> MultiTuple.<SModel,SModel>from(inputModel, it));
                  });
                  progressMonitor.advance(1);

                  ProgressMonitor collectingNodesMonitor = progressMonitor.subTask(1);
                  collectingNodesMonitor.start("Collecting nodes for screenshots", Sequence.fromIterable(allModels).count());
                  for (Tuples._2<SModel, SModel> modelsPair : Sequence.fromIterable(allModels)) {
                    collectingNodesMonitor.step(jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations.getModelName(modelsPair._0()));
                    // XXX what if there are multiple GenerationTargetFacet (now it's only JavaModuleFacet), shall we generate into each? Or identify them somehow?
                    IFile modelOutputLocation = SModelOperations.getOutputLocation(modelsPair._0());
                    IFile outputDir = Target_make.vars(pa.global()).alternateOutput().invoke(modelOutputLocation);
                    if (!(MapSequence.fromMap(runnablesByFolder).containsKey(outputDir))) {
                      MapSequence.fromMap(runnablesByFolder).put(outputDir, ListSequence.fromList(new ArrayList<MakeScreenshotRunnable>()));
                    }
                    final DeltaKey dk = new DeltaKey(modelsPair._0().getModule(), modelsPair._0(), modelsPair._1());

                    for (SNode modelContent : ListSequence.fromList(jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations.roots(modelsPair._1(), CONCEPTS.ModelContentAsImageParagraph$vS))) {
                      if (isMpsEnvironment) {
                        if (reportMpsEnvironment.value) {
                          monitor.reportFeedback(new IFeedback.WARNING(String.valueOf(mpsEnvironmentWarning)));
                          reportMpsEnvironment.value = false;
                        }
                        break;
                      }

                      SNode node = SNodeOperations.as(TracingUtil.getInputNode(modelContent, repository), CONCEPTS.ModelContentAsImageParagraph$vS);
                      // adding code paragraph decider for the node of the transient model and pass the resulting hints 
                      // down into the screenshooter. The code CodeParagraphManager uses dynamically constructed hint that
                      // contain the node id of the nodes it should operate on. See CodeParagraphManager.concatHint  
                      Iterable<String> hints = ListSequence.fromList(SLinkOperations.getChildren(modelContent, LINKS.hints$eSBG)).select((it) -> (String) ConceptEditorHintDeclaration__BehaviorDescriptor.getQualifiedName_id59ZEGVRaGvv.invoke(SLinkOperations.getTarget(it, LINKS.hint$Facj))).concat(Sequence.fromIterable(CodeParagraphHelper.getCodeParagraphHints(modelContent)));
                      MakeScreenshotRunnable printRunnable = new MakeScreenshotRunnable(modelContent, AbstractModelContentParagraph__BehaviorDescriptor.targetNode_id627_yy34GnC.invoke(node), SPropertyOperations.getString(modelContent, PROPS.name$MnvL), repository, dk, hints, SPropertyOperations.getBoolean(node, PROPS.renderInspector$wSXQ));
                      ListSequence.fromList(MapSequence.fromMap(runnablesByFolder).get(outputDir)).addElement(printRunnable);
                    }

                    for (SNode sectionAsImage : ListSequence.fromList(jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations.roots(modelsPair._1(), CONCEPTS.SectionAsImageParagraph$zF))) {
                      if (isMpsEnvironment) {
                        if (reportMpsEnvironment.value) {
                          monitor.reportFeedback(new IFeedback.WARNING(String.valueOf(mpsEnvironmentWarning)));
                          reportMpsEnvironment.value = false;
                        }
                        break;
                      }

                      SNode node = SNodeOperations.as(TracingUtil.getInputNode(sectionAsImage, repository), CONCEPTS.SectionAsImageParagraph$zF);
                      MakeScreenshotRunnable printRunnable = new MakeScreenshotRunnable(sectionAsImage, SLinkOperations.getTarget(node, LINKS.section$jTN2), SPropertyOperations.getString(sectionAsImage, PROPS.name$MnvL), repository, dk, ListSequence.fromList(SLinkOperations.getChildren(sectionAsImage, LINKS.hints$Svxk)).select((it) -> (String) ConceptEditorHintDeclaration__BehaviorDescriptor.getQualifiedName_id59ZEGVRaGvv.invoke(SLinkOperations.getTarget(it, LINKS.hint$Facj))), SPropertyOperations.getBoolean(node, PROPS.renderInspector$1deD));
                      ListSequence.fromList(MapSequence.fromMap(runnablesByFolder).get(outputDir)).addElement(printRunnable);
                    }
                    collectingNodesMonitor.advance(1);
                  }
                  collectingNodesMonitor.done();
                });

                List<IDelta> deltaList = ListSequence.fromList(new ArrayList<IDelta>());
                final FileProcessor fp = new FileProcessor(monitor.getSession().getMessageHandler());
                ProgressMonitor screenshotingFilesFoldersMonitor = progressMonitor.subTask(1);
                screenshotingFilesFoldersMonitor.start("Creating screenshot for folders", MapSequence.fromMap(runnablesByFolder).count());
                for (IFile folder : SetSequence.fromSet(MapSequence.fromMap(runnablesByFolder).keySet())) {
                  List<MakeScreenshotRunnable> runnables = MapSequence.fromMap(runnablesByFolder).get(folder);
                  ProgressMonitor screenshotFilesMonitor = screenshotingFilesFoldersMonitor.subTask(1);
                  screenshotFilesMonitor.start("Creating screenshots", ListSequence.fromList(runnables).count());
                  int index = 0;
                  for (MakeScreenshotRunnable currentRunnable : ListSequence.fromList(runnables)) {
                    screenshotFilesMonitor.step("Creating screenshot step " + index++ + " of " + ListSequence.fromList(runnables).count());

                    if (ThreadUtils.isInEDT()) {
                      repository.getModelAccess().runWriteAction(currentRunnable);
                    } else {
                      repository.getModelAccess().runWriteInEDT(currentRunnable);
                    }

                    if (currentRunnable.waitForExecution()) {
                      FilesDelta fd = new FilesDelta(currentRunnable.getDeltaKey());
                      ListSequence.fromList(deltaList).addElement(fd);
                    } else {
                      (monitor).reportFeedback(new IFeedback.ERROR("Exception generating screenshot for node: " + SNodeOperations.getPointer(currentRunnable.myOriginalNode) + " (effective node: " + SNodeOperations.getPointer(currentRunnable.myNode) + ")", currentRunnable.getError()));
                    }
                    screenshotFilesMonitor.advance(1);
                  }
                  screenshotFilesMonitor.done();
                }
                screenshotingFilesFoldersMonitor.done();

                _output_1msyh8_a0a = Sequence.fromIterable(_output_1msyh8_a0a).concat(Sequence.fromIterable(Sequence.<IResource>singleton(new DResource(deltaList))));

                progressMonitor.step("Finishing creating screenshots");
                if (!(FileSystem.getInstance().runWriteTransaction(() -> fp.flushChanges()))) {
                  monitor.reportFeedback(new IFeedback.ERROR(String.valueOf("Failed to save files")));
                  return new IResult.FAILURE(_output_1msyh8_a0a);
                }
                progressMonitor.advance(1);
              } finally {
                progressMonitor.done();
              }
            default:
              progressMonitor.done();
              return new IResult.SUCCESS(_output_1msyh8_a0a);
          }
        }
      };
    }
    public IConfig createConfig() {
      return null;
    }
    public Iterable<ITarget.Name> notAfter() {
      return null;
    }
    public Iterable<ITarget.Name> after() {
      return Sequence.fromArray(new ITarget.Name[]{new ITarget.Name("jetbrains.mps.make.facets.Generate.generate")});
    }
    public Iterable<ITarget.Name> notBefore() {
      return null;
    }
    public Iterable<ITarget.Name> before() {
      return Sequence.fromArray(new ITarget.Name[]{new ITarget.Name("jetbrains.mps.make.facets.Make.reconcile")});
    }
    public ITarget.Name getName() {
      return name;
    }
    public boolean isOptional() {
      return false;
    }
    public boolean requiresInput() {
      return true;
    }
    public boolean producesOutput() {
      return true;
    }
    public Iterable<Class<? extends IResource>> expectedInput() {
      List<Class<? extends IResource>> rv = ListSequence.fromList(new ArrayList<Class<? extends IResource>>());
      ListSequence.fromList(rv).addElement(GResource.class);
      return rv;
    }
    public Iterable<Class<? extends IResource>> expectedOutput() {
      return null;
    }
    public <T> T createParameters(Class<T> cls) {
      return null;
    }
    public <T> T createParameters(Class<T> cls, T copyFrom) {
      T t = createParameters(cls);
      return t;
    }
  }
  public static class TargetProperties implements IPropertiesPersistence {
    public TargetProperties() {
    }
    public void storeValues(Map<String, String> store, IPropertiesPool properties) {
    }
    public void loadValues(Map<String, String> store, IPropertiesPool properties) {
      try {
      } catch (RuntimeException re) {
      }
    }
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept ModelContentAsImageParagraph$vS = MetaAdapterFactory.getConcept(0x2374bc907e3741f1L, 0xa9c4c2e35194c36aL, 0x608796288312c04bL, "com.mbeddr.doc.structure.ModelContentAsImageParagraph");
    /*package*/ static final SConcept SectionAsImageParagraph$zF = MetaAdapterFactory.getConcept(0xd7145000936a47e8L, 0x95a571f220e623f9L, 0x590be4903f33f752L, "com.mbeddr.doc.self.structure.SectionAsImageParagraph");
  }

  private static final class LINKS {
    /*package*/ static final SContainmentLink hints$eSBG = MetaAdapterFactory.getContainmentLink(0x2374bc907e3741f1L, 0xa9c4c2e35194c36aL, 0x608796288312c04bL, 0x51188e3ea04d1801L, "hints");
    /*package*/ static final SReferenceLink hint$Facj = MetaAdapterFactory.getReferenceLink(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0x5eadaecad41188dcL, 0x527faacef66db74dL, "hint");
    /*package*/ static final SReferenceLink section$jTN2 = MetaAdapterFactory.getReferenceLink(0xd7145000936a47e8L, 0x95a571f220e623f9L, 0x590be4903f33f752L, 0x79297e8110d78b9cL, "section");
    /*package*/ static final SContainmentLink hints$Svxk = MetaAdapterFactory.getContainmentLink(0xd7145000936a47e8L, 0x95a571f220e623f9L, 0x590be4903f33f752L, 0x51188e3ea0618bc9L, "hints");
  }

  private static final class PROPS {
    /*package*/ static final SProperty name$MnvL = MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name");
    /*package*/ static final SProperty renderInspector$wSXQ = MetaAdapterFactory.getProperty(0x2374bc907e3741f1L, 0xa9c4c2e35194c36aL, 0x608796288312c04bL, 0xebf3c0bd45f3fc8L, "renderInspector");
    /*package*/ static final SProperty renderInspector$1deD = MetaAdapterFactory.getProperty(0xd7145000936a47e8L, 0x95a571f220e623f9L, 0x590be4903f33f752L, 0xebf3c0bd45e5feaL, "renderInspector");
  }
}
