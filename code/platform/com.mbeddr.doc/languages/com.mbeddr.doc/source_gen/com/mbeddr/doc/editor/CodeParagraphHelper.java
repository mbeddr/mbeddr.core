package com.mbeddr.doc.editor;

/*Generated by MPS */

import java.util.UUID;
import java.util.regex.Pattern;
import org.jetbrains.annotations.Nullable;
import jetbrains.mps.openapi.editor.EditorContext;
import org.jetbrains.mps.openapi.model.SNode;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import com.mbeddr.doc.behavior.AbstractModelContentParagraph__BehaviorDescriptor;
import jetbrains.mps.openapi.editor.TextBuilder;
import jetbrains.mps.nodeEditor.cells.EditorCell_Collection;
import jetbrains.mps.openapi.editor.cells.EditorCell;
import jetbrains.mps.util.IterableUtil;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.editor.runtime.TextBuilderImpl;

public class CodeParagraphHelper {
  public static final String NULL_TEXT_MARKER = UUID.nameUUIDFromBytes("nullText".getBytes()).toString();
  public static final Pattern NULL_PATTERN = Pattern.compile("^\\s*" + Pattern.quote(NULL_TEXT_MARKER) + "\\s*$");
  public static final String NEWLINE_PATTERN_STRING = "\\r?\\n";

  /**
   * 
   * @deprecated Use the method that doesn't take a EditorConctext because it is no longer needed.
   */
  @Deprecated
  public static Iterable<String> getCodeParagraphHints(@Nullable final EditorContext editorContext, final SNode codeParagraph) {
    return getCodeParagraphHints(codeParagraph);
  }
  /**
   * Gets the node specific editor hints for the code paragraph and registers the required replacer for the paragraph.
   * 
   * @param codeParagraph code paragraph that should have code replacement enabeled
   * @return the list of hints specific to this codeParagraph
   */
  public static Iterable<String> getCodeParagraphHints(final SNode codeParagraph) {
    List<String> result = ListSequence.fromList(new ArrayList<String>());

    ListSequence.fromList(result).addElement("com.mbeddr.doc.editor.CodeHint.codeHint");
    ListSequence.fromList(result).addElement("com.mbeddr.core.base.editor.presentationMode.presentationMode");
    ListSequence.fromList(result).addElement(CodeParagraphManager.concatHint(codeParagraph));

    CodeParagraphManager.getInstance().registerDecider(codeParagraph, new ICodeParagraphDecider() {
      public boolean shouldBeRemoved(SNode candidate) {
        return (boolean) AbstractModelContentParagraph__BehaviorDescriptor.shouldBeRemoved_id6TjoDcE6uBZ.invoke(codeParagraph, candidate);
      }
    });

    return result;
  }

  public static TextBuilder renderTextWithoutRemovals(EditorCell_Collection childCollection) {
    EditorCell childCell;
    if (childCollection.getCellsCount() >= 2) {
      childCell = IterableUtil.get(childCollection, 1);
    } else {
      childCell = childCollection;
    }
    TextBuilder result = childCell.renderText();

    List<String> resultLines = ListSequence.fromList(new ArrayList<String>());
    for (CharSequence fakeLine : Sequence.fromIterable(result.getLines())) {
      Iterable<String> lines = Sequence.fromArray(fakeLine.toString().split(NEWLINE_PATTERN_STRING));
      for (String line : lines) {
        boolean matches = NULL_PATTERN.matcher(line).matches();
        if (!(matches)) {
          ListSequence.fromList(resultLines).addElement(StringUtils.stripEnd(line, " \n\r\t"));
        }
      }
    }

    final TextBuilder builder = new TextBuilderImpl();
    ListSequence.fromList(resultLines).visitAll((it) -> builder.appendToTheBottom(new TextBuilderImpl(it)));

    return result;
  }
}
