package com.mbeddr.mpsutil.contextactions.runtime;

/*Generated by MPS */

import javax.swing.JComponent;
import com.intellij.openapi.Disposable;
import jetbrains.mps.logging.Logger;
import java.awt.datatransfer.DataFlavor;
import java.util.Map;
import com.intellij.openapi.project.Project;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.WeakHashMap;
import java.util.Set;
import java.util.HashMap;
import java.util.HashSet;
import javax.swing.JPanel;
import java.util.List;
import javax.swing.Timer;
import jetbrains.mps.ide.tools.BaseTool;
import java.awt.event.ActionListener;
import java.awt.event.ActionEvent;
import java.awt.BorderLayout;
import javax.swing.BoxLayout;
import javax.swing.JScrollPane;
import javax.swing.BorderFactory;
import java.awt.Color;
import jetbrains.mps.ide.ThreadUtils;
import jetbrains.mps.nodeEditor.EditorComponent;
import jetbrains.mps.openapi.editor.selection.Selection;
import java.util.Objects;
import com.intellij.openapi.application.ApplicationManager;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import jetbrains.mps.ide.project.ProjectHelper;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import jetbrains.mps.internal.collections.runtime.IMapping;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.nodeEditor.hintsSettings.ConceptEditorHintSettingsComponent;
import java.util.TreeMap;
import javax.swing.JLabel;
import org.apache.commons.lang3.StringUtils;
import java.awt.Font;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import jetbrains.mps.editor.runtime.commands.EditorCommand;
import java.awt.dnd.DragSource;
import java.awt.dnd.DnDConstants;
import java.awt.dnd.DragGestureListener;
import java.awt.dnd.DragGestureEvent;
import java.awt.datatransfer.Transferable;
import java.awt.Point;
import jetbrains.mps.internal.collections.runtime.CollectionSequence;
import javax.swing.Icon;
import jetbrains.mps.internal.collections.runtime.IterableUtils;
import com.intellij.openapi.wm.ToolWindow;

public class ToolComponent extends JComponent implements Disposable {
  private static final Logger LOG = Logger.getLogger(ToolComponent.class);
  public static final DataFlavor ACTION_FLAVOR = new DataFlavor(IContextAction.class, "Context Action");

  private static Map<Project, ToolComponent> ourInstances = MapSequence.fromMap(new WeakHashMap<Project, ToolComponent>());


  /**
   * This property currently only allows temporary disabling of context actions based on a particular context (based on pushed hints)
   */
  private static Map<String, Set<String>> disabledActionIdsWithHints = new HashMap<String, Set<String>>();


  public static ToolComponent getInstance(Project ideaProject) {
    return MapSequence.fromMap(ourInstances).get(ideaProject);
  }

  public static void addDisabledContextActionId(String actionId, String hint) {
    Set<String> hints;
    if (!(disabledActionIdsWithHints.containsKey(actionId))) {
      hints = new HashSet<String>();
    } else {
      hints = disabledActionIdsWithHints.get(actionId);
    }
    hints.add(hint);
    disabledActionIdsWithHints.put(actionId, hints);
  }


  private Project myIdeaProject;
  private volatile IContext myLoadedContext;
  private volatile IContext myNextContext;

  private ViewType myViewType = ViewType.LIST;
  private JPanel myItemPanel = new JPanel();
  private String myFilterString = "";
  private SearchField mySearchField = new SearchField() {
    @Override
    public void executeSearch(boolean next) {
      myFilterString = mySearchField.getText().toLowerCase();
      reloadItems();
    }
  };
  private List<Item> myLoadedItems;
  private Timer myUpdateTimer;
  private BaseTool myTool;

  public ToolComponent(Project ideaProject, BaseTool tool) {
    myIdeaProject = ideaProject;
    myTool = tool;
    MapSequence.fromMap(ourInstances).put(ideaProject, this);

    initComponents();

    myUpdateTimer = new Timer(1000, new ActionListener() {
      public void actionPerformed(ActionEvent p0) {
        checkActiveEditorChanged();
      }
    });
    myUpdateTimer.start();
  }

  protected void initComponents() {
    setLayout(new BorderLayout());

    myItemPanel.setLayout(new BoxLayout(myItemPanel, BoxLayout.Y_AXIS));

    JComponent viewport = new JPanel();
    viewport.setLayout(new BorderLayout());
    viewport.add(myItemPanel, BorderLayout.NORTH);
    JScrollPane scrollPane = new JScrollPane(viewport);
    scrollPane.setBorder(BorderFactory.createEmptyBorder());
    scrollPane.getVerticalScrollBar().setUnitIncrement(16);
    scrollPane.getHorizontalScrollBar().setUnitIncrement(8);
    add(scrollPane, BorderLayout.CENTER);
    add(mySearchField, BorderLayout.NORTH);

    myItemPanel.setOpaque(false);
    viewport.setOpaque(true);
    viewport.setBackground(new Color(238, 238, 238));
  }

  /**
   * 
   * @deprecated Not necessary anymore. Tool now updates itself when it is opened.
   */
  @Deprecated(forRemoval = true)
  public void setRefreshOnlyWhenVisible(boolean value) {
  }

  @Override
  public void setBounds(int x, int y, int w, int h) {
    // Relayout the folders after resizing the tool

    boolean widthChanged = w != getSize().width;
    super.setBounds(x, y, w, h);
    if (widthChanged) {
      ThreadUtils.runInUIThreadNoWait(() -> reloadItems());
    }
  }

  @Override
  public void dispose() {
    myUpdateTimer.stop();
  }

  protected void checkActiveEditorChanged() {
    EditorComponent activeEditor = ContextActionsUtil.findActiveEditor(this);
    if (activeEditor == null) {
      return;
    }
    if (check_cnbxua_a0c0jb(myLoadedContext) == null) {
      return;
    }
    if (activeEditor == check_cnbxua_a0d0jb(myLoadedContext)) {
      return;
    }
    if (activeEditor == check_cnbxua_a0e0jb(myNextContext)) {
      return;
    }
    Selection selection = activeEditor.getSelectionManager().getSelection();
    if (selection != null) {
      update(new EditorSelectionContext(selection));
    }
  }

  public boolean isToolVisible() {
    return check_cnbxua_a0a73(myTool.getToolWindow());
  }

  public IContext getContext() {
    return myLoadedContext;
  }

  public void update(final IContext context) {
    if (Objects.equals(context, myLoadedContext)) {
      return;
    }
    myNextContext = context;
    if (!(isToolVisible())) {
      return;
    }

    ApplicationManager.getApplication().executeOnPooledThread(() -> {
      try {
        Thread.sleep(500);
      } catch (InterruptedException ex) {
        return;
      }

      if (myNextContext == myLoadedContext) {
        return;
      }
      doLoadContext(myNextContext);
    });
  }

  public void forceUpdate() {
    ApplicationManager.getApplication().executeOnPooledThread(() -> doLoadContext(myNextContext));
  }

  public void doLoadContext(IContext context) {
    myLoadedContext = context;

    // skip updates for contexts with disposed editor components by now, might happen after closing an editor (avoids exceptions when querying for actions)
    if (context.getEditorComponent() == null || context.getEditorComponent().isDisposed() || (context.getSNode() == null)) {
      return;
    }

    try {
      final Wrappers._T<List<Item>> items = new Wrappers._T<List<Item>>(null);
      ProjectHelper.toMPSProject(myIdeaProject).getRepository().getModelAccess().runReadAction(() -> items.value = queryItems(myNextContext));
      items.value = ListSequence.fromList(items.value).sort((it) -> it.myLabel, true).toList();
      ThreadUtils.runInUIThreadNoWait(() -> {
        myNextContext.getProject().getRepository().getModelAccess().runReadAction(() -> items.value = ListSequence.fromList(items.value).where((it) -> it.myAction.isVisible(myNextContext)).toList());
        loadItems(items.value);
      });
    } catch (Exception ex) {
      if (LOG.isErrorLevel()) {
        LOG.error("context actions update failed", ex);
      }
    }
  }

  protected List<Item> queryItems(IContext context) {
    List<Item> result = ListSequence.fromList(new ArrayList<Item>());
    Set<ContextActionId> existingIds = SetSequence.fromSet(new HashSet<ContextActionId>());

    for (IMapping<IContextActionsDescriptor, List<IContextActionSource>> mapping : MapSequence.fromMap(ContextActionManager.getInstance().getActionSourcesAndDescriptors())) {
      IContextActionsDescriptor descriptor = mapping.key();
      if (!(descriptor.isApplicable(context))) {
        continue;
      }

      for (IContextActionSource actionSource : ListSequence.fromList(mapping.value())) {
        if (!(actionSource.isApplicable(context))) {
          continue;
        }
        for (IContextAction action : Sequence.fromIterable(actionSource.getActions(context))) {
          if (SetSequence.fromSet(existingIds).contains(action.getId()) || checkDisabledActionWithContext(action.getOriginalContextActionID(), context)) {
            continue;
          }
          if (SetSequence.fromSet(existingIds).contains(action.getId()) || checkDisabledActionWithContext(action.getOriginalContextActionID(), context)) {
            continue;
          }
          Item item = new Item(action, context);
          ListSequence.fromList(result).addElement(item);
          SetSequence.fromSet(existingIds).addElement(action.getId());
        }
      }
    }
    return result;
  }

  private boolean checkDisabledActionWithContext(String disabledContextID, IContext context) {
    jetbrains.mps.openapi.editor.EditorComponent comp = context.getEditorComponent();
    ConceptEditorHintSettingsComponent instance = ConceptEditorHintSettingsComponent.getInstance(myIdeaProject);
    Set<String> enabledHints = instance.getState().getEnabledHints();
    Set<String> hints = disabledActionIdsWithHints.get(disabledContextID);
    if (!(Objects.equals(hints, null))) {
      for (String hint : hints) {
        if (enabledHints.contains(hint)) {
          return true;
        }
      }
    }
    return false;
  }

  protected void loadItems(List<Item> items) {
    if (items == null) {
      items = ListSequence.fromList(new ArrayList<Item>());
    }
    myLoadedItems = items;
    myItemPanel.removeAll();

    Map<String, Folder> folders = new TreeMap<String, Folder>();

    for (final Item item : items) {
      if ((myFilterString != null && myFilterString.length() > 0)) {
        boolean matchesLabel = item.myLabel.toLowerCase().contains(myFilterString);
        boolean matchesFolder = isNotEmptyString(item.myFolderName) && item.myFolderName.toLowerCase().contains(myFilterString);
        if (!(matchesLabel) && !(matchesFolder)) {
          continue;
        }
      }
      Folder folder = getOrCreateFolder(item.myFolderName, folders);
      final JLabel jlabel = new HoverLabel((myViewType == ViewType.LIST ? item.myLabel : StringUtils.abbreviate(item.myLabel, 15)));

      if (myViewType == ViewType.SYMBOLS) {
        Font font = jlabel.getFont();
        jlabel.setFont(font.deriveFont(0.7f * font.getSize()));
        jlabel.setHorizontalAlignment(JLabel.CENTER);
      }

      jlabel.setToolTipText(item.myTooltip);

      jlabel.addMouseListener(new MouseAdapter() {
        @Override
        public void mouseClicked(MouseEvent event) {
          if (event.getClickCount() > 1) {
            return;
          }
          EditorComponent editorComponent = ((EditorComponent) myLoadedContext.getEditorComponent());
          if (editorComponent != null) {
            editorComponent.getEditorContext().getRepository().getModelAccess().executeCommandInEDT(new EditorCommand(editorComponent) {
              protected void doExecute() {
                item.myAction.execute(myLoadedContext);
              }
            });
            editorComponent.requestFocusInWindow();
          } else {
            myLoadedContext.getProject().getRepository().getModelAccess().executeCommand(() -> item.myAction.execute(myLoadedContext));
          }
        }
      });

      if (item.myAction.supportsDrag()) {
        DragSource dragSource = new DragSource();
        dragSource.createDefaultDragGestureRecognizer(jlabel, DnDConstants.ACTION_COPY, new DragGestureListener() {
          @Override
          public void dragGestureRecognized(DragGestureEvent event) {
            final Wrappers._T<Transferable> transferable = new Wrappers._T<Transferable>();
            myLoadedContext.getProject().getRepository().getModelAccess().runReadAction(() -> transferable.value = item.myAction.createTransferable(myLoadedContext));
            event.startDrag(null, ImageUtil.component2image(jlabel), new Point(), transferable.value, null);
          }
        });
      }

      jlabel.setIcon(ScaledIcon.scaleIfNeeded((myViewType == ViewType.SYMBOLS ? 32 : 16), item.myIcon));
      if (myViewType == ViewType.SYMBOLS) {
        jlabel.setHorizontalTextPosition(JLabel.CENTER);
        jlabel.setVerticalTextPosition(JLabel.BOTTOM);
      }
      folder.addItem(jlabel);
    }

    for (Folder folder : CollectionSequence.fromCollection(folders.values())) {
      myItemPanel.add(folder.getComponent());
    }

    doLayout();
    invalidate();
    revalidate();
    repaint();
  }

  public void reloadItems() {
    loadItems(myLoadedItems);
  }

  public Folder getOrCreateFolder(String folderName, Map<String, Folder> folders) {
    if (folderName == null) {
      folderName = "";
    }
    Folder folder = folders.get(folderName);
    if (folder == null) {
      folder = new Folder(folderName, myViewType);
      folders.put(folderName, folder);
    }
    return folder;
  }


  public void setViewType(ViewType type) {
    myViewType = type;
    reloadItems();
  }

  public ViewType getViewType() {
    return myViewType;
  }

  public class Item {
    private String myLabel;
    private Icon myIcon;
    private String myFolderName;
    private String myTooltip;
    private IContextAction myAction;

    public Item(IContextAction action, IContext context) {
      // everything is loaded here, so that we don't need a read action later

      myAction = action;
      myIcon = action.getIcon(context);
      myLabel = action.getLabel(context);
      myFolderName = IterableUtils.join(ListSequence.fromList(action.getFolders(context)).where((it) -> it != null), "/");
      myTooltip = action.getTooltip(context);
      if (myIcon == null) {
        myIcon = EmptyIcon.ICON_16x16;
      } else {
        myIcon = ScaledIcon.scaleIfNeeded(16, myIcon);
      }
      if ((myLabel == null || myLabel.length() == 0)) {
        myLabel = " ";
      }
    }
  }
  private static jetbrains.mps.openapi.editor.EditorComponent check_cnbxua_a0c0jb(IContext checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getEditorComponent();
    }
    return null;
  }
  private static jetbrains.mps.openapi.editor.EditorComponent check_cnbxua_a0d0jb(IContext checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getEditorComponent();
    }
    return null;
  }
  private static jetbrains.mps.openapi.editor.EditorComponent check_cnbxua_a0e0jb(IContext checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getEditorComponent();
    }
    return null;
  }
  private static boolean check_cnbxua_a0a73(ToolWindow checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.isVisible();
    }
    return false;
  }
  private static boolean isNotEmptyString(String str) {
    return str != null && str.length() > 0;
  }
}
