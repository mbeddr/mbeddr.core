package com.mbeddr.mpsutil.traceExplorer.plugin;

/*Generated by MPS */

import javax.swing.tree.DefaultTreeModel;
import jetbrains.mps.project.MPSProject;
import javax.swing.tree.DefaultMutableTreeNode;
import java.util.Map;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.internal.collections.runtime.Sequence;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import java.util.function.Consumer;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import jetbrains.mps.baseLanguage.logging.rt.LogContext;
import jetbrains.mps.references.BLOperations;

public class TraceTreeModel extends DefaultTreeModel {

  private ITraceRecord rootTrace;
  private final MPSProject project;
  private DefaultMutableTreeNode rootNode;
  private Map<ITraceRecord, DefaultMutableTreeNode> traceRecordToTreeNode = MapSequence.fromMap(new HashMap<ITraceRecord, DefaultMutableTreeNode>());
  private Map<ITraceRecord, Integer> avoidinfiniteTrees = MapSequence.fromMap(new HashMap<ITraceRecord, Integer>());

  /**
   * We allow at least 1 repetition of found child traces to give feedback to the person implementing a filter
   */
  private final int allowedRepetitions = 1;


  public TraceTreeModel(MPSProject project, ITraceRecord root) {
    super(new DefaultMutableTreeNode(root));
    rootTrace = root;
    this.project = project;
    rootNode = ((DefaultMutableTreeNode) getRoot());
  }

  public void createTree(final Iterable<IComputationTraceFilter> filters) {
    Sequence.fromIterable(filters).visitAll((it) -> it.setup(rootTrace));
    rootNode.removeAllChildren();
    MapSequence.fromMap(traceRecordToTreeNode).clear();
    MapSequence.fromMap(avoidinfiniteTrees).clear();
    project.getRepository().getModelAccess().runReadAction(() -> fillTreeRecursive(filters, rootNode, rootTrace));
    Sequence.fromIterable(filters).visitAll((it) -> it.tearDown());
    printCollectedMessages();
  }

  public void createTree(Iterable<IComputationTraceFilter> filters, ITraceRecord root) {
    rootTrace = root;
    createTree(filters);
  }

  public List<? extends ITraceRecord> getChildren(Iterable<IComputationTraceFilter> filters, final ITraceRecord traceRecord) {
    final List<ITraceRecord> result = ListSequence.fromList(new ArrayList<ITraceRecord>());
    final Consumer<ITraceRecord> addDistinctToList = new Consumer<ITraceRecord>() {
      public void accept(ITraceRecord trace) {
        if (ListSequence.fromList(result).contains(trace)) {
          return;
        }
        ListSequence.fromList(result).addElement(trace);
      }
    };
    Sequence.fromIterable(filters).visitAll((it) -> it.getChildren(traceRecord).forEach(addDistinctToList));
    return result;
  }


  public DefaultMutableTreeNode getChildContainingTraceRecord(ITraceRecord record) {
    return MapSequence.fromMap(traceRecordToTreeNode).get(record);
  }

  private void printCollectedMessages() {
    SetSequence.fromSet(MapSequence.fromMap(avoidinfiniteTrees).keySet()).sort(new _FunctionTypes._return_P1_E0<Comparable<?>, ITraceRecord>() {
      public Comparable<?> invoke(ITraceRecord it) {
        return it.hashCode();
      }
    }, true).visitAll(new _FunctionTypes._void_P1_E0<ITraceRecord>() {
      public void invoke(ITraceRecord it) {
        if (MapSequence.fromMap(avoidinfiniteTrees).get(it) > allowedRepetitions) {
          LogContext.with(TraceTreeModel.class, null, project, null).warning("trace with hash: " + it.hashCode() + " containing node with node ID:" + it.getTarget().getNodeId() + " collected " + MapSequence.fromMap(avoidinfiniteTrees).get(it) + " times");
        }
      }
    });
  }

  private void fillTreeRecursive(Iterable<IComputationTraceFilter> filters, DefaultMutableTreeNode parentTreeNode, ITraceRecord parentRecord) {
    Iterable<? extends ITraceRecord> traceRecords = getChildren(filters, parentRecord);
    for (ITraceRecord child : traceRecords) {
      // avoid infinite trees and get direct accesss
      if (SetSequence.fromSet(MapSequence.fromMap(avoidinfiniteTrees).keySet()).contains(child)) {
        // Extra allow to add childs already added to give user feedback!
        BLOperations.getAndIncrement_int(MapSequence.fromMap(avoidinfiniteTrees).getValueRef(child));
        if (MapSequence.fromMap(avoidinfiniteTrees).get(child) > allowedRepetitions) {
          continue;
        }
      } else {
        MapSequence.fromMap(avoidinfiniteTrees).put(child, 1);
      }
      DefaultMutableTreeNode childNode = new DefaultMutableTreeNode(child);
      MapSequence.fromMap(traceRecordToTreeNode).put(child, childNode);
      parentTreeNode.add(childNode);
      fillTreeRecursive(filters, childNode, child);
    }
  }

}
