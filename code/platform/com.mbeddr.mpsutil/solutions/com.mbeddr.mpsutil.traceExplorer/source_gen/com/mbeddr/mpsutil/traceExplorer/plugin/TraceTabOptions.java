package com.mbeddr.mpsutil.traceExplorer.plugin;

/*Generated by MPS */

import java.util.Set;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import org.jetbrains.annotations.NotNull;
import javax.swing.Icon;
import java.util.List;
import javax.swing.tree.TreeCellRenderer;
import java.util.function.Consumer;
import javax.swing.JComponent;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import org.jetbrains.annotations.Nullable;
import jetbrains.mps.internal.collections.runtime.Sequence;

public class TraceTabOptions<RecT extends ITraceRecord<?>> {

  public enum ToolButtonEnum {
    NextTrace(),
    Rerun(),
    Highlight(),
    Filter(),
    GotoSource()
  }

  private final Set<ToolButtonEnum> toolButtonHidden = SetSequence.fromSetAndArray(new HashSet<ToolButtonEnum>(), ToolButtonEnum.NextTrace);
  public final String title;
  @NotNull
  public final ITraceRecord root;
  @NotNull
  public final ITraceDecorator decorator;
  public boolean pin = false;
  public boolean showDetailPane = false;
  public String filterMenuTitle = "Choose One or More Options";
  public Icon tabIcon;
  @Deprecated
  public boolean supportFiltering = false;
  @Deprecated
  public boolean navButtons = false;
  public IASTHighlighter codeHighlighter;
  public IASTHighlighter valueHighlighter;
  private List<IComputationTraceFilter> traceFilters = null;
  private INodeMapper mapper;

  /**
   * (Optional) Renderer to use for the trace tree.
   */
  public TreeCellRenderer renderer;
  /**
   * (Optional) Called when the tab is being disposed/closed.
   */
  public Consumer<JComponent> disposer;

  public TraceTabOptions(String title, @NotNull RecT root, @NotNull ITraceDecorator<RecT> decorator) {
    this.title = title;
    this.root = root;
    this.decorator = decorator;
    traceFilters = ListSequence.fromList(new ArrayList<IComputationTraceFilter>());
  }

  @Deprecated
  public TraceTabOptions(String title, @NotNull RecT root, @NotNull ITraceDecorator<RecT> decorator, @Nullable IASTHighlighter codeHighlighter, @Nullable IASTHighlighter valueHighlighter, @NotNull TreeCellRenderer renderer, boolean showDetailPane, boolean supportNav) {
    this.title = title;
    this.root = root;
    this.decorator = decorator;
    this.codeHighlighter = codeHighlighter;
    this.valueHighlighter = valueHighlighter;
    this.renderer = renderer;
    this.showDetailPane = showDetailPane;
    allToolButtonsVisible();
    if (!(supportNav)) {
      SetSequence.fromSet(toolButtonHidden).addElement(ToolButtonEnum.NextTrace);
    }
    traceFilters = ListSequence.fromList(new ArrayList<IComputationTraceFilter>());
  }

  public void addFilter(IComputationTraceFilter filter) {
    if (!(ListSequence.fromList(traceFilters).contains(filter))) {
      ListSequence.fromList(traceFilters).addElement(filter);
    }
  }

  public List<IComputationTraceFilter> getFilters() {
    return traceFilters;
  }

  public void clearFilters() {
    ListSequence.fromList(traceFilters).clear();
  }

  public void removeFilter(IComputationTraceFilter filter) {
    ListSequence.fromList(traceFilters).removeElement(filter);
  }

  public void removeFilterByName(final String name) {
    ListSequence.fromList(traceFilters).removeWhere((it) -> it.getName() == name);
  }

  public void allToolButtonsVisible() {
    SetSequence.fromSet(toolButtonHidden).clear();
  }

  public void hideToolButtons(ToolButtonEnum[] values) {
    Sequence.fromIterable(Sequence.fromArray(values)).visitAll((it) -> SetSequence.fromSet(toolButtonHidden).addElement(it));
  }

  public boolean toolButtonVisible(ToolButtonEnum value) {
    return !(SetSequence.fromSet(toolButtonHidden).contains(value));
  }

  public void setNodeMapper(INodeMapper mapper) {
    this.mapper = mapper;
  }
  public INodeMapper getNodeMapper() {
    return this.mapper;
  }

}
