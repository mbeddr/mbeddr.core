package com.mbeddr.mpsutil.traceExplorer.plugin;

/*Generated by MPS */

import com.intellij.openapi.ui.SimpleToolWindowPanel;
import jetbrains.mps.ide.tools.BaseTabbedProjectTool;
import com.intellij.ui.treeStructure.Tree;
import com.intellij.openapi.actionSystem.ActionToolbar;
import com.intellij.ui.OnePixelSplitter;
import jetbrains.mps.project.MPSProject;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import org.jetbrains.annotations.NotNull;
import javax.swing.event.TreeExpansionListener;
import javax.swing.event.TreeExpansionEvent;
import com.intellij.ui.ScrollPaneFactory;
import org.jetbrains.annotations.Nullable;
import javax.swing.tree.TreeCellRenderer;
import com.intellij.openapi.actionSystem.DefaultActionGroup;
import jetbrains.mps.workbench.action.ActionUtils;
import com.intellij.openapi.actionSystem.AnAction;
import com.intellij.openapi.actionSystem.ActionManager;
import com.intellij.openapi.actionSystem.ActionPlaces;
import javax.swing.JPanel;
import java.awt.GridLayout;
import com.intellij.openapi.ui.JBCheckboxMenuItem;
import javax.swing.event.ChangeListener;
import javax.swing.event.ChangeEvent;
import com.intellij.openapi.ui.popup.ComponentPopupBuilder;
import com.intellij.openapi.ui.popup.JBPopupFactory;
import java.awt.Component;
import com.intellij.openapi.ui.popup.JBPopup;
import com.intellij.ide.actions.CloseTabToolbarAction;
import com.intellij.openapi.actionSystem.AnActionEvent;
import com.intellij.openapi.actionSystem.Separator;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.TreePath;
import com.intellij.openapi.util.NlsActions;
import javax.swing.Icon;
import com.intellij.openapi.actionSystem.ActionUpdateThread;
import com.intellij.icons.AllIcons;
import org.jetbrains.mps.openapi.model.SNodeReference;
import com.intellij.openapi.actionSystem.ToggleAction;
import org.jetbrains.mps.openapi.persistence.PersistenceFacade;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.openapi.navigation.NavigationSupport;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import jetbrains.mps.internal.collections.runtime.Sequence;
import com.intellij.openapi.application.ApplicationManager;
import com.intellij.openapi.ui.Messages;
import javax.swing.JComponent;
import javax.swing.BoxLayout;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import jetbrains.mps.project.Project;
import jetbrains.mps.openapi.editor.Editor;
import jetbrains.mps.openapi.editor.EditorComponent;

public class TraceTab extends SimpleToolWindowPanel {
  protected final BaseTabbedProjectTool tool;
  protected Tree tree = new Tree();
  private TraceTreeModel traceTreeModel;
  private boolean doSaveExpansionState;
  protected ActionToolbar toolbar;
  protected OnePixelSplitter opx;

  protected final MPSProject project;

  protected ITraceRecord root;
  protected ITraceRecord currentlyTracedRecord;
  private TraceTabOptions options;

  protected List<ITraceRecord> treeExpansionState;

  protected boolean currentlyColored = false;

  protected List<FilterMenuOption> filters = ListSequence.fromList(new ArrayList<FilterMenuOption>());
  private FilterAction filterAction;


  public TraceTab(@NotNull final BaseTabbedProjectTool tool, @NotNull MPSProject project, @NotNull TraceTabOptions options) {
    super(false);
    this.tool = tool;
    this.project = project;
    this.options = options;
    this.root = options.root;

    if (ListSequence.fromList(options.getFilters()).count() == 0) {
      TraceFilterNoChildsMarkedSkip f1 = new TraceFilterNoChildsMarkedSkip();
      ListSequence.fromList(filters).addElement(new FilterMenuOption(f1).setSelected(f1.isSelectedByDefault()));
      TraceFilterByITracerFrame f2 = new TraceFilterByITracerFrame();
      ListSequence.fromList(filters).addElement(new FilterMenuOption(f2).setSelected(f2.isSelectedByDefault()));
    } else {
      ListSequence.fromList(options.getFilters()).visitAll((it) -> {
        IComputationTraceFilter filter = ((IComputationTraceFilter) it);
        ListSequence.fromList(filters).addElement(new FilterMenuOption(filter).setSelected(filter.isSelectedByDefault()));
      });
      if (ListSequence.fromList(filters).where((it) -> it.isSelected()).count() == 0) {
        ListSequence.fromList(filters).first().setSelected(true);
      }
    }
    tree.setCellRenderer(options.renderer);
    tree.addMouseListener(new OnDoubleClick());
    tree.setToggleClickCount(-1);
    tree.setOpaque(false);
    tree.setRootVisible(false);
    traceTreeModel = new TraceTreeModel(this.project, options.root);
    traceTreeModel.createTree(getSelectedFilter());
    tree.setModel(traceTreeModel);
    doSaveExpansionState = true;
    tree.addTreeExpansionListener(new TreeExpansionListener() {
      @Override
      public void treeExpanded(TreeExpansionEvent p1) {
        if (doSaveExpansionState) {
          treeExpansionState = TreeExpansionUtil.getExpandedTraces(tree);
        }
      }
      @Override
      public void treeCollapsed(TreeExpansionEvent p1) {
        treeExpanded(p1);
      }
    });

    createContents();

    if (options.showDetailPane) {
      opx.setFirstComponent(ScrollPaneFactory.createScrollPane(tree, true));
      this.setContent(opx);
    } else {
      this.setContent(ScrollPaneFactory.createScrollPane(tree, true));
    }
    toolbar.setTargetComponent(tree);
  }


  @Deprecated
  public TraceTab(@NotNull final BaseTabbedProjectTool tool, @NotNull MPSProject project, @NotNull final ITraceRecord root, @NotNull ITraceDecorator decorator, @Nullable IASTHighlighter codeHighlighter, @Nullable IASTHighlighter valueHighlighter, @NotNull TreeCellRenderer renderer, boolean addDetailPane, boolean supportFiltering, boolean supportNav) {
    this(tool, project, new TraceTabOptions<>("", root, decorator, codeHighlighter, valueHighlighter, renderer, addDetailPane, supportNav));
  }


  private Iterable<IComputationTraceFilter> getSelectedFilter() {
    return ListSequence.fromList(this.filters).where((it) -> it.isSelected()).select((it) -> it.getFilter());
  }

  private void createTreeButKeepExpansionState() {
    doSaveExpansionState = false;
    traceTreeModel.createTree(getSelectedFilter());
    // the next instructions are order dependent!
    traceTreeModel.reload();
    TreeExpansionUtil.setExpandedTraces(tree, treeExpansionState);
    doSaveExpansionState = true;
  }


  public void createContents() {
    DefaultActionGroup toolbarActions = ActionUtils.groupFromActions(ListSequence.fromList(createActions()).toGenericArray(AnAction.class));
    toolbar = ActionManager.getInstance().createActionToolbar(ActionPlaces.TOOLBAR, toolbarActions, false);

    if (options.showDetailPane) {
      opx = new OnePixelSplitter(false, "TracerTool.Splitter.Proportion", 0.75f);
      JPanel pp = new JPanel();
      opx.setSecondComponent(ScrollPaneFactory.createScrollPane(pp, true));
      this.setContent(opx);
    }

    this.setToolbar(toolbar.getComponent());
  }

  private void createSelectionPopupMenu() {
    final JPanel panel = new JPanel(new GridLayout(ListSequence.fromList(filters).count(), 1));
    ListSequence.fromList(filters).visitAll((final FilterMenuOption it) -> {
      JBCheckboxMenuItem item = new JBCheckboxMenuItem(it.getName(), it.getIcon(), it.isSelected());
      item.addChangeListener(new ChangeListener() {
        @Override
        public void stateChanged(ChangeEvent p1) {
          it.setSelected(item.getState());
          createTreeButKeepExpansionState();
        }
      });
      panel.add(item);
    });
    final ComponentPopupBuilder menuComponent = JBPopupFactory.getInstance().createComponentPopupBuilder(panel, null);
    menuComponent.setMovable(true);
    menuComponent.setTitle(options.filterMenuTitle);
    Component componentOfFilterAction = toolbar.getComponent().getComponent(toolbar.getActions().indexOf(filterAction));
    JBPopup popup = menuComponent.createPopup();
    popup.showUnderneathOf(componentOfFilterAction);
  }

  protected void showSelectionDialog() {
    createSelectionPopupMenu();
  }

  protected List<AnAction> createActions() {
    final List<AnAction> actions = ListSequence.fromList(new ArrayList<AnAction>());
    ListSequence.fromList(actions).addElement(new CloseTabToolbarAction() {
      public void actionPerformed(final AnActionEvent event) {
        tool.closeTab(TraceTab.this);
      }
    });
    ListSequence.fromList(actions).addElement(new Separator());
    ListSequence.fromList(actions).addElement(new ClearTraceInformationFromCodeAction());
    if (root instanceof IRerunnableTraceRecord && options.toolButtonVisible(TraceTabOptions.ToolButtonEnum.Rerun)) {
      ListSequence.fromList(actions).addElement(new Separator());
      ListSequence.fromList(actions).addElement(new RerunTraceAction());
    }
    if (ListSequence.fromList(this.filters).count() > 1 && options.toolButtonVisible(TraceTabOptions.ToolButtonEnum.Filter)) {
      ListSequence.fromList(actions).addElement(new Separator());
      filterAction = new FilterAction();
      ListSequence.fromList(actions).addElement(filterAction);
    }
    ListSequence.fromList(actions).addElement(new Separator());
    ListSequence.fromList(actions).addElement(new ExpandAll());
    ListSequence.fromList(actions).addElement(new ExpandAsSaved());
    ListSequence.fromList(actions).addElement(new CollapseAll());
    if (options.toolButtonVisible(TraceTabOptions.ToolButtonEnum.NextTrace)) {
      ListSequence.fromList(actions).addElement(new Separator());
      ListSequence.fromList(actions).addElement(new NavDownAction());
    }
    if (options.codeHighlighter != null && options.toolButtonVisible(TraceTabOptions.ToolButtonEnum.Highlight)) {
      ListSequence.fromList(actions).addElement(new Separator());
      ListSequence.fromList(actions).addElement(new HighlightCodeAction());
    }
    if (options.toolButtonVisible(TraceTabOptions.ToolButtonEnum.GotoSource)) {
      ListSequence.fromList(actions).addElement(new Separator());
      ListSequence.fromList(actions).addElement(new GoToSourceAction());
    }
    return actions;
  }



  public void revealHighlightedNodes(DefaultMutableTreeNode n, boolean scrolledToFirst) {
    ITraceRecord tr = recordForTreeNode(n);
    if (tr != null && tr.mustBeRevealed()) {
      TreePath path = new TreePath(n.getPath()).getParentPath();
      tree.expandPath(path);
      if (!(scrolledToFirst)) {
        scrolledToFirst = true;
        tree.scrollPathToVisible(path);
      }
    }
    int cc = n.getChildCount();
    for (int i = 0; i < cc; i++) {
      revealHighlightedNodes(((DefaultMutableTreeNode) n.getChildAt(i)), scrolledToFirst);
    }
  }

  public ITraceRecord recordForTreeNode(DefaultMutableTreeNode treeNode) {
    Object uo = treeNode.getUserObject();
    if (uo != null) {
      if (uo instanceof ITraceRecord) {
        ITraceRecord tr = (ITraceRecord) uo;
        return tr;
      }
    }
    return null;
  }



  public void dispose() {
    clearTrace();
  }

  protected void clearTrace() {
    if (currentlyTracedRecord != null) {
      try {
        options.decorator.undecorate(currentlyTracedRecord);
      } finally {
        currentlyTracedRecord = null;
      }
    }
  }

  public abstract class TraceAction extends AnAction {

    public TraceAction(@Nullable @NlsActions.ActionText String text, @Nullable @NlsActions.ActionDescription String description, @Nullable Icon icon) {
      super(text, description, icon);
    }

    @NotNull
    @Override
    public ActionUpdateThread getActionUpdateThread() {
      return ActionUpdateThread.BGT;
    }
  }

  protected class ClearTraceInformationFromCodeAction extends TraceAction {
    public ClearTraceInformationFromCodeAction() {
      super("Removal of Trace Information from Code", "Undecorates any currently visible trace information within the code", AllIcons.Actions.CloseHovered);
    }
    @Override
    public void actionPerformed(AnActionEvent event) {
      clearTrace();
    }
  }

  protected class NavDownAction extends TraceAction {
    public NavDownAction() {
      super("Next Trace for Same Node", "Go to next trace of the same node", AllIcons.Actions.Forward);
    }
    @Override
    public void update(AnActionEvent e) {
      e.getPresentation().setEnabled(getTarget() != null);
    }

    @Override
    public void actionPerformed(AnActionEvent event) {
      final ITraceRecord record = getSelectedRecord();
      if (record == null) {
        return;
      }
      final SNodeReference target = record.getTarget();
      if (target == null) {
        return;
      }
      project.getRepository().getModelAccess().runReadAction(() -> findNextFor(target, record, record));
    }

    @Nullable
    protected SNodeReference getTarget() {
      ITraceRecord record = getSelectedRecord();
      if (record == null) {
        return null;
      }
      return record.getTarget();
    }

    @Nullable
    protected ITraceRecord getSelectedRecord() {
      List<ITraceRecord> recs = currentlySelectedRecords();
      if (ListSequence.fromList(recs).count() != 1) {
        return null;
      }

      return ListSequence.fromList(recs).first();
    }
  }


  /*package*/ List<ITraceRecord> searchNextHistory = ListSequence.fromList(new ArrayList<ITraceRecord>());
  /*package*/ SNodeReference searchNextNode = null;


  public boolean findNextFor(@NotNull SNodeReference nr, ITraceRecord start, ITraceRecord whereToLookFrom) {
    if (searchNextNode == null || !(searchNextNode.getNodeId().equals(nr.getNodeId()))) {
      searchNextNode = nr;
      ListSequence.fromList(searchNextHistory).clear();
      ListSequence.fromList(searchNextHistory).addElement(start);
    }
    ITraceRecord cur = whereToLookFrom;
    do {
      boolean found = findNextForInSubtree(nr, start, cur);
      if (found) {
        return true;
      }
      cur = cur.getParent();
    } while (cur != null);
    return false;
  }

  public boolean findNextForInSubtree(@NotNull SNodeReference nr, ITraceRecord start, ITraceRecord whereToLookFrom) {
    List<? extends ITraceRecord> children = traceTreeModel.getChildren(options.getFilters(), whereToLookFrom);
    for (ITraceRecord c : ListSequence.fromList(children)) {
      if (nr.equals(c.getTarget()) && !(ListSequence.fromList(searchNextHistory).contains(c))) {
        ListSequence.fromList(searchNextHistory).addElement(c);
        DefaultMutableTreeNode n = traceTreeModel.getChildContainingTraceRecord(c);
        TreePath path = new TreePath(n.getPath());
        tree.setSelectionPath(path);
        tree.scrollPathToVisible(path);
        tree.expandPath(path);
        return true;
      }
    }
    for (ITraceRecord c : ListSequence.fromList(children)) {
      boolean found = findNextForInSubtree(nr, start, c);
      if (found) {
        return true;
      }
    }
    return false;
  }


  protected class FilterAction extends TraceAction {
    public FilterAction() {
      super("Open Filter Menu", "Let you choose which filter should be applied", AllIcons.Actions.Checked);
    }
    @Override
    public void actionPerformed(@NotNull AnActionEvent event) {
      showSelectionDialog();
    }
  }

  protected class HighlightCodeAction extends ToggleAction {
    public HighlightCodeAction() {
      super("Highlight in Editor", null, AllIcons.Actions.Annotate);
    }
    @Override
    public boolean isSelected(AnActionEvent event) {
      return currentlyColored;
    }
    @Override
    public void setSelected(AnActionEvent event, boolean b) {
      currentlyColored = b;
      if (!(b)) {
        highlight(root, false);
      }
    }


    @NotNull
    @Override
    public ActionUpdateThread getActionUpdateThread() {
      return ActionUpdateThread.BGT;
    }
  }

  protected class GoToSourceAction extends TraceAction {

    public GoToSourceAction() {
      super("Goto Computation Source", "Go to the code that created this node, if available", AllIcons.Actions.EditSource);
    }

    @Override
    public void actionPerformed(AnActionEvent event) {
      List<ITraceRecord> records = currentlySelectedRecords();
      if (ListSequence.fromList(records).isNotEmpty()) {
        final ITraceRecord record = ListSequence.fromList(records).first();
        final SNodeReference reference = (record.computationSourceURL() != null ? PersistenceFacade.getInstance().createNodeReference(record.computationSourceURL()) : null);
        if (reference != null) {
          project.getRepository().getModelAccess().executeCommand(() -> {
            SNode node = reference.resolve(project.getRepository());
            if (node != null) {
              NavigationSupport.getInstance().openNode(project, node, true, true);
            }
          });
        }
      }
    }
    @Override
    public void update(@NotNull AnActionEvent e) {
      e.getPresentation().setEnabled(!(tree.isSelectionEmpty()));
    }
  }

  protected void highlight(final ITraceRecord r, final boolean setOrUnset) {
    project.getRepository().getModelAccess().runReadAction(() -> {
      Set<SNode> roots = SetSequence.fromSet(new HashSet<SNode>());
      highlightCodeInternal(r, setOrUnset, roots);
      highlightValueInternal(r, setOrUnset, roots);
      if (options.codeHighlighter != null) {
        options.codeHighlighter.updateEditors(roots);
      }
    });
  }

  public void highlightCodeInternal(ITraceRecord r, boolean setOrUnset, Set<SNode> roots) {
    if (options.codeHighlighter == null) {
      return;
    }
    if (setOrUnset) {
      options.codeHighlighter.highlight(r, roots);
    } else {
      options.codeHighlighter.unhighlight(r, roots);
    }
    Iterable<? extends ITraceRecord> cs = r.getChildren(false);
    for (ITraceRecord c : Sequence.fromIterable(cs)) {
      highlightCodeInternal(c, setOrUnset, roots);
    }
  }

  public void highlightValueInternal(ITraceRecord r, boolean setOrUnset, Set<SNode> roots) {
    if (options.valueHighlighter == null) {
      return;
    }
    if (setOrUnset) {
      options.valueHighlighter.highlight(r, roots);
    } else {
      options.valueHighlighter.unhighlight(r, roots);
    }
    if (!(setOrUnset)) {
      Iterable<? extends ITraceRecord> cs = r.getChildren(false);
      for (ITraceRecord c : Sequence.fromIterable(cs)) {
        highlightValueInternal(c, setOrUnset, roots);
      }
    }

  }

  protected class ExpandAll extends TraceAction {
    public ExpandAll() {
      super("Expand All", "Expand all trace nodes", AllIcons.Actions.Expandall);
    }
    @Override
    public void actionPerformed(AnActionEvent event) {
      doSaveExpansionState = false;
      project.getRepository().getModelAccess().runReadAction(() -> {
        for (int i = 0; i < tree.getRowCount(); ++i) {
          tree.expandRow(i);
        }
      });
      doSaveExpansionState = true;
    }
  }

  protected class ExpandAsSaved extends TraceAction {
    public ExpandAsSaved() {
      super("Apply last Manual Unfolding", "Unfolds the tree as done with last manual operation", AllIcons.Actions.ArrowExpand);
    }
    @Override
    public void actionPerformed(AnActionEvent event) {
      doSaveExpansionState = false;
      TreeExpansionUtil.setExpandedTraces(tree, treeExpansionState);
      doSaveExpansionState = true;
    }
    @Override
    public void update(@NotNull AnActionEvent e) {
      e.getPresentation().setEnabled(treeExpansionState != null);
    }
  }

  protected class CollapseAll extends TraceAction {
    public CollapseAll() {
      super("Collapse All", "Collapse all trace nodes", AllIcons.Actions.Collapseall);
    }
    @Override
    public void actionPerformed(AnActionEvent event) {
      doSaveExpansionState = false;
      project.getRepository().getModelAccess().runReadAction(() -> {
        for (int i = tree.getRowCount() - 1; i >= 0; i--) {
          tree.collapseRow(i);
        }
      });
      doSaveExpansionState = true;
    }
  }

  protected class RerunTraceAction extends TraceAction {
    public RerunTraceAction() {
      super("Rerun", "Rerun the underlying program to update the trace", AllIcons.Actions.Execute);
    }
    @Override
    public void actionPerformed(AnActionEvent event) {
      if (root instanceof IRerunnableTraceRecord) {
        project.getRepository().getModelAccess().runReadAction(() -> {
          ITraceRerunner rerunner = ((IRerunnableTraceRecord) root).getRerunner();
          if (rerunner != null) {
            IRerunnableTraceRecord newRoot = rerunner.rerun();
            if (newRoot != null) {
              root = newRoot;
              treeExpansionState = null;
              traceTreeModel.createTree(getSelectedFilter(), root);
              traceTreeModel.reload();
            } else {
              ApplicationManager.getApplication().invokeLater(() -> Messages.showErrorDialog(tree, "Rerunner returned null; retaining original tree."));
            }
          }
        });
      }
    }
    @Override
    public void update(@NotNull AnActionEvent e) {
      ITraceRerunner rerunner = ((IRerunnableTraceRecord) root).getRerunner();
      e.getPresentation().setEnabled(rerunner != null);
    }
  }

  protected void renderValueInternal(Object val) {
    if (options.showDetailPane) {
      JComponent pp = CVR.render(val, project);
      if (pp != null) {
        opx.setSecondComponent(ScrollPaneFactory.createScrollPane(wrapWithBox(pp), true));
      }
    }
  }

  protected JPanel wrapWithBox(JComponent comp) {
    JPanel box = new JPanel();
    box.setLayout(new BoxLayout(box, BoxLayout.Y_AXIS));
    box.add(comp);
    box.setOpaque(false);
    return box;
  }


  protected class OnDoubleClick extends MouseAdapter {
    @Override
    public void mouseClicked(MouseEvent e) {
      if (e.isPopupTrigger()) {
        // No context menu defined for the tree
        return;
      }
      if (e.getClickCount() == 1) {
        DefaultMutableTreeNode node = getNodeToClick(e);
        if (node != null) {
          this.onSingleClick(node);
        }
      }
      if (e.getClickCount() == 2) {
        DefaultMutableTreeNode node = getNodeToClick(e);
        if (node != null) {
          this.onDoubleClick(node);
        }
      }

    }

    protected void onDoubleClick(DefaultMutableTreeNode node) {
      ITraceRecord rec = recordForTreeNode(node);
      if (highlightCodeForRec(rec)) {
        return;
      }
    }


    protected void onSingleClick(DefaultMutableTreeNode node) {
      currentlySelectedRecords();
      ITraceRecord rec = recordForTreeNode(node);
      if (rec == null) {
        return;
      }
      if (options.codeHighlighter != null) {
        if (currentlyColored) {
          highlight(root, false);
          highlight(rec, true);
        }
      }

      renderValueInternal(rec.getTracedValue());
    }

    protected DefaultMutableTreeNode getNodeToClick(MouseEvent e) {
      Tree tree = (Tree) e.getSource();
      TreePath path = tree.getClosestPathForLocation(e.getX(), e.getY());
      if (path == null) {
        return null;
      }
      return (DefaultMutableTreeNode) path.getLastPathComponent();
    }
  }

  protected boolean highlightCodeForRec(ITraceRecord rec) {
    if (rec == null) {
      return true;
    }
    highlight(rec, false);
    clearTrace();
    options.decorator.decorate(rec);
    currentlyTracedRecord = rec;
    final Wrappers._T<SNode> target = new Wrappers._T<SNode>(rec.getTargetNode());
    if (options.getNodeMapper() != null) {
      project.getRepository().getModelAccess().runReadAction(() -> target.value = options.getNodeMapper().getMappedNodeOrGivenNode(target.value));
    }
    if (target.value != null) {
      selectFirstLeafCell(project, target.value.getReference());
    }
    return false;
  }


  public boolean selectNodeInTree(SNode n, boolean selectAll) {
    List<DefaultMutableTreeNode> toSelect = ListSequence.fromList(new ArrayList<DefaultMutableTreeNode>());
    DefaultMutableTreeNode root = ((DefaultMutableTreeNode) tree.getModel().getRoot());
    if (selectAll) {
      collectCorrespondingNodesInTree(toSelect, root, n.getReference(), true, null);
    } else {
      List<ITraceRecord> selected = currentlySelectedRecords();
      if (ListSequence.fromList(selected).count() == 1) {
        collectCorrespondingNodesInTree(toSelect, root, n.getReference(), false, ListSequence.fromList(selected).first());
      } else {
        collectCorrespondingNodesInTree(toSelect, root, n.getReference(), false, null);
      }
    }
    tree.setSelectionPaths(ListSequence.fromList(toSelect).select((it) -> new TreePath(it.getPath())).toGenericArray(TreePath.class));
    return ListSequence.fromList(toSelect).isNotEmpty();
  }

  public boolean selectNodeInTreeAndInspectSource(SNode n) {
    List<DefaultMutableTreeNode> toSelect = ListSequence.fromList(new ArrayList<DefaultMutableTreeNode>());
    DefaultMutableTreeNode root = ((DefaultMutableTreeNode) tree.getModel().getRoot());
    List<ITraceRecord> selected = currentlySelectedRecords();
    if (ListSequence.fromList(selected).count() == 1) {
      collectCorrespondingNodesInTree(toSelect, root, n.getReference(), false, ListSequence.fromList(selected).first());
    } else {
      collectCorrespondingNodesInTree(toSelect, root, n.getReference(), false, null);
    }
    tree.setSelectionPaths(ListSequence.fromList(toSelect).select((it) -> new TreePath(it.getPath())).toGenericArray(TreePath.class));
    if (ListSequence.fromList(toSelect).isNotEmpty()) {
      highlightCodeForRec(recordForTreeNode(ListSequence.fromList(toSelect).first()));
    }
    return ListSequence.fromList(toSelect).isNotEmpty();
  }

  protected boolean collectCorrespondingNodesInTree(List<DefaultMutableTreeNode> collector, DefaultMutableTreeNode treeNode, @NotNull SNodeReference mpsNode, boolean selectAll, ITraceRecord mustBeUnderThisOne) {
    ITraceRecord tr = recordForTreeNode(treeNode);
    if (tr != null) {
      SNodeReference target = tr.getTarget();
      if (mpsNode.equals(target)) {
        if (!(selectAll)) {
          if (mustBeUnderThisOne == null) {
            ListSequence.fromList(collector).addElement(treeNode);
            return true;
          } else {
            if (isUnder(tr, mustBeUnderThisOne)) {
              ListSequence.fromList(collector).addElement(treeNode);
              return true;
            }
          }
        } else {
          ListSequence.fromList(collector).addElement(treeNode);
        }
      }
    }
    int cc = treeNode.getChildCount();
    for (int i = 0; i < cc; i++) {
      boolean found = collectCorrespondingNodesInTree(collector, ((DefaultMutableTreeNode) treeNode.getChildAt(i)), mpsNode, selectAll, mustBeUnderThisOne);
      if (!(selectAll) && found) {
        return true;
      }
    }
    return false;
  }

  protected boolean isUnder(ITraceRecord child, ITraceRecord anc) {
    ITraceRecord pp = child.getParent();
    if (pp == null) {
      return false;
    }
    if (pp == anc) {
      return true;
    }
    return isUnder(pp, anc);
  }


  public List<ITraceRecord> currentlySelectedRecords() {
    List<ITraceRecord> res = ListSequence.fromList(new ArrayList<ITraceRecord>());
    TreePath[] paths = tree.getSelectionPaths();
    if (paths == null) {
      return res;
    }
    for (TreePath p : paths) {
      Object lpc = p.getLastPathComponent();
      if (lpc instanceof DefaultMutableTreeNode) {
        ListSequence.fromList(res).addElement(recordForTreeNode(((DefaultMutableTreeNode) lpc)));
      } else {
        ListSequence.fromList(res).addElement((ITraceRecord) lpc);
      }
    }
    return res;
  }

  public void renderValue(Object value) {
    renderValueInternal(value);
  }

  protected void selectFirstLeafCell(final Project project, final SNodeReference target) {
    project.getRepository().getModelAccess().executeCommand(() -> {
      SNode node = target.resolve(project.getRepository());
      if (node == null) {
        return;
      }
      Editor editor = NavigationSupport.getInstance().openNode(project, node, true, true);
      EditorComponent editorComponent = editor.getCurrentEditorComponent();
      editorComponent.getEditorContext().selectWRTFocusPolicy(node, true);
    });
  }
}
