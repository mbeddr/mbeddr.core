package com.mbeddr.mpsutil.traceExplorer.plugin;

/*Generated by MPS */

import java.util.List;
import com.mbeddr.mpsutil.interpreter.rt.ComputationTrace;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.internal.collections.runtime.Sequence;
import javax.swing.Icon;

public class TraceFilterNoChildsMarkedSkip implements IComputationTraceFilter {

  @Override
  public Iterable<? extends ITraceRecord> getChildren(ITraceRecord trace) {
    List<ComputationTrace> childTraces = ListSequence.fromList(new ArrayList<ComputationTrace>());
    if (!(trace instanceof ComputationTrace)) {
      return childTraces;
    }
    ComputationTrace computationTrace = as_fcmqqo_a0a2a1(trace, ComputationTrace.class);
    ListSequence.fromList(childTraces).addSequence(Sequence.fromIterable(findNextLevelFiltered(computationTrace)));
    return childTraces;
  }

  @Override
  public Icon getIcon() {
    return null;
  }
  @Override
  public String getName() {
    return "show all non-skippable trace nodes";
  }

  private Iterable<ComputationTrace> findNextLevelFiltered(ComputationTrace trace) {
    List<ComputationTrace> res = ListSequence.fromList(new ArrayList<ComputationTrace>());
    for (ComputationTrace c : ListSequence.fromList(trace.children()).where((it) -> !(it.neverEverShow()))) {
      if (c.getSkip()) {
        ListSequence.fromList(res).addSequence(Sequence.fromIterable(findNextLevelFiltered(c)));
      } else {
        ListSequence.fromList(res).addElement(c);
      }
    }
    return res;
  }

  @Override
  public void setup(ITraceRecord rootTrace) {
  }
  @Override
  public void tearDown() {
  }
  @Override
  public boolean isSelectedByDefault() {
    return false;
  }
  private static <T> T as_fcmqqo_a0a2a1(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
}
