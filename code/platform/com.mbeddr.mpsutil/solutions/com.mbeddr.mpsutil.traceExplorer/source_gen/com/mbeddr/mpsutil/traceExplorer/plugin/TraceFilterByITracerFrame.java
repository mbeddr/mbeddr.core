package com.mbeddr.mpsutil.traceExplorer.plugin;

/*Generated by MPS */

import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import com.mbeddr.mpsutil.interpreter.rt.ComputationTrace;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import jetbrains.mps.internal.collections.runtime.Sequence;
import com.mbeddr.mpsutil.interpreter.behavior.ITracerFrame__BehaviorDescriptor;
import javax.swing.Icon;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import org.jetbrains.mps.openapi.language.SInterfaceConcept;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;

public class TraceFilterByITracerFrame implements IComputationTraceFilter {

  private final List<ITraceRecord> alreadyMentionedTraces = ListSequence.fromList(new ArrayList<ITraceRecord>());

  @Override
  public Iterable<? extends ITraceRecord> getChildren(ITraceRecord trace) {
    List<ITraceRecord> childFrames = ListSequence.fromList(new ArrayList<ITraceRecord>());
    if (!(trace instanceof ComputationTrace)) {
      return childFrames;
    }
    ComputationTrace computationTrace = as_o1b279_a0a2a3(trace, ComputationTrace.class);

    final SNode targetNode = computationTrace.getTargetNode();
    // nested frames
    final Iterable<SNode> frames = SNodeOperations.ofConcept(SNodeOperations.getNodeDescendants(targetNode, CONCEPTS.ITracerFrame$iZ, false, new SAbstractConcept[]{}), CONCEPTS.ITracerFrame$iZ);
    for (SNode f : Sequence.fromIterable(frames)) {
      final List<SNode> fAnc = SNodeOperations.getNodeAncestors(f, null, false);
      if (ListSequence.fromList(fAnc).any((it) -> it != targetNode && ListSequence.fromList(fAnc).indexOf(it) < ListSequence.fromList(fAnc).indexOf(targetNode))) {
        continue;
      }
      ComputationTrace original = computationTrace.descendantForNode(f);
      if (original != null) {
        addIfNotNullAnyNotYetThere(childFrames, ((ComputationTrace) ITracerFrame__BehaviorDescriptor.constructCustomFrame_id2kg0xI3thT2.invoke(f, computationTrace, original)), false);
      }
    }

    // referenced frames
    if (SNodeOperations.isInstanceOf(targetNode, CONCEPTS.ITracerFrame$iZ)) {
      addThoseForFrames(computationTrace, childFrames);
    }

    final Iterable<ComputationTrace> showInAnyCase = findNextLevelFiltered(computationTrace);
    for (ComputationTrace any : Sequence.fromIterable(showInAnyCase)) {
      addIfNotNullAnyNotYetThere(childFrames, any, true);
    }

    return removeAlreadyScannedChilds(childFrames);
  }
  @Override
  public Icon getIcon() {
    return null;
  }

  @Override
  public String getName() {
    return "show reduced trace tree (default)";
  }

  private Iterable<ITraceRecord> removeAlreadyScannedChilds(Iterable<ITraceRecord> traces) {
    List<ITraceRecord> result = Sequence.fromIterable(traces).where(new _FunctionTypes._return_P1_E0<Boolean, ITraceRecord>() {
      public Boolean invoke(ITraceRecord it) {
        return !(ListSequence.fromList(alreadyMentionedTraces).contains(it));
      }
    }).toList();
    ListSequence.fromList(alreadyMentionedTraces).addSequence(ListSequence.fromList(result));
    return result;
  }

  private Iterable<ComputationTrace> findNextLevelFiltered(ComputationTrace trace) {
    List<ComputationTrace> res = ListSequence.fromList(new ArrayList<ComputationTrace>());
    for (ComputationTrace c : ListSequence.fromList(trace.children())) {
      if (c.getShowInAnyCase()) {
        ListSequence.fromList(res).addElement(c);
      } else {
        ListSequence.fromList(res).addSequence(Sequence.fromIterable(findNextLevelFiltered(c)));
      }
    }
    return res;
  }


  private void addThoseForFrames(ComputationTrace trace, List<ITraceRecord> childFrames) {

    SNode irf = SNodeOperations.cast(trace.getTargetNode(), CONCEPTS.ITracerFrame$iZ);
    List<SNode> referencedNodes = ITracerFrame__BehaviorDescriptor.referencedNodes_id7lHetQxJqtN.invoke(irf);
    for (SNode f : ListSequence.fromList(referencedNodes)) {
      addIfNotNullAnyNotYetThere(childFrames, trace.descendantForNode(f), false);
    }

    List<SNode> additionals = ITracerFrame__BehaviorDescriptor.additionallyShownNodes_id5Beavy19lGt.invoke(irf);
    for (SNode a : ListSequence.fromList(additionals)) {
      addIfNotNullAnyNotYetThere(childFrames, trace.descendantForNode(a), true);
    }
  }

  private void addIfNotNullAnyNotYetThere(List<ITraceRecord> l, final ComputationTrace o, boolean allowDuplicateNodes) {
    if (o == null) {
      return;
    }
    if (ListSequence.fromList(l).contains(o)) {
      return;
    }
    if (!(allowDuplicateNodes) && ListSequence.fromList(l).any(new _FunctionTypes._return_P1_E0<Boolean, ITraceRecord>() {
      public Boolean invoke(ITraceRecord it) {
        return it.getTarget().equals(o.getTarget());
      }
    })) {
      return;
    }
    ListSequence.fromList(l).addElement(o);
  }

  @Override
  public void setup(ITraceRecord rootTrace) {
    ListSequence.fromList(alreadyMentionedTraces).clear();
  }
  @Override
  public void tearDown() {
  }
  @Override
  public boolean isSelectedByDefault() {
    return true;
  }
  private static <T> T as_o1b279_a0a2a3(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }

  private static final class CONCEPTS {
    /*package*/ static final SInterfaceConcept ITracerFrame$iZ = MetaAdapterFactory.getInterfaceConcept(0x47f075a6558e4640L, 0xa6067ce0236c8023L, 0x760b48e4e8391c1fL, "com.mbeddr.mpsutil.interpreter.structure.ITracerFrame");
  }
}
