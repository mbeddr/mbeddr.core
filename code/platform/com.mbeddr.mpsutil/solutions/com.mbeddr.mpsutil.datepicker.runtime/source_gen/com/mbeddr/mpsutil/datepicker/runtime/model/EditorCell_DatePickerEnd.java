package com.mbeddr.mpsutil.datepicker.runtime.model;

/*Generated by MPS */

import jetbrains.mps.nodeEditor.cells.EditorCell_Constant;
import jetbrains.mps.openapi.editor.EditorContext;
import org.jetbrains.mps.openapi.model.SNode;
import java.awt.Graphics;
import jetbrains.mps.nodeEditor.cells.ParentSettings;
import java.awt.Color;
import java.awt.event.KeyEvent;
import jetbrains.mps.nodeEditor.CellSide;
import com.intellij.util.ui.UIUtil;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import jetbrains.mps.nodeEditor.IntelligentInputUtil;
import java.lang.reflect.Method;
import jetbrains.mps.nodeEditor.cells.EditorCell_Label;
import java.lang.reflect.InvocationTargetException;

public class EditorCell_DatePickerEnd extends EditorCell_Constant {

  public EditorCell_DatePickerEnd(EditorContext context, SNode snode) {
    super(context, snode, "", false);
  }

  @Override
  public void paintContent(Graphics graphics, ParentSettings settings) {
    super.paintContent(graphics, settings);

    graphics.setColor(new Color(0, 0, 0, 0));
    graphics.fillRect(getX(), getY(), getWidth(), getHeight());
  }

  @Override
  public int getWidth() {
    return 2;
  }

  @Override
  protected boolean doProcessKeyTyped(final KeyEvent keyEvent, final boolean allowErrors) {
    final CellSide side = CellSide.RIGHT;
    setCaretVisible(true);
    if (UIUtil.isReallyTypedEvent(keyEvent)) {
      final Wrappers._T<String> pattern = new Wrappers._T<String>(null);
      getEditorComponent().getEditorContext().getRepository().getModelAccess().runReadAction(() -> pattern.value = getTextOnEvent(keyEvent));

      pattern.value = " " + pattern.value;
      return IntelligentInputUtil.processCell(this, getContext(), pattern.value, side);
    }
    return false;
  }

  @Override
  public boolean isValidText(String text) {
    return "".equals(text) || " ".equals(text);
  }

  private String getTextOnEvent(KeyEvent keyEvent) {
    try {
      Method m = EditorCell_Label.class.getDeclaredMethod("getTextOnEvent", KeyEvent.class);
      m.setAccessible(true);
      return (String) m.invoke(this, keyEvent);
    } catch (InvocationTargetException e) {
      throw new RuntimeException(e);
    } catch (IllegalAccessException e) {
      throw new RuntimeException(e);
    } catch (NoSuchMethodException e) {
      throw new RuntimeException(e);
    }
  }
}
