package com.mbeddr.mpsutil.interpreter.migration.plugin;

/*Generated by MPS */

import jetbrains.mps.project.Project;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.project.MPSProject;
import javax.swing.SwingUtilities;
import com.intellij.openapi.application.ApplicationManager;
import jetbrains.mps.smodel.Language;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModuleOperations;
import jetbrains.mps.internal.collections.runtime.NotNullWhereFilter;
import org.jetbrains.mps.openapi.model.SNode;
import java.util.Objects;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import java.util.Set;
import org.jetbrains.mps.openapi.module.SModule;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import com.intellij.openapi.ui.Messages;
import jetbrains.mps.internal.collections.runtime.IterableUtils;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple;
import java.util.Map;
import java.util.HashMap;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import org.jetbrains.mps.openapi.model.SReference;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import jetbrains.mps.smodel.ModelDependencyUpdate;
import org.jetbrains.mps.openapi.module.SRepository;
import jetbrains.mps.project.Solution;
import jetbrains.mps.vfs.IFile;
import jetbrains.mps.project.structure.modules.SolutionDescriptor;
import jetbrains.mps.project.ModuleId;
import jetbrains.mps.persistence.DefaultModelRoot;
import jetbrains.mps.project.ProjectPathUtil;
import jetbrains.mps.smodel.GeneralModuleFactory;
import org.jetbrains.mps.openapi.persistence.ModelRoot;
import org.jetbrains.mps.openapi.model.EditableSModel;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import java.nio.file.Path;
import java.nio.file.Paths;
import jetbrains.mps.build.behavior.BuildRelativePath__BehaviorDescriptor;
import jetbrains.mps.build.util.Context;
import jetbrains.mps.generator.template.TemplateQueryContext;
import jetbrains.mps.build.mps.util.ModuleLoader;
import jetbrains.mps.ide.messages.DefaultMessageHandler;
import jetbrains.mps.build.mps.util.ModuleChecker;
import org.jetbrains.mps.openapi.language.SConcept;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import org.jetbrains.mps.openapi.language.SReferenceLink;
import org.jetbrains.mps.openapi.language.SProperty;

public class InterpreterMigrations {

  private static final String SOLUTION_SUFFIX = ".interpreter";

  private Project mpsProject;
  private com.intellij.openapi.project.Project ideaProject;
  private List<BuildScriptUpdateTask> buildScriptUpdateTasks = ListSequence.fromList(new ArrayList<BuildScriptUpdateTask>());

  public InterpreterMigrations(Project project) {
    mpsProject = project;
    ideaProject = ((MPSProject) project).getProject();
  }

  public void migrateProject() {
    SwingUtilities.invokeLater(() -> {

      ApplicationManager.getApplication().invokeLater(() -> mpsProject.getRepository().getModelAccess().executeCommand(() -> {
        Iterable<Language> module = mpsProject.getProjectModules(Language.class);
        Iterable<SModel> models = Sequence.fromIterable(module).select((it) -> SModuleOperations.getAspect(it, "plugin")).where(new NotNullWhereFilter());
        Iterable<SNode> allRoots = Sequence.fromIterable(models).translate((it) -> it.getRootNodes());
        Iterable<SNode> interpreterRoots = Sequence.fromIterable(allRoots).where((it) -> Objects.equals(it.getConcept().getLanguage(), MetaAdapterFactory.getLanguage(0x47f075a6558e4640L, 0xa6067ce0236c8023L, "com.mbeddr.mpsutil.interpreter"))).toList();

        final Set<SModule> nonMigratedLanguages = SetSequence.fromSet(new HashSet<SModule>());
        for (SNode relationshipTarget : Sequence.fromIterable(SLinkOperations.collect(SLinkOperations.collectMany(SNodeOperations.ofConcept(interpreterRoots, CONCEPTS.Interpreter$pR), LINKS.relationships$5tcg), LINKS.target$de6W))) {
          if (SNodeOperations.getModel(relationshipTarget).getModule() instanceof Language && !(Sequence.fromIterable(interpreterRoots).contains(relationshipTarget))) {
            SetSequence.fromSet(nonMigratedLanguages).addElement(SNodeOperations.getModel(relationshipTarget).getModule());
          }
        }
        if (SetSequence.fromSet(nonMigratedLanguages).isNotEmpty()) {
          ApplicationManager.getApplication().invokeLater(() -> Messages.showErrorDialog(ideaProject, "The following languages are not migrated and are not part of this project:\n\n" + IterableUtils.join(SetSequence.fromSet(nonMigratedLanguages).select((it) -> it.getModuleName()).sort((it) -> it, true), "\n"), "Interpreter Migration"));
          return;
        }

        moveRootNodes(interpreterRoots);
      }));
    });
  }

  protected void moveRootNodes(Iterable<SNode> nodes) {
    resolveBrokenReferences(SNodeOperations.ofConcept(nodes, CONCEPTS.Interpreter$pR));

    List<Tuples._2<SNode, SNode>> relationships = Sequence.fromIterable(SLinkOperations.collectMany(SNodeOperations.ofConcept(nodes, CONCEPTS.Interpreter$pR), LINKS.relationships$5tcg)).select((it) -> MultiTuple.<SNode,SNode>from(it, SLinkOperations.getTarget(it, LINKS.target$de6W))).toList();

    final Map<SModule, List<SNode>> moduleToNodes = new HashMap<SModule, List<SNode>>();
    for (SNode node : Sequence.fromIterable(nodes)) {
      SModule module = SNodeOperations.getModel(node).getModule();
      List<SNode> values = moduleToNodes.get(module);
      if (values == null) {
        // interpreterRoots in the caller are unique, no reason to bother with set
        values = ListSequence.fromList(new ArrayList<>());
        moduleToNodes.put(module, values);
      }
      ListSequence.fromList(values).addElement(node);
    }

    List<SModel> pluginModels = ListSequence.fromList(new ArrayList<SModel>());
    for (Map.Entry<SModule, List<SNode>> entry : SetSequence.fromSet(moduleToNodes.entrySet())) {
      SModel pluginModel = getOrCreatePluginModel(entry.getKey(), mpsProject);
      ListSequence.fromList(pluginModels).addElement(pluginModel);
      for (SNode node : ListSequence.fromList(entry.getValue())) {
        SModelOperations.addRootNode(pluginModel, SNodeOperations.deleteNode(node));
      }
    }

    for (Tuples._2<SNode, SNode> relationship : ListSequence.fromList(relationships)) {
      SLinkOperations.setTarget(relationship._0(), LINKS.target$de6W, relationship._1());
    }

    for (SModel pluginModel : ListSequence.fromList(pluginModels)) {
      fixModelDependencies(pluginModel);
    }

    if (ListSequence.fromList(buildScriptUpdateTasks).isEmpty()) {
      showMessage(moduleToNodes.keySet());
    } else {
      ApplicationManager.getApplication().invokeLater(() -> ApplicationManager.getApplication().runWriteAction(() -> {
        ApplicationManager.getApplication().saveAll();
        ApplicationManager.getApplication().invokeLater(() -> mpsProject.getRepository().getModelAccess().executeCommand(() -> {
          for (BuildScriptUpdateTask task : ListSequence.fromList(buildScriptUpdateTasks)) {
            task.run();
          }
          showMessage(moduleToNodes.keySet());
        }));
      }));
    }
  }

  public void resolveBrokenReferences(Iterable<SNode> movedInterpreters) {
    Iterable<SModule> allModules = mpsProject.getRepository().getModules();
    final Map<String, SNode> allInterpreters = MapSequence.fromMap(new HashMap<String, SNode>());
    Sequence.fromIterable(SNodeOperations.ofConcept(Sequence.fromIterable(allModules).where((it) -> it.getModuleName().endsWith(SOLUTION_SUFFIX)).translate((it) -> it.getModels()).translate((it) -> it.getRootNodes()), CONCEPTS.Interpreter$pR)).visitAll((it) -> MapSequence.fromMap(allInterpreters).put(SPropertyOperations.getString(it, PROPS.name$MnvL), it));

    for (SNode rel : Sequence.fromIterable(SLinkOperations.collectMany(movedInterpreters, LINKS.relationships$5tcg))) {
      SReference ref = SNodeOperations.getReference(rel, LINKS.target$de6W);
      if (SLinkOperations.getTargetNode(ref) == null && isNotEmptyString(SLinkOperations.getResolveInfo(ref))) {
        SNode resolved = MapSequence.fromMap(allInterpreters).get(SLinkOperations.getResolveInfo(ref));
        if ((resolved != null)) {
          SLinkOperations.setTarget(rel, LINKS.target$de6W, resolved);
        }
      }
    }
  }

  public void showMessage(Set<SModule> migratedLanguages) {
    final Wrappers._T<String> message = new Wrappers._T<String>();
    if (SetSequence.fromSet(migratedLanguages).isEmpty()) {
      message.value = "No migrations required";
    } else {
      message.value = "Migrated " + SetSequence.fromSet(migratedLanguages).count() + " languages";
      message.value += "\n\n";
      message.value += IterableUtils.join(SetSequence.fromSet(migratedLanguages).select((it) -> it.getModuleName()).sort((it) -> it, true), "\n");
    }
    ApplicationManager.getApplication().invokeLater(() -> Messages.showInfoMessage(ideaProject, message.value, "Interpreter Migration"));
  }

  protected void fixModelDependencies(SModel model) {
    ModelDependencyUpdate mdu = new ModelDependencyUpdate(model);
    mdu.updateUsedLanguages();
    SRepository repo = model.getRepository();
    mdu.updateImportedModels(repo);
    if (repo != null) {
      mdu.updateModuleDependencies(repo);
    }
  }

  public SModel getOrCreatePluginModel(SModule language, Project project) {
    String langName = language.getModuleName();
    String solutionName = langName + SOLUTION_SUFFIX;
    String pluginModelName = solutionName + ".plugin";

    Solution pluginSolution = getOrCreatePluginSolution(solutionName, project, project.getRepository(), language);
    SModel pluginModel = getOrCreateModel(pluginSolution, pluginModelName);

    return pluginModel;
  }

  protected Solution getOrCreatePluginSolution(final String moduleName, Project project, SRepository repository, SModule language) {
    Iterable<SModule> modules = repository.getModules();
    Solution module = Sequence.fromIterable(modules).ofType(Solution.class).findFirst((it) -> Objects.equals(it.getModuleName(), moduleName));

    // FIXME there's handy SolutionProducer in MPS 2022.2, please refactor
    if (module == null && project instanceof MPSProject) {
      MPSProject mpsProject = ((MPSProject) project);
      IFile projectPath = mpsProject.getFileSystem().getFile(mpsProject.getProjectFile());
      IFile folder = projectPath.findChild("solutions").findChild(moduleName);
      IFile descriptorFile = folder.findChild(moduleName + ".msd");
      SolutionDescriptor descriptor = new SolutionDescriptor();
      descriptor.setNamespace(moduleName);
      descriptor.setId(ModuleId.regular());

      IFile modelsDir = folder.findChild(Solution.SOLUTION_MODELS);
      modelsDir.mkdirs();

      descriptor.getModelRootDescriptors().add(DefaultModelRoot.createDescriptor(folder, modelsDir));
      ProjectPathUtil.setGeneratorOutputPath(descriptor, folder.findChild("source_gen").getPath());

      module = (Solution) new GeneralModuleFactory().instantiate(descriptor, descriptorFile);
      // Add the plugin solution to the project and put it in the same virtual folder as the language
      mpsProject.addModule(module);
      module.save();
      String folderName = mpsProject.getVirtualFolder(language);
      if ((folderName != null && folderName.length() > 0)) {
        mpsProject.setVirtualFolder(module, folderName);
      }
      mpsProject.save();

      addSolutionToBuildScripts(module, descriptorFile, language);
    }

    return module;
  }

  protected SModel getOrCreateModel(SModule module, final String modelName) {
    Iterable<SModel> models = module.getModels();
    SModel planModel = Sequence.fromIterable(models).findFirst((it) -> Objects.equals(it.getName().getValue(), modelName));
    if (planModel == null) {
      Iterable<ModelRoot> modelRoots = module.getModelRoots();
      ModelRoot mr = Sequence.fromIterable(modelRoots).findFirst((it) -> it.canCreateModels());
      planModel = (mr == null ? null : mr.createModel(modelName));
      if (planModel instanceof EditableSModel) {
        ((EditableSModel) planModel).save();
      }
    }
    return planModel;
  }

  private List<SNode> buildScripts;
  protected List<SNode> getBuildScripts() {
    if (buildScripts == null) {
      Iterable<SModule> modules = mpsProject.getRepository().getModules();
      buildScripts = Sequence.fromIterable(SNodeOperations.ofConcept(Sequence.fromIterable(modules).where((it) -> !(it.isReadOnly())).ofType(Solution.class).translate((it) -> it.getModels()).translate((it) -> it.getRootNodes()), CONCEPTS.BuildProject$ae)).toList();
    }
    return buildScripts;
  }

  protected void addSolutionToBuildScripts(SModule solution, IFile pathToDescriptor, final SModule language) {
    SNode languageEntry = ListSequence.fromList(getBuildScripts()).translate((it) -> SNodeOperations.getNodeDescendants(it, CONCEPTS.BuildMps_Language$RA, false, new SAbstractConcept[]{})).findFirst((it) -> Objects.equals(SPropertyOperations.getString(it, PROPS.uuid$pC01), language.getModuleId().toString()));
    if ((languageEntry == null)) {
      return;
    }

    SNode solutionEntry = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0xcf935df46994e9cL, 0xa132fa109541cba3L, 0x2c446791464290f7L, "jetbrains.mps.build.mps.structure.BuildMps_Solution"));
    SPropertyOperations.assign(solutionEntry, PROPS.compact$3xo1, true);
    SPropertyOperations.assign(solutionEntry, PROPS.uuid$pC01, solution.getModuleId().toString());
    SPropertyOperations.assign(solutionEntry, PROPS.name$MnvL, solution.getModuleName());
    SNodeOperations.insertNextSiblingChild(languageEntry, solutionEntry);

    SNode pathNode = SNodeOperations.copyNode(SNodeOperations.as(SLinkOperations.getTarget(languageEntry, LINKS.path$iYKB), CONCEPTS.BuildRelativePath$Kc));
    if ((pathNode == null)) {
      pathNode = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0x798100da4f0a421aL, 0xb99171f8c50ce5d2L, 0x4c12642949048fb2L, "jetbrains.mps.build.structure.BuildSourceProjectRelativePath"));
    }
    SLinkOperations.setTarget(solutionEntry, LINKS.path$iYKB, pathNode);

    Path relativized = Paths.get(BuildRelativePath__BehaviorDescriptor.getBasePath_id4jjtc7WZMYz.invoke(pathNode, Context.defaultContext())).normalize().relativize(Paths.get(pathToDescriptor.getPath()));
    SNode pathElementNode = null;
    for (Path pathElement : Sequence.fromIterable(relativized)) {
      if ((pathElementNode == null)) {
        pathElementNode = SLinkOperations.setNewChild(pathNode, LINKS.compositePart$blMW, null);
      } else {
        pathElementNode = SLinkOperations.setNewChild(pathElementNode, LINKS.tail$$gpz, null);
      }
      SPropertyOperations.assign(pathElementNode, PROPS.head$$gC$, pathElement.toString());
    }

    ListSequence.fromList(buildScriptUpdateTasks).addElement(new BuildScriptUpdateTask(solutionEntry));
  }

  public class BuildScriptUpdateTask implements Runnable {
    private SNode entry;

    public BuildScriptUpdateTask(SNode entry1) {
      entry = entry1;
    }

    @Override
    public void run() {
      // FIXME need explicit use of j.m.l.generator.generationContext language
      // otherwise face puzzling compilation error. ModuleLoader uses the language and get its RT, MPS.Generator,
      // but doesn't expose/re-export it further (general MPS approach). Apparently, Java compiler could not
      // live without access to TemplateQueryContext class here, even if we pass 'null'.
      // This hack is here to ensure MPS.Generator runtime (with TQC class) is part of classpath of this module.
      TemplateQueryContext gctx = null;
      ModuleLoader loader = new ModuleLoader(SNodeOperations.getNodeAncestor(entry, CONCEPTS.BuildProject$ae, false, false), gctx, new DefaultMessageHandler(ideaProject));
      loader.createModuleChecker(entry).check(ModuleChecker.CheckType.LOAD_IMPORTANT_PART);
      SPropertyOperations.assign(entry, PROPS.compact$3xo1, true);
    }
  }
  private static boolean isNotEmptyString(String str) {
    return str != null && str.length() > 0;
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept Interpreter$pR = MetaAdapterFactory.getConcept(0x47f075a6558e4640L, 0xa6067ce0236c8023L, 0x778ee47a6de672eaL, "com.mbeddr.mpsutil.interpreter.structure.Interpreter");
    /*package*/ static final SConcept BuildProject$ae = MetaAdapterFactory.getConcept(0x798100da4f0a421aL, 0xb99171f8c50ce5d2L, 0x4df58c6f18f84a13L, "jetbrains.mps.build.structure.BuildProject");
    /*package*/ static final SConcept BuildMps_Language$RA = MetaAdapterFactory.getConcept(0xcf935df46994e9cL, 0xa132fa109541cba3L, 0x2c446791464290f8L, "jetbrains.mps.build.mps.structure.BuildMps_Language");
    /*package*/ static final SConcept BuildRelativePath$Kc = MetaAdapterFactory.getConcept(0x798100da4f0a421aL, 0xb99171f8c50ce5d2L, 0x65997a657729f6fbL, "jetbrains.mps.build.structure.BuildRelativePath");
  }

  private static final class LINKS {
    /*package*/ static final SContainmentLink relationships$5tcg = MetaAdapterFactory.getContainmentLink(0x47f075a6558e4640L, 0xa6067ce0236c8023L, 0x778ee47a6de672eaL, 0x5c78e297336844c3L, "relationships");
    /*package*/ static final SReferenceLink target$de6W = MetaAdapterFactory.getReferenceLink(0x47f075a6558e4640L, 0xa6067ce0236c8023L, 0x5c78e2973360a2c1L, 0x5c78e29733672c61L, "target");
    /*package*/ static final SContainmentLink path$iYKB = MetaAdapterFactory.getContainmentLink(0xcf935df46994e9cL, 0xa132fa109541cba3L, 0x4780308f5d333ebL, 0x4780308f5d47f25L, "path");
    /*package*/ static final SContainmentLink compositePart$blMW = MetaAdapterFactory.getContainmentLink(0x798100da4f0a421aL, 0xb99171f8c50ce5d2L, 0x65997a657729f6fbL, 0x65997a65772aebcbL, "compositePart");
    /*package*/ static final SContainmentLink tail$$gpz = MetaAdapterFactory.getContainmentLink(0x798100da4f0a421aL, 0xb99171f8c50ce5d2L, 0x779c6e65c01467f1L, 0x779c6e65c01467f2L, "tail");
  }

  private static final class PROPS {
    /*package*/ static final SProperty name$MnvL = MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name");
    /*package*/ static final SProperty uuid$pC01 = MetaAdapterFactory.getProperty(0xcf935df46994e9cL, 0xa132fa109541cba3L, 0x4780308f5d333ebL, 0x4780308f5d3868bL, "uuid");
    /*package*/ static final SProperty compact$3xo1 = MetaAdapterFactory.getProperty(0xcf935df46994e9cL, 0xa132fa109541cba3L, 0x4780308f5d333ebL, 0x742675d05378e98dL, "compact");
    /*package*/ static final SProperty head$$gC$ = MetaAdapterFactory.getProperty(0x798100da4f0a421aL, 0xb99171f8c50ce5d2L, 0x779c6e65c01467f1L, 0x779c6e65c01467f3L, "head");
  }
}
