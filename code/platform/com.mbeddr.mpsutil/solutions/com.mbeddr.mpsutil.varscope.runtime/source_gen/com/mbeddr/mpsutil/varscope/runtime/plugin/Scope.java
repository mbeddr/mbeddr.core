package com.mbeddr.mpsutil.varscope.runtime.plugin;

/*Generated by MPS */

import java.util.Map;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.internal.collections.runtime.IMapping;
import org.jetbrains.mps.openapi.language.SProperty;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;

public class Scope {

  public static final int NO_POSITION = -1;
  private Scope outer;
  private Map<String, SNode> elementMap = MapSequence.fromMap(new HashMap<String, SNode>());

  public Scope(Iterable<SNode> elements) {
    for (SNode element : Sequence.fromIterable(elements)) {
      MapSequence.fromMap(elementMap).put(SPropertyOperations.getString(element, PROPS.name$MnvL), element);
    }
  }

  public void setOuterScope(Scope outer) {
    this.outer = outer;
  }

  public Iterable<SNode> getScopeElements() {
    Map<String, SNode> result = MapSequence.fromMap(new HashMap<String, SNode>());

    Scope current = this;
    while (current != null) {
      for (IMapping<String, SNode> var : MapSequence.fromMap(current.elementMap)) {
        if (!(MapSequence.fromMap(result).containsKey(var.key()))) {
          MapSequence.fromMap(result).put(var.key(), var.value());
        }
      }
      current = current.outer;
    }

    return MapSequence.fromMap(result).values();
  }

  public SNode getScopeElementByName(final String name) {
    return Sequence.fromIterable(getScopeElements()).findFirst((it) -> SPropertyOperations.getString(it, PROPS.name$MnvL).equals(name));
  }

  private static final class PROPS {
    /*package*/ static final SProperty name$MnvL = MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name");
  }
}
