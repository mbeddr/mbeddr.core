package com.mbeddr.mpsutil.targetchooser;

/*Generated by MPS */

import jetbrains.mps.ide.ui.tree.smodel.SNodeTreeNode;
import org.jetbrains.mps.openapi.model.SNode;
import org.jetbrains.mps.util.Condition;
import de.slisson.mps.reflection.runtime.ReflectionUtil;
import javax.swing.tree.DefaultTreeModel;
import jetbrains.mps.ide.ui.tree.smodel.SModelTreeNode;

public class TargetChooser_SNodeTreeNode extends SNodeTreeNode {

  private TargetChooserScope myScope;

  public TargetChooser_SNodeTreeNode(SNode node, String role, TargetChooserScope scope) {
    super(node, null, new InvalidSNodeCondition());
    myScope = scope;
  }

  protected Condition<SNode> getCondition() {
    return ((Condition<SNode>) ReflectionUtil.readField(SNodeTreeNode.class, ((SNodeTreeNode) this), "myCondition"));
  }

  @Override
  protected void doInit() {
    this.removeAllChildren();
    SNode n = getSNode();
    if (n == null) {
      return;
    }

    // FIXME SNodeTreeNode in MPS delegates to NodeChildrenProvider ancestor in the tree, seems there's no reason to have dedicated
    //      TargetChooser_SNodeTreeNode with myScope, any ancestor could do the same.

    for (SNode childNode : myScope.getChildNodes(n)) {
      SNodeTreeNode child = createChildTreeNode(childNode, childNode.getRoleInParent());
      ReflectionUtil.writeField(SNodeTreeNode.class, child, "myCondition", getCondition());
      add(child);
    }
    DefaultTreeModel treeModel = (DefaultTreeModel) getTree().getModel();
    treeModel.nodeStructureChanged(this);
    myInitialized = true;
  }

  protected SNodeTreeNode createChildTreeNode(SNode childNode, String role) {
    SModelTreeNode sModelTreeNode = getSModelModelTreeNode();
    SNodeTreeNode child = (sModelTreeNode == null ? new TargetChooser_SNodeTreeNode(childNode, role, myScope) : sModelTreeNode.createSNodeTreeNode(childNode, role));
    return child;
  }

}
