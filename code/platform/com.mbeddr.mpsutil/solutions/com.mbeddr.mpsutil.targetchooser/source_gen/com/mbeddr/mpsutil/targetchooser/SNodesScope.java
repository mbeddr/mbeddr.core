package com.mbeddr.mpsutil.targetchooser;

/*Generated by MPS */

import java.util.Set;
import org.jetbrains.mps.openapi.module.SModule;
import org.jetbrains.mps.openapi.model.SModel;
import org.jetbrains.mps.openapi.model.SNode;
import org.jetbrains.annotations.Nullable;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.LinkedHashSet;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import java.util.HashSet;
import jetbrains.mps.project.Project;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import org.jetbrains.mps.util.Condition;

public class SNodesScope extends AbstractTargetChooserScope {

  private Set<SModule> myModules;
  private Set<SModel> myModels;
  private Set<SNode> myRootNodes;
  private Set<SNode> myNodes;
  private Set<SNode> myAncestors;
  @Nullable
  private SNodeFilter myAncestorFilter;

  public SNodesScope(Iterable<SNode> nodes, @Nullable SNodeFilter ancestorFilter) {
    myAncestorFilter = ancestorFilter;
    myNodes = SetSequence.fromSetWithValues(new LinkedHashSet<SNode>(), nodes);
    myRootNodes = SetSequence.fromSetWithValues(new LinkedHashSet<SNode>(), Sequence.fromIterable(nodes).select((it) -> SNodeOperations.getContainingRoot(it)));
    myModels = SetSequence.fromSetWithValues(new LinkedHashSet<SModel>(), SetSequence.fromSet(myRootNodes).select((it) -> SNodeOperations.getModel(it)));
    myModules = SetSequence.fromSetWithValues(new LinkedHashSet<SModule>(), SetSequence.fromSet(myModels).select((it) -> it.getModule()));
    if (ancestorFilter != null) {
      myAncestors = SetSequence.fromSetWithValues(new HashSet<SNode>(), SetSequence.fromSet(myNodes).translate((it) -> SNodeOperations.getNodeAncestors(it, null, false)));
    }
  }

  public SNodesScope(Iterable<SNode> nodes) {
    this(nodes, null);
  }

  public Iterable<SModule> getModules(Project project) {
    return myModules;
  }

  public boolean showModel(SModel model) {
    return SetSequence.fromSet(myModels).contains(model);
  }

  public Iterable<SNode> getRootNodes(SModel model) {
    return ListSequence.fromList(SModelOperations.roots(model, null)).where((it) -> SetSequence.fromSet(myRootNodes).contains(it));
  }

  public Iterable<SNode> getChildNodes(SNode parent) {
    return TargetChooserUtil.getFirstLevelDescendants(parent, new Condition<SNode>() {
      public boolean met(SNode candidate) {
        if (SetSequence.fromSet(myNodes).contains(candidate)) {
          return true;
        }
        if (myAncestorFilter != null) {
          if (SetSequence.fromSet(myAncestors).contains(candidate) && myAncestorFilter.keep(candidate)) {
            return true;
          }
        }
        return false;
      }
    });
  }
}
