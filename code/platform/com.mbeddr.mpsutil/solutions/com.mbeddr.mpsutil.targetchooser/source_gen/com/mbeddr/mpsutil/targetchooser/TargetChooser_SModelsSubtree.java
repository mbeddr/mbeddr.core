package com.mbeddr.mpsutil.targetchooser;

/*Generated by MPS */

import jetbrains.mps.project.Project;
import jetbrains.mps.ide.ui.tree.module.ProjectModuleTreeNode;
import org.jetbrains.mps.openapi.module.SModule;
import jetbrains.mps.smodel.Language;
import jetbrains.mps.project.Solution;
import jetbrains.mps.project.AbstractModule;
import jetbrains.mps.project.DevKit;
import jetbrains.mps.smodel.Generator;
import jetbrains.mps.ide.ui.tree.module.GeneratorTreeNode;
import jetbrains.mps.ide.ui.tree.MPSTreeNode;
import jetbrains.mps.util.IterableUtil;
import java.util.List;
import org.jetbrains.mps.openapi.model.SModel;
import java.util.ArrayList;
import jetbrains.mps.smodel.tempmodel.TemporaryModels;
import jetbrains.mps.smodel.SModelStereotype;
import jetbrains.mps.ide.ui.tree.smodel.SModelTreeNode;
import jetbrains.mps.ide.ui.tree.module.SModelNamespaceTreeBuilder;
import java.util.Enumeration;
import javax.swing.tree.MutableTreeNode;
import jetbrains.mps.ide.ui.tree.module.ProjectLanguageTreeNode;
import jetbrains.mps.ide.ui.tree.module.TransientModelsTreeNode;
import jetbrains.mps.ide.ui.tree.SortUtil;
import org.jetbrains.mps.openapi.model.SModelName;
import jetbrains.mps.generator.TransientModelsModule;
import jetbrains.mps.ide.ui.tree.TextTreeNode;
import jetbrains.mps.ide.ui.tree.module.StereotypeProvider;
import com.intellij.icons.AllIcons;
import jetbrains.mps.smodel.LanguageID;

public class TargetChooser_SModelsSubtree {

  private Project myProject;
  private TargetChooserOptions myOptions;

  public TargetChooser_SModelsSubtree(Project project, TargetChooserOptions options) {
    myProject = project;
    myOptions = options;
  }

  public Project getProject() {
    return myProject;
  }

  public TargetChooserOptions getOptions() {
    return myOptions;
  }

  public ProjectModuleTreeNode createProjectModuleTreeNode(SModule module, boolean shortNameOnly) {
    if (module instanceof Language) {
      return new TargetChooser_ProjectLanguageTreeNode((Language) module, myProject, shortNameOnly, this);
    } else
    if (module instanceof Solution) {
      return new TargetChooser_ProjectSolutionTreeNode((AbstractModule) module, myProject, shortNameOnly, this);
    } else
    if (module instanceof DevKit) {
      return new TargetChooser_ProjectDevKitTreeNode((DevKit) module, myProject, false, this);
    } else
    if (module instanceof Generator) {
      return new GeneratorTreeNode((Generator) module, myProject);
    }
    return null;
  }

  public ProjectModuleTreeNode createProjectModuleTreeNode(SModule module) {
    return createProjectModuleTreeNode(module, false);
  }

  public void create(MPSTreeNode rootTreeNode, SModule module) {
    create(rootTreeNode, module, IterableUtil.asList(module.getModels()), false);
  }

  public void create(MPSTreeNode rootTreeNode, SModule contextModule, List<SModel> models, boolean dropMiddleNodes) {
    List<SModel> regularModels = new ArrayList<SModel>();
    List<SModel> tests = new ArrayList<SModel>();
    List<SModel> stubs = new ArrayList<SModel>();
    // todo this subdivision should be eliminated later
    for (SModel modelDescriptor : models) {
      if (TemporaryModels.isTemporary(modelDescriptor)) {
        continue;
      }
      if (SModelStereotype.isStubModel(modelDescriptor)) {
        stubs.add(modelDescriptor);
      } else
      if (SModelStereotype.isTestModel(modelDescriptor)) {
        tests.add(modelDescriptor);
      } else {
        regularModels.add(modelDescriptor);
      }
    }

    // filter models
    regularModels = TargetChooserUtil.applyFilter(myOptions.getScope(), regularModels);
    tests = TargetChooserUtil.applyFilter(myOptions.getScope(), tests);
    stubs = TargetChooserUtil.applyFilter(myOptions.getScope(), stubs);

    List<SModelTreeNode> regularModelNodes = getRootModelTreeNodes(regularModels, isNeedBuildChildModels(rootTreeNode));
    if (!(regularModelNodes.isEmpty())) {
      if (contextModule instanceof Language) {
        for (SModelTreeNode treeNode : regularModelNodes) {
          rootTreeNode.add(treeNode);
        }
        if (!(rootTreeNode.equals(rootTreeNode))) {
          rootTreeNode.add(rootTreeNode);
        }
      } else {
        SModelNamespaceTreeBuilder builder = new SModelNamespaceTreeBuilder();
        for (SModelTreeNode treeNode : regularModelNodes) {
          builder.addNode(treeNode);
        }
        builder.fillNode(rootTreeNode);
      }
    }
    if (!(tests.isEmpty())) {
      SModelNamespaceTreeBuilder builder = new SModelNamespaceTreeBuilder();
      List<SModelTreeNode> testNodes = getRootModelTreeNodes(tests, isNeedBuildChildModels(rootTreeNode));
      for (SModelTreeNode testNode : testNodes) {
        builder.addNode(testNode);
      }
      TestsTreeNode testsNode = new TestsTreeNode();
      builder.fillNode(testsNode);
      if (!(dropMiddleNodes)) {
        rootTreeNode.add(testsNode);
      } else {
        Enumeration children = testsNode.children();
        while (children.hasMoreElements()) {
          rootTreeNode.add((MutableTreeNode) children.nextElement());
        }
      }
    }
    if (!(stubs.isEmpty())) {
      SModelNamespaceTreeBuilder builder = new SModelNamespaceTreeBuilder();
      List<SModelTreeNode> stubNodes = getRootModelTreeNodes(stubs, isNeedBuildChildModels(rootTreeNode));
      for (SModelTreeNode treeNode : stubNodes) {
        builder.addNode(treeNode);
      }
      StubsTreeNode stubsNode = new StubsTreeNode();
      builder.fillNode(stubsNode);
      if (!(dropMiddleNodes)) {
        rootTreeNode.add(stubsNode);
      } else {
        Enumeration children = stubsNode.children();
        List<MutableTreeNode> tmpList = new ArrayList<MutableTreeNode>();
        while (children.hasMoreElements()) {
          tmpList.add((MutableTreeNode) children.nextElement());
        }
        for (MutableTreeNode child : tmpList) {
          rootTreeNode.add(child);
        }
      }
    }
  }

  private boolean isNeedBuildChildModels(MPSTreeNode rootTreeNode) {
    return !(rootTreeNode instanceof ProjectLanguageTreeNode || rootTreeNode instanceof TransientModelsTreeNode);
  }

  private List<SModelTreeNode> getRootModelTreeNodes(List<SModel> models, boolean isNeedBuildChildModels) {
    List<SModelTreeNode> result = new ArrayList<SModelTreeNode>();
    List<SModel> sortedModels = SortUtil.sortModels(models);
    if (!(sortedModels.isEmpty())) {
      int rootIndex = 0;
      while (rootIndex < sortedModels.size()) {
        SModel rootModelDescriptor = sortedModels.get(rootIndex);
        int countNamePart = getCountNamePart(rootModelDescriptor, rootModelDescriptor.getName().getNamespace());
        SModelTreeNode treeNode = createSModelTreeNode(sortedModels.get(rootIndex), countNamePart);
        result.add(treeNode);
        rootIndex = ((isNeedBuildChildModels) ? buildChildModels(treeNode, sortedModels, rootIndex) : rootIndex + 1);
      }
    }
    return result;
  }

  private int buildChildModels(SModelTreeNode treeNode, List<SModel> candidates, int rootIndex) {
    int index = rootIndex + 1;
    SModelName parentModelName = treeNode.getModel().getName();
    while (index < candidates.size()) {
      SModel candidate = candidates.get(index);
      if (isSubfolderModel(parentModelName, candidate)) {
        int countNamePart = getCountNamePart(candidate, treeNode.getModel().getName().getLongName());
        SModelTreeNode newChildModel = createSModelTreeNode(candidate, countNamePart);
        treeNode.addChildModel(newChildModel);
        index = buildChildModels(newChildModel, candidates, index);
      } else {
        return index;
      }
    }
    return index;
  }

  private static boolean isSubfolderModel(SModelName rootModel, SModel candidate) {
    final String modelName = rootModel.getLongName();
    String candidateName = candidate.getName().getLongName();
    if (!(candidateName.startsWith(modelName)) || modelName.equals(candidateName)) {
      return false;
    }
    if (candidateName.charAt(modelName.length()) == '.') {
      String modelStereotype = rootModel.getStereotype();
      String candidateStereotype = candidate.getName().getStereotype();
      if (!(modelStereotype.equals(candidateStereotype))) {
        return false;
      }
      return true;
    }
    return false;
  }


  public SModelTreeNode createSModelTreeNode(SModel candidate, int countNamePart) {
    return new TargetChooser_SModelTreeNode(candidate, null, myOptions.getScope(), countNamePart);
  }

  public int getCountNamePart(SModel md, String baseName) {
    String modelLongName = md.getName().getLongName();
    String shortName = (md instanceof TransientModelsModule.TransientSModelDescriptor ? modelLongName : modelLongName.replace(baseName + '.', ""));
    return shortName.split("\\.").length - 1;
  }

  public static class StubsTreeNode extends TextTreeNode implements StereotypeProvider {
    public StubsTreeNode() {
      super("stubs");
      setIcon(AllIcons.Nodes.ModuleGroup);
    }
    @Override
    public String getStereotype() {
      return SModelStereotype.getStubStereotypeForId(LanguageID.JAVA);
    }
    @Override
    public boolean isStrict() {
      return true;
    }
  }

  public static class TestsTreeNode extends TextTreeNode implements StereotypeProvider {
    public TestsTreeNode() {
      super("tests");
      setIcon(AllIcons.Nodes.ModuleGroup);
    }
    @Override
    public String getStereotype() {
      return SModelStereotype.TESTS;
    }
    @Override
    public boolean isStrict() {
      return true;
    }
  }
}
