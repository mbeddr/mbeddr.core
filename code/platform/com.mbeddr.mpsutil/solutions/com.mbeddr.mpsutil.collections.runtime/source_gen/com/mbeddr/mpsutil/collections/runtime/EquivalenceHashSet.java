package com.mbeddr.mpsutil.collections.runtime;

/*Generated by MPS */

import java.util.AbstractSet;
import java.util.Set;
import com.google.common.base.Equivalence;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import java.util.Collection;
import java.util.Iterator;
import com.intellij.util.containers.ContainerUtil;
import java.util.Objects;
import java.util.function.Function;
import java.util.stream.Collectors;

public class EquivalenceHashSet<T> extends AbstractSet<T> {
  private final Set<Equivalence.Wrapper<T>> internalSet;
  private final Equivalence<T> equivalence;

  public EquivalenceHashSet() {
    this((Equivalence<T>) EqualsEquivalence.INSTANCE);
  }

  public EquivalenceHashSet(Equivalence<T> equivalence) {
    this(SetSequence.fromSet(new HashSet<>()), equivalence);
  }

  public EquivalenceHashSet(Set set, Equivalence<T> equivalence) {
    this.internalSet = set;
    this.equivalence = equivalence;
  }

  private Equivalence.Wrapper<T> wrap(T element) {
    return equivalence.wrap(element);
  }

  @Override
  public boolean add(T element) {
    return internalSet.add(wrap(element));
  }

  @Override
  public boolean addAll(Collection<? extends T> elements) {
    boolean modified = false;
    for (T element : elements) {
      if (add(element)) {
        modified = true;
      }
    }
    return modified;
  }

  @Override
  public int size() {
    return internalSet.size();
  }

  @Override
  public boolean isEmpty() {
    return internalSet.isEmpty();
  }

  @Override
  public boolean contains(Object o) {
    return internalSet.contains(wrap(((T) o)));
  }

  @Override
  public Iterator<T> iterator() {
    return ContainerUtil.<T>filterIterator(ContainerUtil.mapIterator(internalSet.iterator(), Equivalence.Wrapper::get), Objects::nonNull);
  }

  @Override
  public Object[] toArray() {
    return internalSet.stream().map((Equivalence.Wrapper<T> e) -> e.get()).toArray();
  }

  @Override
  public <T> T[] toArray(T[] a) {
    return internalSet.stream().map(new Function<Equivalence.Wrapper, T>() {
      public T apply(Equivalence.Wrapper a) {
        return (T) a.get();
      }
    }).collect(Collectors.toList()).toArray(a);
  }

  @Override
  public boolean remove(Object o) {
    return internalSet.remove(wrap(((T) o)));
  }

  @Override
  public boolean containsAll(Collection<?> c) {
    return internalSet.containsAll(c);
  }

  @Override
  public boolean removeAll(Collection<?> c) {
    return internalSet.removeAll(c);
  }

  @Override
  public boolean retainAll(Collection<?> c) {
    return internalSet.retainAll(c);
  }

  @Override
  public void clear() {
    internalSet.clear();
  }
}
