package com.mbeddr.mpsutil.asynccell.plugin;

/*Generated by MPS */

import jetbrains.mps.logging.Logger;
import java.util.concurrent.Future;
import javax.swing.Timer;
import java.awt.event.ActionEvent;
import java.util.concurrent.ExecutionException;
import com.intellij.openapi.application.ApplicationManager;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import jetbrains.mps.editor.runtime.style.StyleImpl;
import javax.swing.SwingUtilities;

/**
 * I regularly reevaluate the callable that was provided to this cell ({@link com.mbeddr.mpsutil.asynccell.plugin.EditorCell_Async#getAsyncValueCallable() }.
 * If it returns a non-null value, I update the cell and remove it from {@link com.mbeddr.mpsutil.asynccell.plugin.AsyncCellManager }.
 */
public class AsyncCellUpdater {
  private static final Logger LOG = Logger.getLogger(AsyncCellUpdater.class);
  protected final int CHECK_INTERVAL = 500;
  private Future<?> _currentUpdate;
  private final AsyncCellManager _cellManager;
  private final Timer _timer = new Timer(this.CHECK_INTERVAL, (ActionEvent evt) -> AsyncCellUpdater.this.scheduleReevaluation());

  /**
   * Start checking if the cells' computation finished every {@link com.mbeddr.mpsutil.asynccell.plugin.AsyncCellUpdater#CHECK_INTERVAL }
   */
  public void start() {
    _timer.start();
  }

  public boolean isRunning() {
    return _timer.isRunning();
  }

  /**
   * Stop checking every {@link com.mbeddr.mpsutil.asynccell.plugin.AsyncCellUpdater#CHECK_INTERVAL }
   */
  public void stop() {
    _timer.stop();
    check_wdjy4l_a1a9(_currentUpdate);
  }

  /**
   * Suspend the current threat until the background worker finished posting the update to the EDT
   */
  public void waitForUpdateToFinish() throws InterruptedException, ExecutionException {
    if (_currentUpdate == null || _currentUpdate.isDone()) {
      return;
    }
    _currentUpdate.get();
  }

  public AsyncCellUpdater(AsyncCellManager cellManager) {
    _cellManager = cellManager;
  }

  /**
   * Called whenever the timer ticks.
   */
  public Future<?> scheduleReevaluation() {
    // abort if the last update didn't finish yet
    if (_currentUpdate != null && !(_currentUpdate.isDone())) {
      return _currentUpdate;
    }

    // schedule update
    _currentUpdate = ApplicationManager.getApplication().executeOnPooledThread(new AsyncCellUpdaterThread());

    return _currentUpdate;
  }

  public class AsyncCellUpdaterThread implements Runnable {
    @Override
    public void run() {
      if (LOG.isTraceLevel()) {
        LOG.trace("AsyncCellUpdaterThread#run for " + Sequence.fromIterable(_cellManager.getAsyncCells()).count() + " cells");
      }

      for (final EditorCell_Async cell : Sequence.fromIterable(_cellManager.getAsyncCells())) {
        if (cell.isAsyncValueUpdateRequired() && cell.getContext() != null) {
          final Wrappers._T<AsyncCellValue> result = new Wrappers._T<AsyncCellValue>(null);
          cell.getContext().getRepository().getModelAccess().runReadAction(() -> {
            try {
              result.value = cell.getAsyncValueCallable().call();
            } catch (Throwable e) {
              // <no line> print
              e.printStackTrace();
              // <no line> show error
              StyleImpl impl = new StyleImpl();
              result.value = new AsyncCellValue("ERR_AsyncCell", impl);
              // <no line> and forget about it immediately to prevent spamming
              _cellManager.removeAsyncCell(cell);
            }
          });
          if (result.value != null) {
            // the computation finished
            SwingUtilities.invokeLater(() -> {
              // update the cell
              cell.setAsyncValue(result.value);
              // and forget about it
              _cellManager.removeAsyncCell(cell);
            });
          }
        }
      }
    }
  }
  private static boolean check_wdjy4l_a1a9(Future<?> checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.cancel(true);
    }
    return false;
  }
}
