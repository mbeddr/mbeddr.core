package com.mbeddr.mpsutil.asynccell.plugin;

/*Generated by MPS */

import java.util.Set;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.LinkedHashSet;
import javax.swing.Timer;
import java.awt.event.ActionEvent;
import com.intellij.openapi.application.ApplicationManager;
import jetbrains.mps.internal.collections.runtime.Sequence;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.LinkedList;

/**
 * I keep track of the async cells that don't have values yet {@link com.mbeddr.mpsutil.asynccell.plugin.AsyncCellManager#_pendingCells }, and own the threads that work on such ({@link com.mbeddr.mpsutil.asynccell.plugin.AsyncCellManager#_updater } and {@link com.mbeddr.mpsutil.asynccell.plugin.AsyncCellManager#_spinningTimer }).
 */
public class AsyncCellManager {
  protected int SPINNING_INTERVAL = 200;
  /**
   * Cells for which the calculation has not finished yet
   */
  private final Set<EditorCell_Async> _pendingCells = SetSequence.fromSet(new LinkedHashSet<EditorCell_Async>());
  /**
   * Rechecks regularly if the cell value did arrive and schedules updating its value to EDT and removes that cell from 
   * my {@link com.mbeddr.mpsutil.asynccell.plugin.AsyncCellManager#_pendingCells } list.
   */
  private final AsyncCellUpdater _updater = new AsyncCellUpdater(this);
  /**
   * Updates all {@link com.mbeddr.mpsutil.asynccell.plugin.AsyncCellManager#_pendingCells } to show the next rotation state of the spinner.
   */
  private final Timer _spinningTimer = new Timer(this.SPINNING_INTERVAL, (ActionEvent e) -> {

    ApplicationManager.getApplication().invokeLater(() -> {
      for (EditorCell_Async cell : Sequence.fromIterable(getAsyncCells())) {
        cell.turnSpinningWheel();
      }
    });
  });

  private static AsyncCellManager _instance = null;
  public static AsyncCellManager getInstance() {
    if (_instance == null) {
      _instance = new AsyncCellManager();
    }
    return _instance;
  }

  public static void disposeInstance() {
    if (_instance != null) {
      _instance.dispose();
      _instance = null;
    }
  }

  /**
   * Only call this for testing
   */
  public AsyncCellManager() {
    if (SetSequence.fromSet(this._pendingCells).isNotEmpty()) {
      start();
    }
  }

  public void registerAsyncCell(EditorCell_Async asyncCell) {
    synchronized (this) {
      SetSequence.fromSet(_pendingCells).addElement(asyncCell);
      if (!(_updater.isRunning())) {
        start();
      }
    }
  }

  public void removeAsyncCell(EditorCell_Async asyncCell) {
    synchronized (this) {
      SetSequence.fromSet(_pendingCells).removeElement(asyncCell);
      if (SetSequence.fromSet(_pendingCells).isEmpty()) {
        stop();
      }
    }
  }

  public AsyncCellUpdater _getUpdater() {
    return _updater;
  }

  public Timer _getSpinner() {
    return _spinningTimer;
  }

  public Iterable<EditorCell_Async> getAsyncCells() {
    List<EditorCell_Async> editorCells = ListSequence.fromList(new LinkedList<EditorCell_Async>());
    synchronized (this) {
      ListSequence.fromList(editorCells).addSequence(SetSequence.fromSet(_pendingCells));
    }
    return editorCells;
  }

  private void start() {
    _updater.start();
    _spinningTimer.start();
  }

  private void stop() {
    _updater.stop();
    _spinningTimer.stop();
  }

  private void dispose() {
    synchronized (this) {
      stop();
    }
  }

}
