package com.mbeddr.mpsutil.spreferences.runtime.plugin;

/*Generated by MPS */

import jetbrains.mps.plugins.prefs.BasePrefsPage;
import com.mbeddr.mpsutil.spreferences.runtime.SPreferencesPanel;
import com.mbeddr.mpsutil.spreferences.runtime.SPrefererencesComponent;
import org.jetbrains.mps.openapi.model.SModel;
import org.jetbrains.mps.openapi.module.SModule;
import org.jetbrains.mps.openapi.module.SRepository;
import com.intellij.openapi.project.Project;
import com.mbeddr.mpsutil.spreferences.runtime.SPreferencesModelFactory;
import jetbrains.mps.project.MPSProject;
import jetbrains.mps.ide.project.ProjectHelper;
import com.intellij.openapi.application.ApplicationManager;
import com.intellij.openapi.options.ConfigurationException;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import javax.swing.JComponent;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import org.jetbrains.mps.openapi.model.SNode;
import com.mbeddr.mpsutil.spreferences.runtime.SPreferencesUtil;
import jetbrains.mps.ide.ThreadUtils;
import com.intellij.openapi.extensions.DefaultPluginDescriptor;
import com.intellij.openapi.extensions.PluginId;

public class SPreferencesPage extends BasePrefsPage {

  private SPreferencesPanel panel;
  private SPrefererencesComponent myPrefsComponent;

  private SModel mySModel;
  private SModule mySModule;
  private String myTitle;
  private boolean myIsRegistered = false;
  private SRepository repo;


  public SPreferencesPage(Project project, SPrefererencesComponent prefsComponent, String title, String id, final SPreferencesModelFactory modelFactory) {
    super(prefsComponent, title);
    this.id = id;
    myPrefsComponent = prefsComponent;
    myTitle = title;
    final MPSProject mpsProject = ProjectHelper.fromIdeaProject(getProject());
    ApplicationManager.getApplication().invokeAndWait(() -> mpsProject.getRepository().getModelAccess().executeCommand(() -> {
      mySModel = modelFactory.getModel(mpsProject);
      mySModule = mySModel.getModule();
    }));
    repo = mpsProject.getRepository();
    panel = new SPreferencesPanel(repo, mpsProject);
    this.providerClass = this.getClass().getName();
    this.instanceClass = this.getClass().getName();

  }

  public void apply() throws ConfigurationException {
  }
  @Override
  @NotNull
  public String getDisplayName() {
    return myTitle;
  }

  @Nullable
  public JComponent createComponent() {
    return panel;
  }

  public void disposeUIResources() {
  }

  public boolean isModified() {
    return false;
  }

  @Nullable
  @Override
  public Class<?> getConfigurableType() {
    return this.getClass();
  }
  public void reset() {
    final Wrappers._T<SNode> firstRoot = new Wrappers._T<SNode>(null);

    repo.getModelAccess().runReadAction(() -> firstRoot.value = SPreferencesUtil.getFirstRoot(mySModel));
    ThreadUtils.runInUIThreadNoWait(() -> panel.edit(firstRoot.value));
  }

  public void dispose() {
    if (isRegistered()) {
      unregister();
    }
    panel.dispose();
  }


  @Override
  public void register() {
    myIsRegistered = true;
    super.register();
    // Fixing registration of this Configurable extension to work around ClassNotFoundException when opening Settings in MPS (if spreferences is used) 
    // The exception is caused by a not properly supported registration of IDEA extension instances from MPS code - the expectation is to have them registered in plugin.xml.
    // When EP is requested to load its provider class (SPreferencePage) using findClassOrNull() in EpBasedConfigurableGroup.collect, it fails to do so because the class 
    // is actually loaded by a ModuleClassLoader and EP has no classloader info due to not available pluginDescriptor data.
    // The following workaround fakes a custom plugin descriptor for this ConfigurableEP with the ModuleClassLoader that can actually load SPreferencePage class.
    DefaultPluginDescriptor customPluginDesc = new DefaultPluginDescriptor(PluginId.findId("com.mbeddr.mpsutil.spreferences.runtime"), SPreferencesPage.class.getClassLoader());
    // This is necessary so that getDisplayName() can be read.
    customPluginDesc.setEnabled(true);
    this.setPluginDescriptor(customPluginDesc);
  }
  @Override
  public void unregister() {
    super.unregister();
    myIsRegistered = false;
  }

  public boolean isRegistered() {
    return myIsRegistered;
  }
}
