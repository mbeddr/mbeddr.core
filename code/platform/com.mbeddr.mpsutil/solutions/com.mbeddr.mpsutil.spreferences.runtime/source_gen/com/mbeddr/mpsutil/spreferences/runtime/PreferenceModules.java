package com.mbeddr.mpsutil.spreferences.runtime;

/*Generated by MPS */

import jetbrains.mps.logging.Logger;
import jetbrains.mps.project.MPSExtentions;
import jetbrains.mps.smodel.MPSModuleOwner;
import jetbrains.mps.smodel.BaseMPSModuleOwner;
import java.util.Map;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import org.jetbrains.mps.openapi.module.SModule;
import java.lang.ref.WeakReference;
import org.jetbrains.mps.openapi.model.SModel;
import java.util.WeakHashMap;
import jetbrains.mps.project.Project;
import jetbrains.mps.project.FileBasedProject;
import java.io.File;
import com.intellij.openapi.application.PathManager;
import org.jetbrains.annotations.Nullable;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.project.ProjectManager;
import jetbrains.mps.vfs.IFile;
import jetbrains.mps.vfs.FileSystem;
import java.util.List;
import jetbrains.mps.library.ModulesMiner;
import java.util.ArrayList;
import jetbrains.mps.project.Solution;
import org.jetbrains.mps.openapi.module.SRepository;
import jetbrains.mps.smodel.MPSModuleRepository;
import jetbrains.mps.smodel.ModuleRepositoryFacade;
import jetbrains.mps.project.AbstractModule;
import java.util.Collection;
import jetbrains.mps.internal.collections.runtime.CollectionSequence;
import java.util.Objects;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.project.structure.modules.SolutionDescriptor;
import jetbrains.mps.project.ModuleId;
import jetbrains.mps.persistence.DefaultModelRoot;
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple;
import org.jetbrains.mps.openapi.model.SModelName;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.lang.modelapi.behavior.ModelIdentity__BehaviorDescriptor;
import java.io.IOException;
import jetbrains.mps.smodel.TrivialModelDescriptor;
import jetbrains.mps.project.MPSProject;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.mps.openapi.persistence.PersistenceFacade;
import jetbrains.mps.persistence.PersistenceRegistry;
import jetbrains.mps.smodel.ModelAccessHelper;
import java.util.Collections;
import jetbrains.mps.project.io.DescriptorIOFacade;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import jetbrains.mps.project.structure.modules.ModuleReference;
import jetbrains.mps.project.structure.modules.ModuleDescriptor;
import java.util.concurrent.atomic.AtomicReference;
import jetbrains.mps.project.io.DescriptorIOException;
import org.jetbrains.mps.openapi.persistence.ModelRoot;
import org.jetbrains.mps.openapi.model.EditableSModel;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import org.jetbrains.mps.openapi.language.SConcept;

public class PreferenceModules {
  private static final Logger LOG = Logger.getLogger(PreferenceModules.class);
  public static final String PROJECT_SCOPE_FOLDER = "_spreferences";
  public static final String USER_PREFERENCES_FOLDER = "spreferences";
  public static final String MODULE_FILE_NAME = "module." + MPSExtentions.SOLUTION;
  public static final String MODELS_FOLDER_NAME = "models";
  public static final String MODEL_PREFIX = "__spreferences";
  private static MPSModuleOwner ourModuleOwner = new BaseMPSModuleOwner();

  private static final Map<Tuples._2<SModule, String>, WeakReference<SModel>> ourPreferencesModelCache = new WeakHashMap<Tuples._2<SModule, String>, WeakReference<SModel>>();

  public static String getProjectScopeFolder(Project mpsProject, String preferencesId) {
    return ((FileBasedProject) mpsProject).getProjectFile().getAbsolutePath() + File.separator + PROJECT_SCOPE_FOLDER + File.separator + preferencesId;
  }

  public static String getProjectScopeUserFolder(Project mpsProject, String id) {
    return PathManager.getConfigPath() + File.separator + USER_PREFERENCES_FOLDER + File.separator + mpsProject.getName() + File.separator + id;
  }

  public static String getApplicationScopeFolder(String preferencesId) {
    return PathManager.getConfigPath() + File.separator + USER_PREFERENCES_FOLDER + File.separator + preferencesId;
  }

  public static String getModelNameForApplication(String id) {
    return getModelName(null, true, id);
  }

  public static String getModelName(@Nullable Project mpsProject, boolean applicationScope, String id) {
    String modelName;
    if (applicationScope) {
      modelName = MODEL_PREFIX + "." + id;
    } else {
      modelName = mpsProject.getName() + "." + MODEL_PREFIX + "." + id;
    }
    return modelName;
  }

  public static SModel findPreferencesModelByName(String id) {
    for (SModule module : Sequence.fromIterable(ProjectManager.getInstance().getOpenedProjects().get(0).getRepository().getModules())) {
      for (SModel model : Sequence.fromIterable(module.getModels())) {
        if (model.getName().getValue().endsWith("." + MODEL_PREFIX + "." + id)) {
          return model;
        }
      }
    }
    return null;
  }

  public static String getFolder(Project mpsProject, String id, boolean applicationScope, boolean userFolder) {
    if (applicationScope) {
      return getApplicationScopeFolder(id);
    } else {
      if (userFolder) {
        return getProjectScopeUserFolder(mpsProject, id);
      } else {
        return getProjectScopeFolder(mpsProject, id);
      }
    }
  }

  public static IFile findModuleFolderOfProject(String startPath, String id) {
    IFile file = FileSystem.getInstance().getFile(startPath);
    return findModuleFile(file, id);
  }

  public static IFile findModuleFile(IFile startPath, String id) {
    IFile current = startPath;

    while (current != null) {
      IFile moduleFile = current.getDescendant(PROJECT_SCOPE_FOLDER).getDescendant(id).getDescendant(MODULE_FILE_NAME);
      if (moduleFile.exists()) {
        return moduleFile;
      }
      current = current.getParent();
    }

    return null;
  }

  private static List<ModulesMiner.ModuleHandle> unregisteredModules = new ArrayList<ModulesMiner.ModuleHandle>();
  public static Solution getPreferencesModuleInScope(SModule scopeModule, String preferencesId) {
    // FIXME Need a context repository to manage modules, pass from outside if scopeModule can't reliably supply one.
    final SRepository repo = (scopeModule.getRepository() == null ? MPSModuleRepository.getInstance() : scopeModule.getRepository());
    ModuleRepositoryFacade repoFacade = new ModuleRepositoryFacade(repo);
    // register modules that could not be registered the last time
    if (repo.getModelAccess().canWrite()) {
      for (ModulesMiner.ModuleHandle k : new ArrayList<ModulesMiner.ModuleHandle>(unregisteredModules)) {
        repoFacade.instantiateModule(k, ourModuleOwner);
        unregisteredModules.remove(k);
      }
    }

    IFile moduleFile = findModuleFile(check_btr3eu_a0a6a82(as_btr3eu_a0a0a6a92(scopeModule, AbstractModule.class)), preferencesId);
    if (moduleFile == null) {
      return null;
    }

    // find already loaded module
    Collection<Solution> allModules = repoFacade.getAllModules(Solution.class);
    for (Solution mod : CollectionSequence.fromCollection(allModules)) {
      if (Objects.equals(mod.getDescriptorFile(), moduleFile)) {
        return mod;
      }
    }

    // already loaded but not registered
    for (ModulesMiner.ModuleHandle mh : ListSequence.fromList(unregisteredModules)) {
      if (Objects.equals(mh.getFile(), moduleFile)) {
        return null;
      }
    }

    // load module from file
    // FIXME PLEASE provide some context here (e.g. mps project). Though for the moment here's a workaround not to use ModulesMiner, in case you ever need to
    //        read the module file (not to construct it in memory with arbitrary id), you'll face the need to have a context with a platform component access here
    SolutionDescriptor sd = new SolutionDescriptor();
    sd.setId(ModuleId.regular());
    sd.setNamespace(preferencesId);
    sd.getModelRootDescriptors().add(DefaultModelRoot.createSingleFolderDescriptor(moduleFile.getParent().findChild(MODELS_FOLDER_NAME)));
    ModulesMiner.ModuleHandle moduleHandle = new ModulesMiner.ModuleHandle(moduleFile, sd);
    if (repo.getModelAccess().canWrite()) {
      return (Solution) repoFacade.instantiateModule(moduleHandle, ourModuleOwner);
    } else {
      // the code here used to instantiate Solution and keep it detached. I see no point
      // as subsequent solution.getModels() would yield empty sequence anyway.
      unregisteredModules.add(moduleHandle);
      return null;
    }
  }

  private static SModel getPreferencesModelInScope(SModule scopeModule, String preferencesId) {
    Tuples._2<SModule, String> key = MultiTuple.<SModule,String>from(scopeModule, preferencesId);
    boolean containsKey = ourPreferencesModelCache.containsKey(key);
    WeakReference<SModel> ref = ourPreferencesModelCache.get(key);
    if (ref == null && containsKey) {
      return null;
    }

    SModel model = check_btr3eu_a0f0eb(ref);
    if (model == null) {
      model = getPreferencesModelInScope_(scopeModule, preferencesId);
      if (model == null) {
        ourPreferencesModelCache.put(key, null);
      } else {
        ourPreferencesModelCache.put(key, new WeakReference<SModel>(model));
      }
    }
    return model;
  }

  private static SModel getPreferencesModelInScope_(SModule scopeModule, String preferencesId) {
    Solution module = getPreferencesModuleInScope(scopeModule, preferencesId);
    if (module == null) {
      return null;
    }
    SModel model = null;
    for (SModel m : ListSequence.fromList(module.getModels())) {
      SModelName name = m.getName();
      // Descriptor models have similar name, ignore them (they have a stereotype defined)
      if (name.getValue().contains(MODEL_PREFIX) && name.getStereotype().isEmpty()) {
        model = m;
      }
    }
    if (model == null) {
      return null;
    }

    return model;
  }

  public static SNode getPreferencesRootInScope(SModule scopeModule, String preferencesId) {
    SModel model = getPreferencesModelInScope(scopeModule, preferencesId);
    if (model == null) {
      return null;
    }
    return SPreferencesUtil.getFirstRoot(model);
  }

  public static SNode getPreferencesRootInScope(SModel model, String preferencesId) {
    if (model == null) {
      return null;
    }
    model = redirectModel(model);
    return getPreferencesRootInScope(model.getModule(), preferencesId);
  }

  public static SModel redirectModel(SModel model) {
    if (model == null) {
      return null;
    }
    SModel m = model;
    for (SNode rootNode : ListSequence.fromList(SModelOperations.roots(m, CONCEPTS.SPreferencesContext$X6))) {
      if ((SLinkOperations.getTarget(rootNode, LINKS.redirectToModel$qBd0) != null)) {
        SModel redirect = ModelIdentity__BehaviorDescriptor.toModelReference_id1Bs_61$mvvu.invoke(SLinkOperations.getTarget(SLinkOperations.getTarget(rootNode, LINKS.redirectToModel$qBd0), LINKS.modelRef$l8tE)).resolve(model.getRepository());
        if (redirect != null) {
          return redirect;
        }
      }
    }
    return model;
  }

  public static SModel getModel(String directory, String modelName, MPSModuleOwner moduleOwner) {
    try {
      return getModel_(directory, modelName, moduleOwner);
    } catch (IOException ex) {
      throw new RuntimeException(ex);
    }
  }

  private static SModel getModel_(String directory, final String modelName, MPSModuleOwner moduleOwner) throws IOException {
    Solution solution = getPreferencesSolution(directory, modelName, moduleOwner);
    List<SModel> models = ((List<SModel>) solution.getModels());
    SModel model = ListSequence.fromList(models).findFirst((it) -> Objects.equals(it.getName().getLongName(), modelName));
    if (model == null) {
      model = ListSequence.fromList(models).first();
    }
    if (model == null || model instanceof TrivialModelDescriptor) {
      model = createModel(solution, modelName);
    }
    return model;
  }

  public static Solution getPreferencesSolution(String directory, String modelName, MPSModuleOwner moduleOwner) {
    final Solution solution;
    if (moduleOwner instanceof Project) {
      // the only use of the method I've found comes from SPreferences_ProjectPlugin, with MPSProject as owner
      // If it's indeed the only one, we can safely drop the alternative, which I've left for compatibility with existing code
      solution = getPreferencesSolution_((Project) moduleOwner, directory, modelName);
    } else {
      if (LOG.isErrorLevel()) {
        LOG.error("Deprecated code in PreferenceModules, please refactor");
      }
      solution = getPreferencesSolution_(directory, modelName, moduleOwner);
    }
    if (moduleOwner instanceof MPSProject) {
      MPSProject project = ((MPSProject) moduleOwner);
      if (!(projectContainsModule(project, solution))) {
        project.addModule(solution);
      }
      String currentFolderName = project.getVirtualFolder(solution);
      if ((currentFolderName == null || currentFolderName.length() == 0)) {
        project.setVirtualFolder(solution, "_spreferences");
      }
    }
    return solution;
  }

  private static boolean projectContainsModule(Project project, SModule module) {
    return project.isProjectModule(module);
  }

  /**
   * PLEASE USE THIS METHOD AS AN EXAMPLE. PreferenceModules class, full of static methods, is poorly designed, please refactor!
   */
  private static Solution getPreferencesSolution_(@NotNull final Project mpsProject, final String directory, final String modelName) {
    final ModuleId solutionId = ModuleId.foreign("_PreferencesModule#" + modelName);

    final PersistenceFacade persistenceFacade = mpsProject.getComponent(PersistenceRegistry.class);
    return new ModelAccessHelper(mpsProject.getModelAccess()).runWriteAction(() -> {
      // It's odd to use 'modelName' as a name of a module
      SModule s = persistenceFacade.createModuleReference(solutionId, modelName).resolve(mpsProject.getRepository());
      if (s instanceof Solution) {
        return (Solution) s;
      }

      // FIXME could utilize FileBasedProject once it gives access to project's FileSystem
      IFile solutionFile = FileSystem.getInstance().getFile(directory + File.separator + MODULE_FILE_NAME);
      if (solutionFile.exists()) {
        // Load from file system
        ModulesMiner mm = new ModulesMiner(Collections.<IFile>emptySet(), mpsProject.getComponent(DescriptorIOFacade.class));
        mm.collectModules(solutionFile);
        if (mm.getCollectedModules().size() == 1) {
          ModulesMiner.ModuleHandle moduleHandle = mm.getCollectedModules().iterator().next();
          return (Solution) new ModuleRepositoryFacade(mpsProject).instantiateModule(moduleHandle, mpsProject);
        }
        // fall-through
      }
      SolutionDescriptor solutionDescriptor = new SolutionDescriptor();
      solutionDescriptor.setId(solutionId);
      solutionDescriptor.setNamespace(modelName);
      ModulesMiner.ModuleHandle moduleHandle = new ModulesMiner.ModuleHandle(solutionFile, solutionDescriptor);

      Solution solution = (Solution) new ModuleRepositoryFacade(mpsProject).instantiateModule(moduleHandle, mpsProject);

      createModel(solution, modelName);
      return solution;
    });
  }

  /**
   * 
   * @deprecated this method is full of static accessors that have been deprecated for years! There's alternative method that gives an idea how to approach this with contemporary API
   */
  @Deprecated
  private static Solution getPreferencesSolution_(String directory, final String modelName, final MPSModuleOwner moduleOwner) {
    ModuleId solutionId = ModuleId.foreign("_PreferencesModule#" + modelName);

    // get loaded
    final Wrappers._T<Solution> solution = new Wrappers._T<Solution>(ModuleRepositoryFacade.getInstance().getModule(new ModuleReference(modelName, solutionId), Solution.class));
    if (solution.value != null) {
      return solution.value;
    }

    final MPSModuleRepository globalRepo = MPSModuleRepository.getInstance();

    IFile solutionFile = FileSystem.getInstance().getFile(directory + File.separator + MODULE_FILE_NAME);
    if (solutionFile.exists()) {
      // Load from file system
      try {
        ModuleDescriptor moduleDescriptor = DescriptorIOFacade.getInstance().fromFileType(solutionFile).readFromFile(solutionFile);
        final ModulesMiner.ModuleHandle moduleHandle = new ModulesMiner.ModuleHandle(solutionFile, moduleDescriptor);
        final AtomicReference<Solution> res = new AtomicReference<Solution>();
        globalRepo.getModelAccess().runWriteAction(() -> res.set((Solution) new ModuleRepositoryFacade(globalRepo).instantiateModule(moduleHandle, moduleOwner)));
        return res.get();
      } catch (DescriptorIOException e) {
        // Log error: solution was not correctly loaded
      }
    }

    SolutionDescriptor solutionDescriptor = new SolutionDescriptor();
    solutionDescriptor.setId(solutionId);
    solutionDescriptor.setNamespace(modelName);
    final ModulesMiner.ModuleHandle moduleHandle = new ModulesMiner.ModuleHandle(solutionFile, solutionDescriptor);
    globalRepo.getModelAccess().runWriteAction(() -> solution.value = (Solution) new ModuleRepositoryFacade(globalRepo).instantiateModule(moduleHandle, moduleOwner));

    createModel(solution.value, modelName);

    return solution.value;
  }

  private static SModel createModel(Solution solution, final String modelName) {
    DefaultModelRoot dmr = findFileBackedModelRoot(solution);
    if (dmr == null) {
      IFile moduleSourceDir = solution.getModuleSourceDir();
      solution.getModuleDescriptor().getModelRootDescriptors().add(DefaultModelRoot.createDescriptor(moduleSourceDir, moduleSourceDir.getDescendant(MODELS_FOLDER_NAME)));
      solution.updateModelsSet();
      dmr = findFileBackedModelRoot(solution);
    }

    SModel model = createModel_(dmr, modelName);
    solution.setChanged();
    return model;
  }

  private static DefaultModelRoot findFileBackedModelRoot(Solution s) {
    for (ModelRoot mr : s.getModelRoots()) {
      if (mr instanceof DefaultModelRoot) {
        return ((DefaultModelRoot) mr);
      }
    }
    return null;
  }

  private static SModel createModel_(DefaultModelRoot modelRoot, final String modelName) {
    EditableSModel model = (EditableSModel) modelRoot.createModel(modelName);
    if (model == null) {
      throw new RuntimeException("Failed to create " + modelName + " model");
    }
    model.save();
    return model;
  }
  private static IFile check_btr3eu_a0a6a82(AbstractModule checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getModuleSourceDir();
    }
    return null;
  }
  private static SModel check_btr3eu_a0f0eb(WeakReference<SModel> checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.get();
    }
    return null;
  }
  private static <T> T as_btr3eu_a0a0a6a92(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }

  private static final class LINKS {
    /*package*/ static final SContainmentLink redirectToModel$qBd0 = MetaAdapterFactory.getContainmentLink(0x5e845763f4ca40bfL, 0xb31f74e236ffed75L, 0xc2ec72dace3a2fcL, 0xc2ec72dace3a772L, "redirectToModel");
    /*package*/ static final SContainmentLink modelRef$l8tE = MetaAdapterFactory.getContainmentLink(0x7866978ea0f04cc7L, 0x81bc4d213d9375e1L, 0x19dc9460645cfdd7L, 0x19dc9460645d0827L, "modelRef");
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept SPreferencesContext$X6 = MetaAdapterFactory.getConcept(0x5e845763f4ca40bfL, 0xb31f74e236ffed75L, 0xc2ec72dace3a2fcL, "com.mbeddr.mpsutil.spreferences.context.structure.SPreferencesContext");
  }
}
