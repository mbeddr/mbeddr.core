package com.mbeddr.mpsutil.actionsfilter.runtime;

/*Generated by MPS */

import java.util.Set;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.LinkedHashSet;
import java.util.Map;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import javax.swing.Timer;
import java.awt.event.ActionEvent;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.HashSet;
import com.intellij.openapi.actionSystem.AnAction;
import com.intellij.openapi.actionSystem.ActionGroup;
import com.intellij.openapi.actionSystem.ActionManager;
import com.intellij.openapi.actionSystem.DefaultActionGroup;
import java.util.ArrayList;
import com.intellij.openapi.actionSystem.Constraints;
import com.intellij.openapi.actionSystem.Anchor;
import java.lang.ref.WeakReference;
import jetbrains.mps.classloading.ModuleClassLoader;

public class ActionFilter {

  private static ActionFilter ourInstance = new ActionFilter();

  public static ActionFilter getInstance() {
    return ourInstance;
  }

  protected Set<String> myFilteredIds = SetSequence.fromSet(new LinkedHashSet<String>());
  protected Map<String, List<RememberedAction>> myRememberedActions = MapSequence.fromMap(new HashMap<String, List<RememberedAction>>());
  private Timer myReapplyTimer = new Timer(5000, (ActionEvent e) -> reapplyFilters());

  public ActionFilter() {
    myReapplyTimer.start();
  }

  public void cleanUpRememberedActions() {
    Sequence.fromIterable(MapSequence.fromMap(myRememberedActions).values()).visitAll((list) -> ListSequence.fromList(list).removeWhere((ra) -> !(ra.isValid())));
    ListSequence.fromList(SetSequence.fromSet(MapSequence.fromMap(myRememberedActions).mappingsSet()).where((it) -> ListSequence.fromList(it.value()).isEmpty()).select((it) -> it.key()).toList()).visitAll((it) -> MapSequence.fromMap(myRememberedActions).removeKey(it));
  }

  public Iterable<String> getFilters() {
    return myFilteredIds;
  }

  public void clearFilters() {
    removeFilters(myFilteredIds);
  }

  public void addFilter(String actionId) {
    addFilters(Sequence.<String>singleton(actionId));
  }

  public void addFilters(Iterable<String> actionIds) {
    List<String> newIds = Sequence.fromIterable(actionIds).where((it) -> !(SetSequence.fromSet(myFilteredIds).contains(it))).distinct().toList();
    SetSequence.fromSet(myFilteredIds).addSequence(ListSequence.fromList(newIds));
    applyFilters(newIds);
  }

  public void removeFilter(String actionId) {
    removeFilters(Sequence.<String>singleton(actionId));
  }

  public void removeFilters(Iterable<String> actionIds) {
    List<String> removedIds = Sequence.fromIterable(actionIds).where((it) -> SetSequence.fromSet(myFilteredIds).contains(it)).distinct().toList();
    SetSequence.fromSet(myFilteredIds).removeSequence(ListSequence.fromList(removedIds));
    unapplyFilters(ListSequence.fromList(removedIds).reversedList());
  }

  public void setFilters(Iterable<String> actionIds_) {
    final Set<String> actionIds = SetSequence.fromSetWithValues(new HashSet<String>(), actionIds_);
    List<String> newIds = SetSequence.fromSet(actionIds).where((it) -> !(SetSequence.fromSet(myFilteredIds).contains(it))).toList();
    List<String> removedIds = SetSequence.fromSet(myFilteredIds).where((it) -> !(SetSequence.fromSet(actionIds).contains(it))).toList();

    removeFilters(removedIds);
    addFilters(newIds);
  }

  public void setFilters(Model model) {
    setFilters(check_anzoaf_a0a0bb(check_anzoaf_a0a0a72(model.getActiveProfileOrFirst())));
  }

  protected void applyFilters(Iterable<String> idsToRemove) {
    cleanUpRememberedActions();
    List<AnAction> actionsToRemove = getActions(idsToRemove);

    Iterable<ActionGroup> allGroups = Sequence.fromIterable(Sequence.fromArray(ActionManager.getInstance().getActionIds(""))).select((it) -> as_anzoaf_a0a0a0a0a3a92(ActionManager.getInstance().getAction(it), ActionGroup.class)).where((it) -> it != null);
    for (ActionGroup group : Sequence.fromIterable(allGroups)) {
      removeActionsFromGroup(group, actionsToRemove);
    }
  }

  public void applyFilters(ActionGroup group) {
    removeActionsFromGroup(group, getActions(myFilteredIds));
  }

  protected List<AnAction> getActions(Iterable<String> actionIds) {
    return Sequence.fromIterable(actionIds).select((it) -> ActionManager.getInstance().getAction(it)).where((it) -> it != null).toList();
  }

  protected void unapplyFilters(Iterable<String> actionIds) {
    cleanUpRememberedActions();
    for (String actionId : actionIds) {
      ListSequence.fromList(getRememberedActionList(actionId)).visitAll((it) -> undoRemove(it));
      MapSequence.fromMap(myRememberedActions).removeKey(actionId);
    }
  }

  protected void reapplyFilters() {
    if (SetSequence.fromSet(myFilteredIds).isEmpty()) {
      return;
    }
    List<AnAction> actionsToRemove = getActions(myFilteredIds);

    Iterable<ActionGroup> allGroups = Sequence.fromIterable(Sequence.fromArray(ActionManager.getInstance().getActionIds(""))).select((it) -> as_anzoaf_a0a0a0a0a3a73(ActionManager.getInstance().getAction(it), ActionGroup.class)).where((it) -> it != null);
    for (ActionGroup group : Sequence.fromIterable(allGroups)) {
      removeActionsFromGroup(group, actionsToRemove);
    }
  }

  protected void removeActionsFromGroup(ActionGroup group, Iterable<AnAction> actions) {
    AnAction[] children = group.getChildren(null);
    for (AnAction child : children) {
      if (child instanceof ActionGroup) {
        removeActionsFromGroup((ActionGroup) child, actions);
      }
    }

    if (group instanceof DefaultActionGroup) {
      DefaultActionGroup defaultGroup = (DefaultActionGroup) group;
      Set<AnAction> existingChildren = SetSequence.fromSetAndArray(new HashSet<AnAction>(), group.getChildren(null));
      for (AnAction action : actions) {
        if (SetSequence.fromSet(existingChildren).contains(action)) {
          rememberRemovedAction(action, defaultGroup);
          defaultGroup.remove(action);
        }
      }
    }
  }

  protected void rememberRemovedAction(AnAction action, DefaultActionGroup parentGroup) {
    String id = ActionManager.getInstance().getId(action);
    List<AnAction> children = Sequence.fromIterable(Sequence.fromArray(parentGroup.getChildren(null))).toList();
    int position = ListSequence.fromList(children).indexOf(action);
    List<RememberedAction> removedActions = getRememberedActionList(id);
    ListSequence.fromList(removedActions).addElement(new RememberedAction(id, action, parentGroup, safeSublist(children, 0, position), safeSublist(children, position + 1, ListSequence.fromList(children).count() - 1)));
  }

  protected List<RememberedAction> getRememberedActionList(String actionId) {
    List<RememberedAction> result = MapSequence.fromMap(myRememberedActions).get(actionId);
    if (result == null) {
      result = ListSequence.fromList(new ArrayList<RememberedAction>());
      MapSequence.fromMap(myRememberedActions).put(actionId, result);
    }
    ListSequence.fromList(result).removeWhere((it) -> !(it.isValid()));
    return result;
  }

  protected void undoRemove(RememberedAction removed) {
    if (!(removed.isValid())) {
      return;
    }
    int bestPosition = findBestPosition(Sequence.fromIterable(Sequence.fromArray(removed.getParent().getChildren(null))).toList(), removed.getAction(), removed.getActionsBefore(), removed.getActionsAfter());
    addAction(removed.getParent(), removed.getAction(), bestPosition);
  }

  protected int findBestPosition(List<AnAction> elements, AnAction element, List<AnAction> wasBefore_, List<AnAction> wasAfter_) {
    int bestCandidate = 0;
    int bestError = 0;
    final Set<AnAction> wasBefore = SetSequence.fromSetWithValues(new HashSet<AnAction>(), wasBefore_);
    final Set<AnAction> wasAfter = SetSequence.fromSetWithValues(new HashSet<AnAction>(), wasAfter_);
    for (int candiate = 0; candiate <= ListSequence.fromList(elements).count(); candiate++) {
      int wrongBefore = ListSequence.fromList(safeSublist(elements, 0, candiate)).where((it) -> SetSequence.fromSet(wasAfter).contains(it)).count();
      int wrongAfter = ListSequence.fromList(safeSublist(elements, candiate, ListSequence.fromList(elements).count())).where((it) -> SetSequence.fromSet(wasBefore).contains(it)).count();
      int error = wrongBefore + wrongAfter;
      if (candiate == 0 || error < bestError) {
        bestCandidate = candiate;
        bestError = error;
      }
    }

    return bestCandidate;
  }

  protected void addAction(DefaultActionGroup group, AnAction action, int position) {
    Constraints constraints = Constraints.LAST;
    AnAction[] children = group.getChildren(null);
    if (position < children.length) {
      String id = ActionManager.getInstance().getId(children[position]);
      if (id != null) {
        constraints = new Constraints(Anchor.BEFORE, id);
      }
    }
    group.add(action, constraints);
  }

  public List<AnAction> getUnfilteredChildActions(AnAction parent) {
    List<AnAction> result = ListSequence.fromList(new ArrayList<AnAction>());
    if (parent instanceof ActionGroup) {
      ListSequence.fromList(result).addSequence(Sequence.fromIterable(Sequence.fromArray(((ActionGroup) parent).getChildren(null))));

      for (RememberedAction remembered : ListSequence.fromList(Sequence.fromIterable(getRememberedActionsByParent(parent)).toList()).reversedList()) {
        int bestPosition = findBestPosition(result, remembered.getAction(), remembered.getActionsBefore(), remembered.getActionsAfter());
        ListSequence.fromList(result).insertElement(bestPosition, remembered.getAction());
      }
    }
    return result;
  }

  protected Iterable<RememberedAction> getRememberedActionsByParent(final AnAction parent) {
    return Sequence.fromIterable(MapSequence.fromMap(myRememberedActions).values()).translate((it) -> it).where((it) -> it.isValid()).where((it) -> it.getParent() == parent);
  }

  protected class RememberedAction {
    protected String myId;
    protected WeakReference<AnAction> myAction;
    protected WeakReference<DefaultActionGroup> myParent;
    protected List<WeakReference<AnAction>> myActionsBefore;
    protected List<WeakReference<AnAction>> myActionsAfter;

    protected RememberedAction(String id1, AnAction action1, DefaultActionGroup parent1, List<AnAction> actionsBefore1, List<AnAction> actionsAfter1) {
      myAction = new WeakReference<AnAction>(action1);
      myActionsAfter = ListSequence.fromList(actionsAfter1).select((it) -> new WeakReference<AnAction>(it)).toList();
      myActionsBefore = ListSequence.fromList(actionsBefore1).select((it) -> new WeakReference<AnAction>(it)).toList();
      myId = id1;
      myParent = new WeakReference<DefaultActionGroup>(parent1);
    }

    protected AnAction getAction() {
      return myAction.get();
    }

    protected DefaultActionGroup getParent() {
      return myParent.get();
    }

    protected List<AnAction> getActionsBefore() {
      return ListSequence.fromList(myActionsBefore).select((it) -> it.get()).where((it) -> it != null).toList();
    }

    protected List<AnAction> getActionsAfter() {
      return ListSequence.fromList(myActionsAfter).select((it) -> it.get()).where((it) -> it != null).toList();
    }

    protected boolean isValid() {
      AnAction action = myAction.get();
      DefaultActionGroup parent = myParent.get();
      boolean valid = action != null && parent != null && !(isDisposed(action)) && !(isDisposed(parent));
      return valid;
    }
  }

  public static <T> List<T> safeSublist(List<T> list, int from, int to) {
    if (ListSequence.fromList(list).isEmpty()) {
      return list;
    }
    from = Math.max(from, 0);
    from = Math.min(from, ListSequence.fromList(list).count());
    to = Math.max(to, 0);
    to = Math.min(to, ListSequence.fromList(list).count());
    to = Math.max(to, from);
    return ListSequence.fromList(list).subListSequence(from, to);
  }

  public static boolean isDisposed(Object obj) {
    ClassLoader cl = obj.getClass().getClassLoader();
    if (cl instanceof ModuleClassLoader) {
      ModuleClassLoader moduleCL = ((ModuleClassLoader) cl);
      if (moduleCL.isDisposed()) {
        return true;
      }
    }
    return false;
  }
  private static Set<String> check_anzoaf_a0a0bb(FilterSettings checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getFilteredIds();
    }
    return null;
  }
  private static FilterSettings check_anzoaf_a0a0a72(Profile checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getFilterSettings();
    }
    return null;
  }
  private static <T> T as_anzoaf_a0a0a0a0a3a92(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
  private static <T> T as_anzoaf_a0a0a0a0a3a73(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
}
