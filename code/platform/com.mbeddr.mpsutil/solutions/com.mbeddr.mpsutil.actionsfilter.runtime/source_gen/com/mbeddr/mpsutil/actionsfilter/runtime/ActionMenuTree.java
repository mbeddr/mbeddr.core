package com.mbeddr.mpsutil.actionsfilter.runtime;

/*Generated by MPS */

import javax.swing.JTree;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.Color;
import com.intellij.ui.TreeSpeedSearch;
import java.util.List;
import javax.swing.tree.TreePath;
import java.util.ArrayList;
import javax.swing.tree.TreeNode;
import org.jetbrains.annotations.Nullable;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.DefaultTreeModel;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import com.intellij.openapi.actionSystem.AnAction;
import com.intellij.openapi.actionSystem.ActionManager;
import jetbrains.mps.ide.ui.tree.TreeScrollingUtil;
import javax.swing.JPanel;
import javax.swing.tree.TreeCellRenderer;
import javax.swing.JLabel;
import javax.swing.JCheckBox;
import javax.swing.BoxLayout;
import com.intellij.ui.JBColor;
import javax.swing.BorderFactory;
import java.awt.Component;
import jetbrains.mps.plugins.actions.LabelledAnchor;
import com.intellij.icons.AllIcons;

public class ActionMenuTree extends JTree {

  private Model myModel;

  public ActionMenuTree(Model model) {
    super();
    myModel = model;

    setCellRenderer(new CellRenderer());
    addMouseListener(new MouseAdapter() {
      @Override
      public void mousePressed(MouseEvent event) {
        ActionMenuTree.this.mousePressed(event.getX(), event.getY());
      }
    });

    setOpaque(false);
    setBackground(new Color(0, 0, 0, 0));
    setLargeModel(true);

    init();
    installSpeedSearch();
  }

  protected void installSpeedSearch() {
    new TreeSpeedSearch(this) {
      @Override
      protected Object[] getAllElements() {
        List<TreePath> result = new ArrayList<TreePath>();
        collectPaths(new TreePath(getModel().getRoot()), result);
        return result.toArray();
      }

      public void collectPaths(TreePath parentPath, List<TreePath> result) {
        result.add(parentPath);
        TreeNode parent = (TreeNode) parentPath.getLastPathComponent();
        for (int i = 0; i < parent.getChildCount(); i++) {
          collectPaths(parentPath.pathByAddingChild(parent.getChildAt(i)), result);
        }
      }
    };
  }

  protected void init() {
    load(myModel.getActiveProfile());
  }

  public void load(@Nullable Profile profile) {
    @Nullable FilterSettings settings = check_my1ngp_a0a0j(profile);
    DefaultMutableTreeNode root = new DefaultMutableTreeNode();
    setModel(new DefaultTreeModel(root));
    if (profile != null) {
      for (ActionRootGroup group : ListSequence.fromList(ActionRootGroup.getGroups())) {
        AnAction action = ActionManager.getInstance().getAction(group.getId());
        if (action == null) {
          continue;
        }
        ActionTreeNode node = new ActionTreeNode(action, settings);
        root.add(node);
        node.setText(group.getName());
      }
      expandPath(new TreePath(root.getPath()));
    }
  }

  public void mousePressed(int x, int y) {
    if (isCurrentProfileReadOnly()) {
      return;
    }
    int row = this.getRowForLocation(x, y);
    if (row == 0) {
      this.revalidate();
      this.repaint();
    }
    TreePath path = this.getPathForRow(row);
    if (path == null) {
      return;
    }
    Object lastPathComponent = path.getLastPathComponent();
    if (lastPathComponent instanceof ActionTreeNode) {
      ActionTreeNode node = (ActionTreeNode) lastPathComponent;
      node.setChecked(!(node.isChecked()));
      this.repaint();
    }
  }

  /**
   * Checks if currently shown profile is read only. 
   * This is the case for the predefined profiles as they should not be edited by the user.
   */
  public boolean isCurrentProfileReadOnly() {
    return check_my1ngp_a0a31(this.myModel.getActiveProfile(), this);
  }

  public boolean selectMatching(String text, boolean next) {
    List<TreePath> matchingPaths = getMatchingPaths(text);
    if (ListSequence.fromList(matchingPaths).isEmpty()) {
      return false;
    }

    TreePath pathToSelect;
    if (next) {
      int nextIndex = 0;
      int selectedIndex = ListSequence.fromList(matchingPaths).indexOf(getSelectionPath());
      if (selectedIndex >= 0) {
        nextIndex = (selectedIndex + 1) % ListSequence.fromList(matchingPaths).count();
      }
      pathToSelect = ListSequence.fromList(matchingPaths).getElement(nextIndex);
    } else {
      pathToSelect = ListSequence.fromList(matchingPaths).first();
    }
    TreeScrollingUtil.selectPath(this, pathToSelect);
    return true;
  }

  public List<TreePath> getMatchingPaths(final String text) {
    return ListSequence.fromList(getAllPaths()).where((it) -> matches(it, text)).toList();
  }

  protected boolean matches(TreePath path, String text) {
    Object lastPathComponent = path.getLastPathComponent();
    String toString = lastPathComponent.toString();
    if (toString == null) {
      return false;
    }
    return toString.contains(text);
  }

  public List<TreePath> getAllPaths() {
    List<TreePath> result = new ArrayList<TreePath>();
    collectPaths(new TreePath(getModel().getRoot()), result);
    return result;
  }

  protected void collectPaths(TreePath parentPath, List<TreePath> result) {
    result.add(parentPath);
    TreeNode parent = (TreeNode) parentPath.getLastPathComponent();
    for (int i = 0; i < parent.getChildCount(); i++) {
      collectPaths(parentPath.pathByAddingChild(parent.getChildAt(i)), result);
    }
  }


  public class CellRenderer extends JPanel implements TreeCellRenderer {

    private JLabel nameLabel = new JLabel();
    private JLabel idLabel = new JLabel();
    private JCheckBox checkbox;

    public CellRenderer() {
      checkbox = new JCheckBox();
      add(checkbox);
      add(nameLabel);
      add(idLabel);
      setLayout(new BoxLayout(this, BoxLayout.X_AXIS));

      setOpaque(true);
      idLabel.setForeground(JBColor.GRAY);
      idLabel.setBorder(BorderFactory.createEmptyBorder(0, 6, 0, 0));
    }

    public Component getTreeCellRendererComponent(JTree tree, Object value, boolean selected, boolean expanded, boolean leaf, int row, boolean hasFocus) {

      nameLabel.setText(convertValueToText(value, selected, expanded, leaf, row, hasFocus));
      idLabel.setText("");

      nameLabel.setForeground(JBColor.BLACK);
      nameLabel.setIcon(null);
      checkbox.setSelected(true);
      checkbox.setEnabled(false);
      checkbox.setVisible(true);
      if (value instanceof ActionTreeNode) {
        ActionTreeNode node = ((ActionTreeNode) value);
        AnAction action = node.getAction();
        checkbox.setSelected(node.isChecked());

        String id = ActionManager.getInstance().getId(action);
        checkbox.setEnabled(id != null && !(isCurrentProfileReadOnly()));
        if (action instanceof LabelledAnchor) {
          nameLabel.setForeground(new Color(0, 120, 0));
        }

        idLabel.setText((id != null ? id : ""));
        nameLabel.setIcon(action.getTemplatePresentation().getIcon());
      }

      setBackground((selected ? new JBColor(new Color(100, 100, 200), new Color(74, 74, 150)) : new Color(0, 0, 0, 0)));
      nameLabel.setForeground((selected ? JBColor.WHITE : JBColor.BLACK));

      boolean isRoot = tree.getModel().getRoot() == value;
      if (isRoot) {
        nameLabel.setIcon(AllIcons.Nodes.ModuleGroup);
        checkbox.setVisible(false);
      }

      return this;
    }
  }
  private static FilterSettings check_my1ngp_a0a0j(Profile checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getFilterSettings();
    }
    return null;
  }
  private static boolean check_my1ngp_a0a31(Profile checkedDotOperand, ActionMenuTree checkedDotThisExpression) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.isPredefined();
    }
    return false;
  }
}
