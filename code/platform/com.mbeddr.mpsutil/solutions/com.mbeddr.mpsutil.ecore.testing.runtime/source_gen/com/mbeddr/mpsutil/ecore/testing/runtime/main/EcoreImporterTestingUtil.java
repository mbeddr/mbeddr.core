package com.mbeddr.mpsutil.ecore.testing.runtime.main;

/*Generated by MPS */

import java.util.List;
import de.itemis.mps.comparator.code.NodeDifference;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import java.util.Objects;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import de.itemis.mps.comparator.code.MPSNodeComparator;
import de.itemis.mps.comparator.code.IgnoredProperty;
import org.jetbrains.mps.openapi.language.SProperty;
import jetbrains.mps.smodel.tempmodel.TemporaryModels;
import jetbrains.mps.smodel.tempmodel.TempModuleOptions;
import org.jetbrains.mps.openapi.language.SConcept;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import org.jetbrains.mps.openapi.language.SInterfaceConcept;

public class EcoreImporterTestingUtil {

  private List<NodeDifference> nodeComparisonResults;
  private List<String> undiscoveredRoots;

  public void calculateDifferences(SModel mdlExpected, SModel mdlImported) {
    nodeComparisonResults = ListSequence.fromList(new ArrayList<NodeDifference>());
    undiscoveredRoots = ListSequence.fromList(new ArrayList<String>());
    check(CONCEPTS.ConceptDeclaration$gH, mdlExpected, mdlImported);
    check(CONCEPTS.InterfaceConceptDeclaration$CG, mdlExpected, mdlImported);
    check(CONCEPTS.DataTypeDeclaration$AD, mdlExpected, mdlImported);
  }

  private void check(SAbstractConcept rootConcept, SModel mdlExpected, SModel mdlImported) {
    for (final SNode expected : Sequence.fromIterable(SNodeOperations.ofConcept(SModelOperations.roots(mdlExpected, CONCEPTS.INamedStructureElement$gD), SNodeOperations.asSConcept(rootConcept)))) {
      // match based on proper concept and name
      SNode matched = Sequence.fromIterable(SNodeOperations.ofConcept(SModelOperations.roots(mdlImported, CONCEPTS.INamedStructureElement$gD), SNodeOperations.asSConcept(rootConcept))).findFirst((imported) -> Objects.equals(SPropertyOperations.getString(imported, PROPS.name$MnvL), SPropertyOperations.getString(expected, PROPS.name$MnvL)));
      if ((matched == null)) {
        ListSequence.fromList(undiscoveredRoots).addElement(SPropertyOperations.getString(expected, PROPS.name$MnvL));
      } else {
        ListSequence.fromList(nodeComparisonResults).addSequence(ListSequence.fromList(MPSNodeComparator.compare(expected, matched, propertiesToIgnore(), true, false).getDifferences()));
      }
    }
  }

  private static List<IgnoredProperty> propertiesToIgnore() {
    List<SProperty> ignoredProps = ListSequence.fromListAndArray(new ArrayList<SProperty>(), PROPS.conceptId$rrGe, PROPS.propertyId$m5HU, PROPS.linkId$mi9g, PROPS.datatypeId$$gBg);
    return ListSequence.fromList(ignoredProps).select((it) -> new IgnoredProperty(it.getOwner(), it)).toList();
  }

  public void printDifferences() {
    System.out.println("Differences between classes");
    for (NodeDifference nodeDifference : nodeComparisonResults) {
      System.out.println(nodeDifference.getDescription());
    }
    for (String className : undiscoveredRoots) {
      System.out.println("Undiscovered class : " + className);
    }
  }

  public List<NodeDifference> getDifferences(String ecoreFileName, SModel expectedModel) {
    SModel importedModel = TemporaryModels.getInstance().create(true, TempModuleOptions.forDefaultModule());
    EcoreTestingImporter testImporter = new EcoreTestingImporter(importedModel, ecoreFileName);
    testImporter.importEcoreModel();
    calculateDifferences(expectedModel, importedModel);
    return getNodeDifference();
  }

  public List<NodeDifference> getNodeDifference() {
    return nodeComparisonResults;
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept ConceptDeclaration$gH = MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979ba0450L, "jetbrains.mps.lang.structure.structure.ConceptDeclaration");
    /*package*/ static final SConcept InterfaceConceptDeclaration$CG = MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x1103556dcafL, "jetbrains.mps.lang.structure.structure.InterfaceConceptDeclaration");
    /*package*/ static final SConcept DataTypeDeclaration$AD = MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xfc26875dfaL, "jetbrains.mps.lang.structure.structure.DataTypeDeclaration");
    /*package*/ static final SInterfaceConcept INamedStructureElement$gD = MetaAdapterFactory.getInterfaceConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x160b046db90a2b95L, "jetbrains.mps.lang.structure.structure.INamedStructureElement");
  }

  private static final class PROPS {
    /*package*/ static final SProperty name$MnvL = MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name");
    /*package*/ static final SProperty conceptId$rrGe = MetaAdapterFactory.getProperty(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x1103553c5ffL, 0x5d2e6079771f8cc0L, "conceptId");
    /*package*/ static final SProperty propertyId$m5HU = MetaAdapterFactory.getProperty(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979bd086bL, 0x35a81382d82a4d9L, "propertyId");
    /*package*/ static final SProperty linkId$mi9g = MetaAdapterFactory.getProperty(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979bd086aL, 0x35a81382d82a4e4L, "linkId");
    /*package*/ static final SProperty datatypeId$$gBg = MetaAdapterFactory.getProperty(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xfc26875dfaL, 0x6c1f946a87044403L, "datatypeId");
  }
}
