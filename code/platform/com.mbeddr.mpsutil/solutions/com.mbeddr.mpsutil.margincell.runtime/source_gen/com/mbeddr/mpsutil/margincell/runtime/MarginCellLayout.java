package com.mbeddr.mpsutil.margincell.runtime;

/*Generated by MPS */

import jetbrains.mps.nodeEditor.cellLayout.AbstractCellLayout;
import jetbrains.mps.logging.Logger;
import jetbrains.mps.openapi.editor.cells.EditorCell_Collection;
import jetbrains.mps.openapi.editor.cells.EditorCell;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import org.jetbrains.mps.openapi.model.SNode;
import com.mbeddr.mpsutil.margincell.behavior.IMarginCellContent__BehaviorDescriptor;
import org.jetbrains.mps.openapi.module.SRepository;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import java.util.Objects;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import java.util.List;
import jetbrains.mps.openapi.editor.TextBuilder;
import jetbrains.mps.editor.runtime.TextBuilderImpl;
import org.jetbrains.mps.openapi.language.SProperty;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import org.jetbrains.mps.openapi.language.SReferenceLink;
import org.jetbrains.mps.openapi.language.SInterfaceConcept;

public class MarginCellLayout extends AbstractCellLayout implements IUserObjectKeys {
  private static final Logger LOG = Logger.getLogger(MarginCellLayout.class);
  private final MarginCellStyle style;

  public MarginCellLayout(MarginCellStyle style) {
    super();
    this.style = style;
  }

  public void doLayout(EditorCell_Collection editorCell) {
    EditorCell contentCell = editorCell.firstCell();
    contentCell.moveTo(editorCell.getX(), editorCell.getY());
    contentCell.relayout();

    editorCell.setWidth(Math.max(contentCell.getWidth(), style.getCellWidth(editorCell) + style.getMarginLeft(editorCell) + style.getVerticalBound(editorCell)));
    editorCell.setHeight(contentCell.getHeight());

    layoutContentCells(editorCell);
    moveOverlappingContentCells(editorCell);

  }

  protected Iterable<EditorCell> getContentCells(final EditorCell_Collection editorCell) {
    final Iterable<EditorCell> contentCells = ((EditorCell_Collection) editorCell.getContentCells());
    if (sortedContentCells == null || contentCellsHash != contentCells.hashCode()) {
      editorCell.getSNode().getModel().getRepository().getModelAccess().runReadAction(() -> {
        sortedContentCells = ListSequence.fromList(ListSequence.fromListWithValues(new ArrayList<EditorCell>(), contentCells)).tailListSequence(1).sort((a, b) -> {
          SNode aNode = ((SNode) a.getSNode());
          SNode bNode = ((SNode) b.getSNode());
          int result = (int) IMarginCellContent__BehaviorDescriptor.compareTo_id10nVqVg5kqc.invoke(aNode, bNode, editorCell.getContext());

          return result;
        }, true).toList();
        contentCellsHash = contentCells.hashCode();
      });
    }

    return sortedContentCells;
  }

  protected void layoutContentCells(final EditorCell_Collection editorCell) {
    SRepository repository = editorCell.getEditorComponent().getEditorContext().getRepository();

    int x = style.getVerticalBound(editorCell) + style.getMarginLeft(editorCell);

    for (final EditorCell contentCell : Sequence.fromIterable(getContentCells(editorCell))) {
      contentCell.moveTo(style.getVerticalBound(contentCell) - style.getCellWidth(contentCell), 0);
      contentCell.relayout();

      final Wrappers._T<SNode> contentNode = new Wrappers._T<SNode>();
      final Wrappers._T<String> attachedCellId = new Wrappers._T<String>();
      final Wrappers._T<SNode> attachedNode = new Wrappers._T<SNode>();
      editorCell.getSNode().getModel().getRepository().getModelAccess().runReadAction(() -> {
        contentNode.value = (SNode) contentCell.getSNode();
        attachedCellId.value = SPropertyOperations.getString(contentNode.value, PROPS.attachedCellId$G9fZ);
        attachedNode.value = SLinkOperations.getTarget(contentNode.value, LINKS.attachedNode$Bgt0);

        if ((boolean) IMarginCellContent__BehaviorDescriptor.isConnectionAllowed_id10nVqVftAKg.invoke(contentNode.value)) {
          final SNode predecessor = IMarginCellContent__BehaviorDescriptor.getPredecessor_id10nVqVftAKE.invoke(contentNode.value);

          EditorCell connectedCell = Sequence.fromIterable(getContentCells(editorCell)).findFirst((it) -> Objects.equals(predecessor, it.getSNode()));
          if (connectedCell != null) {
            contentCell.putUserObject(CONNECTED_CONTENT_NODE_KEY, predecessor);
            contentCell.putUserObject(CONNECTED_CONTENT_CELL_ID_KEY, connectedCell.getCellId());
          }
        }

        IMarginCellContent__BehaviorDescriptor.callbackLayout_id10nVqVgfXA7.invoke(contentNode.value, contentCell);
      });

      EditorCell attachedCell = editorCell.getEditorComponent().findCellWithId(attachedNode.value, attachedCellId.value);
      final Wrappers._T<SNode> currentNode = new Wrappers._T<SNode>(attachedNode.value);
      while (attachedCell == null && currentNode.value != null) {
        attachedCell = editorCell.getEditorComponent().findNodeCell(currentNode.value);
        repository.getModelAccess().runReadAction(() -> currentNode.value = SNodeOperations.getParent(currentNode.value));
      }
      if (attachedCell == null) {
        repository.getModelAccess().runReadAction(() -> {
          if (LOG.isWarningLevel()) {
            LOG.warning("cannot find attached node for " + SPropertyOperations.getString(SNodeOperations.asNode(CONCEPTS.IMarginCellContent$zg), PROPS.name$MnvL) + " '" + contentNode.value + "'");
          }
        });
        continue;
      }
      int y = attachedCell.getY();

      contentCell.moveTo(x, y);
      contentCell.relayout();

      contentCell.setWidth(style.getCellWidth(contentCell));

      contentCell.putUserObject(ATTACHED_X_KEY, attachedCell.getX());
      contentCell.putUserObject(ATTACHED_Y_KEY, attachedCell.getY());
      contentCell.putUserObject(ATTACHED_WIDTH_KEY, attachedCell.getWidth());
      contentCell.putUserObject(ATTACHED_HEIGHT_KEY, attachedCell.getHeight());
    }
  }

  protected void moveOverlappingContentCells(EditorCell_Collection editorCell) {
    int maxHeight = editorCell.getHeight();
    boolean foundOverlap;

    long start = System.currentTimeMillis();

    List<EditorCell> contentCells = Sequence.fromIterable(getContentCells(editorCell)).toList();
    do {
      foundOverlap = false;
      for (int i = 0; i < ListSequence.fromList(contentCells).count(); i++) {
        EditorCell contentCellA = ListSequence.fromList(contentCells).getElement(i);

        for (int j = 0; j < ListSequence.fromList(contentCells).count(); j++) {
          if (i == j) {
            continue;
          }

          EditorCell contentCellB = ListSequence.fromList(contentCells).getElement(j);

          int overlapHalf = overlap(contentCellA, contentCellB);
          if (overlapHalf > 0) {
            foundOverlap = true;

            EditorCell upper = (i < j ? contentCellA : contentCellB);
            EditorCell lower = (i < j ? contentCellB : contentCellA);

            move(upper, -overlapHalf);
            move(lower, overlapHalf);

            maxHeight = Math.max(maxHeight, lower.getBottom());
          }
        }

        maxHeight = Math.max(maxHeight, contentCellA.getBottom());
      }
    } while (foundOverlap && (System.currentTimeMillis() - start) < style.getOverlapResolutionTimeout(editorCell));

    editorCell.setHeight(maxHeight);
  }

  private int overlap(EditorCell contentCellA, EditorCell contentCellB) {
    int gap = style.getGap(contentCellA);
    if (contentCellA.getBottom() > (contentCellB.getY() - gap) && contentCellA.getY() < (contentCellB.getBottom() + gap)) {
      int overlap = contentCellA.getBottom() - contentCellB.getY();
      int overlapHalf = overlap / 2 + gap;

      return overlapHalf;
    } else {
      return -1;
    }
  }

  private void move(EditorCell editorCell, int delta) {
    if (editorCell == null) {
      return;
    }

    int y = Math.max(editorCell.getY() + delta, style.getBorderWidth(editorCell));
    editorCell.moveTo(editorCell.getX(), y);
    editorCell.relayout();
  }

  public TextBuilder doLayoutText(Iterable<EditorCell> iterable) {
    TextBuilder result = new TextBuilderImpl();

    for (EditorCell contentCell : Sequence.fromIterable(iterable)) {
      result.appendToTheBottom(contentCell.renderText());
      result.appendToTheBottom(new TextBuilderImpl("\n"));
    }

    return result;
  }

  private Iterable<EditorCell> sortedContentCells;
  private int contentCellsHash;

  private static final class PROPS {
    /*package*/ static final SProperty attachedCellId$G9fZ = MetaAdapterFactory.getProperty(0x92f195b6a2094804L, 0xad65f5248ecd5873L, 0x1017edaecf766251L, 0x6f909de0265473f1L, "attachedCellId");
    /*package*/ static final SProperty name$MnvL = MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name");
  }

  private static final class LINKS {
    /*package*/ static final SReferenceLink attachedNode$Bgt0 = MetaAdapterFactory.getReferenceLink(0x92f195b6a2094804L, 0xad65f5248ecd5873L, 0x1017edaecf766251L, 0x6f909de0265512a1L, "attachedNode");
  }

  private static final class CONCEPTS {
    /*package*/ static final SInterfaceConcept IMarginCellContent$zg = MetaAdapterFactory.getInterfaceConcept(0x92f195b6a2094804L, 0xad65f5248ecd5873L, 0x1017edaecf766251L, "com.mbeddr.mpsutil.margincell.structure.IMarginCellContent");
  }
}
