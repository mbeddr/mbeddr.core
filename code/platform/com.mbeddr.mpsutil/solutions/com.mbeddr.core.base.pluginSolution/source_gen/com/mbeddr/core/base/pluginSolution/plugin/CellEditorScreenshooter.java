package com.mbeddr.core.base.pluginSolution.plugin;

/*Generated by MPS */

import java.awt.Image;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import org.jetbrains.mps.openapi.module.SRepository;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import java.io.IOException;
import jetbrains.mps.nodeEditor.EditorComponent;
import jetbrains.mps.editor.runtime.HeadlessEditorComponent;
import jetbrains.mps.project.Project;
import jetbrains.mps.ide.project.ProjectHelper;
import jetbrains.mps.openapi.editor.extensions.EditorExtensionUtil;
import jetbrains.mps.openapi.editor.update.Updater;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.Arrays;
import jetbrains.mps.openapi.editor.cells.EditorCell;
import jetbrains.mps.openapi.editor.cells.CellTraversalUtil;
import java.util.Map;
import de.itemis.mps.editor.diagram.runtime.model.DiagramModel;
import de.itemis.mps.editor.diagram.runtime.jgraph.MyGraph;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import de.itemis.mps.editor.diagram.runtime.jgraph.RootDiagramECell;
import de.itemis.mps.editor.diagram.runtime.jgraph.BaseDiagramDCell;
import jetbrains.mps.internal.collections.runtime.IMapping;
import com.intellij.openapi.progress.EmptyProgressIndicator;
import jetbrains.mps.ide.ThreadUtils;
import java.awt.image.BufferedImage;
import java.awt.Graphics2D;
import jetbrains.mps.nodeEditor.AdditionalPainter;
import jetbrains.mps.nodeEditor.cells.ParentSettings;
import jetbrains.mps.nodeEditor.EditorCell_WithComponent;
import javax.swing.JComponent;
import java.awt.Graphics;
import javax.imageio.ImageIO;
import java.io.File;
import java.awt.Component;
import java.awt.Container;

public class CellEditorScreenshooter {

  public static Image takeScreenshot(@NotNull final SNode n, @NotNull final String imageFileName) {
    return CellEditorScreenshooter.createImage(n, imageFileName, new String[0]);
  }

  public static Image takeScreenshot(@NotNull final SNode n, @NotNull final String imageFileName, @NotNull String[] hints) {
    return CellEditorScreenshooter.createImage(n, imageFileName, hints);
  }

  private static Image createImage(@NotNull final SNode n, @NotNull final String imageFileName, @NotNull final String[] hints) {
    try {
      final Wrappers._T<Image> image = new Wrappers._T<Image>();
      try {
        final SRepository repository = SNodeOperations.getModel(n).getRepository();
        repository.getModelAccess().executeCommand(() -> {

          ScreenshotOptions options = new ScreenshotOptions();
          options.hints = hints;
          try {
            image.value = takeScreenshotSynchronously(repository, n, imageFileName, options);
          } catch (IOException io) {
            throw new RuntimeException(io);
          }
        });
      } catch (Exception ex) {
        throw new RuntimeException(ex);
      }
      return image.value;
    } catch (Exception ex) {
      throw new RuntimeException(ex);
    }
  }

  public static class ScreenshotOptions {
    public String[] hints;
    public boolean renderInspector = false;
  }

  public static Image takeScreenshotSynchronously(@NotNull SRepository repository, @NotNull final SNode n, @NotNull final String imageFileName, @NotNull final ScreenshotOptions options) throws IOException {
    final EditorComponent editorComp = (options.renderInspector ? new HeadlessInspectorComponent(repository) : new HeadlessEditorComponent(repository));
    try {
      editorComp.editNode(n);
      Project project = ProjectHelper.getProject(repository);
      if (project != null) {
        EditorExtensionUtil.extendUsingProject(editorComp, project);
      }

      if (options.hints.length > 0) {
        Updater updater = editorComp.getUpdater();
        // enable conditional editors by setting the required hints. Otherwise no conditional 
        // editors are considered and for instance code paragraphs would not render correctly
        String[] hintsWithConditionalEditor = Sequence.fromIterable(Sequence.fromArray(options.hints)).concat(ListSequence.fromList(Arrays.asList("de.slisson.mps.conditionalEditor.hints.editor.conditionalEditorHints.conditionalEditor", "de.slisson.mps.conditionalEditor.hints.editor.conditionalEditorHints.conditionalEditor_doNotUseThisHint"))).toGenericArray(String.class);
        updater.setInitialEditorHints(hintsWithConditionalEditor);
        updater.update();
      }

      editorComp.setSize(editorComp.getPreferredSize());

      Iterable<EditorCell> descendants = CellTraversalUtil.iterateTree(editorComp.getRootCell(), editorComp.getRootCell(), true);
      final Map<DiagramModel, MyGraph> modelMap = MapSequence.fromMap(new HashMap<DiagramModel, MyGraph>());
      Sequence.fromIterable(descendants).ofType(RootDiagramECell.class).visitAll((it) -> {
        BaseDiagramDCell rootCell = (BaseDiagramDCell) it.getDCell();
        DiagramModel model = rootCell.getDiagramModel();
        MapSequence.fromMap(modelMap).put(model, it.getContextGraph());
      });
      for (IMapping<DiagramModel, MyGraph> entry : MapSequence.fromMap(modelMap)) {
        entry.key().getLayouter().layout(entry.value(), new EmptyProgressIndicator());
      }

      layoutAll(editorComp);

      EditorCell cell = editorComp.getRootCell();
      return writeImage(cell, imageFileName);
    } finally {
      ThreadUtils.runInUIThreadNoWait(() -> editorComp.dispose());
    }
  }

  public static Image writeImage(EditorCell cell, String imageFileName) throws IOException {
    EditorComponent editorComp = (EditorComponent) cell.getEditorComponent();
    int width = cell.getX() + cell.getWidth() + 20;
    int height = cell.getY() + cell.getHeight() + 15;

    BufferedImage image = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);
    final Graphics2D g = image.createGraphics();
    editorComp.turnOnAliasingIfPossible(g);
    g.setColor(editorComp.getBackground());
    g.fillRect(0, 0, width, height);
    for (AdditionalPainter painter : ListSequence.fromList(editorComp.getAdditionalPainters())) {
      if (painter.paintsBackground()) {
        painter.paintBackground(g, editorComp);
      }
    }
    ((jetbrains.mps.nodeEditor.cells.EditorCell) cell).paintCell(g, ParentSettings.createDefaultSetting());
    ((jetbrains.mps.nodeEditor.cells.EditorCell) cell).paintDecorations(g);
    for (AdditionalPainter painter : ListSequence.fromList(editorComp.getAdditionalPainters())) {
      if (painter.paintsAbove()) {
        painter.paint(g, editorComp);
      }
    }
    Iterable<EditorCell> descendants = CellTraversalUtil.iterateTree(cell, cell, true);
    Sequence.fromIterable(descendants).ofType(EditorCell_WithComponent.class).visitAll((it) -> {
      JComponent comp = it.getComponent();
      Graphics gc = g.create(comp.getX(), comp.getY(), comp.getWidth(), comp.getHeight());
      try {
        comp.paint(gc);
      } finally {
        gc.dispose();
      }
    });
    ImageIO.write(image, "png", new File(imageFileName));
    return image;
  }

  public static void layoutAll(Component comp) {
    comp.doLayout();
    if (comp instanceof Container) {
      for (Component child : ((Container) comp).getComponents()) {
        layoutAll(child);
      }
    }
  }
}
