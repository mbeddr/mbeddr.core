package com.mbeddr.core.base.pluginSolution.plugin;

/*Generated by MPS */

import org.jetbrains.mps.openapi.model.SModel;
import com.intellij.openapi.application.ApplicationNamesInfo;
import com.intellij.openapi.project.Project;
import jetbrains.mps.workbench.action.BaseGroup;
import jetbrains.mps.smodel.ModelDependencyResolver;
import jetbrains.mps.smodel.language.LanguageRegistry;
import org.jetbrains.mps.openapi.language.SLanguage;
import java.util.TreeMap;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.util.NameUtil;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import jetbrains.mps.smodel.constraints.ConstraintsCanBeFacade;
import jetbrains.mps.core.aspects.constraints.rules.kinds.CanBeRootContext;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import com.mbeddr.core.base.behavior.IMbeddrIDERoot__BehaviorDescriptor;
import java.util.ArrayList;
import java.util.Objects;
import org.jetbrains.mps.openapi.language.SInterfaceConcept;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;

public class MbeddrMenuHelper {
  public static final String MBEDDR_STEREOTYPE = "mbeddr";
  public static final String MBEDDR_IDE_PRODUCT_NAME = "mbeddr";
  private static final String MPS_IDE_PRODUCT_NAME = "MPS";
  /**
   * category key for all IMbeddrIDERoots without specified category name
   */
  private static final String KEY_CATEGORY_NONE = "KEY_CATEGORY_NONE";


  public static boolean isMbeddrModel(SModel model) {
    return true;
  }

  public static boolean isMPSorMbeddrStandalone() {
    ApplicationNamesInfo info = ApplicationNamesInfo.getInstance();
    String name = info.getProductName();

    return MPS_IDE_PRODUCT_NAME.equals(name) || MBEDDR_IDE_PRODUCT_NAME.equals(name);
  }

  public static boolean isMbeddrMenuEnabled(Project project) {
    return true;
  }

  public static void attachMbeddrRootMenu(final SModel model, final String packageName, BaseGroup parent) {
    // XXX It's unclear to me how this could happen. Temporary/transient models are not the cause for the possible NullPointer.
    if (model == null || model.getRepository() == null) {
      return;
    }
    ModelDependencyResolver modelDeps = new ModelDependencyResolver(LanguageRegistry.getInstance(model.getRepository()), model.getRepository());
    Iterable<SLanguage> allUsedLanguages = modelDeps.usedLanguages(model);
    // XXX BTW, there's SModelOperations.getAllLanguageImports(SModel), that gives all directly imported language
    // and those coming through devkit imports. Why not to use it instead?

    final BaseGroup rootsNoCategoryGroup = new BaseGroup("NoCategoryRoots");
    parent.add(rootsNoCategoryGroup);
    parent.addSeparator();
    BaseGroup rootsWithCategoryGroup = new BaseGroup("CategoryRoots");
    parent.add(rootsWithCategoryGroup);
    parent.addSeparator();
    final BaseGroup otherRootsGroup = new BaseGroup("OtherRoots");
    parent.add(otherRootsGroup);

    final TreeMap<String, List<RootConceptHolder>> rootNodesByCategory = new TreeMap<String, List<RootConceptHolder>>(String.CASE_INSENSITIVE_ORDER);

    // collect MbeddrIDERoots from all used languages (including from devkits and from transitively required devkits)
    Sequence.fromIterable(allUsedLanguages).visitAll((lang) -> {
      BaseGroup languageGroup = new BaseGroup(NameUtil.compactNamespace(lang.getQualifiedName()));
      languageGroup.setPopup(true);

      for (SAbstractConcept rootConcept : Sequence.fromIterable(((Iterable<SAbstractConcept>) lang.getConcepts())).where((it) -> ConstraintsCanBeFacade.checkCanBeRoot(new CanBeRootContext(it, model)).isEmpty() && !(it.isAbstract()))) {
        if (ListSequence.fromList(SConceptOperations.getAllSuperConcepts(rootConcept, false)).contains(CONCEPTS.IMbeddrIDERoot$Vl)) {
          // use simple node instantiation instead of node factory as there is no need for node instance creation
          // (methods of IMbeddrIDERoot should be anyway rather static concept methods than instance methods)
          SNode createNode = ((SNode) SConceptOperations.createNewNode(SNodeOperations.asInstanceConcept(rootConcept)));
          if (!((boolean) IMbeddrIDERoot__BehaviorDescriptor.isDisplayed_id2daXVy6Qz1j.invoke(createNode))) {
            continue;
          }
          String category = (isNotEmptyString(IMbeddrIDERoot__BehaviorDescriptor.getCategory_id1uL8CIsKxiy.invoke(createNode)) ? IMbeddrIDERoot__BehaviorDescriptor.getCategory_id1uL8CIsKxiy.invoke(createNode) : KEY_CATEGORY_NONE);
          rootNodesByCategory.computeIfAbsent(category, (String cat) -> new ArrayList<RootConceptHolder>()).add(new RootConceptHolder(rootConcept, (int) IMbeddrIDERoot__BehaviorDescriptor.getSortOrder_id1uL8CIs6rGR.invoke(createNode), IMbeddrIDERoot__BehaviorDescriptor.getIDEDisplayString_idIviauXb0g.invoke(createNode), category));
        } else {
          String displayLabel = (isNotEmptyString(SConceptOperations.conceptAlias(rootConcept)) ? SConceptOperations.conceptAlias(rootConcept) : rootConcept.getName());
          languageGroup.add(new AddRootAction(rootConcept, model, displayLabel, packageName));
        }
      }

      if (languageGroup.getChildrenCount() > 0) {
        otherRootsGroup.add(languageGroup);
      }
    });

    for (String category : rootNodesByCategory.keySet()) {
      List<RootConceptHolder> categoryNodes = rootNodesByCategory.get(category);
      categoryNodes.sort(new NodeIdeValueComparator());
      if (Objects.equals(category, KEY_CATEGORY_NONE)) {
        categoryNodes.forEach((RootConceptHolder it) -> rootsNoCategoryGroup.add(new AddRootAction(it.getConcept(), model, it.getDisplayString(), packageName)));
      } else {
        final BaseGroup group = new BaseGroup(category);
        group.setPopup(true);
        categoryNodes.forEach((RootConceptHolder it) -> group.add(new AddRootAction(it.getConcept(), model, it.getDisplayString(), packageName)));
        rootsWithCategoryGroup.add(group);
      }
    }
  }
  private static boolean isNotEmptyString(String str) {
    return str != null && str.length() > 0;
  }

  private static final class CONCEPTS {
    /*package*/ static final SInterfaceConcept IMbeddrIDERoot$Vl = MetaAdapterFactory.getInterfaceConcept(0xd4280a54f6df4383L, 0xaa41d1b2bffa7eb1L, 0x2e7d229ef4a2cdL, "com.mbeddr.core.base.structure.IMbeddrIDERoot");
  }
}
