package com.mbeddr.core.base.pluginSolution.plugin;

/*Generated by MPS */

import jetbrains.mps.project.Project;
import org.jetbrains.mps.openapi.module.SearchScope;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import java.util.List;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import com.intellij.openapi.progress.ProgressManager;
import com.intellij.openapi.progress.Task;
import jetbrains.mps.ide.project.ProjectHelper;
import org.jetbrains.annotations.NotNull;
import com.intellij.openapi.progress.ProgressIndicator;
import java.util.LinkedList;
import jetbrains.mps.progress.ProgressMonitorAdapter;
import java.util.regex.Pattern;
import java.util.regex.PatternSyntaxException;
import java.util.Set;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import org.jetbrains.mps.openapi.util.ProgressMonitor;
import com.mbeddr.core.base.behavior.ISearchSupport__BehaviorDescriptor;
import jetbrains.mps.smodel.SNodePointer;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.lang.core.behavior.BaseConcept__BehaviorDescriptor;
import com.mbeddr.core.base.behavior.IIdentifierNamedConcept__BehaviorDescriptor;
import jetbrains.mps.util.NameUtil;
import org.jetbrains.mps.openapi.language.SInterfaceConcept;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import org.jetbrains.mps.openapi.language.SProperty;

public class SearchEngine {

  public static int MEDIUM_SEARCH_TOLERANCE = 2;
  public static int LONG_SEARCH_TOLERANCE = 3;

  public static int SHORT_SEARCH_MAXIMUM = 3;

  public static int MEDIUM_SEARCH_MINIMUM = 4;
  public static int MEDIUM_SEARCH_MAXIMUM = 7;

  public static int LONG_SEARCH_MINIMUM = 8;

  public static int MAXIMUM_RESULT = 10000;

  private Project project;
  private SearchScope scope;

  public SearchEngine(SearchScope scope, final Project project) {
    this.scope = scope;
    this.project = project;
  }

  public void search(String text, boolean searchAll, boolean approximateSearch, boolean matchCase, boolean matchRegex, SearchCallback callback) {
    final Wrappers._T<List<SModel>> models = new Wrappers._T<List<SModel>>();
    project.getRepository().getModelAccess().runReadAction(() -> models.value = ListSequence.fromListWithValues(new ArrayList<SModel>(), scope.getModels()));
    searchModels(models.value, text, searchAll, approximateSearch, matchCase, matchRegex, callback);
  }

  private void searchModels(final List<SModel> models, final String text, final boolean searchAll, final boolean approximateSearch, final boolean matchCase, final boolean matchRegex, final SearchCallback callback) {
    final String textToSearch = (matchCase ? text : text.toLowerCase());

    ProgressManager.getInstance().run(new Task.Backgroundable(ProjectHelper.toIdeaProject(project), "Searching...", true) {
      public void run(@NotNull ProgressIndicator pi) {
        final List<SearchResult> results = ListSequence.fromList(new LinkedList<SearchResult>());

        final ProgressMonitorAdapter progress = new ProgressMonitorAdapter(pi);
        progress.start("Searching: " + ListSequence.fromList(models).count() + " models", ListSequence.fromList(models).count());
        final Wrappers._T<Pattern> searchPattern = new Wrappers._T<Pattern>();
        if (matchRegex) {
          try {
            if (matchCase) {
              searchPattern.value = Pattern.compile(text);
            } else {
              searchPattern.value = Pattern.compile(text, Pattern.CASE_INSENSITIVE);
            }
          } catch (PatternSyntaxException e) {
            callback.resultsReceived(results);
            return;
          }
        }
        int modelIndex = 1;
        final List<ISearchNodeFilter> filters = ListSequence.fromList(SearchNodeFilterConfig.getFilters()).where((it) -> it.isEnabled()).toList();

        final boolean inclusionMode = ListSequence.fromList(filters).any((it) -> it.isInclusionFilter());

        for (final SModel model : ListSequence.fromList(models)) {
          final Set<SNode> toBeSearched = SetSequence.fromSet(new HashSet<SNode>());
          final List<SNode> toBeRemoved = ListSequence.fromList(new LinkedList<SNode>());
          final List<SNode> toBeKept = ListSequence.fromList(new LinkedList<SNode>());

          project.getRepository().getModelAccess().runReadAction(() -> {
            if (searchAll) {
              SetSequence.fromSet(toBeSearched).addSequence(ListSequence.fromList(SModelOperations.nodes(model, null)));
            } else {
              SetSequence.fromSet(toBeSearched).addSequence(ListSequence.fromList(SModelOperations.nodes(model, CONCEPTS.ISearchSupport$uE)));
              SetSequence.fromSet(toBeSearched).addSequence(ListSequence.fromList(SModelOperations.nodes(model, CONCEPTS.INamedConcept$Kd)));
            }

            for (final ISearchNodeFilter filter : ListSequence.fromList(filters)) {
              for (SAbstractConcept concept : SetSequence.fromSet(filter.getApplicableConcepts())) {
                Sequence.fromIterable(SNodeOperations.ofConcept(toBeSearched, SNodeOperations.asSConcept(concept))).visitAll((it) -> {
                  if (filter.filter(it)) {
                    if (inclusionMode) {
                      ListSequence.fromList(toBeKept).addElement(it);
                    } else {
                      ListSequence.fromList(toBeRemoved).addElement(it);
                    }
                  }
                });
              }
            }
            if (ListSequence.fromList(toBeKept).isNotEmpty()) {
              SetSequence.fromSet(toBeSearched).clear();
              SetSequence.fromSet(toBeSearched).addSequence(ListSequence.fromList(toBeKept));
            } else if (inclusionMode) {
              SetSequence.fromSet(toBeSearched).clear();
            } else {
              SetSequence.fromSet(toBeSearched).removeSequence(ListSequence.fromList(toBeRemoved));
            }

          });

          ProgressMonitor subTask = progress.subTask(1);
          subTask.start("Model " + (modelIndex++) + " of " + ListSequence.fromList(models).count(), SetSequence.fromSet(toBeSearched).count());

          final Set<SNode> found = SetSequence.fromSet(new HashSet<SNode>());
          for (final SNode it : SetSequence.fromSet(toBeSearched)) {
            subTask.advance(1);
            if (pi.isCanceled()) {
              break;
            }

            if (SNodeOperations.isInstanceOf(it, CONCEPTS.IEmpty$6_)) {
              continue;
            }

            project.getRepository().getModelAccess().runReadAction(() -> {
              if (SNodeOperations.isInstanceOf(it, CONCEPTS.ISearchSupport$uE)) {
                SNode iss = SNodeOperations.cast(it, CONCEPTS.ISearchSupport$uE);
                if ((boolean) ISearchSupport__BehaviorDescriptor.containsText_idjpyKDg1onB.invoke(iss, text)) {
                  SNode resultNode = ISearchSupport__BehaviorDescriptor.getResultNode_id4ueXZrqtaGB.invoke(iss);
                  if (!(SetSequence.fromSet(found).contains(resultNode))) {
                    SetSequence.fromSet(found).addElement(resultNode);
                    ListSequence.fromList(results).addElement(new SearchResult(model, new SNodePointer(resultNode), ISearchSupport__BehaviorDescriptor.resultName_idjpyKDg1pW5.invoke(iss), conceptLabel(resultNode), getNameSpace(resultNode)));
                  }
                }
              }
              if (SNodeOperations.isInstanceOf(it, CONCEPTS.INamedConcept$Kd)) {
                SNode in = SNodeOperations.cast(it, CONCEPTS.INamedConcept$Kd);
                boolean matches = false;
                String name = SPropertyOperations.getString(in, PROPS.name$MnvL);
                if (!(matchCase) && name != null) {
                  name = name.toLowerCase();
                }
                if (name != null) {
                  int searchlength = textToSearch.length();

                  if (approximateSearch && searchlength >= MEDIUM_SEARCH_MINIMUM) {
                    matches = LevenshteinDistance.compute(name, textToSearch) <= ((searchlength < LONG_SEARCH_MINIMUM ? MEDIUM_SEARCH_TOLERANCE : LONG_SEARCH_TOLERANCE));
                  } else if (matchRegex) {
                    matches = searchPattern.value.matcher(name).matches();
                  } else {
                    matches = name.contains(textToSearch);
                  }
                }
                if (matches) {
                  if (!(SetSequence.fromSet(found).contains(it))) {
                    if (!(SetSequence.fromSet(found).contains(it))) {
                      SetSequence.fromSet(found).addElement(it);
                      SearchResult resItem = new SearchResult(model, new SNodePointer(it), SPropertyOperations.getString(in, PROPS.name$MnvL), conceptLabel(in), getNameSpace(it));
                      ListSequence.fromList(results).addElement(resItem);
                    }
                  }

                }
              }
              if (searchAll) {
                String pres = null;

                try {
                  pres = BaseConcept__BehaviorDescriptor.getPresentation_idhEwIMiw.invoke(it);
                  if (!(matchCase) && pres != null) {
                    pres = pres.toLowerCase();
                  }
                } catch (Exception e) {
                  // all kind of issues could happen here
                }
                if (pres != null) {
                  boolean matches;
                  if (approximateSearch) {
                    matches = LevenshteinDistance.compute(pres, textToSearch) <= MEDIUM_SEARCH_TOLERANCE;
                  } else if (matchRegex) {
                    matches = searchPattern.value.matcher(pres).matches();
                  } else {
                    matches = pres.contains(textToSearch);
                  }
                  if (matches) {
                    if (!(SetSequence.fromSet(found).contains(it))) {
                      String label = pres;
                      if (!(SetSequence.fromSet(found).contains(it))) {
                        SetSequence.fromSet(found).addElement(it);
                        SearchResult resItem = new SearchResult(model, new SNodePointer(it), label, conceptLabel(it), getNameSpace(it));
                        ListSequence.fromList(results).addElement(resItem);
                      }
                    }

                  }
                }
              }
            });

          }

        }

        if (!(pi.isCanceled())) {
          progress.done();
        }
        callback.resultsReceived(ListSequence.fromList(results).take(MAXIMUM_RESULT).sort((a, b) -> a.getShortName().length() - b.getShortName().length(), true).toList());

      }
      private String conceptLabel(SNode resultNode) {
        String conceptLabel = check_yi845x_a0a0b0a0a0c0u(SNodeOperations.getConcept(resultNode));
        return conceptLabel;
      }

    });


  }
  public static String getNameSpace(SNode node) {
    String nameSpaceSupport = ISearchSupport__BehaviorDescriptor.resultNamespace_idjpyKDg2TXB.invoke(SNodeOperations.as(node, CONCEPTS.ISearchSupport$uE));
    if ((nameSpaceSupport != null && nameSpaceSupport.length() > 0)) {
      return nameSpaceSupport;
    }
    SNode namedConcept = SNodeOperations.getNodeAncestor(node, CONCEPTS.IIdentifierNamedConcept$PS, true, false);
    if ((namedConcept != null)) {
      nameSpaceSupport = IIdentifierNamedConcept__BehaviorDescriptor.namespace_id6wvhQs7n_YM.invoke(namedConcept);
    }
    if ((nameSpaceSupport != null && nameSpaceSupport.length() > 0)) {
      return nameSpaceSupport;
    }

    StringBuilder nameSpace = new StringBuilder();
    SModel model = SNodeOperations.getModel(node);
    if (model != null) {
      nameSpace.append(NameUtil.compactModelName(SNodeOperations.getModel(node).getReference()));
      nameSpace.append(".");
    }
    nameSpace.append(SNodeOperations.getContainingRoot(node).getName());
    SNode ancestor = SNodeOperations.getNodeAncestor(node, CONCEPTS.INamedConcept$Kd, false, false);
    if (ancestor != null) {
      nameSpace.append(".");
      nameSpace.append(SPropertyOperations.getString(ancestor, PROPS.name$MnvL));
      nameSpace.append(" [");
      nameSpace.append(SNodeOperations.getConcept(ancestor).getName());
      nameSpace.append("]");
    }
    return nameSpace.toString();
  }
  private static String check_yi845x_a0a0b0a0a0c0u(SAbstractConcept checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getName();
    }
    return null;
  }

  private static final class CONCEPTS {
    /*package*/ static final SInterfaceConcept ISearchSupport$uE = MetaAdapterFactory.getInterfaceConcept(0xd4280a54f6df4383L, 0xaa41d1b2bffa7eb1L, 0x4d98b0a500585e3L, "com.mbeddr.core.base.structure.ISearchSupport");
    /*package*/ static final SInterfaceConcept INamedConcept$Kd = MetaAdapterFactory.getInterfaceConcept(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, "jetbrains.mps.lang.core.structure.INamedConcept");
    /*package*/ static final SInterfaceConcept IEmpty$6_ = MetaAdapterFactory.getInterfaceConcept(0xd4280a54f6df4383L, 0xaa41d1b2bffa7eb1L, 0xe900768cf47dcc3L, "com.mbeddr.core.base.structure.IEmpty");
    /*package*/ static final SInterfaceConcept IIdentifierNamedConcept$PS = MetaAdapterFactory.getInterfaceConcept(0xd4280a54f6df4383L, 0xaa41d1b2bffa7eb1L, 0x617d88a37ec2f433L, "com.mbeddr.core.base.structure.IIdentifierNamedConcept");
  }

  private static final class PROPS {
    /*package*/ static final SProperty name$MnvL = MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name");
  }
}
