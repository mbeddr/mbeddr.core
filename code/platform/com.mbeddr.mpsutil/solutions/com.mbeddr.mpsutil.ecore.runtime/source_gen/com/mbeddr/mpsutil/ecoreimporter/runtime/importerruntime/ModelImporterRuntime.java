package com.mbeddr.mpsutil.ecoreimporter.runtime.importerruntime;

/*Generated by MPS */

import org.jetbrains.mps.openapi.language.SLanguage;
import org.eclipse.emf.common.util.URI;
import org.jetbrains.mps.openapi.model.SModel;
import org.eclipse.emf.ecore.EPackage;
import java.util.Map;
import org.eclipse.emf.ecore.EObject;
import org.jetbrains.mps.openapi.model.SNode;
import org.jetbrains.mps.openapi.module.SRepository;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import jetbrains.mps.smodel.LanguageAspect;
import jetbrains.mps.smodel.Language;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import com.mbeddr.mpsutil.smodule.runtime.lib.ModelHelper;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import java.util.Objects;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EAttribute;
import org.eclipse.emf.ecore.impl.EEnumLiteralImpl;
import org.jetbrains.mps.openapi.language.SProperty;
import org.jetbrains.mps.openapi.language.SDataType;
import org.jetbrains.mps.openapi.language.SEnumeration;
import java.util.Collection;
import org.jetbrains.mps.openapi.language.SEnumerationLiteral;
import jetbrains.mps.internal.collections.runtime.CollectionSequence;
import org.eclipse.emf.ecore.EReference;
import org.jetbrains.mps.openapi.language.SReferenceLink;
import org.eclipse.xtext.EcoreUtil2;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.emf.ecore.xmi.impl.XMIResourceFactoryImpl;
import org.eclipse.emf.ecore.xmi.impl.XMLResourceFactoryImpl;
import java.io.IOException;
import org.jetbrains.mps.openapi.language.SConcept;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;

public class ModelImporterRuntime {

  private SLanguage lng;
  private URI ecoreMetaModelFileName;
  private URI pathToInst;
  private SModel modelToImportInto;
  private EPackage emfMetaModel;
  private Map<EObject, SNode> mappedNodes;

  protected void importModel(final SRepository repo) {
    final Wrappers._T<SModel> languageStructure = new Wrappers._T<SModel>();
    repo.getModelAccess().runReadAction(() -> languageStructure.value = LanguageAspect.STRUCTURE.get((Language) lng.getSourceModule()));
    for (final EObject object : ListSequence.fromList(getInstanceResource().getContents())) {
      repo.getModelAccess().executeCommand(() -> {
        SAbstractConcept conceptToInstantiate = findConceptByName(languageStructure.value, ((EObject) object).eClass().getName(), repo);
        SNode nodeInstance = SConceptOperations.createNewNode(SNodeOperations.asInstanceConcept(conceptToInstantiate));
        mappedNodes = MapSequence.fromMap(new HashMap<EObject, SNode>());
        addProperty(nodeInstance, object, ((EObject) object).eClass(), conceptToInstantiate);
        MapSequence.fromMap(mappedNodes).put(object, nodeInstance);
        addChildren(nodeInstance, object, languageStructure.value, repo);
        addReferences(nodeInstance, object, languageStructure.value);
        ModelHelper.addLanguage(modelToImportInto, lng);
        SModelOperations.addRootNode(modelToImportInto, nodeInstance);
      });
    }
  }

  private SAbstractConcept findConceptByName(final SModel model, final String eClassName, SRepository repo) {
    final Wrappers._T<SAbstractConcept> retConcept = new Wrappers._T<SAbstractConcept>();
    repo.getModelAccess().runReadAction(() -> retConcept.value = SNodeOperations.asSConcept(ListSequence.fromList(SModelOperations.nodes(model, CONCEPTS.ConceptDeclaration$gH)).findFirst((cd) -> Objects.equals(SPropertyOperations.getString(cd, PROPS.name$MnvL), eClassName))));
    return retConcept.value;
  }
  public ModelImporterRuntime(SModel mdlToImportInto, SLanguage mdl1, URI ecoreMetaModelFileName1, URI pathToInstanceXml) {
    lng = mdl1;
    ecoreMetaModelFileName = ecoreMetaModelFileName1;
    pathToInst = pathToInstanceXml;
    modelToImportInto = mdlToImportInto;
    emfMetaModel = EMFUtils.getEPackage(ecoreMetaModelFileName);
  }

  private void addProperty(SNode instanceMPS, EObject instanceEMF, EClass classEmf, SAbstractConcept classMPS) {
    for (EAttribute attribute : ListSequence.fromList(classEmf.getEAttributes())) {
      setAttribute(instanceEMF, attribute, instanceMPS);
    }
    for (EAttribute attribute : ListSequence.fromList(classEmf.getEAllAttributes())) {
      setAttribute(instanceEMF, attribute, instanceMPS);
    }
  }
  private void setAttribute(EObject instanceEMF, EAttribute attribute, SNode instanceMPS) {
    Object val = instanceEMF.eGet(attribute);
    if (val instanceof EEnumLiteralImpl) {
      final String emfLiteral = ((EEnumLiteralImpl) val).getLiteral();
      SProperty propertyByName = getPropertyByName(attribute.getName(), instanceMPS);
      if (!(Objects.equals(propertyByName, null))) {
        SDataType type = propertyByName.getType();
        assert type instanceof SEnumeration;
        Collection<SEnumerationLiteral> literals = ((SEnumeration) type).getLiterals();
        SEnumerationLiteral literal = CollectionSequence.fromCollection(literals).findFirst((it) -> Objects.equals(it.getPresentation(), emfLiteral));
        instanceMPS.setProperty(propertyByName, type.toString(literal));
      }
    } else {
      if (val != null) {
        instanceMPS.setProperty(attribute.getName(), val.toString());
      }
    }
  }

  private SProperty getPropertyByName(String propertyName, SNode nod) {
    for (SProperty property : CollectionSequence.fromCollection(SNodeOperations.getConcept(nod).getProperties())) {
      if (Objects.equals(property.getName(), propertyName)) {
        return property;
      }
    }
    return null;
  }
  private void addChildren(SNode instanceMPS, EObject instanceEMF, SModel languageStructure, SRepository repo) {
    for (EObject child : instanceEMF.eContents()) {
      if (child.eContainer().eClass().getName().equals(instanceMPS.getConcept().getName())) {
        EReference childReference = findReference(instanceEMF, child.eClass().getName());
        SAbstractConcept childConcept = findConceptByName(languageStructure, child.eClass().getName(), repo);
        SNode childInstance = SConceptOperations.createNewNode(SNodeOperations.asInstanceConcept(childConcept));
        addProperty(childInstance, child, child.eClass(), childConcept);
        if (childReference != null) {
          instanceMPS.addChild(childReference.getName(), childInstance);
        }
        MapSequence.fromMap(mappedNodes).put(child, childInstance);
        addChildren(childInstance, child, languageStructure, repo);
      }
    }
  }

  private void addReferences(SNode mpsInstance, EObject emfInstance, SModel languageStructure) {
    for (EReference ref : emfInstance.eClass().getEAllReferences()) {
      if (!(ref.isContainment()) && emfInstance.eGet(ref) instanceof EObject) {
        EObject eo = (EObject) emfInstance.eGet(ref);
        for (SReferenceLink referenceMps : CollectionSequence.fromCollection(mpsInstance.getConcept().getReferenceLinks())) {
          if (referenceMps.getName().equals(ref.getName())) {
            mpsInstance.setReferenceTarget(referenceMps, MapSequence.fromMap(mappedNodes).get(eo));
          }
        }
      }
    }
    for (EObject childEmf : emfInstance.eContents()) {
      addReferences(MapSequence.fromMap(mappedNodes).get(childEmf), childEmf, languageStructure);
    }
  }

  private EReference findReference(EObject instanceEMF, String referenceTypeName) {
    EClass potentialSubClass = (EClass) emfMetaModel.getEClassifier(referenceTypeName);
    for (EReference ref : instanceEMF.eClass().getEReferences()) {
      String referenceNm = ref.getEReferenceType().getName();
      EClass potentielSuperClass = (EClass) emfMetaModel.getEClassifier(referenceNm);
      if (EcoreUtil2.isAssignableFrom(potentielSuperClass, potentialSubClass)) {
        return ref;
      }
    }
    for (EReference ref : instanceEMF.eClass().getEAllReferences()) {
      String referenceNm = ref.getEReferenceType().getName();
      EClass potentielSuperClass = (EClass) emfMetaModel.getEClassifier(referenceNm);
      if (EcoreUtil2.isAssignableFrom(potentielSuperClass, potentialSubClass)) {
        return ref;
      }
    }
    return null;
  }

  private Resource getInstanceResource() {
    EPackage metamodel = EMFUtils.getEPackage(ecoreMetaModelFileName);
    EPackage.Registry.INSTANCE.put(metamodel.getNsURI(), metamodel);
    Resource.Factory.Registry.INSTANCE.getExtensionToFactoryMap().put("xmi", new XMIResourceFactoryImpl());
    Resource.Factory.Registry.INSTANCE.getExtensionToFactoryMap().put("xml", new XMLResourceFactoryImpl());

    Resource res = Resource.Factory.Registry.INSTANCE.getFactory(pathToInst).createResource(pathToInst);
    try {
      res.load(null);
    } catch (IOException e) {
      System.out.println("Error Loading model");
      e.printStackTrace();
    }
    return res;
  }


  private static final class CONCEPTS {
    /*package*/ static final SConcept ConceptDeclaration$gH = MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979ba0450L, "jetbrains.mps.lang.structure.structure.ConceptDeclaration");
  }

  private static final class PROPS {
    /*package*/ static final SProperty name$MnvL = MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name");
  }
}
