package com.mbeddr.mpsutil.ecoreimporter.runtime.importerruntime;

/*Generated by MPS */

import org.jetbrains.mps.openapi.model.SModel;
import org.eclipse.emf.common.util.URI;
import java.util.Map;
import org.jetbrains.mps.openapi.model.SNode;
import org.eclipse.emf.ecore.EObject;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import java.util.logging.Logger;
import org.eclipse.emf.ecore.resource.ResourceSet;
import org.eclipse.emf.ecore.resource.impl.ResourceSetImpl;
import org.eclipse.emf.ecore.xmi.impl.XMLResourceFactoryImpl;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.emf.ecore.EFactory;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import org.eclipse.emf.ecore.EClass;
import java.io.IOException;
import org.jetbrains.mps.openapi.model.SReference;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import org.eclipse.emf.ecore.EReference;
import java.util.List;
import org.apache.commons.lang3.tuple.Pair;
import java.util.Objects;
import org.jetbrains.mps.openapi.language.SProperty;
import jetbrains.mps.internal.collections.runtime.Sequence;
import org.jetbrains.mps.openapi.language.SEnumeration;
import org.eclipse.emf.ecore.EAttribute;
import org.eclipse.emf.ecore.EDataType;
import org.jetbrains.mps.openapi.model.SNodeAccessUtil;
import jetbrains.mps.smodel.adapter.structure.types.SEnumerationAdapter;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EEnumLiteral;
import org.eclipse.emf.ecore.impl.EEnumImpl;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import jetbrains.mps.baseLanguage.closures.runtime.YieldingIterator;
import org.eclipse.emf.ecore.EcorePackage;
import java.math.BigInteger;
import org.eclipse.xtext.EcoreUtil2;
import org.apache.commons.lang3.tuple.ImmutablePair;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;

public class ExporterRuntime {

  private SModel mdl;
  private URI ecoreMetaModelFileName;
  private URI pathToInst;

  private Map<SNode, EObject> mappedNodes = MapSequence.fromMap(new HashMap<SNode, EObject>());

  /*package*/ Logger log = Logger.getLogger("Exporter log");

  public ExporterRuntime(SModel model, URI ecoreMetaModelFileNm, URI pathToInstance) {
    mdl = model;
    ecoreMetaModelFileName = ecoreMetaModelFileNm;
    pathToInst = pathToInstance;
  }

  protected void exportModel() {
    ResourceSet resourceSet = new ResourceSetImpl();
    resourceSet.getResourceFactoryRegistry().getExtensionToFactoryMap().put("*", new XMLResourceFactoryImpl());
    Resource modelInstanceResource = resourceSet.createResource(pathToInst);
    EPackage emfMetaModel = EMFUtils.getEPackage(ecoreMetaModelFileName);
    EFactory factoryInstance = emfMetaModel.getEFactoryInstance();
    for (SNode nod : SModelOperations.roots(mdl, null)) {
      String conceptOfNode = nod.getConcept().getName();
      EClass classEMF = (EClass) emfMetaModel.getEClassifier(conceptOfNode);
      EObject classInstance = factoryInstance.create(classEMF);
      addProperties(nod, classInstance, classEMF);
      addChildrenRecursively(nod, classInstance, classEMF, factoryInstance, emfMetaModel);
      MapSequence.fromMap(mappedNodes).put(nod, classInstance);
    }
    // Second pass for References
    for (SNode nod : SModelOperations.roots(mdl, null)) {
      String conceptOfNode = nod.getConcept().getName();
      EClass classEMF = (EClass) emfMetaModel.getEClassifier(conceptOfNode);
      EObject classInstance = MapSequence.fromMap(mappedNodes).get(nod);
      addReferences(nod, classInstance, classEMF, emfMetaModel, factoryInstance);
      modelInstanceResource.getContents().add(classInstance);
    }

    try {
      modelInstanceResource.save(null);
    } catch (IOException e) {
      e.printStackTrace();
    }
  }

  private void addReferences(SNode nod, EObject objectInstance, EClass classEmf, EPackage emfMetaModel, EFactory factoryInstance) {
    for (SReference reference : ListSequence.fromList(SNodeOperations.getReferences(nod))) {
      try {
        EReference eReference = findPropertyReference(reference.getRole(), classEmf, emfMetaModel);
        if (eReference.isMany()) {
          ((List) objectInstance.eGet(eReference)).add(MapSequence.fromMap(mappedNodes).get(reference.getTargetNode()));
        } else {
          objectInstance.eSet(eReference, MapSequence.fromMap(mappedNodes).get(reference.getTargetNode()));
        }
      } catch (NullPointerException e) {
      }
    }
    for (SNode child : SNodeOperations.getChildren(nod)) {
      // TODO: Remove hack of using name of concept and name of the EMF class to compare and use a more robust method
      Pair<EReference, EClass> childReference = findChildReference(child.getConcept().getName(), classEmf, emfMetaModel);
      if (!(Objects.equals(childReference, null))) {
        EReference childEReference = childReference.getLeft();
        EClass childEClass = childReference.getRight();
        if (!(Objects.equals(childEReference, null))) {
          EObject childEObject = MapSequence.fromMap(mappedNodes).get(child);
          addReferences(child, childEObject, childEClass, emfMetaModel, factoryInstance);
        } else {
          log.warning("Could not find reference for concept " + child.getConcept().getName());
        }
      }
    }
  }

  private void addProperties(SNode nod, EObject objectInstance, EClass classEmF) {
    final Iterable<SProperty> propertiesOfNode = nod.getProperties();
    for (SProperty property : Sequence.fromIterable(propertiesOfConcept(SNodeOperations.getConcept(nod))).where((p) -> Sequence.fromIterable(propertiesOfNode).contains(p) || p.getType() instanceof SEnumeration)) {
      // either the node has an actual value for the property or it is an enumeration property
      // (in the latter case we use the default literal, as the default might be different from
      //  the default in ecore)
      String propName = property.getName();
      EAttribute attribute = findAttribute(classEmF, propName);
      if (attribute == null) {
        // property not found in ecore model (maybe we have to provide an "ignore" mode later)
        throw new RuntimeException("Could not found EAttribute for SNode property '" + propName + "' in EClass '" + classEmF.getName() + "'");
      }

      EDataType attrType = attribute.getEAttributeType();
      Object propertyVal = SNodeAccessUtil.getPropertyValue(nod, property);
      if (propertyVal instanceof SEnumerationAdapter.SEnumLiteralAdapter) {
        // this is an enumerator property
        EList<EEnumLiteral> literals = ((EEnumImpl) attrType).getELiterals();
        SEnumerationAdapter.SEnumLiteralAdapter litAdapter = as_9x5eob_a0a2a9a1a51(propertyVal, SEnumerationAdapter.SEnumLiteralAdapter.class);
        EEnumLiteral lit = literals.get(litAdapter.getOrdinal());

        // NOTE: when setting to the first literal in the enumeration,
        //      the xml persistent file will not contain a value for this attribute
        //      (probably because it is the default value)
        objectInstance.eSet(attribute, lit);
      } else {
        // this is a non-enumerator property
        String propValue = nod.getProperty(property);
        Object value = getValueAsObject(attrType, propValue);
        if (propValue != null) {
          objectInstance.eSet(attribute, value);
        }
      }
    }
  }

  private Iterable<SProperty> propertiesOfConcept(SAbstractConcept conc) {
    Iterable<SProperty> ignore = Sequence.fromClosure(() -> {
      return (Iterable<SProperty>) () -> {
        return new YieldingIterator<SProperty>() {
          private int __CP__ = 0;
          protected boolean moveToNext() {
__loop__:
            do {
__switch__:
              switch (this.__CP__) {
                case -1:
                  assert false : "Internal error";
                  return false;
                case 2:
                  this.__CP__ = 3;
                  this.yield(PROPS.shortDescription$Yd4v);
                  return true;
                case 3:
                  this.__CP__ = 1;
                  this.yield(PROPS.virtualPackage$EkXl);
                  return true;
                case 0:
                  this.__CP__ = 2;
                  break;
                default:
                  break __loop__;
              }
            } while (true);
            return false;
          }
        };
      };
    });
    Iterable<SProperty> props = conc.getProperties();
    return Sequence.fromIterable(props).subtract(Sequence.fromIterable(ignore));
  }

  private Object getValueAsObject(EDataType attrType, String value) {
    String typeName = attrType.getName();
    if (EcorePackage.eINSTANCE.getEInt().getName().equals(typeName)) {
      return Integer.valueOf(value);
    }
    if (EcorePackage.eINSTANCE.getEString().getName().equals(typeName)) {
      return value;
    }
    if (EcorePackage.eINSTANCE.getELong().getName().equals(typeName)) {
      return Long.valueOf(value);
    }
    if (EcorePackage.eINSTANCE.getEDouble().getName().equals(typeName)) {
      return Double.valueOf(value);
    }
    if (EcorePackage.eINSTANCE.getEBigInteger().getName().equals(typeName)) {
      return BigInteger.valueOf(Long.valueOf(value));
    }
    // fallback
    return value;
  }

  private EAttribute findAttribute(EClass classEmf, String attrName) {
    for (EAttribute attr : ListSequence.fromList(classEmf.getEAttributes())) {
      if (attr.getName().equals(attrName)) {
        return attr;
      }
    }
    for (EAttribute attr : ListSequence.fromList(classEmf.getEAllAttributes())) {
      if (attr.getName().equals(attrName)) {
        return attr;
      }
    }
    return null;
  }

  private void addChildrenRecursively(SNode parentNode, EObject parentEObject, EClass parentEClass, EFactory factoryInstance, EPackage emfMetaModel) {
    for (SNode child : SNodeOperations.getChildren(parentNode)) {
      if (parentEClass.getName().equalsIgnoreCase("Runnable")) {
        System.out.println("Breakpoint");
      }
      // TODO: Remove hack of using name of concept and name of the EMF class to compare and use a more robust method
      Pair<EReference, EClass> childReference = findChildReference(child.getConcept().getName(), parentEClass, emfMetaModel);
      if (!(Objects.equals(childReference, null))) {
        EReference childEReference = childReference.getLeft();
        EClass childEClass = childReference.getRight();
        if (!(Objects.equals(childEReference, null))) {
          EObject childEObject = factoryInstance.create(childEClass);
          addProperties(child, childEObject, childEClass);
          MapSequence.fromMap(mappedNodes).put(child, childEObject);
          if (childEReference.isMany()) {
            ((List) parentEObject.eGet(childEReference)).add(childEObject);
          } else {
            parentEObject.eSet(childEReference, childEObject);
          }
          addChildrenRecursively(child, childEObject, childEClass, factoryInstance, emfMetaModel);
        } else {
          log.warning("Could not find reference for concept " + child.getConcept().getName());
        }

      }
    }
  }

  private Pair<EReference, EClass> findChildReference(String referenceName, EClass classEMF, EPackage emfMetaModel) {
    EClass potentielSubClass = (EClass) emfMetaModel.getEClassifier(referenceName);
    for (EReference reference : classEMF.getEReferences()) {
      String referenceNm = reference.getEReferenceType().getName();
      EClass potentielSuperClass = (EClass) emfMetaModel.getEClassifier(referenceNm);
      if (EcoreUtil2.isAssignableFrom(potentielSuperClass, potentielSubClass)) {
        return new ImmutablePair<EReference, EClass>(reference, potentielSubClass);
      }
    }
    for (EReference reference : classEMF.getEAllReferences()) {
      String referenceNm = reference.getEReferenceType().getName();
      EClass potentielSuperClass = (EClass) emfMetaModel.getEClassifier(referenceNm);
      if (EcoreUtil2.isAssignableFrom(potentielSuperClass, potentielSubClass)) {
        return new ImmutablePair<EReference, EClass>(reference, potentielSubClass);
      }
    }
    return null;
  }

  private EReference findPropertyReference(String referenceName, EClass classEMF, EPackage emfMetaModel) {
    for (EReference reference : ListSequence.fromList(classEMF.getEReferences())) {
      if (reference.getName().equals(referenceName)) {
        return reference;
      }
    }
    for (EReference reference : ListSequence.fromList(classEMF.getEAllReferences())) {
      if (reference.getName().equals(referenceName)) {
        return reference;
      }
    }
    return null;
  }
  private static <T> T as_9x5eob_a0a2a9a1a51(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }

  private static final class PROPS {
    /*package*/ static final SProperty shortDescription$Yd4v = MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x10802efe25aL, 0x10d34f97574L, "shortDescription");
    /*package*/ static final SProperty virtualPackage$EkXl = MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x10802efe25aL, 0x115eca8579fL, "virtualPackage");
  }
}
