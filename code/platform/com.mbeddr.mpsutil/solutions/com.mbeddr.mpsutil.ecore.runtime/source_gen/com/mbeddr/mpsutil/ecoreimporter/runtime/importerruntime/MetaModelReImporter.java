package com.mbeddr.mpsutil.ecoreimporter.runtime.importerruntime;

/*Generated by MPS */

import org.jetbrains.mps.openapi.model.SModel;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.emf.common.util.URI;
import java.util.Objects;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.ENamedElement;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import java.util.List;
import org.eclipse.emf.ecore.impl.EClassImpl;
import org.eclipse.emf.ecore.impl.EEnumImpl;
import java.util.ArrayList;
import org.jetbrains.mps.openapi.model.SNode;
import org.eclipse.emf.ecore.EClass;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import org.eclipse.emf.ecore.EAttribute;
import org.eclipse.emf.ecore.EReference;
import org.jetbrains.mps.openapi.language.SInterfaceConcept;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import org.jetbrains.mps.openapi.language.SConcept;
import org.jetbrains.mps.openapi.language.SProperty;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import org.jetbrains.mps.openapi.language.SReferenceLink;

public class MetaModelReImporter {

  /*package*/ MetaModelImporterCore runner;

  public MetaModelReImporter(SModel inputModel, boolean genEnumValues, String ecoreFileName) {
    runner = new MetaModelImporterCore(inputModel, genEnumValues, ecoreFileName);
  }

  public void reImportIntoMPS() {
    EPackage ecoreModel = EMFUtils.getEPackage(URI.createFileURI(runner.ecoreFileName()));
    assert !(Objects.equals(ecoreModel, null));
    reImportMetaModel(runner.inputModel(), ecoreModel);
  }

  public void reImportMetaModel(SModel inputModel, EPackage emfModel) {
    handleInsertions(inputModel, emfModel);

    handleDeletions(inputModel, emfModel);

    handleModifications(inputModel, emfModel);
  }

  private void handleDeletions(SModel mpsModel, final EPackage emfModel) {
    ListSequence.fromList(SModelOperations.roots(mpsModel, CONCEPTS.INamedConcept$Kd)).visitAll((mpsRootNode) -> {
      String rootNodeName = SPropertyOperations.getString(mpsRootNode, PROPS.name$MnvL);
      boolean foundInEMFModel = false;
      for (EObject emfContent : ListSequence.fromList(emfModel.eContents())) {
        if (emfContent instanceof ENamedElement) {
          if (Objects.equals(((ENamedElement) emfContent).getName(), rootNodeName)) {
            foundInEMFModel = true;
          }
        }
      }
      if (!(foundInEMFModel)) {
        SNodeOperations.deleteNode(mpsRootNode);
      }
    });
  }


  private void handleInsertions(SModel inputModel, EPackage emfModel) {
    List<Object> toAdd = emfContentsToAdd(inputModel, emfModel);
    ListSequence.fromList(toAdd).visitAll((eContent) -> {
      if (eContent instanceof EClassImpl) {
        runner.addEclass((EClassImpl) eContent);
      } else if (eContent instanceof EEnumImpl) {
        runner.addEEnum((EEnumImpl) eContent);
      }
    });
    runner.resolveLazyObjects();
  }

  private List<Object> emfContentsToAdd(SModel mpsModel, EPackage emfModel) {
    List<Object> classListToAdd = ListSequence.fromList(new ArrayList<Object>());
    for (final EObject emfContent : ListSequence.fromList(emfModel.eContents())) {
      // ENamedElement is implemented by EClass and EEnum
      if (emfContent instanceof ENamedElement) {
        // INamedConcept is implemented by ConceptDeclaration, InterfaceConceptDeclaration and EnumerationDataTypeDeclaration
        if (ListSequence.fromList(SModelOperations.roots(mpsModel, CONCEPTS.INamedConcept$Kd)).where((mpsRootNode) -> Objects.equals(SPropertyOperations.getString(mpsRootNode, PROPS.name$MnvL), ((ENamedElement) emfContent).getName())).isEmpty()) {
          ListSequence.fromList(classListToAdd).addElement(emfContent);
        }
      }
    }
    return classListToAdd;
  }

  private void handleModifications(SModel mpsModel, EPackage emfModel) {
    for (SNode mpsAbstractConcept : ListSequence.fromList(SModelOperations.roots(mpsModel, CONCEPTS.AbstractConceptDeclaration$KA))) {
      // Handles InterfaceConceptDeclaration and ConceptDeclaration
      EClass emfClass = runner.findClassByName(SPropertyOperations.getString(mpsAbstractConcept, PROPS.name$MnvL), emfModel);

      // Remove properties missing in EMF
      removeMissingProperties(mpsAbstractConcept, emfClass);

      // Add missing properties
      for (SNode propertyToAdd : ListSequence.fromList(propertiesToAdd(mpsAbstractConcept, emfClass))) {
        ListSequence.fromList(SLinkOperations.getChildren(mpsAbstractConcept, LINKS.propertyDeclaration$YUgg)).addElement(propertyToAdd);
      }

      // Remove links missing in EMF
      removeMissingLinks(mpsAbstractConcept, emfClass);

      // Add missing link declarations
      for (SNode linkToAdd : ListSequence.fromList(linksToAdd(mpsAbstractConcept, emfClass))) {
        ListSequence.fromList(SLinkOperations.getChildren(mpsAbstractConcept, LINKS.linkDeclaration$YU1f)).addElement(linkToAdd);
      }

      // Handle Implements and Extends
      if (SNodeOperations.isInstanceOf(mpsAbstractConcept, CONCEPTS.ConceptDeclaration$gH)) {
        handleImplementsExtendsForClasses(SNodeOperations.cast(mpsAbstractConcept, CONCEPTS.ConceptDeclaration$gH), emfClass, mpsModel);
      } else if (SNodeOperations.isInstanceOf(mpsAbstractConcept, CONCEPTS.AbstractConceptDeclaration$KA)) {
        handleExtendsForInterfaces(SNodeOperations.cast(mpsAbstractConcept, CONCEPTS.InterfaceConceptDeclaration$CG), emfClass, mpsModel);
      }
    }
  }


  private void handleExtendsForInterfaces(final SNode mpsInterface, EClass emfClass, SModel inputModel) {
    // MPS does not support interfaces extending classes. So we have to stick to implemented abstract classes in the emf side
    // for our comparison

    final List<EClass> implementedInterfacesInEMF = ListSequence.fromList(new ArrayList<EClass>());
    for (EClass superType : ListSequence.fromList(emfClass.getESuperTypes())) {
      if (superType.isAbstract()) {
        ListSequence.fromList(implementedInterfacesInEMF).addElement(superType);
      }
    }

    for (final EClass ifInEMF : ListSequence.fromList(implementedInterfacesInEMF)) {
      if (ListSequence.fromList(SLinkOperations.getChildren(mpsInterface, LINKS.extends$nawU)).where((ifInMPS) -> Objects.equals(SPropertyOperations.getString(SLinkOperations.getTarget(ifInMPS, LINKS.intfc$zM4e), PROPS.name$MnvL), ifInEMF.getName())).isEmpty()) {
        // Implementing interface in EMF not found in MPS
        SNode intfc = ListSequence.fromList(SModelOperations.nodes(inputModel, CONCEPTS.InterfaceConceptDeclaration$CG)).findFirst((interfaceDeclaration) -> Objects.equals(SPropertyOperations.getString(interfaceDeclaration, PROPS.name$MnvL), ifInEMF.getName()));
        ListSequence.fromList(SLinkOperations.getChildren(mpsInterface, LINKS.extends$nawU)).addElement(runner.createInterfaceReference(intfc));
      }
    }
    ListSequence.fromList(SLinkOperations.getChildren(mpsInterface, LINKS.extends$nawU)).visitAll((ifInMPS) -> {
      boolean foundInEMF = false;
      for (EClass ifInEMF : ListSequence.fromList(implementedInterfacesInEMF)) {
        if (Objects.equals(ifInEMF.getName(), SPropertyOperations.getString(SLinkOperations.getTarget(ifInMPS, LINKS.intfc$zM4e), PROPS.name$MnvL))) {
          foundInEMF = true;
        }
      }
      if (!(foundInEMF)) {
        ListSequence.fromList(SLinkOperations.getChildren(mpsInterface, LINKS.extends$nawU)).removeElement(ifInMPS);
      }
    });
  }


  private void handleImplementsExtendsForClasses(final SNode mpsConcept, EClass emfClass, SModel inputModel) {
    // Handle extends (TODO: Should we support multiple ineritance changes)
    List<EClass> superClassesInEmf = ListSequence.fromList(new ArrayList<EClass>());
    final List<EClass> implementedInterfacesInEMF = ListSequence.fromList(new ArrayList<EClass>());
    for (EClass superType : ListSequence.fromList(emfClass.getESuperTypes())) {
      if (superType.isAbstract()) {
        ListSequence.fromList(implementedInterfacesInEMF).addElement(superType);
      } else {
        ListSequence.fromList(superClassesInEmf).addElement(superType);
      }
    }

    if (ListSequence.fromList(superClassesInEmf).count() == 1) {
      // Incremental import is currently supported only for scenarios without multiple inheritance
      // It assumes that any modification to a super class in the emf side is either an insertion/deletion/shift of ONE extending super class
      final String superClassName = ListSequence.fromList(superClassesInEmf).getElement(0).getName();
      if (!(Objects.equals(SPropertyOperations.getString(SLinkOperations.getTarget(mpsConcept, LINKS.extends$_Isg), PROPS.name$MnvL), superClassName))) {
        SLinkOperations.setTarget(mpsConcept, LINKS.extends$_Isg, ListSequence.fromList(SModelOperations.nodes(inputModel, CONCEPTS.ConceptDeclaration$gH)).findFirst((conceptDeclaration) -> Objects.equals(SPropertyOperations.getString(conceptDeclaration, PROPS.name$MnvL), superClassName)));
      }
    }

    // Handle implements
    for (final EClass ifInEMF : ListSequence.fromList(implementedInterfacesInEMF)) {
      if (ListSequence.fromList(SLinkOperations.getChildren(mpsConcept, LINKS.implements$u_P2)).where((ifInMPS) -> Objects.equals(SPropertyOperations.getString(SLinkOperations.getTarget(ifInMPS, LINKS.intfc$zM4e), PROPS.name$MnvL), ifInEMF.getName())).isEmpty()) {
        // Implementing interface in EMF not found in MPS
        SNode intfc = ListSequence.fromList(SModelOperations.nodes(inputModel, CONCEPTS.InterfaceConceptDeclaration$CG)).findFirst((interfaceDeclaration) -> Objects.equals(SPropertyOperations.getString(interfaceDeclaration, PROPS.name$MnvL), ifInEMF.getName()));
        ListSequence.fromList(SLinkOperations.getChildren(mpsConcept, LINKS.implements$u_P2)).addElement(runner.createInterfaceReference(intfc));
      }
    }
    ListSequence.fromList(SLinkOperations.getChildren(mpsConcept, LINKS.implements$u_P2)).visitAll((ifInMPS) -> {
      boolean foundInEMF = false;
      for (EClass ifInEMF : ListSequence.fromList(implementedInterfacesInEMF)) {
        if (Objects.equals(ifInEMF.getName(), SPropertyOperations.getString(SLinkOperations.getTarget(ifInMPS, LINKS.intfc$zM4e), PROPS.name$MnvL))) {
          foundInEMF = true;
        }
      }
      if (!(foundInEMF)) {
        ListSequence.fromList(SLinkOperations.getChildren(mpsConcept, LINKS.implements$u_P2)).removeElement(ifInMPS);
      }
    });

  }

  private List<SNode> propertiesToAdd(SNode mpsConcept, EClass emfClass) {
    List<SNode> listPropertiesToAdd = ListSequence.fromList(new ArrayList<SNode>());
    for (EAttribute emfProperty : ListSequence.fromList(emfClass.getEAttributes())) {
      boolean foundINMps = false;
      for (SNode mpsProperty : ListSequence.fromList(SLinkOperations.getChildren(mpsConcept, LINKS.propertyDeclaration$YUgg))) {
        if (runner.checkPropertyEquality(mpsProperty, emfProperty)) {
          foundINMps = true;
        }
      }
      if (!(foundINMps)) {
        ListSequence.fromList(listPropertiesToAdd).addElement(runner.getPropertyFromEmfAttribute(emfProperty));
      }
    }
    return listPropertiesToAdd;
  }

  private List<SNode> linksToAdd(SNode mpsConcept, EClass emfClass) {
    List<SNode> listLinksToAdd = ListSequence.fromList(new ArrayList<SNode>());
    for (EReference emfLink : ListSequence.fromList(emfClass.getEReferences())) {
      boolean foundINMps = false;
      for (SNode mpsLink : ListSequence.fromList(SLinkOperations.getChildren(mpsConcept, LINKS.linkDeclaration$YU1f))) {
        if (runner.checkLinkDeclarationEquality(mpsLink, emfLink)) {
          foundINMps = true;
        }
      }
      if (!(foundINMps)) {
        ListSequence.fromList(listLinksToAdd).addElement(runner.getLinkFromEMFLink(emfLink));
      }
    }
    return listLinksToAdd;
  }


  private void removeMissingProperties(SNode mpsConcept, EClass emfClass) {
    for (SNode mpsProperty : ListSequence.fromList(SLinkOperations.getChildren(mpsConcept, LINKS.propertyDeclaration$YUgg))) {
      boolean foundINEmf = false;
      for (EAttribute emfProperty : ListSequence.fromList(emfClass.getEAllAttributes())) {
        if (runner.checkPropertyEquality(mpsProperty, emfProperty)) {
          foundINEmf = true;
        }
      }
      if (!(foundINEmf)) {
        ListSequence.fromList(SLinkOperations.getChildren(mpsConcept, LINKS.propertyDeclaration$YUgg)).removeElement(mpsProperty);
      }
    }
  }

  private void removeMissingLinks(SNode mpsConcept, EClass emfClass) {
    for (SNode mpsLink : ListSequence.fromList(SLinkOperations.getChildren(mpsConcept, LINKS.linkDeclaration$YU1f))) {
      boolean foundINEmf = false;
      for (EReference emfLink : ListSequence.fromList(emfClass.getEReferences())) {
        if (runner.checkLinkDeclarationEquality(mpsLink, emfLink)) {
          foundINEmf = true;
        }
      }
      if (!(foundINEmf)) {
        ListSequence.fromList(SLinkOperations.getChildren(mpsConcept, LINKS.linkDeclaration$YU1f)).removeElement(mpsLink);
      }
    }
  }

  private static final class CONCEPTS {
    /*package*/ static final SInterfaceConcept INamedConcept$Kd = MetaAdapterFactory.getInterfaceConcept(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, "jetbrains.mps.lang.core.structure.INamedConcept");
    /*package*/ static final SConcept ConceptDeclaration$gH = MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979ba0450L, "jetbrains.mps.lang.structure.structure.ConceptDeclaration");
    /*package*/ static final SConcept AbstractConceptDeclaration$KA = MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x1103553c5ffL, "jetbrains.mps.lang.structure.structure.AbstractConceptDeclaration");
    /*package*/ static final SConcept InterfaceConceptDeclaration$CG = MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x1103556dcafL, "jetbrains.mps.lang.structure.structure.InterfaceConceptDeclaration");
  }

  private static final class PROPS {
    /*package*/ static final SProperty name$MnvL = MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name");
  }

  private static final class LINKS {
    /*package*/ static final SContainmentLink propertyDeclaration$YUgg = MetaAdapterFactory.getContainmentLink(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x1103553c5ffL, 0xf979c3ba6cL, "propertyDeclaration");
    /*package*/ static final SContainmentLink linkDeclaration$YU1f = MetaAdapterFactory.getContainmentLink(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x1103553c5ffL, 0xf979c3ba6bL, "linkDeclaration");
    /*package*/ static final SContainmentLink extends$nawU = MetaAdapterFactory.getContainmentLink(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x1103556dcafL, 0x110356e9df4L, "extends");
    /*package*/ static final SReferenceLink intfc$zM4e = MetaAdapterFactory.getReferenceLink(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x110356fc618L, 0x110356fe029L, "intfc");
    /*package*/ static final SReferenceLink extends$_Isg = MetaAdapterFactory.getReferenceLink(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979ba0450L, 0xf979be93cfL, "extends");
    /*package*/ static final SContainmentLink implements$u_P2 = MetaAdapterFactory.getContainmentLink(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979ba0450L, 0x110358d693eL, "implements");
  }
}
