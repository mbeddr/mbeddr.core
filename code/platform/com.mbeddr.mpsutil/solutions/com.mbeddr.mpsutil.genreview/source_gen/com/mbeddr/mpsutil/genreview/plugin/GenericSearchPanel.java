package com.mbeddr.mpsutil.genreview.plugin;

/*Generated by MPS */

import jetbrains.mps.ide.search.AbstractSearchPanel;
import java.awt.Color;
import javax.swing.text.JTextComponent;
import java.util.List;
import java.util.ArrayList;
import jetbrains.mps.ide.search.SearchHistoryStorage;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.LinkedList;
import javax.swing.text.BadLocationException;
import javax.swing.text.DefaultHighlighter;

public class GenericSearchPanel extends AbstractSearchPanel {
  private static Color CURRENT_CURSOR_HIGHLIGHT = Color.red;
  private static Color OCCURRENCES_HIGHLIGHT = Color.orange;

  private JTextComponent textComponent;

  private int currentIndex;
  private List<Integer> myResultsStarts = new ArrayList<Integer>();
  private List<Integer> myResultsEnds = new ArrayList<Integer>();
  private int myCountResult;

  public void setCurrentTextComponent(JTextComponent jtc) {
    this.textComponent = jtc;
    reinit();
    myText.setText("");
  }

  protected SearchHistoryStorage getSearchHistory() {
    return null;
  }

  public void goToPrevious() {
    if (currentIndex > 0) {
      currentIndex--;
    }
    highlightCurrentPosition(currentIndex, CURRENT_CURSOR_HIGHLIGHT);
  }

  public void goToNext() {
    if (currentIndex < myCountResult - 1) {
      currentIndex++;
    }
    highlightCurrentPosition(currentIndex, CURRENT_CURSOR_HIGHLIGHT);
  }

  protected void search() {
    if (isEmptyString(myText.getText())) {
      textComponent.getHighlighter().removeAllHighlights();
      return;
    }
    reinit();
    String textToSearchIn = textComponent.getText();
    Pattern pattern = getPattern();
    Matcher matcher = pattern.matcher(textToSearchIn);
    while (matcher.find()) {
      myResultsStarts.add(matcher.start());
      myResultsEnds.add(matcher.end());
      myCountResult++;
    }
    updateSearchReport(myCountResult);
    if (myCountResult > 0) {
      highlightAll();
      highlightCurrentPosition(0, CURRENT_CURSOR_HIGHLIGHT);
    }
  }

  private void reinit() {
    currentIndex = 0;
    myCountResult = 0;
    myResultsStarts.clear();
    myResultsEnds.clear();
  }

  public void deactivate() {
    textComponent.getHighlighter().removeAllHighlights();
    setVisible(false);
  }

  private List<Object> lastHighlights = ListSequence.fromList(new LinkedList<Object>());
  private int previousPosition = 0;

  private void highlightCurrentPosition(int idx, Color color) {
    try {
      if (previousPosition != idx && previousPosition < myCountResult) {
        int start = myResultsStarts.get(previousPosition);
        int end = myResultsEnds.get(previousPosition);
        textComponent.getHighlighter().removeHighlight(ListSequence.fromList(lastHighlights).getElement(previousPosition));
        Object newHighlight = doHighlight(start, end, OCCURRENCES_HIGHLIGHT);
        ListSequence.fromList(lastHighlights).setElement(previousPosition, newHighlight);
      }
      int start = myResultsStarts.get(idx);
      int end = myResultsEnds.get(idx);
      textComponent.getHighlighter().removeHighlight(ListSequence.fromList(lastHighlights).getElement(idx));
      Object newHighlight = doHighlight(start, end, color);
      ListSequence.fromList(lastHighlights).setElement(idx, newHighlight);
      previousPosition = idx;
    } catch (Exception e) {
      e.printStackTrace();
    }
  }

  private void highlightAll() {
    ListSequence.fromList(lastHighlights).clear();
    textComponent.getHighlighter().removeAllHighlights();
    try {
      for (int idx = 0; idx < myCountResult; idx++) {
        int start = myResultsStarts.get(idx);
        int end = myResultsEnds.get(idx);
        ListSequence.fromList(lastHighlights).addElement(doHighlight(start, end, OCCURRENCES_HIGHLIGHT));
      }
    } catch (Exception e) {
      e.printStackTrace();
    }
  }

  private Object doHighlight(int start, int end, Color color) throws BadLocationException {
    DefaultHighlighter.DefaultHighlightPainter painter = new DefaultHighlighter.DefaultHighlightPainter(color);
    return textComponent.getHighlighter().addHighlight(start, end, painter);
  }

  private static boolean isEmptyString(String str) {
    return str == null || str.isEmpty();
  }
}
