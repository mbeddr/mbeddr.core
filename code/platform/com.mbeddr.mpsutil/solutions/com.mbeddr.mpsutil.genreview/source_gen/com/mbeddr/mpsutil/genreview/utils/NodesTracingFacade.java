package com.mbeddr.mpsutil.genreview.utils;

/*Generated by MPS */

import java.util.Map;
import java.util.List;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.textgen.trace.DebugInfo;
import org.jetbrains.mps.openapi.module.SRepository;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import org.apache.commons.io.FileUtils;
import java.io.File;
import java.io.IOException;
import jetbrains.mps.textgen.trace.DefaultTraceInfoProvider;
import java.util.stream.Collectors;
import org.jetbrains.mps.openapi.model.SNodeReference;
import java.util.LinkedList;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.vfs.IFile;
import jetbrains.mps.smodel.SModelOperations;
import java.util.Collection;
import jetbrains.mps.internal.collections.runtime.CollectionSequence;
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple;

/**
 * Facade for tracing lines from generated files to nodes.
 */
public class NodesTracingFacade {

  /**
   * Cache that maps a program location to all possible original nodes.
   */
  private static Map<String, List<SNode>> location2AllOriginalNodes = MapSequence.fromMap(new HashMap<String, List<SNode>>());

  /**
   * Clears the cache for original nodes.
   */
  public static void clearCache() {
    MapSequence.fromMap(location2AllOriginalNodes).clear();
  }

  /*package*/ static List<DebugInfo> list;
  /*package*/ static String filePath;
  /*package*/ static long savedChecksum;


  /**
   * Returns the first original node that is traced to a certain file and line.
   */
  public static SNode findOriginalNode(String file, int line, SRepository repository) throws IllegalArgumentException {
    return ListSequence.fromList(doFindAllPossibleOriginalNodes(file, line, repository)).first();
  }

  /**
   * Returns all possible original nodes that can be traced to a certain file and line.
   */
  public static List<SNode> doFindAllPossibleOriginalNodes(String file, int line, SRepository repository) throws IllegalArgumentException {
    List<SNode> originalNodes = new ArrayList<SNode>();
    if ((file == null || file.length() == 0)) {
      return originalNodes;
    }

    String location = file + line;

    if (SetSequence.fromSet(MapSequence.fromMap(NodesTracingFacade.location2AllOriginalNodes).keySet()).contains(location)) {
      return MapSequence.fromMap(NodesTracingFacade.location2AllOriginalNodes).get(location);
    }

    if (file.contains("source_gen") || file.contains("classes_gen") || file.contains("test_gen")) {
      String fileName = NodeUtils.getFileName(file);
      String unitName = NodeUtils.getUnitNameFromPath(file);

      if (list == null || !(filePath.equals(file))) {
        long checksum = 0;
        try {
          checksum = FileUtils.checksumCRC32(new File(file));
        } catch (IOException e) {
          e.printStackTrace();
        }
        if (savedChecksum != checksum) {
          list = ((List<DebugInfo>) new DefaultTraceInfoProvider(repository).debugInfo(unitName.substring(0, unitName.lastIndexOf('.'))).collect(Collectors.toList()));
          filePath = file;
          savedChecksum = checksum;
        }
      }
      for (DebugInfo di : ListSequence.fromList(list)) {
        for (SNodeReference np : di.getTracedNodesForPosition(fileName, line)) {
          SNode resolved = np.resolve(repository);
          if (resolved != null) {
            ListSequence.fromList(originalNodes).addElement(resolved);
          }
        }
      }
    }
    MapSequence.fromMap(NodesTracingFacade.location2AllOriginalNodes).put(location, originalNodes);
    return originalNodes;
  }

  /**
   * finds lines of code in generated file for certain node selected in the editor
   */
  public static List<Integer> findLinesForNode(SNode searchedNode, File file, SRepository repository) {
    List<Integer> list = ListSequence.fromList(new LinkedList<Integer>());
    int linesCount = NodeUtils.getLinesNumber(file);
    for (int line = 0; line < linesCount; line++) {
      List<SNode> nodes = doFindAllPossibleOriginalNodes(file.getAbsolutePath(), line, repository);
      if (ListSequence.fromList(nodes).contains(searchedNode)) {
        ListSequence.fromList(list).addElement(line);
      }
    }
    return list;
  }

  /**
   * Finds lines of code file for certain node selected in the editor
   */
  public static Tuples._2<File, List<Integer>> findLinesForNode(SNode searchedNode, SRepository repository) {
    SModel m = searchedNode.getModel();
    assert m != null;
    IFile loc = SModelOperations.getOutputLocation(m);
    String path = (loc == null ? null : loc.getPath());
    File dir = new File(path);
    return NodesTracingFacade.findLinesForNodeFromPath(dir, searchedNode, repository);
  }

  public static Tuples._2<File, List<Integer>> findLinesForNodeFromPath(File dir, SNode searchedNode, SRepository repository) throws IllegalArgumentException {
    List<Integer> list = ListSequence.fromList(new LinkedList<Integer>());
    Collection<File> allFiles = FileUtils.listFiles(dir, null, false);
    for (File file : CollectionSequence.fromCollection(allFiles)) {
      int linesCount = NodeUtils.getLinesNumber(file);
      for (int line = 0; line < linesCount; line++) {
        List<SNode> nodes = doFindAllPossibleOriginalNodes(file.getAbsolutePath(), line, repository);
        if (ListSequence.fromList(nodes).contains(searchedNode)) {
          ListSequence.fromList(list).addElement(line);
        }
      }
      if (ListSequence.fromList(list).isNotEmpty()) {
        return MultiTuple.<File,List<Integer>>from(file, list);
      }
    }
    return null;
  }

}
