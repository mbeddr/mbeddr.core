package com.mbeddr.mpsutil.dataflow.runtime.plugin;

/*Generated by MPS */

import jetbrains.mps.lang.dataFlow.framework.instructions.Instruction;
import java.util.concurrent.atomic.AtomicLong;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.lang.dataFlow.framework.Program;
import java.util.List;
import jetbrains.mps.lang.dataFlow.framework.ProgramState;
import java.util.ArrayList;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.dataFlow.framework.instructions.RetInstruction;
import jetbrains.mps.lang.dataFlow.framework.instructions.JumpInstruction;
import jetbrains.mps.lang.dataFlow.framework.instructions.EndTryInstruction;
import org.jetbrains.mps.openapi.language.SInterfaceConcept;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import org.jetbrains.mps.openapi.language.SProperty;

public abstract class BaseInstruction extends Instruction implements IInterProcAwareInstruction {

  protected String label;
  protected static final AtomicLong counter = new AtomicLong(0);
  protected long id;

  public BaseInstruction(@NotNull SNode node) {
    this.label = getNodeId(node);
    this.id = counter.incrementAndGet();
  }

  public BaseInstruction(@NotNull String label) {
    this.label = label;
    this.id = counter.incrementAndGet();
  }

  public abstract SNode getNode();

  public static String getNodeId(SNode node, boolean considerNamed) {
    if (considerNamed && SNodeOperations.isInstanceOf(node, CONCEPTS.INamedConcept$Kd)) {
      return SPropertyOperations.getString(SNodeOperations.cast(node, CONCEPTS.INamedConcept$Kd), PROPS.name$MnvL);
    } else if (node == null || node.getNodeId() == null || node.getNodeId().toString() == null) {
      return "null";
    } else {
      return node.getNodeId().toString();
    }
  }

  public static String getNodeId(SNode node) {
    return getNodeId(node, false);
  }

  @Override
  public boolean equals(Object object) {
    if (object == null || object.getClass() != this.getClass()) {
      return false;
    } else if (object == this) {
      return true;
    } else {
      BaseInstruction that = (BaseInstruction) object;
      return this.label != null && that.label != null && this.label.equals(that.label) && this.id == that.id;
    }
  }

  public String getLabel() {
    return this.label;
  }

  @Override
  public int hashCode() {
    int hash = 1;
    hash = hash * 17 + (int) this.id;
    hash = hash * 31 + this.label.hashCode();
    return hash;
  }

  @Override
  public InterProceduralDataFlowGraph getParentProgram() {
    return this.getOwnProgram().getParent();
  }

  @Override
  public InterProceduralDataFlowGraph getRootProgram() {
    return this.getOwnProgram().getRoot();
  }

  @Override
  public InterProceduralDataFlowGraph getOwnProgram() {
    Program program = this.myProgram;
    assert program instanceof InterProceduralDataFlowGraph;
    return ((InterProceduralDataFlowGraph) program);
  }

  @Override
  public Program getProgram() {
    return this.getRootProgram();
  }

  @Override
  public void buildCaches() {
    super.buildCaches();
  }

  @Override
  public Program.TryFinallyInfo getEnclosingBlock() {
    return super.getEnclosingBlock();
  }

  @Override
  public int getIndex() {
    return getProgram().indexOf(this);
  }

  @Override
  public void setIndex(int i) {
    super.setIndex(i);
  }

  public abstract String getShortPresentation();

  public List<ProgramState> getDirectSuccessors(ProgramState state) {
    List<ProgramState> successors = new ArrayList<>();
    for (Instruction successor : ListSequence.fromList(getDirectSuccessors())) {
      successors.add(new ProgramState(successor, state.isReturnMode()));
    }
    return successors;
  }

  public List<Instruction> getDirectSuccessors() {
    List<Instruction> successors = new ArrayList<>();
    InterProceduralDataFlowGraph program = this.getOwnProgram();
    int index = program.indexOfOwn(this);
    Instruction successor = program.getOwnInstructions().get(index + 1);
    successors.add(successor);
    return successors;
  }

  @Override
  public List<ProgramState> pred(ProgramState state) {
    return pred(this, state);
  }

  public static List<ProgramState> pred(Instruction instruction, ProgramState state) {
    List<ProgramState> predecessors = new ArrayList<>();
    Program program = instruction.getProgram();

    if (instruction != program.getStart()) {
      Instruction predecessor = program.get(instruction.getIndex() - 1);
      if (!(predecessor instanceof RetInstruction) && !(predecessor instanceof JumpInstruction) && !(predecessor instanceof FunctionCallInstruction) && !(predecessor instanceof EndTryInstruction && state.isReturnMode())) {
        predecessors.add(new ProgramState(predecessor, state.isReturnMode()));
      }

      if (predecessor instanceof FunctionCallInstruction) {
        FunctionCallInstruction call = ((FunctionCallInstruction) predecessor);
        assert program instanceof InterProceduralDataFlowGraph;
        EntryPointInstruction entry = ((InterProceduralDataFlowGraph) program).getRootCallMap().get(call);
        predecessors.add(new ProgramState(entry.getOwnProgram().getEnd(), state.isReturnMode()));
      }
    }

    for (Instruction jump : instruction.getJumps()) {
      predecessors.add(new ProgramState(jump, state.isReturnMode()));
    }

    return predecessors;
  }

  @Override
  public List<ProgramState> succ(ProgramState state) {
    return succ(this, state);
  }

  public static List<ProgramState> succ(Instruction instruction, ProgramState state) {
    List<ProgramState> result = new ArrayList<ProgramState>();
    Program program = instruction.getProgram();
    result.add(new ProgramState(program.get(instruction.getIndex() + 1), state.isReturnMode()));
    return result;
  }

  private static final class CONCEPTS {
    /*package*/ static final SInterfaceConcept INamedConcept$Kd = MetaAdapterFactory.getInterfaceConcept(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, "jetbrains.mps.lang.core.structure.INamedConcept");
  }

  private static final class PROPS {
    /*package*/ static final SProperty name$MnvL = MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name");
  }
}
