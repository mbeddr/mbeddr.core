package com.mbeddr.mpsutil.dataflow.runtime.plugin;

/*Generated by MPS */

import jetbrains.mps.lang.dataFlow.framework.instructions.EndInstruction;
import jetbrains.mps.lang.dataFlow.framework.instructions.Instruction;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.dataFlow.framework.instructions.RetInstruction;
import java.util.List;
import jetbrains.mps.lang.dataFlow.framework.ProgramState;
import java.util.ArrayList;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import jetbrains.mps.lang.dataFlow.framework.Program;

public class InterProcEndInstruction extends EndInstruction implements IInterProcAwareInstruction {

  public InterProcEndInstruction(String ruleNodeReference) {
    super(ruleNodeReference);
  }

  public InterProcEndInstruction() {
    super();
  }

  @Override
  public void buildCaches() {
    for (Instruction instruction : ListSequence.fromList(getOwnProgram().getOwnInstructions())) {
      if (instruction instanceof RetInstruction) {
        myReturns.add((RetInstruction) instruction);
      }
    }
  }

  @Override
  public List<ProgramState> succ(ProgramState state) {
    List<ProgramState> successors = new ArrayList<>();
    Instruction _start = getOwnProgram().getStart();
    Set<FunctionCallInstruction> calls = null;

    if (_start instanceof EntryPointInstruction) {
      EntryPointInstruction start = (EntryPointInstruction) _start;
      calls = MapSequence.fromMap(getOwnProgram().getRootCallMapReversed()).get(start);
    }

    if (getParentProgram() != null) {
      // inlined
      NestedProgramInstruction trigger = getOwnProgram().getTriggeringInstruction();
      successors.addAll(trigger.getDirectSuccessors(state));
    }

    if (calls != null) {
      // looked up in call chain
      for (FunctionCallInstruction call : SetSequence.fromSet(calls)) {
        successors.addAll(call.getDirectSuccessors(state));
      }
    }

    return successors;
  }

  public String getShortPresentation(Instruction target) {
    Instruction _start = getOwnProgram().getStart();
    Set<FunctionCallInstruction> calls = null;

    if (_start instanceof EntryPointInstruction) {
      EntryPointInstruction start = (EntryPointInstruction) _start;
      calls = MapSequence.fromMap(getOwnProgram().getRootCallMapReversed()).get(start);
    }

    if (getParentProgram() != null) {
      // inlined
      NestedProgramInstruction trigger = getOwnProgram().getTriggeringInstruction();
      for (Instruction successor : ListSequence.fromList(trigger.getDirectSuccessors())) {
        if (successor == target) {
          return trigger.getShortPresentation();
        }
      }
    }

    if (calls != null) {
      // looked up in call chain
      for (FunctionCallInstruction call : SetSequence.fromSet(calls)) {
        for (Instruction successor : ListSequence.fromList(call.getDirectSuccessors())) {
          if (successor == target) {
            return call.getShortPresentation();
          }
        }
      }
    }

    return "";
  }

  @Override
  public List<ProgramState> pred(ProgramState state) {
    // result of Instruction.pred must not be added
    List<ProgramState> predecessors = new ArrayList<>();
    if (state.isReturnMode()) {
      for (RetInstruction ret : myReturns) {
        if (ret.getEnclosingBlock() == null) {
          predecessors.add(new ProgramState(ret, false));
          predecessors.add(new ProgramState(ret, true));
        }
      }
    }

    predecessors.addAll(BaseInstruction.pred(this, state));

    return predecessors;
  }

  @Override
  public String toString() {
    return getIndex() + ": " + super.commandPresentation();
  }

  @Override
  public int getIndex() {
    return getProgram().indexOf(this);
  }

  @Override
  public Program getProgram() {
    return this.getRootProgram();
  }

  @Override
  public InterProceduralDataFlowGraph getOwnProgram() {
    Program program = this.myProgram;
    assert program instanceof InterProceduralDataFlowGraph;
    return ((InterProceduralDataFlowGraph) program);
  }

  @Override
  public InterProceduralDataFlowGraph getParentProgram() {
    return this.getOwnProgram().getParent();
  }

  @Override
  public InterProceduralDataFlowGraph getRootProgram() {
    return this.getOwnProgram().getRoot();
  }
}
