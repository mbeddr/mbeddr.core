package com.mbeddr.mpsutil.dataflow.runtime.plugin;

/*Generated by MPS */

import jetbrains.mps.lang.dataFlow.framework.Program;
import java.util.Map;
import java.util.Set;
import java.util.List;
import jetbrains.mps.lang.dataFlow.framework.instructions.Instruction;
import java.util.ArrayList;
import java.util.HashMap;
import org.jetbrains.mps.openapi.model.SNode;
import java.util.HashSet;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.analyzers.runtime.framework.GeneratedInstruction;
import jetbrains.mps.lang.dataFlow.framework.ProgramState;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.Collections;

public class InterProceduralDataFlowGraph extends Program {

  protected Map<String, EntryPointInstruction> entryPointMap;
  protected Map<FunctionCallInstruction, EntryPointInstruction> callMap;
  protected Map<EntryPointInstruction, Set<FunctionCallInstruction>> callMapReversed;
  protected Map<Object, Map<ProgramPath, InterProceduralDataFlowGraph>> traceMap;
  protected InterProceduralDataFlowGraph parent;
  protected NestedProgramInstruction triggeringInstruction;
  protected Map<Object, Map<ProgramPath, Integer>> pathAwareStartMap;
  protected Map<Object, Map<ProgramPath, Integer>> pathAwareEndMap;

  private ProgramPath programPath;
  private boolean dirty;
  private List<Instruction> allInstructionsCache;
  private Map<Instruction, Integer> allInstructionsMapCache;
  private List<Object> allVariablesCache;

  public InterProceduralDataFlowGraph() {
    this.allInstructionsCache = new ArrayList<>();
    this.allInstructionsMapCache = new HashMap<>();
    this.allVariablesCache = new ArrayList<Object>();
    this.dirty = true;
  }

  public ProgramPath getProgramPath() {
    if (this.programPath == null) {
      this.programPath = ProgramPath.from(this);
    }
    return this.programPath;
  }

  public void markAsDirty() {
    this.dirty = true;
    if (this.parent != null) {
      this.parent.markAsDirty();
    }
  }

  public void markAsClean() {
    this.dirty = false;
  }

  public boolean isDirty() {
    return this.dirty;
  }

  public Set<SNode> getAllEntryPoints() {
    Set<SNode> entryPoints = new HashSet<SNode>();
    for (Instruction instruction : ListSequence.fromList(getAllInstructions())) {
      if (instruction instanceof EntryPointInstruction) {
        entryPoints.add(((EntryPointInstruction) instruction).getNode());
      }
    }

    return entryPoints;
  }

  @Override
  protected void init() {
    add(new InterProcEndInstruction());
    collectVariables();
    buildBlockInfos();
    buildInstructionCaches();
  }

  @Override
  protected void add(Instruction instruction) {
    markAsDirty();
    super.add(demandWrap(instruction));
  }

  protected Instruction demandWrap(Instruction instruction) {
    if (instruction instanceof GeneratedInstruction) {
      GeneratedInstruction wrapped = (GeneratedInstruction) instruction;
      InterProcGeneratedInstruction wrapper = new InterProcGeneratedInstruction(wrapped.commandPresentation());
      wrapper.setRuleReference(wrapped.getRuleReference());
      wrapper.setSource(wrapped.getSource());
      for (int i = 0; i < wrapped.getParameters().size(); i++) {
        wrapper.addParameter(wrapped.getParameter(i));
      }
      return wrapper;
    } else {
      return instruction;
    }
  }

  protected void insert(int index, Instruction instruction) {
    markAsDirty();
    myInstructions.add(index, instruction);
  }

  @Override
  public Instruction get(int index) {
    return getAllInstructions().get(index);
  }

  public Instruction getOwn(int index) {
    return getOwnInstructions().get(index);
  }

  @Override
  public int size() {
    return getAllInstructions().size();
  }

  @Override
  public int indexOf(Instruction instruction) {
    return getAllInstructionsMap().get(instruction);
  }

  public int indexOfOwn(Instruction instruction) {
    return getOwnInstructions().indexOf(instruction);
  }

  @Override
  public Instruction getStart() {
    return getAllInstructions().get(0);
  }

  @Override
  public Instruction getEnd() {
    return getAllInstructions().get(getAllInstructions().size() - 1);
  }

  @Override
  public List<Object> getVariables() {
    return getAllVariables();
  }

  @Override
  public int getVariablesCount() {
    return getAllVariables().size();
  }

  @Override
  public int getVariableIndex(Object var) {
    return getAllVariables().indexOf(var);
  }

  @Override
  public Object getVariable(int index) {
    return getAllVariables().get(index);
  }

  @Override
  public void insert(Instruction instruction, int index, boolean update, boolean before) {
    instruction = demandWrap(instruction);

    if (instruction.getSource() == null) {
      instruction.setSource(getAllInstructions().get(index - 1).getSource());
    }

    // find the actual place of the instruction in the hierarchy
    Instruction successor = getAllInstructions().get(index);
    assert successor instanceof IInterProcAwareInstruction;
    InterProceduralDataFlowGraph owningProgram = ((IInterProcAwareInstruction) successor).getOwnProgram();
    int normalizedIndex = owningProgram.indexOfOwn(successor);
    assert normalizedIndex >= 0;
    instruction.setIndex(normalizedIndex);

    for (Instruction _instruction : getAllInstructions().subList(index, getAllInstructions().size())) {
      _instruction.setIndex(_instruction.getIndex() + 1);
    }
    for (Map<ProgramPath, Integer> outer : getPathAwareEndMap().values()) {
      for (Map.Entry<ProgramPath, Integer> inner : outer.entrySet()) {
        if (inner.getValue() > index) {
          inner.setValue(inner.getValue() + 1);
        }
      }
    }
    for (Map<ProgramPath, Integer> outer : getPathAwareStartMap().values()) {
      for (Map.Entry<ProgramPath, Integer> inner : outer.entrySet()) {
        if (inner.getValue() > index) {
          inner.setValue(inner.getValue() + 1);
        }
      }
    }

    instruction.setProgram(owningProgram);
    owningProgram.insert(normalizedIndex, instruction);

    if (update) {
      updateJumpsOnInsert(index, before);
    }
  }

  @Override
  public boolean contains(Object object) {
    return getPathAwareStartMap().containsKey(object);
  }

  @Override
  public int getStart(Object object) {
    return getPathAwareStart(object).get(getProgramPath());
  }

  public Map<ProgramPath, Integer> getPathAwareStart(Object object) {
    return getPathAwareStartMap().get(object);
  }

  @Override
  public int getEnd(Object object) {
    return getPathAwareEnd(object).get(getProgramPath());
  }

  public Map<ProgramPath, Integer> getPathAwareEnd(Object object) {
    return getPathAwareEndMap().get(object);
  }

  @Override
  protected void start(Object _element) {
    if (_element != null) {
      if (myCreationStack.contains(_element)) {
        throw new RuntimeException("Cycle!");
      }

      myCreationStack.push(_element);
      int position = getRoot().getCurrentPosition();

      Map<ProgramPath, Integer> values = getPathAwareStartMap().get(_element);
      if (values == null) {
        values = new HashMap<ProgramPath, Integer>();
        getPathAwareStartMap().put(_element, values);
      }


      values.put(getProgramPath(), position);
    }
  }

  @Override
  protected void end(Object _element) {
    if (_element != null) {
      if (myCreationStack.isEmpty() || myCreationStack.peek() != _element) {
        throw new RuntimeException("Unexpected end");
      }

      myCreationStack.pop();
      int position = getRoot().getCurrentPosition();

      Map<ProgramPath, Integer> values = getPathAwareEndMap().get(_element);
      if (values == null) {
        values = new HashMap<ProgramPath, Integer>();
        getPathAwareEndMap().put(_element, values);
      }


      values.put(getProgramPath(), position);
    }
  }

  @Override
  protected int getCurrentPosition() {
    return getAllInstructions().size();
  }

  public Object getCurrentSource() {
    return getCurrent();
  }

  @Override
  public List<Instruction> getInstructionsFor(Object object) {
    throw new UnsupportedOperationException("getInstructionsFor is not defined for the context sensitive program!");
  }

  @Override
  public String toString(boolean showSource) {
    StringBuilder result = new StringBuilder();
    for (Instruction instruction : getAllInstructions()) {
      result.append(instruction);
      if (instruction.getSource() != null && showSource) {
        result.append(" ").append(instruction.getSource());
      }
      result.append("\n");
    }
    return result.toString();
  }

  @Override
  public ProgramState getState(int n) {
    return new ProgramState(getAllInstructions().get(n >> 1), (n & 1) == 0);
  }

  @Override
  public List<ProgramState> getStates() {
    List<ProgramState> result = new ArrayList<>();
    for (Instruction i : getAllInstructions()) {
      result.add(new ProgramState(i, true));
      result.add(new ProgramState(i, false));
    }
    return result;
  }

  public void setTriggeringInstruction(NestedProgramInstruction instruction) {
    this.triggeringInstruction = instruction;
  }

  public NestedProgramInstruction getTriggeringInstruction() {
    return this.triggeringInstruction;
  }

  public InterProceduralDataFlowGraph getTrace(Object context, ProgramPath path) {
    if (getTraceMap().containsKey(context)) {
      return getTraceMap().get(context).get(path);
    }
    return null;
  }

  protected Map<Object, Map<ProgramPath, InterProceduralDataFlowGraph>> getTraceMap() {
    InterProceduralDataFlowGraph root = getRoot();
    if (root.traceMap == null) {
      root.traceMap = new HashMap<Object, Map<ProgramPath, InterProceduralDataFlowGraph>>();
    }
    return root.traceMap;
  }

  protected Map<Object, Map<ProgramPath, Integer>> getPathAwareStartMap() {
    InterProceduralDataFlowGraph root = getRoot();
    if (root.pathAwareStartMap == null) {
      root.pathAwareStartMap = new HashMap<Object, Map<ProgramPath, Integer>>();
    }
    return root.pathAwareStartMap;
  }

  protected Map<Object, Map<ProgramPath, Integer>> getPathAwareEndMap() {
    InterProceduralDataFlowGraph root = getRoot();
    if (root.pathAwareEndMap == null) {
      root.pathAwareEndMap = new HashMap<Object, Map<ProgramPath, Integer>>();
    }
    return root.pathAwareEndMap;
  }

  protected Map<String, EntryPointInstruction> getEntryPointMap() {
    if (this.entryPointMap == null) {
      this.entryPointMap = new HashMap<String, EntryPointInstruction>();
    }
    return this.entryPointMap;
  }

  protected Map<FunctionCallInstruction, EntryPointInstruction> getRootCallMap() {
    InterProceduralDataFlowGraph root = getRoot();
    if (root.callMap == null) {
      root.callMap = new HashMap<FunctionCallInstruction, EntryPointInstruction>();
    }
    return root.callMap;
  }

  protected Map<EntryPointInstruction, Set<FunctionCallInstruction>> getRootCallMapReversed() {
    InterProceduralDataFlowGraph root = getRoot();
    if (root.callMapReversed == null) {
      root.callMapReversed = new HashMap<EntryPointInstruction, Set<FunctionCallInstruction>>();
    }
    return root.callMapReversed;
  }

  public InterProceduralDataFlowGraph setParent(InterProceduralDataFlowGraph parent) {
    return this.parent = parent;
  }

  public InterProceduralDataFlowGraph getParent() {
    return this.parent;
  }

  public InterProceduralDataFlowGraph getRoot() {
    if (this.parent != null) {
      return this.parent.getRoot();
    } else {
      return this;
    }
  }

  public void addEntryPoint(String label, EntryPointInstruction instruction) {
    if (getEntryPointMap().containsKey(label)) {
      throw new IllegalArgumentException("Entry point is already registered!");
    } else {
      MapSequence.fromMap(getEntryPointMap()).put(label, instruction);
    }
  }

  public void addTraceInformation(SNode node, InterProceduralDataFlowGraph program) {
    addTraceInformation(node, getProgramPath(), program);
  }

  public void addTraceInformation(Object context, ProgramPath path, InterProceduralDataFlowGraph program) {
    Map<ProgramPath, InterProceduralDataFlowGraph> pathMap = getTraceMap().get(context);
    if (pathMap != null && pathMap.containsKey(path)) {
      throw new IllegalArgumentException("Trace is already registered for " + context + " under " + path + "!");
    } else {
      if (pathMap == null) {
        pathMap = new HashMap<ProgramPath, InterProceduralDataFlowGraph>();
        getTraceMap().put(context, pathMap);
      }
      pathMap.put(path, program);
    }
  }

  public void addFunctionCall(FunctionCallInstruction source, EntryPointInstruction target) {
    if (this.getRootCallMap().containsKey(source)) {
      throw new IllegalArgumentException("Function call is already registered!");
    } else {
      MapSequence.fromMap(this.getRootCallMap()).put(source, target);
    }
    Set<FunctionCallInstruction> values = MapSequence.fromMap(this.getRootCallMapReversed()).get(target);
    if (values == null) {
      values = SetSequence.fromSet(new HashSet<FunctionCallInstruction>());
      MapSequence.fromMap(this.getRootCallMapReversed()).put(target, values);
    }
    SetSequence.fromSet(values).addElement(source);
  }

  public EntryPointInstruction getEntryPoint(SNode node) {
    if ((node.getNodeId() != null) && (node.getNodeId().toString() != null)) {
      return getEntryPoint(node.getNodeId().toString());
    } else {
      return null;
    }
  }

  public EntryPointInstruction getEntryPoint(String label) {
    InterProceduralDataFlowGraph current = this;
    while (current != null) {
      EntryPointInstruction instruction = MapSequence.fromMap(current.getEntryPointMap()).get(label);
      if (instruction != null) {
        return instruction;
      } else {
        current = current.getParent();
      }
    }
    return null;
  }

  @Override
  public List<Instruction> getInstructions() {
    return getAllInstructions();
  }

  protected Map<Instruction, Integer> getAllInstructionsMap() {
    initializeCaches();
    return allInstructionsMapCache;
  }

  protected List<Instruction> getAllInstructions() {
    initializeCaches();
    return allInstructionsCache;
  }

  protected List<Object> getAllVariables() {
    initializeCaches();
    return allVariablesCache;
  }

  protected void initializeCaches() {
    if (isDirty()) {
      allInstructionsCache.clear();
      for (Instruction instruction : ListSequence.fromList(getOwnInstructions())) {
        allInstructionsCache.add(instruction);
        if (instruction instanceof NestedProgramInstruction) {
          InterProceduralDataFlowGraph current = ((NestedProgramInstruction) instruction).getNestedProgram();
          if (current != null) {
            allInstructionsCache.addAll(current.getAllInstructions());
          }
        }
      }

      allInstructionsMapCache.clear();
      for (int index = 0; index < allInstructionsCache.size(); index++) {
        if (allInstructionsMapCache.containsKey(allInstructionsCache.get(index))) {
          throw new RuntimeException("Collision in instructions map! Default equals/hashCode implementation is not sufficient in Instruction class!");
        }
        allInstructionsMapCache.put(allInstructionsCache.get(index), index);
      }

      allVariablesCache.clear();
      allVariablesCache.addAll(getOwnVariables());
      for (Instruction instruction : ListSequence.fromList(getOwnInstructions())) {
        if (instruction instanceof NestedProgramInstruction) {
          InterProceduralDataFlowGraph current = ((NestedProgramInstruction) instruction).getNestedProgram();
          if (current != null) {
            allVariablesCache.addAll(current.getAllVariables());
          }
        }
      }

      markAsClean();
    }
  }

  protected List<Instruction> getOwnInstructions() {
    return Collections.unmodifiableList(myInstructions);
  }

  @Override
  protected void collectVariables() {
    super.collectVariables();
  }

  protected List<Object> getOwnVariables() {
    collectVariables();
    return Collections.<Object>unmodifiableList(myVariables);
  }

  @Override
  public void sanityCheck() {
    for (Instruction i : getAllInstructions()) {
      sanityCheck(new ProgramState(i, true));
      sanityCheck(new ProgramState(i, false));
    }
  }

  @Override
  protected void sanityCheck(ProgramState state) {
    List<ProgramState> predecessors = state.pred();
    for (ProgramState predecessor : predecessors) {
      List<ProgramState> _successors = predecessor.succ();
      if (!(_successors.contains(state))) {
        System.out.println("Mismatch during sanity check!");
        System.out.println("\tstate: " + state);
        System.out.println("\tits predecessors: " + predecessors);
        System.out.println("\tpredecessor: " + predecessor);
        System.out.println("\tits successors: " + _successors);
      }
    }

    List<ProgramState> successors = state.succ();
    for (ProgramState successor : successors) {
      List<ProgramState> _predecessors = successor.pred();
      if (!(_predecessors.contains(state))) {
        System.out.println("Mismatch during sanity check!");
        System.out.println("\tstate: " + state);
        System.out.println("\tits successors: " + successors);
        System.out.println("\tsuccessor: " + successor);
        System.out.println("\tits predecessors: " + _predecessors);
      }
    }
  }

  @Override
  public Program copy() {
    InterProceduralDataFlowGraph program = new InterProceduralDataFlowGraph();
    for (Instruction instruction : ListSequence.fromList(getAllInstructions())) {
      program.add(instruction);
    }
    return program;
  }

}
