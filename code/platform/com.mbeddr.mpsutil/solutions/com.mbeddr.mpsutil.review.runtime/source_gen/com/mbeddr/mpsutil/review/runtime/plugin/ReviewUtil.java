package com.mbeddr.mpsutil.review.runtime.plugin;

/*Generated by MPS */

import jetbrains.mps.openapi.editor.cells.EditorCell;
import jetbrains.mps.nodeEditor.EditorComponent;
import java.util.List;
import jetbrains.mps.openapi.editor.cells.CellTraversalUtil;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.editor.runtime.selection.SelectionUtil;
import jetbrains.mps.openapi.editor.selection.SelectionManager;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.Objects;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.internal.collections.runtime.Sequence;
import org.jetbrains.mps.openapi.language.SConcept;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import org.jetbrains.mps.openapi.language.SReferenceLink;
import org.jetbrains.mps.openapi.language.SProperty;

public class ReviewUtil {
  public static EditorCell findCommonParent(EditorComponent editorComponent) {
    List<EditorCell> selectedNodes = editorComponent.getSelectionManager().getSelection().getSelectedCells();
    EditorCell result = CellTraversalUtil.getCommonParent(selectedNodes.get(0), selectedNodes.get(selectedNodes.size() - 1));

    return result;
  }

  public static SNode getReview(EditorComponent editorComponent) {
    EditorCell rootCell = editorComponent.getRootCell();

    SNode rootNode = rootCell.getSNode();

    if (!(SNodeOperations.isInstanceOf(rootNode, CONCEPTS.Review$yq))) {
      throw new IllegalStateException("trying to find review root outside of review");
    }

    SNode result = ((SNode) rootNode);

    return result;
  }

  public static void selectReviewNote(SNode reviewNote, EditorComponent editorComponent) {
    SelectionUtil.selectCell(editorComponent.getEditorContext(), reviewNote, SelectionManager.FIRST_EDITABLE_CELL);
    editorComponent.scrollToNode(reviewNote);
  }

  public static boolean isApplicable(EditorComponent editorComponent) {
    try {
      SNode rootNode = ((SNode) editorComponent.getRootCell().getSNode());
      boolean result = SNodeOperations.isInstanceOf(rootNode, CONCEPTS.CommentAnnotationContainer$3o) || (getReview(editorComponent) != null);
      return result;
    } catch (IllegalStateException e) {
      return false;
    }
  }

  public static boolean isReviewable(EditorComponent editorComponent, SNode node) {
    return isApplicable(editorComponent) && ((node == null) || (SNodeOperations.getNodeAncestor(node, CONCEPTS.ReviewNote$Wo, true, false) == null));
  }

  public static boolean hasReview(EditorComponent editorComponent, SNode node) {
    if ((node == null)) {
      return false;
    }
    return (findReviewNote(editorComponent, node) != null);
  }

  public static boolean hasReviewRecursive(EditorComponent editorComponent, SNode node) {
    if ((node == null)) {
      return false;
    }
    return (findReviewNoteRecursive(editorComponent, node) != null);
  }

  public static List<SNode> getReviewNotes(EditorComponent editorComponent) {
    SNode rootNode = editorComponent.getRootCell().getSNode();
    if (SNodeOperations.isInstanceOf(rootNode, CONCEPTS.CommentAnnotationContainer$3o)) {
      return SLinkOperations.getChildren(((SNode) rootNode), LINKS.comments$KPYX);
    } else {
      return SLinkOperations.getChildren(getReview(editorComponent), LINKS.notes$Cawq);
    }
  }

  public static SNode getCommentAnnotationContainer(EditorComponent editorComponent) {
    SNode rootNode = editorComponent.getRootCell().getSNode();
    if (SNodeOperations.isInstanceOf(rootNode, CONCEPTS.CommentAnnotationContainer$3o)) {
      return SNodeOperations.cast(rootNode, CONCEPTS.CommentAnnotationContainer$3o);
    } else {
      return null;
    }
  }


  public static SNode findReviewNoteRecursive(final EditorComponent editorComponent, SNode node) {
    List<SNode> notes = getReviewNotes(editorComponent);
    for (final SNode n : ListSequence.fromList(SNodeOperations.getNodeAncestors(node, null, true))) {
      final EditorCell selection = findCommonParent(editorComponent);
      SNode result = ListSequence.fromList(notes).findLast((it) -> Objects.equals(SLinkOperations.getTarget(it, LINKS.attachedNode$Bgt0), n) && CellTraversalUtil.isAncestorOrEquals(editorComponent.findCellWithId(n, SPropertyOperations.getString(it, PROPS.attachedCellId$G9fZ)), selection));
      if ((result != null)) {
        return result;
      }
    }

    return null;
  }

  public static SNode findReviewNote(EditorComponent editorComponent, final SNode node) {
    final String selectionCellId = findCommonParent(editorComponent).getCellId();
    return ListSequence.fromList(getReviewNotes(editorComponent)).findFirst((it) -> Objects.equals(SLinkOperations.getTarget(it, LINKS.attachedNode$Bgt0), node) && Objects.equals(SPropertyOperations.getString(it, PROPS.attachedCellId$G9fZ), selectionCellId));
  }

  public static void deleteReviewNote(final EditorComponent editorComponent, final SNode node) {
    Sequence.fromIterable(SNodeOperations.ofConcept(getReviewNotes(editorComponent), CONCEPTS.ReviewReplyNote$Ue)).visitAll((it) -> {
      if (Objects.equals(SLinkOperations.getTarget(it, LINKS.repliedNote$u_0w), node)) {
        deleteReviewNote(editorComponent, it);
      }
    });
    SNodeOperations.deleteNode(node);
    // if this was the last note, then we delete the commenting container as well
    if (ListSequence.fromList(getReviewNotes(editorComponent)).isEmpty() && (getCommentAnnotationContainer(editorComponent) != null)) {
      SNodeOperations.deleteNode(getCommentAnnotationContainer(editorComponent));
    }
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept Review$yq = MetaAdapterFactory.getConcept(0x97f9a38a5b194147L, 0x9eace1a8cab31065L, 0x7556ef16fac69217L, "com.mbeddr.mpsutil.review.readonly.structure.Review");
    /*package*/ static final SConcept CommentAnnotationContainer$3o = MetaAdapterFactory.getConcept(0x7a060fae09e04372L, 0xbe366696d6554c0eL, 0x7556ef16fac6bfb4L, "com.mbeddr.mpsutil.review.annotation.structure.CommentAnnotationContainer");
    /*package*/ static final SConcept ReviewNote$Wo = MetaAdapterFactory.getConcept(0xc788b04620194656L, 0x8b608bb9bbb177b5L, 0x1017edaecf8ecafbL, "com.mbeddr.mpsutil.review.structure.ReviewNote");
    /*package*/ static final SConcept ReviewReplyNote$Ue = MetaAdapterFactory.getConcept(0xc788b04620194656L, 0x8b608bb9bbb177b5L, 0x1017edaecf8efc59L, "com.mbeddr.mpsutil.review.structure.ReviewReplyNote");
  }

  private static final class LINKS {
    /*package*/ static final SContainmentLink comments$KPYX = MetaAdapterFactory.getContainmentLink(0x7a060fae09e04372L, 0xbe366696d6554c0eL, 0x7556ef16fac6bfb4L, 0x7556ef16fac6bfb5L, "comments");
    /*package*/ static final SContainmentLink notes$Cawq = MetaAdapterFactory.getContainmentLink(0x97f9a38a5b194147L, 0x9eace1a8cab31065L, 0x7556ef16fac69217L, 0x7556ef16fac69219L, "notes");
    /*package*/ static final SReferenceLink attachedNode$Bgt0 = MetaAdapterFactory.getReferenceLink(0x92f195b6a2094804L, 0xad65f5248ecd5873L, 0x1017edaecf766251L, 0x6f909de0265512a1L, "attachedNode");
    /*package*/ static final SReferenceLink repliedNote$u_0w = MetaAdapterFactory.getReferenceLink(0xc788b04620194656L, 0x8b608bb9bbb177b5L, 0x1017edaecf8efc59L, 0x1017edaecf8efc5aL, "repliedNote");
  }

  private static final class PROPS {
    /*package*/ static final SProperty attachedCellId$G9fZ = MetaAdapterFactory.getProperty(0x92f195b6a2094804L, 0xad65f5248ecd5873L, 0x1017edaecf766251L, 0x6f909de0265473f1L, "attachedCellId");
  }
}
