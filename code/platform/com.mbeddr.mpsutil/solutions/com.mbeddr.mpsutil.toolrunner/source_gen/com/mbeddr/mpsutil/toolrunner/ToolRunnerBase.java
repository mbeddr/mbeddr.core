package com.mbeddr.mpsutil.toolrunner;

/*Generated by MPS */

import com.intellij.openapi.progress.ProgressIndicator;
import java.io.File;
import org.apache.commons.lang3.StringUtils;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.io.IOException;
import org.apache.commons.lang3.SystemUtils;
import java.util.LinkedList;
import java.io.InputStream;
import java.util.ArrayList;
import java.io.BufferedInputStream;
import java.io.InputStreamReader;
import java.io.BufferedReader;

/**
 * Base class for running external tools.
 */
public class ToolRunnerBase implements ToolRunner {

  /**
   * Should we write debug infos?
   */
  public static final boolean DEBUG = true;

  /**
   * Should we write the raw output?
   */
  public static final boolean DEBUG_RAW_OUTPUT = false;

  /**
   * Constant representing timeout that should be ignored.
   */
  public static final int IGNORE_TIMEOUT = -1;

  /**
   * The name of the binary of the program that will be started.
   */
  private String toolBinaryName;

  /**
   * The timeout in seconds.
   */
  protected int timeoutInSeconds = IGNORE_TIMEOUT;

  /**
   * Progress indicator that tells when the user cancels the task.
   */
  protected ProgressIndicator progress;

  /**
   * Has the external process finished?
   */
  private boolean externalProcessFinished;

  /**
   * {@inheritDoc}
   */
  @Override
  public ToolRunner.ToolRunResult runTool(Iterable<String> files, String toolBinaryName, Iterable<String> args) {
    return runTool(files, toolBinaryName, args, null);
  }

  /**
   * {@inheritDoc}
   */
  @Override
  public ToolRunner.ToolRunResult runTool(Iterable<String> files, String toolName, Iterable<String> args, File dir) {
    String ranCommand = StringUtils.join(buildCmdArray(files, toolName, args), " ");
    try {
      if (progress.isCanceled()) {
        ToolRunner.ToolRunResult res = new ToolRunner.ToolRunResult(ranCommand);
        res.canceled = true;
        return res;
      }
      this.toolBinaryName = toolName;

      long startingTimeInMillis = System.currentTimeMillis();

      externalProcessFinished = false;
      Process toolProcess = doRunToolWithArgs(files, toolName, args, dir);

      StreamReaderThread outputReaderThread = createStreamReaderThread(toolProcess.getInputStream());
      StreamReaderThread errorReaderThread = createStreamReaderThread(toolProcess.getErrorStream());
      CancelWatcherThread cancelWatcherThread = new CancelWatcherThread(timeoutInSeconds);

      outputReaderThread.start();
      errorReaderThread.start();
      cancelWatcherThread.start();

      int exitCode = toolProcess.waitFor();
      externalProcessFinished = true;

      outputReaderThread.join();
      errorReaderThread.join();

      long delay = System.currentTimeMillis() - startingTimeInMillis;
      ToolRunnerBase.debug("Delay: " + delay + "ms");

      List<String> output = outputReaderThread.getReadLines();
      List<String> error = errorReaderThread.getReadLines();

      if (DEBUG_RAW_OUTPUT) {
        System.err.println();
        System.err.println(">>>>>>------------ ToolRunnerBase ---------------- OUTPUT -------");
        ListSequence.fromList(output).visitAll((it) -> System.err.println(it));
        System.err.println("--------------<<<<<<<<");
        System.err.println(">>>>>>------------ ToolRunnerBase ---------------- ERROR -------");
        ListSequence.fromList(error).visitAll((it) -> System.err.println(it));
        System.err.println("---------------<<<<<<<");
      }

      boolean wasTimeout = cancelWatcherThread.timeout();
      boolean wasCanceled = progress.isCanceled();
      return new ToolRunner.ToolRunResult(ranCommand, output, error, delay, wasTimeout, wasCanceled, exitCode);
    } catch (Exception e) {
      e.printStackTrace();
      ToolRunner.ToolRunResult result = new ToolRunner.ToolRunResult(ranCommand);
      result.runtimeError = true;
      result.exception = e;
      return result;
    }
  }

  /**
   * Runs the external program with certain arguments, on a set of files and in a certain directory.
   */
  private Process doRunToolWithArgs(Iterable<String> files, String toolBinaryName, Iterable<String> args, File dir) throws IOException {
    String timeoutInfo = (timeoutInSeconds == IGNORE_TIMEOUT ? ": " : "(timeout " + timeoutInSeconds + "s): ");
    List<String> cmdArray = buildCmdArray(files, toolBinaryName, args);

    String cmdString = StringUtils.join(cmdArray, " ");
    ToolRunnerBase.debug("Running" + timeoutInfo + cmdString);
    if (dir != null) {
      ToolRunnerBase.debug("Directory: " + dir);
    }

    ProcessBuilder procBuilder = new ProcessBuilder(cmdArray);
    procBuilder.directory(dir);
    return procBuilder.start();
  }

  /**
   * Returns a list with the strings which when concatenated represent the command to be run.
   */
  protected List<String> buildCmdArray(Iterable<String> files, String toolBinaryName, Iterable<String> args) {

    String programName = toolBinaryName;
    if (SystemUtils.IS_OS_WINDOWS && !(programName.endsWith(".exe")) && !(programName.endsWith(".bat"))) {
      programName += ".exe";
    }

    List<String> cmdArray = ListSequence.fromList(new LinkedList<String>());
    ListSequence.fromList(cmdArray).addElement(programName);
    for (String a : args) {
      if (isNotEmptyString(((a == null ? null : a.trim())))) {
        ListSequence.fromList(cmdArray).addElement(((a == null ? null : a.trim())));
      }
    }
    for (String f : files) {
      ListSequence.fromList(cmdArray).addElement(((f == null ? null : f.trim())));
    }

    return cmdArray;
  }

  /**
   * Kills the external process.
   */
  /*package*/ void doKillExternalProcesses() throws IOException {
    String runProgramName;
    File f = new File(toolBinaryName);
    if (f.exists()) {
      // the tool binary name contains also the path
      runProgramName = f.getName();
    } else {
      // the tool binary name does not contain the path, it may or may not contain the extension
      runProgramName = toolBinaryName;
      if (SystemUtils.IS_OS_WINDOWS && !(toolBinaryName.endsWith(".exe")) && !(toolBinaryName.endsWith(".bat"))) {
        runProgramName = toolBinaryName + ".exe";
      }
    }
    String killCommand = (SystemUtils.IS_OS_WINDOWS ? "taskkill /F /IM " + runProgramName : "killall -9 " + runProgramName);
    ToolRunnerBase.debug("Kill command: " + killCommand);
    Runtime.getRuntime().exec(killCommand);
  }

  /**
   * Factory method for stream reader.
   */
  protected StreamReaderThread createStreamReaderThread(InputStream is) {
    return new StreamReaderThread(is);
  }

  /**
   * Debug.
   */
  private static void debug(String s) {
    if (DEBUG) {
      System.out.println("{" + ToolRunnerBase.class.getSimpleName() + "} " + s);
    }
  }

  /**
   * Thread to read the output and error streams of a process.
   */
  protected class StreamReaderThread extends Thread {

    /**
     * The input stream to be read.
     */
    protected InputStream inputStream;

    /**
     * Read lines.
     */
    protected List<String> result = ListSequence.fromList(new ArrayList<String>(10000));

    /**
     * Exception that is thrown while reading.
     */
    protected IOException thrownException;

    /**
     * Constructor.
     */
    public StreamReaderThread(InputStream is) {
      inputStream = is;
    }

    /**
     * {@inheritDoc}
     */
    public void run() {
      try {
        BufferedInputStream bis = new BufferedInputStream(inputStream, 65536);
        InputStreamReader isr = new InputStreamReader(bis);
        BufferedReader br = new BufferedReader(isr, 65536);
        String line;
        while ((line = br.readLine()) != null) {
          ListSequence.fromList(result).addElement(line);
        }
        isr.close();
      } catch (IOException ioe) {
        ioe.printStackTrace();
        thrownException = ioe;
      }
    }

    /**
     * Returns the read lines.
     */
    protected List<String> getReadLines() throws IOException {
      if (thrownException != null) {
        throw thrownException;
      }
      return result;
    }
  }

  /**
   * Constant representing timeout that should be ignored.
   */
  public static final int IGNORE_TIMEOUT_MILLISECONDS = IGNORE_TIMEOUT * 1000;

  /**
   * A thread that monitors the cancel of the users. If cancel is pressed, then the external process is killed.
   */
  private class CancelWatcherThread extends Thread {

    /**
     * How many milliseconds elapsed so far.
     */
    private int elapsedMilliSeconds;

    /**
     * Timeout in milliseconds for this process
     */
    private int timeoutInMilliseconds;

    /**
     * Constructor
     */
    public CancelWatcherThread(int timeoutInSeconds) {
      this.timeoutInMilliseconds = timeoutInSeconds * 1000;
    }

    /**
     * {@inheritDoc}
     */
    public void run() {
      elapsedMilliSeconds = 0;
      try {
        while (!(progress.isCanceled()) && !(externalProcessFinished) && !(timeout())) {
          Thread.sleep(100);
          elapsedMilliSeconds += 100;
        }
        if (progress.isCanceled() || timeout()) {
          doKillExternalProcesses();
        }
      } catch (Exception e) {
        e.printStackTrace();
      }
    }

    /**
     * Returns true if the elapsed time is too big and if we should case about timeouts.
     */
    private boolean timeout() {
      return timeoutInMilliseconds != IGNORE_TIMEOUT_MILLISECONDS && elapsedMilliSeconds >= timeoutInMilliseconds;
    }
  }

  /**
   * Sets the timeout in seconds.
   */
  public void setTimeout(int timeoutInSeconds) {
    this.timeoutInSeconds = timeoutInSeconds;
  }

  /**
   * Returns the timeout in seconds.
   */
  public int getTimeout() {
    return this.timeoutInSeconds;
  }

  /**
   * Returns the progress indicator used by this runner.
   */
  public ProgressIndicator getProgress() {
    return progress;
  }

  /**
   * Sets the progress indicator (used for getting the cancel from users).
   */
  public void setProgress(ProgressIndicator progress) {
    this.progress = progress;
  }

  private static boolean isNotEmptyString(String str) {
    return str != null && str.length() > 0;
  }
}
