package com.mbeddr.mpsutil.common.util;

/*Generated by MPS */

import java.util.function.Supplier;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;

/**
 * Supplier which memorizes its value after first call to get(), but is able to
 * trigger a re-computation of the expensive computation if some cheap computation
 * returns a different value.
 * 
 * The implementation is very efficient as it does not need null-checks.
 * 
 * Typical usage: Expensive computation collects some data, and the cheap computation 
 * computes a hashcode based on this data. If a different hashcode is computed later,
 * the expensive data collection has to be executed again.
 * 
 * NOTE: This class is not thread-safe.
 * 
 * @param <T> generic type of supplied value (e.g., a hashcode type like Integer)
 * @param <M> result type for the expensive computation
 */
public class LazyInitWithCheck<T, M> implements Supplier<T> {

  /**
   * Static factory method to construct the memorizing, re-executable supplier
   * 
   * @param expensive the expensive computation
   * @param cheap the additional, cheap computation
   * @param <T> generic type of supplied value (e.g., a hashcode type like Integer)
   * @param <M> result type for the expensive computation
   * @return the memorizing, re-executable supplier
   */
  public static <T, M> Supplier<T> lazy(final _FunctionTypes._return_P0_E0<? extends M> expensive, _FunctionTypes._return_P1_E0<? extends T, ? super M> cheap) {
    return new LazyInitWithCheck<T, M>(expensive, cheap);
  }

  private _FunctionTypes._return_P0_E0<? extends T> innerSupplier;

  private LazyInitWithCheck(_FunctionTypes._return_P0_E0<? extends M> expensive, _FunctionTypes._return_P1_E0<? extends T, ? super M> cheap) {
    this.innerSupplier = inner(expensive, cheap);
  }

  private _FunctionTypes._return_P0_E0<? extends T> inner(final _FunctionTypes._return_P0_E0<? extends M> expensive, final _FunctionTypes._return_P1_E0<? extends T, ? super M> cheap) {
    return () -> {
      // execute expensive code and based on its result also the cheap check
      final M m = expensive.invoke();
      final T t = cheap.invoke(m);
      innerSupplier = () -> {
        if (cheap.invoke(m).equals(t)) {
          return t;
        }
        innerSupplier = inner(expensive, cheap);
        return innerSupplier.invoke();
      };
      return t;
    };
  }

  @Override
  public T get() {
    return innerSupplier.invoke();
  }
}
