package com.mbeddr.mpsutil.common.util;

/*Generated by MPS */

import com.intellij.openapi.application.ex.ApplicationEx;
import org.jetbrains.annotations.NotNull;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.progress.ProgressManager;
import com.intellij.openapi.progress.EmptyProgressIndicator;
import com.intellij.openapi.progress.ProcessCanceledException;
import com.intellij.openapi.progress.util.ProgressWindow;
import java.util.concurrent.atomic.AtomicBoolean;
import javax.swing.SwingUtilities;

public class ApplicationHelper {

  public static void runWithProgressAsync(final ApplicationEx app, @NotNull final Runnable process, @NotNull String titel, boolean canBeCanceled, Project project) {
    app.assertIsDispatchThread();
    if (app.isUnitTestMode() || app.isHeadlessEnvironment()) {
      try {
        ProgressManager.getInstance().runProcess(process, new EmptyProgressIndicator());
      } catch (ProcessCanceledException e) {
        // ok to ignore.
      }
      return;
    }
    final ProgressWindow progress = new ProgressWindow(canBeCanceled, false, project, null, null);
    // in case of abrupt application exit when 'ProgressManager.getInstance().runProcess(process, progress)' below
    // does not have a chance to run, and as a result the progress won't be disposed
    progress.setTitle(titel);
    try {
      final AtomicBoolean threadStarted = new AtomicBoolean();
      // noinspection SSBasedInspection
      SwingUtilities.invokeLater(new Runnable() {
        @Override
        public void run() {
          app.executeOnPooledThread(new Runnable() {
            @Override
            public void run() {
              try {
                ProgressManager.getInstance().runProcess(process, progress);
              } catch (ProcessCanceledException e) {
                progress.cancel();
                // ok to ignore.
              } catch (RuntimeException e) {
                progress.cancel();
                throw e;
              } finally {
              }
            }
          });
          threadStarted.set(true);
        }
      });
      progress.start();
    } finally {
    }
  }

}
