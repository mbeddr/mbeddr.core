package com.mbeddr.mpsutil.common.graph;

/*Generated by MPS */

import java.util.Set;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import java.util.Queue;
import jetbrains.mps.internal.collections.runtime.QueueSequence;
import java.util.LinkedList;
import java.util.Map;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import java.util.List;
import java.util.Deque;
import jetbrains.mps.internal.collections.runtime.DequeSequence;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import java.util.LinkedHashSet;
import java.util.Collections;

public class GraphUtil {

  /**
   * Computes the strongly connected components of the given graph.
   * 
   * @param graph the graph
   * @param <T> the type paramter of the nodes in the graph
   * @return the SCCs as sets of set of nodes
   */
  public static <T> Set<Set<T>> computeSCC(Graph<T> graph) {
    return computeSCC0(null, graph);
  }

  /**
   * Determines whether the given directed graph corresponds to a connected graph, 
   * i.e. all graph nodes are reachable from the initial node, using a BFS. 
   * 
   * @param graph the directed graph containing nodes of type T
   * @param initial the node of type T the algorithm starts from
   * @param <T> the type paramter of the nodes in the graph
   * @return true, if graph has no nodes, otherwise a boolean-value stating whether the graph is connected
   */
  public static <T> boolean isConnected(Graph<T> graph, T initial) {
    Set<T> allNodes = graph.getAllNodes();

    if (SetSequence.fromSet(allNodes).isEmpty()) {
      return true;
    }

    if (!(SetSequence.fromSet(allNodes).contains(initial))) {
      return false;
    }

    Set<T> visited = SetSequence.fromSet(new HashSet<T>());
    Queue<T> toVisit = QueueSequence.fromQueue(new LinkedList<T>());
    QueueSequence.fromQueue(toVisit).addLastElement(initial);

    while (!(QueueSequence.fromQueue(toVisit).isEmpty())) {
      T currentNode = QueueSequence.fromQueue(toVisit).removeFirstElement();
      SetSequence.fromSet(visited).addElement(currentNode);

      for (T target : graph.getTargets(currentNode)) {
        if (!(SetSequence.fromSet(visited).contains(target))) {
          QueueSequence.fromQueue(toVisit).addLastElement(target);
        }
      }
    }

    return SetSequence.fromSet(visited).count() == SetSequence.fromSet(allNodes).count();
  }

  /**
   * Returns the set of nodes in the strongly connected component that the sought node is in. 
   * 
   * @param sought the sought node
   * @param graph the graph
   * @param <T> the type parameter of the nodes in the graph
   * @return the SCC of the sought node
   */
  public static <T> Set<T> computeSCCSingle(T sought, Graph<T> graph) {
    Set<Set<T>> sccs = computeSCC0(sought, graph);
    assert SetSequence.fromSet(sccs).count() == 1 && SetSequence.fromSet(SetSequence.fromSet(sccs).first()).contains(sought);
    return SetSequence.fromSet(sccs).first();
  }

  private static <T> Set<Set<T>> computeSCC0(final T sought, Graph<T> graph) {
    int index = 0;
    Set<Set<T>> result = SetSequence.fromSet(new HashSet<Set<T>>());
    Map<T, SCCProperty> nodeMap = MapSequence.fromMap(new HashMap<T, SCCProperty>());
    Map<T, List<T>> targetNodeMap = MapSequence.fromMap(new HashMap<T, List<T>>());
    Map<T, Set<T>> notVisitedMap = MapSequence.fromMap(new HashMap<T, Set<T>>());

    // the nodeStack will be used to keep track of the nodes, instead of using recursive calls
    Deque<T> nodeStack = DequeSequence.fromDeque(new LinkedList<T>());
    // the scc stack stores the nodes which will be committed to an SCC (there can be nodes from multiple SCCs
    // in the stack at the same time)
    Deque<T> sccStack = DequeSequence.fromDeque(new LinkedList<T>());

    boolean sink = false;
    boolean finishedTraversal = true;

    // add the sought node to the very beginning of the list if it is not null
    List<T> allNodes = ListSequence.fromList(new ArrayList<T>());
    if (sought != null) {
      ListSequence.fromList(allNodes).addElement(sought);
    }
    ListSequence.fromList(allNodes).addSequence(SetSequence.fromSet(graph.getAllNodes()).where((it) -> it != sought));

    for (T node : ListSequence.fromList(allNodes)) {
      MapSequence.fromMap(nodeMap).put(node, new SCCProperty(0, 0));
    }

    for (T node : ListSequence.fromList(allNodes)) {
      // if we haven't already visited the node
      if (MapSequence.fromMap(nodeMap).get(node).index == 0) {
        DequeSequence.fromDequeNew(nodeStack).pushElement(node);

        // perform the DFS like traversal
        while (DequeSequence.fromDequeNew(nodeStack).isNotEmpty()) {
          T currentNode = DequeSequence.fromDequeNew(nodeStack).peekElement();
          sink = false;
          finishedTraversal = false;
          SCCProperty prop = MapSequence.fromMap(nodeMap).get(currentNode);

          // if the node has not been visited
          if (MapSequence.fromMap(nodeMap).get(currentNode).index == 0) {
            index++;
            DequeSequence.fromDequeNew(sccStack).pushElement(currentNode);
            MapSequence.fromMap(nodeMap).get(currentNode).index = index;
            MapSequence.fromMap(nodeMap).get(currentNode).lowLink = index;
            MapSequence.fromMap(notVisitedMap).put(currentNode, SetSequence.fromSet(new HashSet<T>()));
            if (graph.getTargets(currentNode) != null) {
              MapSequence.fromMap(targetNodeMap).put(currentNode, ListSequence.fromListWithValues(new LinkedList<T>(), graph.getTargets(currentNode)));
            }
          }

          if (MapSequence.fromMap(targetNodeMap).get(currentNode) != null) {
            if (ListSequence.fromList(MapSequence.fromMap(targetNodeMap).get(currentNode)).isEmpty()) {
              // the exploration of currentNode and its children has been finished
              MapSequence.fromMap(targetNodeMap).removeKey(currentNode);
              DequeSequence.fromDequeNew(nodeStack).popElement();

              Set<T> targets = graph.getTargets(currentNode);
              if (targets != null) {
                for (T targetNode : SetSequence.fromSet(targets)) {
                  if (SetSequence.fromSet(MapSequence.fromMap(notVisitedMap).get(currentNode)).contains(targetNode)) {
                    prop.lowLink = Math.min(prop.lowLink, MapSequence.fromMap(nodeMap).get(targetNode).lowLink);
                  } else if (DequeSequence.fromDequeNew(sccStack).contains(targetNode)) {
                    prop.lowLink = Math.min(prop.lowLink, MapSequence.fromMap(nodeMap).get(targetNode).index);
                  }
                }
              }

              finishedTraversal = true;
            } else {
              T targetNode = ListSequence.fromList(MapSequence.fromMap(targetNodeMap).get(currentNode)).removeElementAt(0);
              // if the node has not been visited add it to the nodeStack
              // and mark it as a not visited node for currentNode
              if (MapSequence.fromMap(nodeMap).get(targetNode).index == 0) {
                SetSequence.fromSet(MapSequence.fromMap(notVisitedMap).get(currentNode)).addElement(targetNode);
                DequeSequence.fromDequeNew(nodeStack).pushElement(targetNode);
              }
            }
          } else {
            DequeSequence.fromDequeNew(nodeStack).popElement();
            sink = true;
          }

          // create the new SCC by popping the elements off the stack
          if ((sink || finishedTraversal) && prop.lowLink == prop.index) {
            Set<T> newSCC = SetSequence.fromSet(new LinkedHashSet<T>());
            T targetNode = null;

            do {
              targetNode = DequeSequence.fromDequeNew(sccStack).popElement();
              SetSequence.fromSet(newSCC).addElement(targetNode);
            } while (targetNode != null && !(targetNode.equals(currentNode)));

            // early exit if the sought node is found
            if (sought != null && SetSequence.fromSet(newSCC).contains(sought)) {
              SetSequence.fromSet(result).clear();
              SetSequence.fromSet(result).addElement(newSCC);
              return result;
            } else {
              SetSequence.fromSet(result).addElement(newSCC);
            }
          }
        }
      }
    }

    // full SCC computation exit
    return result;
  }

  /**
   * Returns the topological sorting of the nodes of the given graph.
   * If silent is true, a possible cycle is swallowed and simply an empty list is returned, 
   * otherwise an Exception is thrown to indicate the cyclic input graph. 
   * 
   * @param _graph the input graph
   * @param <T> the type parameter of the nodes in the graph
   * @return the nodes in the order of topological sorting
   */
  public static <T> List<T> computeTopologicalSorting(Graph<T> _graph, boolean silent) {
    List<T> result = ListSequence.fromList(new ArrayList<T>());
    Graph<T> graph = _graph.copy();
    Set<T> sources = graph.getSources();
    Set<T> targets = SetSequence.fromSet(new HashSet<T>());
    int size = SetSequence.fromSet(graph.getAllNodes()).count();

    while (SetSequence.fromSet(sources).isNotEmpty()) {
      T source = SetSequence.fromSet(sources).first();
      SetSequence.fromSet(targets).clear();
      SetSequence.fromSet(targets).addSequence(SetSequence.fromSet(graph.getTargets(source)));

      for (T target : SetSequence.fromSet(targets)) {
        graph.removeEdge(source, target);
        if (SetSequence.fromSet(graph.getSources(target)).isEmpty()) {
          SetSequence.fromSet(sources).addElement(target);
        }
      }
      ListSequence.fromList(result).addElement(source);
      SetSequence.fromSet(sources).removeElement(source);
    }

    if (size != ListSequence.fromList(result).count()) {
      if (silent) {
        return Collections.<T>emptyList();
      } else {
        throw new IllegalArgumentException("Topological sorting is defined only on acyclic graphs! The input contains cycles.");
      }
    } else {
      return result;
    }
  }

  /**
   * Returns the topological sorting of the nodes of the given graph.
   * 
   * @param _graph the input graph
   * @param <T> the type parameter of the nodes in the graph
   * @return the nodes in the order of topological sorting
   */
  public static <T> List<T> computeTopologicalSorting(Graph<T> _graph) {
    return computeTopologicalSorting(_graph, false);
  }

}
