package com.mbeddr.mpsutil.common.model;

/*Generated by MPS */

import org.jetbrains.mps.openapi.model.SNode;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import java.util.Collections;
import jetbrains.mps.smodel.SLanguageHierarchy;
import jetbrains.mps.smodel.language.LanguageRegistry;
import jetbrains.mps.smodel.SModelOperations;
import java.util.HashSet;
import org.jetbrains.mps.openapi.language.SLanguage;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.Sequence;
import org.jetbrains.mps.openapi.module.SModule;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import org.jetbrains.mps.openapi.module.FindUsagesFacade;
import jetbrains.mps.project.FilteredScope;
import jetbrains.mps.project.GlobalScope;
import jetbrains.mps.extapi.module.TransientSModule;
import jetbrains.mps.smodel.tempmodel.TempModule;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.extapi.model.TransientSModel;
import jetbrains.mps.smodel.tempmodel.TemporaryModels;
import jetbrains.mps.util.CollectConsumer;

public class ConceptInstanceFinder {
  public static Iterable<SNode> findAllVisibleInstances(SNode context, SAbstractConcept conceptToFind) {
    if (context == null || SNodeOperations.getModel(context) == null || conceptToFind == null) {
      return Collections.emptySet();
    }

    // FIXME this is qiute odd code, with not clear assumptions about module names.
    // The idea seems to be to find instances declared in used languages, though it's not clear why used languages? The model is written in these languages, why
    // do we care to find nodes declared in the source modules of these languages???
    SLanguageHierarchy languages = new SLanguageHierarchy(LanguageRegistry.getInstance(SNodeOperations.getModel(context).getRepository()), SModelOperations.getAllLanguageImports(SNodeOperations.getModel(context)));
    final HashSet<String> visibleLanguageNames = new HashSet<String>();
    for (SLanguage l : languages.getExtended()) {
      visibleLanguageNames.add(l.getQualifiedName());
    }

    List<SNode> result = Sequence.fromIterable(findAllInstances(conceptToFind)).where((instance) -> {
      SModule module = SNodeOperations.getModel(instance).getModule();
      if (module == null) {
        return false;
      }
      return visibleLanguageNames.contains(module.getModuleName());
    }).toList();

    ListSequence.fromList(result).addSequence(ListSequence.fromList(jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations.nodes(SNodeOperations.getModel(context), SNodeOperations.asSConcept(conceptToFind))));

    return result;
  }

  /**
   * Searches for nodes of the given concept in all user models from the global scope (not including transient and temporary models).
   * 
   * @param conceptToFind concept to find
   * @return sequence of concept instances
   */
  public static Iterable<SNode> findAllInstances(SAbstractConcept conceptToFind) {
    FindUsagesFacade findUsagesFacade = FindUsagesFacade.getInstance();
    FilteredScope allGlobalUserModels = new FilteredScope(new GlobalScope(SNodeOperations.getModel(SNodeOperations.asNode(conceptToFind)).getRepository())) {
      @Override
      protected boolean acceptModule(SModule module) {
        return !(module instanceof TransientSModule) && !(module instanceof TempModule);
      }
      @Override
      protected boolean acceptModel(SModel model) {
        return !(model instanceof TransientSModel) && !(TemporaryModels.isTemporary(model));
      }
    };
    CollectConsumer<SNode> collector = new CollectConsumer();
    findUsagesFacade.findInstances(allGlobalUserModels, Collections.singleton(conceptToFind), false, collector, null);
    return collector.getResult();
  }

}
