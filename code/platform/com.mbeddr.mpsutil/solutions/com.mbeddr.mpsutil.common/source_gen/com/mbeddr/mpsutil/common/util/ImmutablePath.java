package com.mbeddr.mpsutil.common.util;

/*Generated by MPS */

import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.internal.collections.runtime.Sequence;
import java.util.Optional;
import java.util.Collections;
import java.util.Objects;

/**
 * A class representing a sequence of segments comprising a "path".
 * 
 * The implementation is immutable, i.e. the path objects are never changed.
 * 
 * @param <S> the type of the path's segments
 * @param <T> the actual application type which extends ImmutablePath<>
 */
public abstract class ImmutablePath<S, T extends ImmutablePath<S, T>> {
  private List<S> segments = ListSequence.fromList(new ArrayList<S>());

  public ImmutablePath() {
    // constructs a path without any segments
  }

  public ImmutablePath(Iterable<S> segments) {
    ListSequence.fromList(this.segments).addSequence(Sequence.fromIterable(segments));
  }

  protected ImmutablePath(ImmutablePath<S, T> orig) {
    this(orig.segments);
  }

  /**
   * This is a copy constructor for the application type T.
   * It would be more elegant to call a copy constructor for generic type T, but this is impossible.
   * 
   * @return the deep copy
   */
  protected abstract T cloneObject();

  public Optional<S> lastSegment() {
    if (ListSequence.fromList(segments).isEmpty()) {
      return Optional.empty();
    } else {
      return Optional.of(ListSequence.fromList(segments).last());
    }
  }

  public int segmentsSize() {
    return ListSequence.fromList(segments).count();
  }

  public Iterable<S> segments() {
    return segments;
  }

  public Iterable<S> segmentsReversed() {
    return ListSequence.fromList(this.segments).reversedList();
  }

  public List<S> segmentsAsList() {
    return Collections.unmodifiableList(this.segments);
  }

  public T append(S additionalSegment) {
    T result = cloneObject();
    ListSequence.fromList(upcast(result).segments).addElement(additionalSegment);
    return result;
  }

  public T append(Iterable<S> additionalSegments) {
    T result = cloneObject();
    ListSequence.fromList(upcast(result).segments).addSequence(Sequence.fromIterable(additionalSegments));
    return result;
  }

  public T concat(ImmutablePath<S, T> second) {
    T result = cloneObject();
    ListSequence.fromList(upcast(result).segments).addSequence(ListSequence.fromList(second.segments));
    return result;
  }

  public Optional<T> shorten() {
    if (ListSequence.fromList(segments).isEmpty()) {
      return Optional.empty();
    } else {
      T result = cloneObject();
      ListSequence.fromList(upcast(result).segments).removeLastElement();
      return Optional.of(result);
    }
  }

  /**
   * This is needed to fix compile errors in the generated Java.
   */
  private ImmutablePath<S, T> upcast(T obj) {
    return as_uusdar_a0a0cb(obj, ImmutablePath.class);
  }

  @Override
  public int hashCode() {
    return ListSequence.fromList(segments).foldLeft(7, (s, it) -> 31 * s + it.hashCode());
  }

  @Override
  public boolean equals(Object obj) {
    if (obj == this) {
      return true;
    }
    if (!(obj instanceof ImmutablePath)) {
      return false;
    }
    ImmutablePath<S, T> other = as_uusdar_a0a2a23(obj, ImmutablePath.class);

    // compare segment list
    return Objects.equals(this.segments, other.segments);
  }

  private static <T> T as_uusdar_a0a0cb(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
  private static <T> T as_uusdar_a0a2a23(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
}
