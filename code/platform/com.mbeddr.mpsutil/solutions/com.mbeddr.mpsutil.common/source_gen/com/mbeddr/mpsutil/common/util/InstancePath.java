package com.mbeddr.mpsutil.common.util;

/*Generated by MPS */

import java.util.Optional;
import jetbrains.mps.internal.collections.runtime.Sequence;
import java.util.Objects;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import org.apache.commons.lang3.builder.ToStringBuilder;
import org.apache.commons.lang3.builder.ToStringStyle;

/**
 * A class representing an instance path, i.e. a root and a sequence of segments.
 * Each segment represents an instance of some definition object. The definition objects
 * and the root must have the same type D (the "definition" type).
 * 
 * Example: The "definition" type is a "Component", and the segment type is a "ComponentInstance".
 *          Each Component has a list of sub-components, specified by ComponentInstance elements.
 *          An InstancePath defines some nested sub-component, starting from a root component definition.
 * 
 * @param <D> the type of the root of the path (the "definition" type)
 * @param <S> the type of the path's segments (the "segment" type)
 * @param <T> the actual application type which extends InstancePath<>
 */
public abstract class InstancePath<D, S, T extends InstancePath<D, S, T>> extends ImmutablePath<S, T> {
  private final D root;

  public InstancePath(D root) {
    this.root = root;
  }

  public InstancePath(D root, Iterable<S> segments) {
    super(segments);
    this.root = root;
  }

  protected InstancePath(InstancePath<D, S, T> orig) {
    super(orig);
    this.root = orig.root;
  }

  /**
   * Provide the definition object for some segment.
   * 
   * Note that this method does not require that the segment is actually part of the path.
   * Instead, the method is computing its result independent from the path-object "this".
   * 
   * @param segment some segment
   * @return the corresponding definition object (or empty)
   */
  protected abstract Optional<D> getDefinition(S segment);

  protected abstract String getRootPresentation();

  public D root() {
    return this.root;
  }

  public D getLeaf() {
    S found = Sequence.fromIterable(segments()).findLast((it) -> getDefinition(it).isPresent());
    if (Objects.equals(found, null)) {
      return root();
    }
    return getDefinition(found).get();
  }

  public boolean hasDefinition(S segment, final D definition) {
    return getDefinition(segment).map((d) -> Objects.equals(d, definition)).orElse(false);
  }

  public boolean visits(final D definition) {
    return Objects.equals(definition, root()) || Sequence.fromIterable(segments()).any((it) -> hasDefinition(it, definition));
  }

  public Optional<T> concatSafe(InstancePath<D, S, T> subPath) {
    // sanity check: root of subPath must match leaf instance
    if (!(Objects.equals(subPath.root(), getLeaf()))) {
      return Optional.empty();
    }

    // do actual concatenation of segments, will result in an InstancePath
    return Optional.of(concat(subPath));
  }

  /**
   * Create expression from instance path.
   * 
   * This version is used if the first part of the expression can be build just from the root definition.
   * 
   * @param startBuilder lambda to build the first expression part from the root definition
   * @param segmentBuilder lambda to enhance the expression by the next segment
   * @param <E> the expression type (e.g., node<Expression>)
   * @return the resulting expression
   */
  public <E> Optional<E> toExpression(_FunctionTypes._return_P1_E0<? extends E, ? super D> startBuilder, final _FunctionTypes._return_P2_E0<? extends E, ? super E, ? super S> segmentBuilder) {
    E start = startBuilder.invoke(root);
    if (start != null) {
      E result = Sequence.fromIterable(segments()).foldLeft(start, (e, it) -> {
        if (Objects.equals(e, null)) {
          return null;
        }
        return segmentBuilder.invoke(e, it);
      });
      return Optional.ofNullable(result);
    }
    return Optional.empty();
  }

  /**
   * Create expression from instance path.
   * 
   * This version is used if the first part of the expression is built from the root definition and the first segment.
   * 
   * @param startBuilder lambda to build the first expression part from the root definition and the first segment
   * @param segmentBuilder lambda to enhance the expression by the next segment (except the first)
   * @param <E> the expression type (e.g., node<Expression>)
   * @return the resulting expression
   */
  public <E> Optional<E> toExpression(_FunctionTypes._return_P2_E0<? extends E, ? super D, ? super S> startBuilder, final _FunctionTypes._return_P2_E0<? extends E, ? super E, ? super S> segmentBuilder) {
    if (segmentsSize() > 0) {
      E start = startBuilder.invoke(root, Sequence.fromIterable(segments()).first());
      if (start != null) {
        E result = Sequence.fromIterable(segments()).skip(1).foldLeft(start, (e, it) -> {
          if (Objects.equals(e, null)) {
            return null;
          }
          return segmentBuilder.invoke(e, it);
        });
        return Optional.ofNullable(result);
      }
    }
    return Optional.empty();
  }

  @Override
  public int hashCode() {
    int hash = (this.root != null ? this.root.hashCode() : 7);
    hash = 31 * hash + super.hashCode();
    return hash;
  }

  @Override
  public boolean equals(Object obj) {
    if (obj == this) {
      return true;
    }
    if (!(obj instanceof InstancePath)) {
      return false;
    }
    InstancePath<D, S, T> other = as_uru81p_a0a2a82(obj, InstancePath.class);

    // compare root
    if (!(Objects.equals(this.root, other.root))) {
      return false;
    }

    // compare segment list
    return super.equals(obj);
  }

  @Override
  public String toString() {
    return new ToStringBuilder(this, ToStringStyle.MULTI_LINE_STYLE).append("root", getRootPresentation()).append("segments", segments()).toString();
  }
  private static <T> T as_uru81p_a0a2a82(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
}
