package com.mbeddr.mpsutil.common.graph;

/*Generated by MPS */


public class AVLTreeImpl<ValueType extends Comparable<ValueType>, NodeType extends AVLTreeNode<ValueType>> implements AVLTree<ValueType, NodeType> {

  protected final AVLTreeNodeFactory<ValueType, NodeType> nodeFactory;
  protected NodeType root;

  public AVLTreeImpl(final AVLTreeNodeFactory<ValueType, NodeType> nodeFactory) {
    this.nodeFactory = nodeFactory;
  }

  @Override
  public AVLTree<ValueType, NodeType> insert(final ValueType value) {
    this.root = (NodeType) insert(this.root, value);
    return this;
  }

  protected AVLTreeNode<ValueType> insert(final AVLTreeNode<ValueType> node, final ValueType value) {
    if (node == null) {
      final NodeType child = this.nodeFactory.createNode(value);
      return child;
    } else {
      final int result = value.compareTo(node.getValue());

      if (result < 0) {
        final AVLTreeNode<ValueType> newLeftChild = insert(node.getLeftChild(), value);
        node.setLeftChild(newLeftChild);
      } else if (result == 0) {
        node.incrementCount();
        // no rotations are needed
        return node;
      } else {
        final AVLTreeNode<ValueType> newRightChild = insert(node.getRightChild(), value);
        node.setRightChild(newRightChild);
      }

      node.setHeight(AVLTreeUtil.computeHeight(node));

      final int factor = AVLTreeUtil.getBalanceFactor(node);

      if (factor > 1) {
        // left subtree is higher
        if (AVLTreeUtil.getBalanceFactor(node.getLeftChild()) > 0) {
          // left left case
          return rightRotate(node);
        } else {
          // left right case
          final AVLTreeNode<ValueType> newLeftChild = leftRotate(node.getLeftChild());
          node.setLeftChild(newLeftChild);
          return rightRotate(node);
        }
      } else if (factor < -1) {
        // right subtree is higher
        if (AVLTreeUtil.getBalanceFactor(node.getRightChild()) < 0) {
          // right right case
          return leftRotate(node);
        } else {
          // right left case
          final AVLTreeNode<ValueType> newRightChild = rightRotate(node.getRightChild());
          node.setRightChild(newRightChild);
          return leftRotate(node);
        }
      }

      return node;
    }
  }

  @Override
  public AVLTree<ValueType, NodeType> remove(final ValueType value) {
    this.root = (NodeType) remove(this.root, value, false, false);
    return this;
  }

  @Override
  public AVLTree<ValueType, NodeType> remove(final ValueType value, final boolean mustBePresent) {
    this.root = (NodeType) remove(this.root, value, false, mustBePresent);
    return this;
  }

  protected AVLTreeNode<ValueType> remove(AVLTreeNode<ValueType> node, final ValueType value, final boolean removeAll, final boolean mustBePresent) {
    if (node == null) {
      if (mustBePresent) {
        throw new IllegalArgumentException("Sought node " + node + " was not present!");
      } else {
        return null;
      }
    } else {
      final int result = value.compareTo(node.getValue());

      if (result < 0) {
        final AVLTreeNode<ValueType> newLeftChild = remove(node.getLeftChild(), value, removeAll, mustBePresent);
        node.setLeftChild(newLeftChild);
      } else if (result > 0) {
        final AVLTreeNode<ValueType> newRightChild = remove(node.getRightChild(), value, removeAll, mustBePresent);
        node.setRightChild(newRightChild);
      } else {
        if (!(removeAll) && node.getCount() > 1) {
          node.decrementCount();
          return node;
        } else {

          if (node.getLeftChild() == null || node.getRightChild() == null) {
            // node with only one child or no child at all
            AVLTreeNode<ValueType> child = null;
            if (node.getLeftChild() == null) {
              child = node.getRightChild();
            } else {
              child = node.getLeftChild();
            }

            if (child == null) {
              // no child case
              return null;
            } else {
              // one child case
              final AVLTreeNode<ValueType> originalParent = node.getParent();
              node = child;
              node.setParent(originalParent);
            }

          } else {
            // node with two children
            final AVLTreeNode<ValueType> child = getLeftMostLeaf(node.getRightChild());
            node.setValue(child.getValue());
            node.setCount(child.getCount());
            final AVLTreeNode<ValueType> newRightChild = remove(node.getRightChild(), child.getValue(), true, mustBePresent);
            node.setRightChild(newRightChild);
          }
        }
      }

      assert node != null;
      node.setHeight(AVLTreeUtil.computeHeight(node));
      final int factor = AVLTreeUtil.getBalanceFactor(node);

      if (factor > 1) {
        // left subtree is higher
        if (AVLTreeUtil.getBalanceFactor(node.getLeftChild()) > 0) {
          // left left case
          return rightRotate(node);
        } else {
          // left right case
          final AVLTreeNode<ValueType> newLeftChild = leftRotate(node.getLeftChild());
          node.setLeftChild(newLeftChild);
          return rightRotate(node);
        }
      } else if (factor < -1) {
        // right subtree is higher
        if (AVLTreeUtil.getBalanceFactor(node.getRightChild()) < 0) {
          // right right case
          return leftRotate(node);
        } else {
          // right left case
          final AVLTreeNode<ValueType> newRightChild = rightRotate(node.getRightChild());
          node.setRightChild(newRightChild);
          return leftRotate(node);
        }
      }

      return node;
    }
  }

  protected AVLTreeNode<ValueType> getLeftMostLeaf(final AVLTreeNode<ValueType> node) {
    AVLTreeNode<ValueType> current = node;

    while (current.getLeftChild() != null) {
      current = current.getLeftChild();
    }

    return current;
  }

  protected AVLTreeNode<ValueType> leftRotate(final AVLTreeNode<ValueType> node) {
    final AVLTreeNode<ValueType> right = node.getRightChild();
    final AVLTreeNode<ValueType> rightLeft = right.getLeftChild();

    // the order of these mutations is important
    // starting with the setRightChild would introduce a temporary cycle
    node.setRightChild(rightLeft);
    right.setLeftChild(node);

    node.setHeight(AVLTreeUtil.computeHeight(node));
    right.setHeight(AVLTreeUtil.computeHeight(right));

    return right;
  }

  protected AVLTreeNode<ValueType> rightRotate(final AVLTreeNode<ValueType> node) {
    final AVLTreeNode<ValueType> left = node.getLeftChild();
    final AVLTreeNode<ValueType> leftRight = left.getRightChild();

    // the order of these mutations is important
    // starting with the setRightChild would introduce a temporary cycle
    node.setLeftChild(leftRight);
    left.setRightChild(node);

    node.setHeight(AVLTreeUtil.computeHeight(node));
    left.setHeight(AVLTreeUtil.computeHeight(left));

    return left;
  }

  @Override
  public NodeType getRoot() {
    return this.root;
  }

  @Override
  public NodeType find(final ValueType value) {
    return (NodeType) find(this.root, value);
  }

  protected AVLTreeNode<ValueType> find(final AVLTreeNode<ValueType> node, final ValueType value) {
    if (node == null) {
      return null;
    } else {
      final int result = value.compareTo(node.getValue());
      if (result < 0) {
        return find(node.getLeftChild(), value);
      } else if (result == 0) {
        return node;
      } else {
        return find(node.getRightChild(), value);
      }
    }
  }

}
