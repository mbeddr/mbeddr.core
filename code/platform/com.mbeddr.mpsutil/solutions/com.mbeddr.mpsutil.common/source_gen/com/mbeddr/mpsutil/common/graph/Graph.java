package com.mbeddr.mpsutil.common.graph;

/*Generated by MPS */

import java.util.Map;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import java.util.Collections;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import jetbrains.mps.internal.collections.runtime.IMapping;

/**
 * A simple directed graph data structure with forward and backward edge mappings. 
 * It is very important to implement the equals and hashcode methods in the  
 * given node type, so that it provides true uniqueness for the nodes. 
 *  
 * @param T The type of the nodes in the graph 
 */
public class Graph<T> {

  private Map<T, Set<T>> forwardMap;
  private Map<T, Set<T>> backwardMap;
  /**
   * This mapping is required so that different instances of nodes  
   * with the same hashCode will not be inserted into the graph.  
   * Basically the first inserted node will be used as a representative  
   * for these nodes. Usually such a situation can arise, when  
   * during the graph construction we try to insert equal nodes  
   * to the graph multiple times.  
   */
  private Map<T, T> nodeMap;

  public Graph() {
    this.forwardMap = MapSequence.fromMap(new HashMap<T, Set<T>>());
    this.backwardMap = MapSequence.fromMap(new HashMap<T, Set<T>>());
    this.nodeMap = MapSequence.fromMap(new HashMap<T, T>());
  }

  public boolean addNode(T node) {
    if (MapSequence.fromMap(nodeMap).get(node) == null) {
      MapSequence.fromMap(nodeMap).put(node, node);
    }
    if (!(MapSequence.fromMap(forwardMap).containsKey(MapSequence.fromMap(nodeMap).get(node)))) {
      MapSequence.fromMap(this.forwardMap).put(MapSequence.fromMap(nodeMap).get(node), SetSequence.fromSet(new HashSet<T>()));
      return true;
    } else {
      return false;
    }
  }

  public boolean removeNode(T node) {
    if (MapSequence.fromMap(nodeMap).get(node) != null) {
      for (T target : SetSequence.fromSet(MapSequence.fromMap(forwardMap).get(MapSequence.fromMap(nodeMap).get(node)))) {
        SetSequence.fromSet(MapSequence.fromMap(backwardMap).get(target)).removeElement(MapSequence.fromMap(nodeMap).get(node));
      }
      MapSequence.fromMap(forwardMap).removeKey(MapSequence.fromMap(nodeMap).get(node));
      MapSequence.fromMap(nodeMap).removeKey(node);
      return true;
    } else {
      return false;
    }
  }

  /**
   * Adds the specified edge to the graph.  
   * This will always be successful, because parallel edges are also allowed.  
   */
  public void addEdge(T from, T to) {
    addNode(from);
    addNode(to);
    T nfrom = MapSequence.fromMap(nodeMap).get(from);
    T nto = MapSequence.fromMap(nodeMap).get(to);
    SetSequence.fromSet(MapSequence.fromMap(forwardMap).get(nfrom)).addElement(nto);
    if (!(MapSequence.fromMap(backwardMap).containsKey(nto))) {
      Set<T> s = SetSequence.fromSet(new HashSet<T>());
      SetSequence.fromSet(s).addElement(nfrom);
      MapSequence.fromMap(backwardMap).put(nto, s);
    } else {
      SetSequence.fromSet(MapSequence.fromMap(backwardMap).get(nto)).addElement(nfrom);
    }
  }

  public boolean removeEdge(T from, T to) {
    if (MapSequence.fromMap(nodeMap).get(from) == null) {
      return false;
    }
    if (!(SetSequence.fromSet(MapSequence.fromMap(forwardMap).get(MapSequence.fromMap(nodeMap).get(from))).contains(MapSequence.fromMap(nodeMap).get(to)))) {
      return false;
    }
    T nfrom = MapSequence.fromMap(nodeMap).get(from);
    T nto = MapSequence.fromMap(nodeMap).get(to);
    SetSequence.fromSet(MapSequence.fromMap(forwardMap).get(nfrom)).removeElement(nto);
    SetSequence.fromSet(MapSequence.fromMap(backwardMap).get(nto)).removeElement(nfrom);
    return true;
  }


  /**
   * Determines all graph nodes of type T, that have an incoming edge from the specified source
   * 
   * @return a set of all found target nodes of type T of source
   */
  public Set<T> getTargets(T source) {
    if (MapSequence.fromMap(nodeMap).get(source) == null) {
      return Collections.<T>emptySet();
    } else {
      Set<T> result = MapSequence.fromMap(forwardMap).get(MapSequence.fromMap(nodeMap).get(source));
      if (result == null) {
        return Collections.<T>emptySet();
      } else {
        return result;
      }
    }
  }


  /**
   * Determines all graph nodes of type T, that have an outgoing edge towards the specified target
   * 
   * @return a set of all found source nodes of type T of target
   */
  public Set<T> getSources(T target) {
    if (MapSequence.fromMap(nodeMap).get(target) == null) {
      return Collections.<T>emptySet();
    } else {
      Set<T> result = MapSequence.fromMap(backwardMap).get(MapSequence.fromMap(nodeMap).get(target));
      if (result == null) {
        return Collections.<T>emptySet();
      } else {
        return result;
      }
    }
  }


  /**
   * Determines all graph nodes of type T, that are sources, i.e. have no incoming edges
   * 
   * @return a set of all found source-nodes of type T
   */
  public Set<T> getSources() {
    Set<T> sources = SetSequence.fromSet(new HashSet<T>());

    for (T node : SetSequence.fromSet(MapSequence.fromMap(nodeMap).keySet())) {
      if (SetSequence.fromSet(MapSequence.fromMap(backwardMap).get(node)).isEmpty()) {
        SetSequence.fromSet(sources).addElement(node);
      }
    }

    return sources;
  }

  /**
   * Determines all graph nodes of type T, that are sinks, i.e. have no outgoing edges
   * 
   * @return a set of all found sink-nodes of type T
   */
  public Set<T> getSinks() {
    Set<T> sinks = SetSequence.fromSet(new HashSet<T>());
    for (T node : SetSequence.fromSet(MapSequence.fromMap(nodeMap).keySet())) {
      if (SetSequence.fromSet(MapSequence.fromMap(forwardMap).get(MapSequence.fromMap(nodeMap).get(node))).isEmpty()) {
        SetSequence.fromSet(sinks).addElement(MapSequence.fromMap(nodeMap).get(node));
      }
    }
    return sinks;
  }

  public Set<T> getAllNodes() {
    return MapSequence.fromMap(nodeMap).keySet();
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("Nodes = {" + MapSequence.fromMap(nodeMap).keySet() + "}\n");
    sb.append("Edges = {");
    for (T source : SetSequence.fromSet(MapSequence.fromMap(forwardMap).keySet())) {
      for (T target : SetSequence.fromSet(MapSequence.fromMap(forwardMap).get(source))) {
        sb.append(source + " -> " + target + "\n");
      }
    }
    sb.append("}");
    return sb.toString();
  }

  private static final String[] colors = new String[]{"yellow", "blue", "red", "green", "gray", "cyan"};

  public String generateDot(boolean colorSCCs, _FunctionTypes._return_P1_E0<? extends String, ? super T> nameMapper) {
    Map<T, String> colorMap = MapSequence.fromMap(new HashMap<T, String>());

    if (colorSCCs) {
      Set<Set<T>> sccs = GraphUtil.computeSCC(this);

      int i = 0;
      for (Set<T> scc : SetSequence.fromSet(sccs)) {
        for (T node : SetSequence.fromSet(scc)) {
          String color = MapSequence.fromMap(colorMap).get(node);
          if (color == null) {
            MapSequence.fromMap(colorMap).put(node, colors[i % colors.length]);
          } else {
            MapSequence.fromMap(colorMap).put(node, MapSequence.fromMap(colorMap).get(node) + ":" + colors[i % colors.length]);
          }
        }
        i++;
      }

      // if a node has no color yet, then make it white
      for (T node : SetSequence.fromSet(MapSequence.fromMap(nodeMap).keySet())) {
        if (!(MapSequence.fromMap(colorMap).containsKey(node))) {
          MapSequence.fromMap(colorMap).put(node, "white");
        }
      }
    } else {
      for (T node : SetSequence.fromSet(MapSequence.fromMap(nodeMap).keySet())) {
        MapSequence.fromMap(colorMap).put(node, "white");
      }
    }

    StringBuilder builder = new StringBuilder();
    builder.append("digraph g {\n");
    for (T node : SetSequence.fromSet(MapSequence.fromMap(nodeMap).keySet())) {
      String nodePresentation = (nameMapper == null ? node.toString() : nameMapper.invoke(node));
      builder.append("\"" + nodePresentation + "\"");
      builder.append("[style=filled,fillcolor=" + MapSequence.fromMap(colorMap).get(node) + "]");
      builder.append(";\n");
    }
    for (T source : SetSequence.fromSet(MapSequence.fromMap(forwardMap).keySet())) {
      for (T target : SetSequence.fromSet(MapSequence.fromMap(forwardMap).get(source))) {
        String sourcePresentation = (nameMapper == null ? source.toString() : nameMapper.invoke(source));
        String targetPresentation = (nameMapper == null ? target.toString() : nameMapper.invoke(target));
        builder.append("\"" + sourcePresentation + "\" -> \"" + targetPresentation + "\";\n");
      }
    }
    builder.append("}");
    return builder.toString();

  }

  public String generateDot() {
    return generateDot(false, null);
  }

  public Graph<T> copy() {
    Graph<T> result = new Graph<T>();
    for (IMapping<T, Set<T>> m : MapSequence.fromMap(this.forwardMap)) {
      MapSequence.fromMap(result.forwardMap).put(m.key(), cloneSet(m.value()));
    }
    for (IMapping<T, Set<T>> m : MapSequence.fromMap(this.backwardMap)) {
      MapSequence.fromMap(result.backwardMap).put(m.key(), cloneSet(m.value()));
    }
    MapSequence.fromMap(result.nodeMap).putAll(this.nodeMap);
    return result;
  }

  private Set<T> cloneSet(Set<T> original) {
    Set<T> cloned = SetSequence.fromSet(new HashSet<T>());
    SetSequence.fromSet(cloned).addSequence(SetSequence.fromSet(original));
    return cloned;
  }
}
