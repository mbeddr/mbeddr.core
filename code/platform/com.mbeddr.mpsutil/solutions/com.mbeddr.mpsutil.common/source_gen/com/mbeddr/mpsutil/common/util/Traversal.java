package com.mbeddr.mpsutil.common.util;

/*Generated by MPS */

import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.LinkedHashSet;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import java.util.Queue;
import jetbrains.mps.internal.collections.runtime.QueueSequence;
import java.util.LinkedList;
import jetbrains.mps.internal.collections.runtime.Sequence;

/**
 * Breadth-first traversal of tree- or graph-structures, with cycle check.
 * 
 * The class offers two APIs:
 * - static methods which allow to use the traversal as-is in a compact way
 * - abstract class API which can be extended, e.g. when collecting extra data during the traversal
 * 
 * @param <T> template parameter defining which type of objects is traversed
 */
public abstract class Traversal<T> {

  /**
   * Run traversal directly by providing a start node.
   * 
   * @param startNode the node where the traversal is started
   * @param finishNow a function which may request a premature finish of the traversal
   * @param successors a function returning the successors for any given node
   * @param <E> template parameter defining which type of objects is traversed
   * @return true if the premature end of the traversal has been requested by finishNow, false otherwise
   */
  public static <E> boolean doBreadthFirst(E startNode, final _FunctionTypes._return_P1_E0<? extends Boolean, ? super E> finishNow, final _FunctionTypes._return_P1_E0<? extends Iterable<E>, ? super E> successors) {
    return create(finishNow, successors).doBreadthFirst(startNode);
  }

  /**
   * Run traversal directly by providing a set of start nodes.
   * 
   * @param startNodes the set of start nodes for the traversal
   * @param finishNow a function which may request a premature finish of the traversal
   * @param successors a function returning the successors for any given node
   * @param <E> template parameter defining which type of objects is traversed
   * @return true if the premature end of the traversal has been requested by finishNow, false otherwise
   */
  public static <E> boolean doBreadthFirst(Iterable<E> startNodes, final _FunctionTypes._return_P1_E0<? extends Boolean, ? super E> finishNow, final _FunctionTypes._return_P1_E0<? extends Iterable<E>, ? super E> successors) {
    return create(finishNow, successors).doBreadthFirst(startNodes);
  }

  /**
   * Factory function for simple creation of an traversal instance.
   * 
   * @param finishNowFunc a function which may request a premature finish of the traversal
   * @param successorsFunc a function returning the successors for any given node
   * @param <E> template parameter defining which type of objects is traversed
   * @return a new traversal instance
   */
  public static <E> Traversal<E> create(final _FunctionTypes._return_P1_E0<? extends Boolean, ? super E> finishNowFunc, final _FunctionTypes._return_P1_E0<? extends Iterable<E>, ? super E> successorsFunc) {
    return new Traversal<E>() {
      @Override
      public boolean finishNow(E n) {
        return finishNowFunc.invoke(n);
      }
      @Override
      public Iterable<E> successorsOf(E n) {
        return successorsFunc.invoke(n);
      }
    };
  }

  /**
   * Run traversal directly by providing a start node.
   * 
   * This traversal will always run until the end, as it does not have a finishNow() function.
   * 
   * @param startNode the node where the traversal is started
   * @param successors a function returning the successors for any given node
   * @param <E> template parameter defining which type of objects is traversed
   * @return true if the premature end of the traversal has been requested by finishNow, false otherwise
   */
  public static <E> boolean doBreadthFirst(E startNode, final _FunctionTypes._return_P1_E0<? extends Iterable<E>, ? super E> successors) {
    return create(successors).doBreadthFirst(startNode);
  }

  /**
   * Run traversal directly by providing a set of start nodes.
   * 
   * This traversal will always run until the end, as it does not have a finishNow() function.
   * 
   * @param startNodes the set of start nodes for the traversal
   * @param successors a function returning the successors for any given node
   * @param <E> template parameter defining which type of objects is traversed
   * @return true if the premature end of the traversal has been requested by finishNow, false otherwise
   */
  public static <E> boolean doBreadthFirst(Iterable<E> startNodes, final _FunctionTypes._return_P1_E0<? extends Iterable<E>, ? super E> successors) {
    return create(successors).doBreadthFirst(startNodes);
  }

  /**
   * Factory function for simple creation of an traversal instance.
   * 
   * This traversal will always run until the end, as it does not have a finishNow() function.
   * 
   * @param successorsFunc a function returning the successors for any given node
   * @param <E> template parameter defining which type of objects is traversed
   * @return a new traversal instance
   */
  public static <E> Traversal<E> create(final _FunctionTypes._return_P1_E0<? extends Iterable<E>, ? super E> successorsFunc) {
    return new Traversal<E>() {
      @Override
      public Iterable<E> successorsOf(E n) {
        return successorsFunc.invoke(n);
      }
    };
  }

  /**
   * We store the set of visited nodes, maybe the client wants to use it later.
   */
  private Set<T> visited = SetSequence.fromSet(new LinkedHashSet<T>());

  /**
   * Start a breadth-first traversal using a single start node.
   * 
   * The traversal will visit nodes in BFS order and will break cycles.
   * 
   * @param startNode the start node for the traversal
   * @return true if the premature end of the traversal has been requested by finishNow(), false otherwise
   */
  public boolean doBreadthFirst(T startNode) {
    return doBreadthFirst(ListSequence.fromListAndArray(new ArrayList<T>(), startNode));
  }

  /**
   * Start a breadth-first traversal using a set of start nodes.
   * 
   * The traversal will visit nodes in BFS order and will break cycles.
   * 
   * @param startNodes the set of start nodes
   * @return true if the premature end of the traversal has been requested by finishNow(), false otherwise
   */
  public boolean doBreadthFirst(Iterable<T> startNodes) {
    Queue<T> worklist = QueueSequence.fromQueue(new LinkedList<T>());
    QueueSequence.fromQueue(worklist).addSequence(Sequence.fromIterable(startNodes));
    SetSequence.fromSet(visited).clear();
    while (QueueSequence.fromQueue(worklist).isNotEmpty()) {
      T item = QueueSequence.fromQueue(worklist).removeFirstElement();
      if (!(SetSequence.fromSet(visited).contains(item))) {
        SetSequence.fromSet(visited).addElement(item);

        if (finishNow(item)) {
          return true;
        }

        Iterable<T> successors = successorsOf(item);
        QueueSequence.fromQueue(worklist).addSequence(Sequence.fromIterable(successors));
      }
    }
    return false;
  }

  /**
   * This method will visit all traversed nodes in turn. It can be used to prematurely end the traversal.
   * 
   * The default implementation returns false, meaning that the traversal should be continued until 
   * every reachable node has been visited.
   * 
   * The logic of the return value has the following use case in mind: Traverse a structure recursively
   * until a node with a specific property is found. If a node is actually found, the method returns true.
   * 
   * @param n the node which is currently traversed
   * @return true if traversal should be aborted immediately, false if it should be continued
   */
  protected boolean finishNow(T n) {
    return false;
  }

  /**
   * Get successors of a given node.
   * 
   * This method has to be provided by the user of this class.
   * 
   * @param n some node in the data structure which is traversed
   * @return all successors of node n
   */
  protected abstract Iterable<T> successorsOf(T n);

  /**
   * After the traversal, this method can be used to find out which nodes were visited
   * 
   * @return the nodes visited during the traversal
   */
  public Iterable<T> getVisited() {
    return this.visited;
  }
}
