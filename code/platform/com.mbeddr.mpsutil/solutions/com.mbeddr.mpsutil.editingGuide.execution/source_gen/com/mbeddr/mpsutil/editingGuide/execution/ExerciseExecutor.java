package com.mbeddr.mpsutil.editingGuide.execution;

/*Generated by MPS */

import java.util.Map;
import jetbrains.mps.project.Project;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.WeakHashMap;
import jetbrains.mps.openapi.editor.EditorContext;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import jetbrains.mps.internal.collections.runtime.IMapping;
import java.util.Objects;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.nodeEditor.EditorComponent;
import jetbrains.mps.openapi.editor.selection.SelectionListener;
import jetbrains.mps.openapi.editor.selection.Selection;
import javax.swing.SwingUtilities;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import com.mbeddr.mpsutil.editingGuide.behavior.Exercise__BehaviorDescriptor;
import jetbrains.mps.openapi.editor.Editor;
import jetbrains.mps.openapi.navigation.NavigationSupport;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.smodel.tempmodel.TemporaryModels;
import jetbrains.mps.smodel.tempmodel.TempModuleOptions;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.project.AbstractModule;
import jetbrains.mps.extapi.model.SModelBase;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import java.util.HashMap;
import java.util.List;
import jetbrains.mps.smodel.CopyUtil;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import org.jetbrains.mps.openapi.module.SModule;
import org.jetbrains.mps.openapi.module.SDependency;
import jetbrains.mps.internal.collections.runtime.Sequence;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import com.mbeddr.mpsutil.editingGuide.runtime.rt.MonitorResult;
import com.mbeddr.mpsutil.editingGuide.behavior.MonitorFunction__BehaviorDescriptor;
import org.jetbrains.mps.openapi.language.SReferenceLink;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import org.jetbrains.mps.openapi.language.SProperty;
import org.jetbrains.mps.openapi.language.SInterfaceConcept;
import org.jetbrains.mps.openapi.language.SConcept;

public class ExerciseExecutor {

  private static Map<Project, Map<SNode, ExerciseExecutor>> ourInstances = MapSequence.fromMap(new WeakHashMap<Project, Map<SNode, ExerciseExecutor>>());

  public static ExerciseExecutor getInstance(Project project, SNode exercise) {
    if ((exercise == null)) {
      return null;
    }

    Map<SNode, ExerciseExecutor> map2 = MapSequence.fromMap(ourInstances).get(project);
    if (map2 == null) {
      map2 = MapSequence.fromMap(new WeakHashMap<SNode, ExerciseExecutor>());
      MapSequence.fromMap(ourInstances).put(project, map2);
    }

    ExerciseExecutor executor = MapSequence.fromMap(map2).get(exercise);
    if (executor == null) {
      executor = new ExerciseExecutor(project, exercise);
      MapSequence.fromMap(map2).put(exercise, executor);
    }

    return executor;
  }

  public static ExerciseExecutor getInstance(EditorContext editorContext, SNode exercise) {
    return getInstance(editorContext.getOperationContext().getProject(), exercise);
  }


  /**
   * Returns the first instance for which the given closure returns true, or null if it doesnt exist
   */
  public static ExerciseExecutor findInstance(_FunctionTypes._return_P2_E0<? extends Boolean, ? super Project, ? super SNode> where) {
    for (IMapping<Project, Map<SNode, ExerciseExecutor>> perProject : MapSequence.fromMap(ourInstances)) {
      for (IMapping<SNode, ExerciseExecutor> perExercise : MapSequence.fromMap(perProject.value())) {
        if (where.invoke(perProject.key(), perExercise.key())) {
          return perExercise.value();
        }
      }
    }

    return null;
  }

  public static ExerciseExecutor guessLastExecutor(final Project project, SNode exercise) {
    // find original exercise
    final ExerciseExecutor myInstance = getInstance(project, exercise);

    ExerciseExecutor existingInstance = findInstance((Project rhsProject, SNode rhsExercise) -> Objects.equals(rhsProject, project) && Objects.equals(SLinkOperations.getTarget(rhsExercise, LINKS.followingExercise$OEv4), myInstance.myOriginalExercise));

    return existingInstance;
  }
  public static ExerciseExecutor guessLastExecutor(EditorContext editorContext, SNode exercise) {
    return guessLastExecutor(editorContext.getOperationContext().getProject(), exercise);
  }

  public static void disposeAll(Project project) {
    Map<SNode, ExerciseExecutor> instancesInProject = MapSequence.fromMap(ourInstances).get(project);
    if (instancesInProject == null) {
      return;
    }
    for (ExerciseExecutor instance : ListSequence.fromListWithValues(new ArrayList<ExerciseExecutor>(), MapSequence.fromMap(instancesInProject).values())) {
      instance.dispose();
    }
    MapSequence.fromMap(ourInstances).removeKey(project);
  }

  private Project myMpsProject;
  private EditorComponent myEditorComponent;
  private SNode myOriginalExercise;
  private SNode mySandboxExercise;
  private Map<SNode, SNode> myOriginal2SandboxMap;
  private Map<SNode, SNode> mySandbox2OriginalMap;
  private SelectionListener mySelectionListener = new SelectionListener() {
    private boolean isUpdating = false;
    public void selectionChanged(jetbrains.mps.openapi.editor.EditorComponent editorComponent, Selection oldSelection, Selection newSelection) {
      if (isUpdating) {
        return;
      }
      isUpdating = true;
      SwingUtilities.invokeLater(() -> myMpsProject.getRepository().getModelAccess().runReadAction(() -> {
        try {
          // introduced to avoid SECA-749
          if (SPropertyOperations.getBoolean(Exercise__BehaviorDescriptor.getCurrentTask_id4TMjSvbG95v.invoke(mySandboxExercise), PROPS.monitorSelectionChange$p6z7)) {
            // reevaluate monitor functions when moving focus if the task wants so
            myEditorComponent.rebuildEditorContent();
          }
        } finally {
          isUpdating = false;
        }
      }));
    }
  };
  private EditorComponent.EditorDisposeListener myEditorDisposeListener = new EditorComponent.EditorDisposeListener() {
    public void editorWillBeDisposed(EditorComponent editorComponent) {
      // give other listeners time to process the event before we kill the temp model
      SwingUtilities.invokeLater(() -> dispose());
      editorComponent.removeDisposeListener(this);
    }
  };

  protected ExerciseExecutor(Project mpsProject, SNode exercise) {
    myOriginalExercise = exercise;
    myMpsProject = mpsProject;
  }

  protected EditorComponent getEditorComponent() {
    if (myEditorComponent == null) {
      Editor editor = NavigationSupport.getInstance().openNode(myMpsProject, getSandboxExercise(), true, false);
      myEditorComponent = (EditorComponent) editor.getCurrentEditorComponent();
      myEditorComponent.addDisposeListener(myEditorDisposeListener);
      myEditorComponent.getSelectionManager().addSelectionListener(mySelectionListener);
      initHints();
    }
    return myEditorComponent;
  }

  public SNode getSandboxExercise() {
    if (mySandboxExercise == null) {
      SModel tempModel = TemporaryModels.getInstance().create(false, true, TempModuleOptions.forDefaultModule());

      copyModelProperties(SNodeOperations.getModel(myOriginalExercise), tempModel);
      copyModuleDependencies(SNodeOperations.getModel(myOriginalExercise).getModule(), tempModel.getModule());
      ((AbstractModule) tempModel.getModule()).addDependency(SNodeOperations.getModel(myOriginalExercise).getModule().getModuleReference(), false);
      ((jetbrains.mps.smodel.SModel) ((SModelBase) tempModel).getModelData()).addLanguage(MetaAdapterFactory.getLanguage(0x39180bba7eb14590L, 0xb6e1bf9cfd76020aL, "com.mbeddr.mpsutil.editingGuide.execution.lang"));


      myOriginal2SandboxMap = MapSequence.fromMap(new HashMap<SNode, SNode>());
      mySandbox2OriginalMap = MapSequence.fromMap(new HashMap<SNode, SNode>());
      List<SNode> copiedRoots = CopyUtil.copyAndPreserveId(SModelOperations.roots(SNodeOperations.getModel(myOriginalExercise), null), myOriginal2SandboxMap);
      for (SNode root : ListSequence.fromList(copiedRoots)) {
        ListSequence.fromList(SNodeOperations.getNodeDescendants(root, CONCEPTS.IAmAwareOfRuntime$k_, true, new SAbstractConcept[]{})).visitAll((it) -> SPropertyOperations.assign(it, PROPS.atRuntime$KYwf, true));
        tempModel.addRootNode(root);
      }
      mySandboxExercise = SNodeOperations.cast(MapSequence.fromMap(myOriginal2SandboxMap).get(myOriginalExercise), CONCEPTS.Exercise$zI);

      MapSequence.fromMap(myOriginal2SandboxMap).visitAll((it) -> MapSequence.fromMap(mySandbox2OriginalMap).put(it.value(), it.key()));

      tempModel.addRootNode(mySandboxExercise);
      registerInstanceForSandbox();
      // apply a fix for references still pointing to the original model
      ListSequence.fromList(SModelOperations.nodes(((SModel) tempModel), null)).translate((it) -> SNodeOperations.getReferences(it)).where((it) -> it.getTargetSModelReference().getModelId().equals(SNodeOperations.getModel(myOriginalExercise).getModelId())).visitAll((it) -> it.getSourceNode().setReferenceTarget(it.getLink(), MapSequence.fromMap(myOriginal2SandboxMap).get(SLinkOperations.getTargetNode(it))));
    }
    return mySandboxExercise;
  }

  protected void copyModuleDependencies(SModule from, SModule to) {
    for (SDependency dep : Sequence.fromIterable(from.getDeclaredDependencies())) {
      ((AbstractModule) to).addDependency(dep.getTargetModule(), false);
    }
  }

  protected void copyModelProperties(SModel from, SModel to) {
    ((jetbrains.mps.smodel.SModel) ((SModelBase) from).getModelData()).copyPropertiesTo(((jetbrains.mps.smodel.SModel) ((SModelBase) to).getModelData()));
  }

  protected void registerInstanceForSandbox() {
    MapSequence.fromMap(MapSequence.fromMap(ourInstances).get(myMpsProject)).put(mySandboxExercise, this);
  }

  public void dispose() {
    if (mySandboxExercise != null) {
      myMpsProject.getRepository().getModelAccess().runWriteAction(() -> TemporaryModels.getInstance().dispose(SNodeOperations.getModel(mySandboxExercise)));
      MapSequence.fromMap(MapSequence.fromMap(ourInstances).get(myMpsProject)).removeKey(mySandboxExercise);
      mySandboxExercise = null;
    }
    if (myEditorComponent != null) {
      myEditorComponent.getSelectionManager().removeSelectionListener(mySelectionListener);
      myEditorComponent.removeDisposeListener(myEditorDisposeListener);
    }
    MapSequence.fromMap(MapSequence.fromMap(ourInstances).get(myMpsProject)).removeKey(myOriginalExercise);
    myEditorComponent = null;
    myMpsProject = null;
    myOriginal2SandboxMap = null;
    mySandbox2OriginalMap = null;
  }

  /**
   * Optionally provide fromTask to start from a specific task.
   */
  public void start(final SNode fromTask) {
    SNode sandboxExercise = getSandboxExercise();

    if ((fromTask != null)) {
      // set the past tasks to be already done
      ListSequence.fromList(SLinkOperations.getChildren(sandboxExercise, LINKS.tasks$FA4J)).where((it) -> SNodeOperations.getIndexInParent(it) < SNodeOperations.getIndexInParent(fromTask)).visitAll((it) -> SPropertyOperations.assign(it, PROPS.isDone$D0eC, true));
    }

    getEditorComponent().editNode(sandboxExercise);
    NavigationSupport.getInstance().openNode(myMpsProject, sandboxExercise, true, false);
    getEditorComponent().getEditorContext().getRepository();
  }

  public void restart(SNode fromTask) {
    // backup project and exercise
    Project myMpsProjectBackup = myMpsProject;
    SNode exerciseBackup = myOriginalExercise;

    // dispose existing instance
    dispose();

    // create new instance
    getInstance(myMpsProjectBackup, exerciseBackup).start(fromTask);
  }

  public SNode getFollowingExercise() {
    return SLinkOperations.getTarget(myOriginalExercise, LINKS.followingExercise$OEv4);
  }

  protected void initHints() {
    Set<String> hints = SetSequence.fromSetAndArray(new HashSet<String>(), myEditorComponent.getUpdater().getInitialEditorHints());
    String hint = "com.mbeddr.mpsutil.editingGuide.editor.editingGuideHints.InGuideExecutionMode";
    if (hint != null) {
      SetSequence.fromSet(hints).addElement(hint);
    }
    SetSequence.fromSet(hints).removeElement(null);
    myEditorComponent.getUpdater().setInitialEditorHints(SetSequence.fromSet(hints).toGenericArray(String.class));
  }

  public MonitorResult checkTask(final SNode task) {
    MonitorResult result = MonitorFunction__BehaviorDescriptor.callFunction_id4TMjSvbDmOr.invoke(SLinkOperations.getTarget(SNodeOperations.cast(MapSequence.fromMap(mySandbox2OriginalMap).get(task), CONCEPTS.Task$i3), LINKS.monitor$sj3G), myEditorComponent.getEditorContext(), task);
    final String resultMessage = check_fnh4l_a0b0ub(result);
    SwingUtilities.invokeLater(() -> myMpsProject.getRepository().getModelAccess().executeCommand(() -> SPropertyOperations.assign(task, PROPS.resultMessage$Kz2L, resultMessage)));
    return result;
  }
  private static String check_fnh4l_a0b0ub(MonitorResult checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getMessage();
    }
    return null;
  }

  private static final class LINKS {
    /*package*/ static final SReferenceLink followingExercise$OEv4 = MetaAdapterFactory.getReferenceLink(0x67506b1e43ad47feL, 0xa8e6bc7837e9e11fL, 0x364130dd8794d97eL, 0xa6729a6eafd5b6bL, "followingExercise");
    /*package*/ static final SContainmentLink tasks$FA4J = MetaAdapterFactory.getContainmentLink(0x67506b1e43ad47feL, 0xa8e6bc7837e9e11fL, 0x364130dd8794d97eL, 0x364130dd8794d97fL, "tasks");
    /*package*/ static final SContainmentLink monitor$sj3G = MetaAdapterFactory.getContainmentLink(0x67506b1e43ad47feL, 0xa8e6bc7837e9e11fL, 0x364130dd8794d93cL, 0x364130dd8794d95bL, "monitor");
  }

  private static final class PROPS {
    /*package*/ static final SProperty monitorSelectionChange$p6z7 = MetaAdapterFactory.getProperty(0x67506b1e43ad47feL, 0xa8e6bc7837e9e11fL, 0x364130dd8794d93cL, 0x3e7260f875173a26L, "monitorSelectionChange");
    /*package*/ static final SProperty atRuntime$KYwf = MetaAdapterFactory.getProperty(0x67506b1e43ad47feL, 0xa8e6bc7837e9e11fL, 0x47383e43b043f1e2L, 0x47383e43b043f1e3L, "atRuntime");
    /*package*/ static final SProperty isDone$D0eC = MetaAdapterFactory.getProperty(0x67506b1e43ad47feL, 0xa8e6bc7837e9e11fL, 0x364130dd8794d93cL, 0x364130dd8794d978L, "isDone");
    /*package*/ static final SProperty resultMessage$Kz2L = MetaAdapterFactory.getProperty(0x67506b1e43ad47feL, 0xa8e6bc7837e9e11fL, 0x364130dd8794d93cL, 0x60b282007fe968f6L, "resultMessage");
  }

  private static final class CONCEPTS {
    /*package*/ static final SInterfaceConcept IAmAwareOfRuntime$k_ = MetaAdapterFactory.getInterfaceConcept(0x67506b1e43ad47feL, 0xa8e6bc7837e9e11fL, 0x47383e43b043f1e2L, "com.mbeddr.mpsutil.editingGuide.structure.IAmAwareOfRuntime");
    /*package*/ static final SConcept Exercise$zI = MetaAdapterFactory.getConcept(0x67506b1e43ad47feL, 0xa8e6bc7837e9e11fL, 0x364130dd8794d97eL, "com.mbeddr.mpsutil.editingGuide.structure.Exercise");
    /*package*/ static final SConcept Task$i3 = MetaAdapterFactory.getConcept(0x67506b1e43ad47feL, 0xa8e6bc7837e9e11fL, 0x364130dd8794d93cL, "com.mbeddr.mpsutil.editingGuide.structure.Task");
  }
}
