package com.mbeddr.mpsutil.logicalChild.behavior;

/*Generated by MPS */

import java.util.Map;
import org.jetbrains.mps.openapi.module.SModule;
import com.google.common.collect.Multimap;
import org.jetbrains.mps.openapi.model.SNode;
import java.util.HashMap;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.Callable;
import jetbrains.mps.internal.collections.runtime.Sequence;
import java.util.Collection;
import jetbrains.mps.internal.collections.runtime.CollectionSequence;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import com.google.common.collect.HashMultimap;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import java.util.Optional;
import java.util.Collections;
import org.jetbrains.mps.openapi.language.SInterfaceConcept;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;

/**
 * This class can be used by algorithms to speed the finding of 'LocgicalChildren' of 'ILogicalCHildOwners' using 
 * a caching mechanism
 */
public class LogicalChildOwnerUtil {

  /**
   * The data structure implementing the cache
   */
  private static Map<SModule, Multimap<SNode, SNode>> module2LogicalChildCache = new HashMap<>();

  /**
   * To make this static class thread-safe we do locking
   */
  private static ReentrantLock lock = new ReentrantLock();


  /**
   * Wrap a code block with an environment where any call to the method 'findLogicalChildren' of 'ILogicalChildOwner' is cached.
   * 
   * @param codeToBeRun code block
   * @param <T> type of result 
   * @throws Exception  
   * @return result
   */
  public static <T> T withCachedLogicalChildren(Callable<T> codeToBeRun) throws Exception {
    try {
      useCacheNow();
      return codeToBeRun.call();
    } finally {
      stopUsingCache();
    }
  }
  /**
   * Indicates that caching should be used 
   */
  private static void useCacheNow() {
    lock.lock();
  }

  /**
   * Stops using the cache and clears it
   */
  private static void stopUsingCache() {
    module2LogicalChildCache.clear();
    lock.unlock();
  }

  public static Boolean shouldUseCache() {
    return lock.isHeldByCurrentThread();
  }

  /**
   * For every 'ILogicalChildOwner' this method delivers its 'ILogicalChildren'. It will use the cache for 
   * subsequent calls.
   * 
   * @param owner owns the children but does not know them
   * @param scopeModules the modules where to find the children
   * @return children of owner
   */
  /*package*/ static Iterable<SNode> findLogicalChildren(final SNode owner, Iterable<SModule> scopeModules) {

    return Sequence.fromIterable(scopeModules).select((module) -> cacheFor(module)).translate((it) -> it.get(owner));
  }

  private static void createCacheFor(Collection<SModule> modules) {
    for (SModule module : CollectionSequence.fromCollection(modules)) {
      final Wrappers._T<Multimap<SNode, SNode>> owner2childen = new Wrappers._T<Multimap<SNode, SNode>>(module2LogicalChildCache.get(module));
      if (owner2childen.value == null) {
        // Create map if not present
        owner2childen.value = HashMultimap.create();
        module2LogicalChildCache.put(module, owner2childen.value);
      }
      for (SModel model : Sequence.fromIterable(module.getModels())) {
        SModel model2 = model;
        ListSequence.fromList(SModelOperations.nodes(model2, CONCEPTS.ILogicalChild$Av)).visitAll((child) -> {
          SNode owner = ILogicalChild__BehaviorDescriptor.getOwner_id7c93VeVMBwo.invoke(child);
          if (owner != null) {
            // Adds the owner-child-relation to the cache
            owner2childen.value.put(owner, child);
          }
        });
      }
    }
  }


  private static Multimap<SNode, SNode> cacheFor(SModule module) {
    Optional<Multimap<SNode, SNode>> logicalChildrenCacheMaybe = LogicalChildOwnerUtil.logicalChildrenCache(module);
    if (!(logicalChildrenCacheMaybe.isPresent())) {
      createCacheFor(Collections.singleton(module));
      logicalChildrenCacheMaybe = logicalChildrenCache(module);
      assert logicalChildrenCacheMaybe.isPresent();
    }
    return logicalChildrenCacheMaybe.get();
  }

  private static Optional<Multimap<SNode, SNode>> logicalChildrenCache(SModule module) {
    return Optional.ofNullable(module2LogicalChildCache.get(module));
  }

  private static final class CONCEPTS {
    /*package*/ static final SInterfaceConcept ILogicalChild$Av = MetaAdapterFactory.getInterfaceConcept(0x85a9bace37a140afL, 0x956a7bb1b081a77cL, 0x4d47311ce85ef55L, "com.mbeddr.mpsutil.logicalChild.structure.ILogicalChild");
  }
}
