package com.mbeddr.mpsutil.jung.behavior;

/*Generated by MPS */

import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.smodel.SNodePointer;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;

public class JNNode extends JNBase {

  private JNGraph graph;
  private int characteristicSize = 10;
  private long continuousAxisOne = -1;


  public JNNode(SNode n, String name, JNGraph graph) {
    if (name == null) {
      throw new RuntimeException("name was null for node" + SNodeOperations.present(n));
    }
    this.nodeptr = new SNodePointer(n);
    this.id = name;
    this.graph = graph;
  }

  public JNNode(SNode n, String name, JNGraph graph, int charSize) {
    this(n, name, graph);
    this.characteristicSize = charSize;
  }

  public JNNode(SNode n, String name, JNGraph graph, int charSize, String kind) {
    this(n, name, graph, charSize);
    this.kinds = new String[]{kind};
  }

  public JNNode(SNode n, String name, JNGraph graph, int charSize, String[] kinds) {
    this(n, name, graph, charSize);
    this.kinds = kinds;
  }

  protected void addKind(String s) {
    int l = this.kinds.length;
    String[] k = new String[l + 1];
    System.arraycopy(this.kinds, 0, k, 0, l);
    k[l] = s;
    this.kinds = k;
  }

  @Override
  public String toString() {
    return id;
  }

  public int numberOfOutEdges() {
    return Sequence.fromIterable(outEdges()).count();
  }

  public Iterable<JNEdge> outEdges() {
    return Sequence.fromIterable(graph.edges()).where((it) -> it.from() == JNNode.this);
  }

  public boolean hasOutEdges() {
    return Sequence.fromIterable(outEdges()).count() > 0;
  }

  public Iterable<JNNode> outNeighbors() {
    return Sequence.fromIterable(this.outEdges()).select((it) -> it.to());
  }

  public Iterable<JNEdge> inEdges() {
    return Sequence.fromIterable(graph.edges()).where((it) -> it.to() == JNNode.this);
  }

  public Iterable<JNEdge> connectedEdges() {
    return Sequence.fromIterable(graph.edges()).where((it) -> it.to() == JNNode.this || it.from() == JNNode.this);
  }

  public int characteristicSize() {
    return this.characteristicSize;
  }

  public float relativeEdgeNumber() {
    Tuples._2<Integer, Integer> outEdges = graph.numberOfOutEdges();
    int range = (int) outEdges._1() - (int) outEdges._0();
    return ((float) this.numberOfOutEdges()) / ((float) range);
  }

  public float relativeCharacteristicSize() {
    Tuples._2<Integer, Integer> characteristicSizes = graph.characteristicVertexSizes();
    int range = (int) characteristicSizes._1() - (int) characteristicSizes._0();
    int cs = this.characteristicSize();
    return ((float) cs) / ((float) range);
  }

  public Iterable<JNNode> outReachableNodes() {
    final Set<JNNode> res = SetSequence.fromSet(new HashSet<JNNode>());
    Sequence.fromIterable(this.outNeighbors()).visitAll((it) -> it.collectReachableNodes(res));
    return res;
  }

  private void collectReachableNodes(final Set<JNNode> result) {
    if (SetSequence.fromSet(result).contains(this)) {
      return;
    }
    SetSequence.fromSet(result).addElement(this);
    Sequence.fromIterable(this.outEdges()).visitAll((it) -> it.to().collectReachableNodes(result));
  }

  public boolean isOutReachable(JNNode n) {
    return Sequence.fromIterable(outReachableNodes()).contains(n);
  }

  public void setContinuousAxisOne(long val) {
    this.continuousAxisOne = val;
  }

  public long continuousAxisOneValue() {
    return this.continuousAxisOne;
  }
  public boolean hasContinuousAxisOneValue() {
    return this.continuousAxisOne >= 0;
  }


}
