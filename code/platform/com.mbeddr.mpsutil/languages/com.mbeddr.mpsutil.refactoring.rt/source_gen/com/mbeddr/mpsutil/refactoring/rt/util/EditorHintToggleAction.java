package com.mbeddr.mpsutil.refactoring.rt.util;

/*Generated by MPS */

import com.intellij.openapi.actionSystem.ToggleAction;
import org.jetbrains.annotations.Nullable;
import com.intellij.openapi.actionSystem.AnActionEvent;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.actionSystem.CommonDataKeys;
import jetbrains.mps.nodeEditor.EditorComponent;
import jetbrains.mps.ide.editor.MPSEditorDataKeys;
import jetbrains.mps.ide.project.ProjectHelper;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import jetbrains.mps.nodeEditor.hintsSettings.ConceptEditorHintSettingsComponent;
import java.util.Set;
import java.util.Arrays;
import jetbrains.mps.ide.editor.util.EditorComponentUtil;
import com.intellij.openapi.fileEditor.FileEditorManager;
import com.intellij.openapi.application.ApplicationManager;
import org.jetbrains.annotations.NotNull;
import com.intellij.openapi.actionSystem.ActionUpdateThread;

public abstract class EditorHintToggleAction extends ToggleAction {

  private String[] hintsToRemove = null;


  public EditorHintToggleAction(@Nullable String text) {
    super(text);
  }
  public EditorHintToggleAction(@Nullable String text, String... hintsToRemove) {
    super(text);
    this.hintsToRemove = hintsToRemove;
  }

  @Override
  public void update(final AnActionEvent event) {
    super.update(event);

    final Project project = event.getData(CommonDataKeys.PROJECT);
    if (project != null) {
      final EditorComponent editorComponent = event.getData(MPSEditorDataKeys.EDITOR_COMPONENT);
      if (editorComponent != null) {
        ProjectHelper.getModelAccess(project).runReadAction(new Runnable() {
          public void run() {
            SNode editedNode = editorComponent.getEditedNode();
            boolean editorContainsReqConcepts = ListSequence.fromList(SNodeOperations.getNodeDescendants(editedNode, SNodeOperations.asSConcept(getRequiredConcept()), true, new SAbstractConcept[]{})).isNotEmpty();
            event.getPresentation().setVisible(editorContainsReqConcepts);
          }
        });
        return;
      }
    }
    event.getPresentation().setVisible(false);
  }

  public boolean isSelected(AnActionEvent event) {
    final Project project = event.getData(CommonDataKeys.PROJECT);
    if (project == null) {
      return false;
    }
    ConceptEditorHintSettingsComponent settingsInstance = ConceptEditorHintSettingsComponent.getInstance(project);
    return settingsInstance.getState().getEnabledHints().contains(getHintID());
  }

  public void setSelected(AnActionEvent event, boolean pushHint) {
    final Project project = event.getData(CommonDataKeys.PROJECT);
    ConceptEditorHintSettingsComponent settingsInstance = ConceptEditorHintSettingsComponent.getInstance(project);

    Set<String> enabledHints = settingsInstance.getState().getEnabledHints();
    if (pushHint) {
      if (hintsToRemove != null) {
        enabledHints.removeAll(Arrays.asList(hintsToRemove));
      }

      enabledHints.add(getHintID());
    } else {
      enabledHints.remove(getHintID());
    }

    ConceptEditorHintSettingsComponent.HintsState newState = new ConceptEditorHintSettingsComponent.HintsState();
    newState.setEnabledHints(enabledHints);
    settingsInstance.loadState(newState);
    ProjectHelper.getModelAccess(project).runReadAction(new Runnable() {
      public void run() {
        for (EditorComponent component : EditorComponentUtil.getAllEditorComponents(FileEditorManager.getInstance(project), true)) {
          component.rebuildEditorContent();
        }
      }
    });
    ApplicationManager.getApplication().saveAll();
  }


  @NotNull
  @Override
  public ActionUpdateThread getActionUpdateThread() {
    return ActionUpdateThread.EDT;
  }

  protected abstract String getHintID();
  protected abstract SAbstractConcept getRequiredConcept();

}
