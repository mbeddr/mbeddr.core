package com.mbeddr.mpsutil.refactoring.rt.util;

/*Generated by MPS */

import com.intellij.openapi.actionSystem.ToggleAction;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import org.jetbrains.annotations.Nullable;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.Arrays;
import com.intellij.openapi.actionSystem.AnActionEvent;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.actionSystem.CommonDataKeys;
import jetbrains.mps.nodeEditor.EditorComponent;
import jetbrains.mps.ide.editor.MPSEditorDataKeys;
import jetbrains.mps.ide.project.ProjectHelper;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import jetbrains.mps.nodeEditor.hintsSettings.ConceptEditorHintSettingsComponent;
import jetbrains.mps.ide.editor.util.EditorComponentUtil;
import com.intellij.openapi.fileEditor.FileEditorManager;
import org.jetbrains.annotations.NotNull;
import com.intellij.openapi.actionSystem.ActionUpdateThread;

public abstract class NoHintToggleAction extends ToggleAction {

  private Set<String> hintsToCheck = SetSequence.fromSet(new HashSet<String>());


  public NoHintToggleAction(@Nullable String text, String... hintsToCheck) {
    super(text);
    SetSequence.fromSet(this.hintsToCheck).addSequence(ListSequence.fromList(Arrays.asList(hintsToCheck)));
  }

  @Override
  public void update(final AnActionEvent event) {
    super.update(event);

    final Project project = event.getData(CommonDataKeys.PROJECT);
    if (project != null) {
      final EditorComponent editorComponent = event.getData(MPSEditorDataKeys.EDITOR_COMPONENT);
      if (editorComponent != null) {
        ProjectHelper.getModelAccess(project).runReadAction(new Runnable() {
          public void run() {
            SNode editedNode = editorComponent.getEditedNode();
            boolean editorContainsReqConcepts = ListSequence.fromList(SNodeOperations.getNodeDescendants(editedNode, SNodeOperations.asSConcept(getRequiredConcept()), true, new SAbstractConcept[]{})).isNotEmpty();
            event.getPresentation().setVisible(editorContainsReqConcepts);
          }
        });
        return;
      }
    }
    event.getPresentation().setVisible(false);
  }

  public boolean isSelected(AnActionEvent event) {
    final Project project = event.getData(CommonDataKeys.PROJECT);
    if (project == null) {
      return false;
    }
    ConceptEditorHintSettingsComponent settingsInstance = ConceptEditorHintSettingsComponent.getInstance(project);
    Set<String> enabledHints = (settingsInstance.getState().getEnabledHints());
    for (String h : hintsToCheck) {
      if (enabledHints.contains(h)) {
        return false;
      }
    }
    return true;
  }

  public void setSelected(AnActionEvent event, boolean pushHint) {
    final Project project = event.getData(CommonDataKeys.PROJECT);
    ConceptEditorHintSettingsComponent settingsInstance = ConceptEditorHintSettingsComponent.getInstance(project);

    Set<String> enabledHints = settingsInstance.getState().getEnabledHints();
    System.err.println("hints to remove:" + hintsToCheck);

    for (String h : hintsToCheck) {
      enabledHints.remove(h);
    }
    System.err.println("remaining: " + enabledHints);

    ConceptEditorHintSettingsComponent.HintsState newState = new ConceptEditorHintSettingsComponent.HintsState();
    newState.setEnabledHints(enabledHints);
    settingsInstance.loadState(newState);
    ProjectHelper.getModelAccess(project).runReadAction(new Runnable() {
      public void run() {
        for (EditorComponent component : EditorComponentUtil.getAllEditorComponents(FileEditorManager.getInstance(project), true)) {
          component.rebuildEditorContent();
        }
      }
    });
  }

  @NotNull
  @Override
  public ActionUpdateThread getActionUpdateThread() {
    return ActionUpdateThread.EDT;
  }

  protected abstract SAbstractConcept getRequiredConcept();

}
