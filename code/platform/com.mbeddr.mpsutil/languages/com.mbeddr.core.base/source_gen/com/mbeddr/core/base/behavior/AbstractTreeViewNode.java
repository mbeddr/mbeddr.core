package com.mbeddr.core.base.behavior;

/*Generated by MPS */

import jetbrains.mps.logging.Logger;
import javax.swing.Icon;
import jetbrains.mps.project.Project;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import jetbrains.mps.smodel.ModelAccess;
import java.util.List;
import java.util.ArrayList;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.internal.collections.runtime.Sequence;
import com.mbeddr.mpsutil.filepicker.behavior.SolutionUtil;
import java.io.File;
import java.net.URL;
import com.intellij.openapi.util.IconLoader;
import java.net.MalformedURLException;

public abstract class AbstractTreeViewNode {
  private static final Logger LOG = Logger.getLogger(AbstractTreeViewNode.class);

  protected Icon icon;
  protected String label;
  protected AbstractTreeViewNode parent;
  protected String toolTipText;
  protected String category;
  protected String[] allCategories;
  protected boolean doubleClickSelectsNode = true;
  protected ICustomTreeBuilder builder;

  protected Project project;

  public AbstractTreeViewNode(String label, Icon icon, String category, String[] categories) {
    this(label, icon, category, categories, null);
  }

  public AbstractTreeViewNode(String label, Icon icon, String category, String[] categories, ICustomTreeBuilder builder) {
    this.label = label;
    this.icon = icon;
    this.category = category;
    this.allCategories = categories;
    this.builder = builder;
  }

  public void setProject(Project p) {
    this.project = p;
  }

  public Project getProject() {
    return this.project;
  }

  public ICustomTreeBuilder getBuilder() {
    return this.builder;
  }

  public final int getChildCount() {
    final Wrappers._int count = new Wrappers._int();
    ModelAccess.instance().runReadAction(() -> count.value = getChildCountFromModel());
    return count.value;
  }

  public String getTooltipText() {
    return this.toolTipText;
  }

  public final List<AbstractTreeViewNode> getChildren() {
    final Wrappers._T<List<AbstractTreeViewNode>> cs = new Wrappers._T<List<AbstractTreeViewNode>>();
    ModelAccess.instance().runReadAction(() -> cs.value = getChildrenFromModel());
    return cs.value;
  }

  public abstract List<AbstractTreeViewNode> getChildrenFromModel();

  public abstract int getChildCountFromModel();



  public String getLabel() {
    return this.label;
  }

  public Icon getIcon() {
    return this.icon;
  }

  public List<TreeViewAction> getActions() {
    return null;
  }

  public String getCategory() {
    return category;
  }

  public String[] getAllCategories() {
    if (allCategories == null) {
      return new String[]{};
    }
    return allCategories;
  }

  protected List<TreeViewAction> oneAction(TreeViewAction action) {
    List<TreeViewAction> res = new ArrayList<TreeViewAction>();
    res.add(action);
    return res;
  }
  protected List<TreeViewAction> twoActions(TreeViewAction a1, TreeViewAction a2) {
    List<TreeViewAction> res = new ArrayList<TreeViewAction>();
    res.add(a1);
    res.add(a2);
    return res;
  }

  protected List<AbstractTreeViewNode> oneNode(AbstractTreeViewNode child) {
    List<AbstractTreeViewNode> res = new ArrayList<AbstractTreeViewNode>();
    res.add(child);
    return res;
  }
  protected List<AbstractTreeViewNode> twoNodes(AbstractTreeViewNode c1, AbstractTreeViewNode c2) {
    List<AbstractTreeViewNode> res = new ArrayList<AbstractTreeViewNode>();
    res.add(c1);
    res.add(c2);
    return res;
  }

  public boolean selectOnDoubleClick() {
    return doubleClickSelectsNode;
  }

  public List<AbstractTreeViewNode> getTheirTreeNodes(Iterable<SNode> itv, final String cat) {
    return Sequence.fromIterable(itv).select((it) -> ((AbstractTreeViewNode) ITreeViewable__BehaviorDescriptor.getTreeNode_id7NyyyjNtbn2.invoke(it, cat))).toList();
  }


  public List<AbstractTreeViewNode> getItsTreeNodes(SNode itv, String cat) {
    return oneNode(ITreeViewable__BehaviorDescriptor.getTreeNode_id7NyyyjNtbn2.invoke(itv, cat));
  }

  protected Icon loadIconFromNodesModule(SNode n, String moduleRelativeFileName) {
    String solPath = SolutionUtil.getSolutionRootPathForNode(n);
    String fullName = solPath + "/" + moduleRelativeFileName;

    // todo [Mihail Muhin]: consider using icon{} expression from resources language
    File iconFile = new File(fullName);
    if (!(iconFile.exists())) {
      if (LOG.isErrorLevel()) {
        LOG.error("image file not found: " + fullName);
      }
      return null;
    }

    try {
      URL iconUrl = iconFile.toURI().toURL();
      return IconLoader.findIcon(iconUrl, true);
    } catch (MalformedURLException e) {
      if (LOG.isErrorLevel()) {
        LOG.error("can't convert icon path to url: " + fullName, e);
      }
      return null;
    }
  }


  public AbstractTreeViewNode setParent(AbstractTreeViewNode parent) {
    this.parent = parent;
    return this;
  }


  public AbstractTreeViewNode getParent() {
    return this.parent;
  }

  public AbstractTreeViewNode getRoot() {
    if (this.parent != null) {
      return this.parent.getRoot();
    }
    return this;
  }

  public SNode getProgramNode() {
    return null;
  }

  public SNode getParentProgramNode() {
    if (parent instanceof NodeTreeViewNode) {
      return ((NodeTreeViewNode) parent).getProgramNode();
    }
    return null;
  }

  public SNode getRootProgramNode() {
    AbstractTreeViewNode root = getRoot();
    if (root instanceof NodeTreeViewNode) {
      return ((NodeTreeViewNode) root).getProgramNode();
    }
    return null;
  }



  public TreeNodeStyle getStyle() {
    return TreeNodeStyle.DEFAULT;
  }

}
