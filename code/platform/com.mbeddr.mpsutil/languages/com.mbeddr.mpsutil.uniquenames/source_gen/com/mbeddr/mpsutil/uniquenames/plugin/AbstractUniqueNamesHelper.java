package com.mbeddr.mpsutil.uniquenames.plugin;

/*Generated by MPS */

import java.util.Map;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.LinkedHashMap;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.LinkedHashSet;
import org.apache.commons.lang3.StringUtils;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.internal.collections.runtime.IMapping;
import jetbrains.mps.internal.collections.runtime.IterableUtils;

public abstract class AbstractUniqueNamesHelper {
  protected class UniqueNamesException extends RuntimeException {

  }

  private static final int FALLBACK_LIMIT = 314;

  private final Map<String, Map<String, String>> names = MapSequence.fromMap(new LinkedHashMap<String, Map<String, String>>(16, (float) 0.75, false));
  protected final Set<String> stopwords = SetSequence.fromSetAndArray(new LinkedHashSet<String>(), "com", "net", "org");
  protected final String delimiter;

  protected AbstractUniqueNamesHelper() {
    this(".");
  }

  protected AbstractUniqueNamesHelper(String delimiter) {
    this.delimiter = delimiter;
  }

  protected String getUniqueDistinguisher(String presentation, String fqName) {
    assureNameExists(presentation, fqName);
    return MapSequence.fromMap(MapSequence.fromMap(names).get(presentation)).get(fqName);
  }

  protected void assureNameExists(String presentation, String fqName) {

    if (MapSequence.fromMap(names).containsKey(presentation) && MapSequence.fromMap(MapSequence.fromMap(names).get(presentation)).containsKey(fqName)) {
      return;
    }

    if (!(MapSequence.fromMap(names).containsKey(presentation))) {
      MapSequence.fromMap(names).put(presentation, MapSequence.fromMap(new LinkedHashMap<String, String>(16, (float) 0.75, false)));
    }

    if (!(MapSequence.fromMap(MapSequence.fromMap(names).get(presentation)).containsKey(fqName))) {
      MapSequence.fromMap(MapSequence.fromMap(names).get(presentation)).put(fqName, "");
    }

    final Map<String, String> samePairs = MapSequence.fromMap(names).get(presentation);

    if (MapSequence.fromMap(samePairs).count() == 1) {
      return;
    }

    String[] fqNames = SetSequence.fromSet(MapSequence.fromMap(samePairs).keySet()).toGenericArray(String.class);

    final int indexOfDifference = Math.max(StringUtils.indexOfDifference(fqNames), 0);

    final Map<String, List<String>> nameParts = MapSequence.fromMap(new LinkedHashMap<String, List<String>>(16, (float) 0.75, false));

    MapSequence.fromMap(samePairs).visitAll((it) -> {
      String differenceToEnd = it.key().substring(indexOfDifference);
      String differenceFirstPart;
      do {
        differenceFirstPart = StringUtils.substringBefore(differenceToEnd, delimiter);
        differenceToEnd = StringUtils.substringAfter(differenceToEnd, differenceFirstPart + delimiter);
      } while (SetSequence.fromSet(stopwords).contains(differenceFirstPart));
      MapSequence.fromMap(nameParts).put(it.key(), ListSequence.fromListAndArray(new ArrayList<String>(), differenceFirstPart));
    });

    boolean foundCollision;
    int fallbackCount = 0;
    do {
      foundCollision = false;
      List<IMapping<String, List<String>>> list = MapSequence.fromMap(nameParts).sort((it) -> IterableUtils.join(ListSequence.fromList(it.value()), delimiter), true).toList();
      for (int i = 0; i < ListSequence.fromList(list).count() - 1; i++) {
        IMapping<String, List<String>> current = ListSequence.fromList(list).getElement(i);
        IMapping<String, List<String>> next = ListSequence.fromList(list).getElement(i + 1);
        if (IterableUtils.join(ListSequence.fromList(current.value()), delimiter).equals(IterableUtils.join(ListSequence.fromList(next.value()), delimiter))) {
          fallbackCount++;
          foundCollision = true;
          try {
            insertNextFqPart(current);
            insertNextFqPart(next);
            if (fallbackCount >= FALLBACK_LIMIT) {
              throw new UniqueNamesException();
            }
          } catch (UniqueNamesException e) {
            MapSequence.fromMap(nameParts).visitAll((it) -> MapSequence.fromMap(samePairs).put(it.key(), it.key()));

            return;
          }
        }
      }
    } while (foundCollision);

    MapSequence.fromMap(nameParts).visitAll((it) -> MapSequence.fromMap(samePairs).put(it.key(), IterableUtils.join(ListSequence.fromList(it.value()), delimiter) + ((ListSequence.fromList(it.value()).isNotEmpty() ? delimiter : ""))));
  }

  protected void insertNextFqPart(IMapping<String, List<String>> entry) {
    int index = ListSequence.fromList(entry.value()).count();
    String existingEntries = IterableUtils.join(ListSequence.fromList(entry.value()), delimiter) + delimiter;
    String nextPart;
    int fallbackCount = 0;
    do {
      fallbackCount++;
      nextPart = StringUtils.substringBetween(entry.key(), existingEntries, delimiter);
      existingEntries += delimiter + nextPart;
      if (fallbackCount >= FALLBACK_LIMIT) {
        throw new UniqueNamesException();
      }
    } while (SetSequence.fromSet(stopwords).contains(nextPart));
    ListSequence.fromList(entry.value()).insertElement(index, nextPart);
  }
}
