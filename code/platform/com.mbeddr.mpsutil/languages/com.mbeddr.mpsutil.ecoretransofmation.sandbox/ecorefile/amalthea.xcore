/**
 * *******************************************************************************
 *  Copyright (c) 2016 Robert Bosch GmbH and others.
 *  All rights reserved. This program and the accompanying materials
 *  are made available under the terms of the Eclipse Public License v1.0
 *  which accompanies this distribution, and is available at
 *  http://www.eclipse.org/legal/epl-v10.html
 * *******************************************************************************
 */
 
 
 @GenModel(
	modelName="Amalthea", prefix="Amalthea",
	editDirectory="/org.eclipse.app4mc.amalthea.model.edit/src-gen",
	rootExtendsClass="org.eclipse.app4mc.amalthea.sphinx.AmaltheaExtendedEObjectImpl",
	providerRootExtendsClass="org.eclipse.app4mc.amalthea.sphinx.AmaltheaExtendedItemProviderAdapter",
	creationIcons="false",
	forceOverwrite="true",
	creationSubmenus="true",
	generateSchema="true",
	loadInitialization="false",
	dynamicTemplates="true",
	templateDirectory="org.eclipse.app4mc.amalthea.model/templates",
	copyrightText="*******************************************************************************\r\n Copyright (c) 2016 Robert Bosch GmbH and others.\r\n All rights reserved. This program and the accompanying materials\r\n are made available under the terms of the Eclipse Public License v1.0\r\n which accompanies this distribution, and is available at\r\n http://www.eclipse.org/legal/epl-v10.html\r\n\r\n    Generated using Eclipse EMF\r\n\r\n*******************************************************************************"
)

@Ecore(
	nsPrefix="am",
	nsURI="http://app4mc.eclipse.org/amalthea/0.7.1"
)

package org.eclipse.app4mc.amalthea.model

import java.net.URLEncoder
import java.nio.charset.StandardCharsets


 /**
 * ===============================================================================
 * ===============================================================================
 * 
 * 								Central Model
 * 
 * ===============================================================================
 * ===============================================================================
 */

 class Amalthea extends BaseObject {
	contains resolving SWModel swModel
	contains resolving HWModel hwModel
	contains resolving OSModel osModel
	contains resolving StimuliModel stimuliModel
	contains resolving ConstraintsModel constraintsModel
	contains resolving EventModel eventModel
	contains resolving PropertyConstraintsModel propertyConstraintsModel	
	contains resolving MappingModel mappingModel
	contains resolving ConfigModel configModel
	contains resolving ComponentsModel componentsModel
}


/**
 * ===============================================================================
 * ===============================================================================
 * 
 * 								Common Model
 * 
 * ===============================================================================
 * ===============================================================================
 */


/*
 * Base classes to be used to provide common functionality for all objects.
 * Needs to be extended by other classes.
 */
abstract class BaseObject extends IAnnotatable
{
}

abstract class ReferableObject extends IReferable
{
}

abstract class ReferableBaseObject extends IAnnotatable, IReferable
{
}

/*
 * IAnnotatable: Possibility to store custom properties on elements
 */
interface IAnnotatable
{
	contains resolving CustomProperty[] customProperties
}

/*
 * ITaggable: Possibility to add tags to an elements
 */
interface ITaggable
{
	refers Tag[] tags
}

/*
 * IReferable: Name attribute and computed ID for name based references
 */
interface IReferable
{
	@GenModel(propertyCategory="Main")
	String name
	// use IPropertySheetEntry.FILTER_ID_EXPERT ("org.eclipse.ui.views.properties.expert")
	@GenModel(propertyCategory="Read only", propertyFilterFlags="org.eclipse.ui.views.properties.expert")
	id derived readonly String uniqueName get {
		return computeUniqueName()
	}
	@GenModel(documentation="Overwrite this method to define specific IDs (used by name-based references).")
	op String computeUniqueName() {
		return encode(name) + "?type=" + eClass.name
	}
	op String encode(String str) {
		return (if (str.nullOrEmpty) "no-name" else URLEncoder.encode(str, StandardCharsets.UTF_8.toString))
	}
}

interface IDisplayName
{
	String displayName
}
/*
 * A tag for processes, runnables, events and labels
 */
class Tag extends ReferableBaseObject
{
	// String tagName -> replaced by attribute "name"
	String tagType
}

/*
 * Time unit enumeration for available units.
 */
enum TimeUnit
{
	_undefined_ // Display: "<unit>"
	s
	ms
	us
	ns
	ps
}

abstract class AbstractTime {
	int value="0"
	TimeUnit unit
	
	op String toString() {
		return value + " " + if (unit == TimeUnit::_UNDEFINED_ ) "<unit>" else unit.literal
	}
}

/*
 * General time class to use including value and given time unit.
 */
class Time extends AbstractTime
{
	op boolean containerNotificationRequired() {
		return true
	}
}

/*
 * Like the general time class but it is explicit allows to define negative time values
 */
class SignedTime extends AbstractTime
{
	op boolean containerNotificationRequired() {
		return true
	}
}

/*
 * Frequency unit enumeration for available units
 */
enum FrequencyUnit {
	_undefined_ // Display: "<unit>"
	Hz
	kHz
	MHz
	GHz
//	rpm ???
}

/*
 * General frequency class to define a frequency value
 */
class Frequency {
	FrequencyUnit unit
	double value="0.0"
	
	op boolean containerNotificationRequired() {
		return true
	}
	
	op String toString() {
		return value + " " +  if (unit == FrequencyUnit::_UNDEFINED_ ) "<unit>" else unit.literal
	}
}

/*
 * Representing data sizes
 */
enum DataSizeUnit {
	_undefined_ // Display: "<unit>"
	bit
	kbit
	Mbit
	Gbit
	Tbit
	
	kibit
	Mibit
	Gibit
	Tibit
	
	byte
	kB
	MB
	GB
	TB
	
	KiB
	MiB
	GiB
	TiB
}

class DataSize {
	BigInteger value="0"
	DataSizeUnit unit
	
	op String toString() {
		return value + " " +  if (unit == DataSizeUnit::_UNDEFINED_ ) "<unit>" else unit.literal
	}
	
	/*
	 * Convenience methods to retrieve the size in Bits and Bytes
	 */
	op long getNumberBits() {
		return AmaltheaServices.convertToBit(this).longValue
	}
	
	op long getNumberBytes() {
		return Math::ceil(getNumberBits() / 8).longValue
	}
}

/*
 * Representing data rates
 */
enum DataRateUnit {
	_undefined_ // Display: "<unit>"
	bitPerSecond // Display: "bit/s"
	kbitPerSecond
	MbitPerSecond
	GbitPerSecond
	TbitPerSecond
	
	kibitPerSecond
	MibitPerSecond
	GibitPerSecond
	TibitPerSecond
	
	bytePerSecond
	kBPerSecond
	MBPerSecond
	GBPerSecond
	TBPerSecond
	
	KiBPerSecond
	MiBPerSecond
	GiBPerSecond
	TiBPerSecond
}

class DataRate {
	BigInteger value ="0"
	DataRateUnit unit
	
	op String toString() {
		return value + " " +  if (unit == DataRateUnit::_UNDEFINED_ ) "<unit>" else unit.literal.replace("PerSecond", "/s")
	}
	
}

/*
 * custom property container for map
 */
class CustomProperty wraps java.util.Map$Entry
{
	String[1] key
	contains resolving Value[1] value
}

/*
 * Abstract generalization of a value entry. 
 */
abstract class Value
{
	op boolean containerNotificationRequired() {
		return true
	}
}

class ListObject extends Value {
	contains resolving Value[] values
	op String toString() {
		return "(List)"
	}
}

/*
 * Object for using the elementary datatype String as generic parameter
 */
class StringObject extends Value{
	String[1] value
	op String toString() {
		if (value == null)
			return "(String) null"
		else
			return "(String) \"" + value + "\""
	}
}

/*
 * Object for using the elementary datatype String as generic parameter
 */
class BigIntegerObject extends Value{ 
	BigInteger[1] value ="0"
	op String toString() {
		if (value == null)
			return "(BigInteger) null"
		else
			return "(BigInteger) \"" + value + "\""
	}
}

/*
 * Object for using object reference as generic parameter
 */
class ReferenceObject extends Value
{
	refers IReferable value
	op String toString() {
		if (value == null)
			return "(Reference) null"
		else
			return "(Reference) " + value.eClass.name + " \"" + value.name + "\""
	}
}

/*
 * Object for using the elementary datatype integer as generic parameter
 */
class IntegerObject extends Value{
	int[1] value="0"
	op String toString() {
		return "(int) " + value
	}
}

/*
 * Object for using the elementary datatype long as generic parameter
 */
class LongObject extends Value{
	long[1] value="0"
	op String toString() {
		return "(long) " + value
	}
}

/*
 * Object for using the elementary datatype float as generic parameter
 */
class FloatObject extends Value{
	float[1] value="0f"
	op String toString() {
		return "(float) " + value
	}
}

/*
 * Object for using the elementary datatype double as generic parameter
 */
class DoubleObject extends Value{
	double[1] value="0.0"
	op String toString() {
		return "(double) " + value
	}
}

/*
 * Object for using the elementary datatype boolean as generic parameter
 */
class BooleanObject extends Value{
	boolean[1] value ="false"
	op String toString() {
		return "(boolean) " + value
	}
}

class TimeObject extends AbstractTime, Value {
	op String toString() {
		return "(Time) " + super.toString
	}
}

class SignedTimeObject extends AbstractTime, Value {
	op String toString() {
		return "(SignedTime) " + super.toString
	}
}

/*
 *
 * The types of sampling
 */
enum SamplingType
{
	^default // Display: "<sampling>"
	BestCase
	WorstCase
	AverageCase
	CornerCase
	Uniform
}

class Deviation<T>{
	contains resolving T lowerBound
	contains resolving T upperBound
	contains resolving Distribution<T> distribution
	SamplingType samplingType
	
	op boolean containerNotificationRequired() {
		return true
	}
}

/*
 * Abstract generic distribution class
 * The generic class T defines the data-type of the value-range of the distribution
 */
abstract class Distribution<T>
{
}

/*
 * Abstract weibull distribution
 */
abstract class WeibullDistribution<T> extends Distribution<T>
{
}

/*
 * Weibull Distribution
 * Starts from zero, upperBound limits maximum value of result
 */
class WeibullParameters<T> extends WeibullDistribution<T>
{
	double kappa="0.0"
	double lambda="0.0"
}

/*
 * Weibull Distribution
 * The parameter of a weibull distribution (kappa, lambda...) are calculated from the estimators minimum, maximum and average. 
 */
class WeibullEstimators<T> extends WeibullDistribution<T>
{
	contains resolving T mean
	double pRemainPromille="0.0"
}

/*
 * Continuous uniform distribution
 */
class UniformDistribution<T> extends Distribution<T>
{
}

/*
 * Defines the upper and lower bounds of a value interval without defining the distribution
 */
class Boundaries<T> extends Distribution<T>
{
}

/*
 * Gauss distribution
 */
class GaussDistribution<T> extends Distribution<T>{
	contains resolving T sd
	contains resolving T mean
}

/*
 * Beta distribution
 */
class BetaDistribution<T> extends Distribution<T>{
	double alpha="0.0"
	double beta="0.0"
}
interface NumericStatistic
{
}

/*
 * Statistic to provide capabilities for min, max and avg
 */
class MinAvgMaxStatistic extends NumericStatistic
{
	int min="0"
	int avg="0"
	int max="0"
}

class SingleValueStatistic extends NumericStatistic
{
	float value="0f"
}

/*
 * Modes
 */
class Mode extends ReferableBaseObject 
{
	contains resolving ModeLiteral [] literals	
}

class ModeLiteral extends ReferableBaseObject 
{
	op String computeUniqueName() {
		val containerName = encode(eContainer?.eGet(eClass.getEStructuralFeature("name")) as String)
		return containerName + "/" + super.computeUniqueName
	}
	
	op String toString() {
		val modeName = eContainer?.eGet(eClass.getEStructuralFeature("name")) as String
		return (if (modeName.nullOrEmpty) "<mode>" else modeName) + "::" + (if (name.nullOrEmpty) "<literal>" else name)
	}
}

interface ModeValueProvider extends IAnnotatable, IReferable
{
	refers Mode mode
	refers ModeLiteral initialValue
}


/**
 * ===============================================================================
 * ===============================================================================
 * 
 * 								Components Model
 * 
 * ===============================================================================
 * ===============================================================================
 */


class ComponentsModel extends BaseObject {
	contains resolving Tag[] tags
	contains Component[] components
	contains System[] systems
}

interface INamedElement {
	String name
}

interface ISystem {
	contains ComponentInstance[] componentInstances
	contains Connector[] connectors
	contains QualifiedPort[] groundedPorts
	
	@GenModel(propertyCategory="Read only", propertyFilterFlags="org.eclipse.ui.views.properties.expert")
	refers derived readonly QualifiedPort[] innerPorts get {
		AmaltheaServices.getInnerPorts(this);
	}
}


abstract class Port extends ReferableBaseObject, ITaggable {
	op String computeUniqueName() {
		val containerName = encode(eContainer?.eGet(eClass.getEStructuralFeature("name")) as String)
		return containerName + "/" + super.computeUniqueName
	}
}

class Component extends ReferableBaseObject, ITaggable {
	contains Port[] ports
	refers AbstractProcess[] tasks
	refers Runnable[] runnables
	refers Label[] labels
	refers Semaphore[] semaphores
	refers OsEvent[] osEvents
}

class Composite extends Component, ISystem {
}

class System extends ReferableBaseObject, ITaggable, ISystem {
}

class ComponentInstance extends ReferableBaseObject, ITaggable {
	refers Component ^type
}

class Connector extends BaseObject, INamedElement, ITaggable {
	contains QualifiedPort sourcePort
	contains QualifiedPort targetPort
}

class QualifiedPort extends BaseObject {
	refers ComponentInstance instance
	refers Port port
}

class FInterfacePort extends Port {
	InterfaceKind kind
	String interfaceName
}

enum InterfaceKind {
	_undefined_ // Display: "<kind>"
	provides // Display: "PROVIDES"
	requires // Display: "REQUIRES"
}


/**
 * ===============================================================================
 * ===============================================================================
 * 
 * 								Config Model
 * 
 * ===============================================================================
 * ===============================================================================
 */

class ConfigModel extends BaseObject
{
	contains resolving EventConfig[] eventsToTrace
}

abstract class EventConfig extends BaseObject
{
	String name
}

class EventConfigLink extends EventConfig
{
	refers EntityEvent[1] event
}

class EventConfigElement extends EventConfig
{
	contains EntityEvent[1] event
}


/**
 * ===============================================================================
 * ===============================================================================
 * 
 * 								Constraints Model
 * 
 * ===============================================================================
 * ===============================================================================
 */


class ConstraintsModel extends BaseObject
{
	///Event chains:
	contains resolving EventChain[] eventChains
	//Timing constraints
	contains resolving TimingConstraint[] timingConstraints
	//Affinity constraints
	contains resolving AffinityConstraint[] affinityConstraints
	//Runnable sequencing constraints
	contains resolving RunnableSequencingConstraint[] runnableSequencingConstraints
	contains resolving DataAgeConstraint[] dataAgeConstraints
	
	contains resolving Requirement [] requirements
	
	contains resolving DataCoherencyGroup [] dataCoherencyGroups
	contains resolving DataStabilityGroup [] dataStabilityGroups
	
	contains resolving PhysicalSectionConstraint[] physicalSectionConstraints
}

//////////////////////////Runnable Sequencing constraints (proposal)
enum RunnableOrderType{
	_undefined_ // Display: "<order>"
	successor
	immediateSuccessorStartSequence
	immediateSuccessorAnySequence
	immediateSuccessorEndSequence
}

class RunnableSequencingConstraint extends ReferableBaseObject
{
	RunnableOrderType orderType
	contains resolving ProcessRunnableGroup[2..*] runnableGroups
	refers AbstractProcess[] processScope
}

class ProcessRunnableGroup extends BaseObject
{
	refers Runnable[1..*] runnables
}

///////////////////////////Affinity constraints:
abstract class AffinityConstraint extends ReferableBaseObject
{
}

/*
 * A abstract superclass for all separation constraints
 */
abstract class SeparationConstraint extends AffinityConstraint
{
}

/*
 * A abstract superclass for all pairing constraints
 */
abstract class PairingConstraint extends AffinityConstraint
{
}

/*
 * A abstract superclass for all process related constraint
 * The target describes the entity on which the processes can be mapped
 */
abstract class ProcessConstraint
{
	contains resolving ProcessConstraintTarget target
}

/*
 * A abstract superclass for all runnable related constraint
 * The target describes the entity on which the runnables can be mapped
 */
abstract class RunnableConstraint
{
	contains resolving RunnableConstraintTarget target
}

/*
 * A abstract superclass for all data related constraint
 * The target describes the entity on which the data can be mapped
 */
abstract class DataConstraint
{
	contains resolving DataConstraintTarget target
}

/*
 * A runnable-separation-constraint
 * groups describes the runnable-groups that should be separated from each other on the target
 * if there is only one group then this means that the runnables of this group are not allowed to be executed on the target
 */
class RunnableSeparationConstraint extends SeparationConstraint, RunnableConstraint, BaseObject
{
	contains resolving RunnableGroup[1..2] groups
}

/*
 * A process-separation-constraint
 * groups describes the process-groups that should be separated from each other on the target
 * if there is only one group then this means that the processes of this group are not allowed to be executed on the target
 */
class ProcessSeparationConstraint extends SeparationConstraint, ProcessConstraint, BaseObject
{
	contains resolving ProcessGroup[1..2] groups
}

/*
 * A data-separation-constraint
 * groups describes the label-groups that should be separated from each other on the target
 * if there is only one group then this means that the label of this group is not allowed to be executed on the target
 */
class DataSeparationConstraint extends SeparationConstraint, DataConstraint, BaseObject
{
	contains resolving LabelEntityGroup[1..2] groups
}

/*
 * A runnable-pairing-constraint
 * runnables describes the group of runnables that should be paired on the target
 */
class RunnablePairingConstraint extends PairingConstraint, RunnableConstraint, BaseObject
{
	contains resolving RunnableGroup runnables
}

/*
 * A process-pairing-constraint
 * processes describes the group of processes that should be paired on the target
 */
class ProcessPairingConstraint extends PairingConstraint, ProcessConstraint, BaseObject
{
	contains resolving ProcessGroup processes
}

/*
 * A data-pairing-constraint
 * labels describes the group of labels that should be paired on the target
 */
class DataPairingConstraint extends PairingConstraint, DataConstraint, BaseObject
{
	contains resolving LabelEntityGroup labels
}

/*
 * A abstract superclass for all possible targets for runnable-constraints
 */
abstract class RunnableConstraintTarget
{
}

/*
 * A abstract superclass for all possible targets for process-constraints
 */
abstract class ProcessConstraintTarget
{
}

/*
 * A abstract superclass for all possible targets for data-constraints
 */
abstract class DataConstraintTarget
{
}

/*
 * A memory target description
 * A memory can be a target for data-constraints
 * memories: the reference to zero or more Memories. If this list is empty, the target stands for all memories! 
 */
class TargetMemory extends DataConstraintTarget, BaseObject

{
	refers Memory[] memories
}

/*
 * A core target description
 * A core can be a target for runnable-constraints, process-constraints and scheduler-constraints
 * cores: the reference to zero or more Cores. If this list is empty, the target stands for all cores! 
 */
class TargetCore extends RunnableConstraintTarget, ProcessConstraintTarget, BaseObject
{
	refers Core[] cores
}

/*
 * A scheduler target description
 * A scheduler can be a target for runnable-constraints and process-constraints
 * schedulers: the reference to zero or more Schedulers. If this list is empty, the target stands for all schedulers! 
 */
class TargetScheduler extends RunnableConstraintTarget, ProcessConstraintTarget, BaseObject
{
	refers Scheduler[] schedulers
}

/*
 * A process target description
 * A process can be a target only for runnable-constraints
 * processes: the reference zero or more Processes. If this list is empty, the target stands for all processes! 
 */
class TargetProcess extends RunnableConstraintTarget, BaseObject
{
	refers Process[] processes
}

/*
 * A call-sequence target description
 * A call-sequence can be a target only for runnable-constraints
 * callSequences: the reference to zero or more call-sequences. If this list is empty, the target stands for all call-sequences!
 */
class TargetCallSequence extends RunnableConstraintTarget, BaseObject
{
	refers CallSequence[] callSequences
}

/*
 * A abstract description for a group of runnables that can be paired or separated by a runnable-constraint
 */
abstract class RunnableGroup
{
}

/*
 * A abstract description for a group of processes that can be paired or separated by a process-constraint
 */
abstract class ProcessGroup
{
}

/*
 * A group of labels that can be paired or separated by a data-constraint
 */
class LabelEntityGroup extends BaseObject
{
	refers Label[] labels
}

/*
 * A group of runnables that can be paired or separated by a runnable-constraint
 */
class RunnableEntityGroup extends RunnableGroup, BaseObject
{
	refers Runnable[] runnables
}

/*
 * A group of processes that can be paired or separated by a process-constraint
 */
class ProcessEntityGroup extends ProcessGroup, BaseObject
{
	refers Process[] processes
}

/*
 * A group that contains only a tag and groups all objects that are marked with this tag
 * This can be runnables or processes
 */
class TagGroup extends RunnableGroup, ProcessGroup, BaseObject
{
	refers Tag tag
}

//////////////////////////Event chains & Timing constraints:
/*
 * Describes an event chain which must have a minimum of two events (stimulus and response)
 * If there are more events the event chain have to be divided into segments. Each segment is another event chain.
 * Alternative event paths are contained in strands.
 * stimulus: Beginning of chain
 * response: End of chain
 * segments: Sub event chains
 * strands: alternative event paths
 */
class EventChain extends ReferableBaseObject
{
	refers Event stimulus
	refers Event response
	contains resolving EventChainItem[] segments
	contains resolving EventChainItem[] strands
	op boolean containerNotificationRequired() {
		return true
	}
}

abstract class EventChainItem
{
}

class EventChainReference extends EventChainItem, BaseObject
{
	refers EventChain[1] eventChain
}

class SubEventChain extends EventChainItem, BaseObject
{
	contains resolving EventChain[1] eventChain
}

abstract class TimingConstraint extends ReferableBaseObject
{
}

 
/*
 * This contraints is used to limit a section in  Memories
 */
class PhysicalSectionConstraint extends ReferableBaseObject, BaseObject
{
	refers Section section
	refers Memory[+] memories
}

/*
 * Base class for synchronization constraints, which limit the distance between events
 * multipleOccurrencesAllowed: Defines whether multiple event occurrences are allowed for analysis
 * tolerance: Maximum allowed tolerance
 */
abstract class SynchronizationConstraint extends TimingConstraint
{
	boolean multipleOccurrencesAllowed ="false"
	contains resolving Time tolerance
}

/*
 * The synchronization constraint considers a group of events and limits the distance of the events within this group.
 */
class EventSynchronizationConstraint extends SynchronizationConstraint
{
	refers EntityEvent[] events	
}

enum SynchronizationType {
	_undefined_ // Display: "<synchronization>"
	Stimulus
	Response
}

/*
 * A synchronization constraint describes the allowed tolerance in synchronization between two event chains
 * scope: Considered event chains that have to by in sync
 * type: Defines which parts of the event chains have to be in sync
 */
class EventChainSynchronizationConstraint extends SynchronizationConstraint
{
	refers EventChain[2] scope
	SynchronizationType ^type
}

enum MappingType {
	_undefined_ // Display: "<mapping>"
	OneToOne
	Reaction
	UniqueReaction
}

/*
 * This constraint describes how a source and a target event are placed relative to each other
 */
class DelayConstraint extends TimingConstraint
{
	MappingType mappingType
	refers EntityEvent source
	refers EntityEvent target
	contains resolving Time upper
	contains resolving Time lower
}

enum LatencyType {
	_undefined_ // Display: "<latency>"
	Age
	Reaction
}

/*
 * A latency constraint describes the allowed range in latency between a stimulus and its response.
 * scope: Considered event chain that defines the stimulus and response relation
 * type: Defines the point of view (forward or backward)
 * minimum: Minimum allowed latency
 * maximum: Maximum allowed latency
 */
class EventChainLatencyConstraint extends TimingConstraint
{
	refers EventChain scope
	LatencyType ^type
	contains resolving Time minimum
	contains resolving Time maximum
}

/*
 * A repetition constraint prescribes the distribution of a single event during runtime.
 */
class RepetitionConstraint extends TimingConstraint
{
	refers EntityEvent event
	int span="0"
	contains resolving Time lower
	contains resolving Time upper
	contains resolving Time jitter
	contains resolving Time period
}

//////////////////////////Data Age Constraint
class DataAgeConstraint extends ReferableBaseObject
{
	refers Runnable[1] runnable
	refers Label[1] label
	contains resolving DataAge[1] dataAge
}

abstract class DataAge
{
}

class DataAgeCycle extends DataAge
{
	int minimumCycle="0"
	int maximumCycle="0"
}

class DataAgeTime extends DataAge
{
	contains resolving Time minimumTime
	contains resolving Time maximumTime
}

////////////////////////// Requirements

abstract class Requirement extends BaseObject 
{
	String name
	Severity severity
	contains resolving RequirementLimit limit 
}

class ProcessRequirement extends Requirement {
	refers AbstractProcess process
}

class RunnableRequirement extends Requirement {
	refers Runnable runnable
}

class ArchitectureRequirement extends Requirement {
	refers Component component
}

class ProcessChainRequirement extends Requirement {
	refers ProcessChain processChain
}

abstract class RequirementLimit {
	LimitType limitType
	
	op boolean containerNotificationRequired() {
		return true
	}
}

class CPUPercentageRequirementLimit extends RequirementLimit {
	CPUPercentageMetric metric
	double limitValue="0.0"
	// can be ECU, Processor or Core
	refers ComplexNode hardwareContext
}

class FrequencyRequirementLimit extends RequirementLimit {
	FrequencyMetric metric
	contains resolving Frequency limitValue
}

class PercentageRequirementLimit extends RequirementLimit {
	PercentageMetric metric
	double limitValue="0.0"
}

class CountRequirementLimit extends RequirementLimit {
	CountMetric metric
	int limitValue="0"
}

class TimeRequirementLimit extends RequirementLimit {
	TimeMetric metric
	// signed time is allowed because the requirement to lateness can be negative
	contains resolving SignedTime limitValue
}

enum Severity {
	_undefined_ // Display: "<severity>"
	Cosmetic
	Minor
	Major
	Critical
}

enum LimitType {
	_undefined_ // Display: "<limit>"
	UpperLimit
	LowerLimit
}

enum TimeMetric {
	_undefined_ // Display: "<time metric>"
	ActivateToActivate
	CoreExecutionTime
	EndToEnd
	GrossExecutionTime
	Lateness
	MemoryAccessTime
	NetExecutionTime
	OsOverhead
	ParkingTime
	PollingTime
	ReadyTime
	ResponseTime
	RunningTime
	StartDelay
	StartToStart
	WaitingTime
}

enum CountMetric {
	_undefined_ // Display: "<count metric>"
	Activations
	BoundedMigrations
	CacheHit
	CacheMiss
	FullMigrations
	MtaLimitExceeding
	Preemptions
}

enum PercentageMetric {
	_undefined_ // Display: "<% metric>"
	CacheHitRatio
	CacheMissRatio
	CoreExecutionTimeRelative
	MemoryAccessTimeRelative
	NormalizedLateness
	NormalizedResponseTime
	OsOverheadRelative
}

enum CPUPercentageMetric {
	_undefined_ // Display: "<CPU % metric>"
	CPUBuffering
	CPULoad
	CPUParking
	CPUPolling
	CPUReady
	CPURunning
	CPUWaiting
}

enum FrequencyMetric {
	_undefined_ // Display: "<frequency metric>"
	CacheHitFrequency
	CacheMissFrequency
}


//////////////////////////// Data Groups (Coherency and Stability)

class DataCoherencyGroup extends ReferableBaseObject {
	refers Label [] labels
	contains resolving DataGroupScope scope
	CoherencyDirection direction
}

enum CoherencyDirection {
	_undefined_ // Display: "<direction>"
	input
	output
}

class DataStabilityGroup extends ReferableBaseObject {
	refers Label [] labels
	contains resolving DataGroupScope scope
}

abstract class DataGroupScope {
	op boolean containerNotificationRequired() {
		return true
	}
}

class ProcessScope extends DataGroupScope {
	refers AbstractProcess process
}

class RunnableScope extends DataGroupScope {
	refers Runnable runnable
}

class ComponentScope  extends DataGroupScope {
	refers Component component
}


/**
 * ===============================================================================
 * ===============================================================================
 * 
 * 								Events Model
 * 
 * ===============================================================================
 * ===============================================================================
 */


class EventModel extends BaseObject
{
	contains resolving Event[] events
}

/*
 * An abstract event
 */
abstract class Event extends ReferableBaseObject
{
	String description
}

/*
 * A set of entity-events
 */
class EventSet extends Event
{
	refers EntityEvent[] events
}

/*
 * An abstract event that describes the notification of a changed state of an entity
 */
abstract class EntityEvent extends Event
{
}

class CustomEvent extends EntityEvent
{
	String eventType
}

/*
 * Describes the event of a stimulus. 
 * It contains only the stimulus but no event type because a stimulus has only one event type.
 */
class StimulusEvent extends EntityEvent
{
	refers Stimulus entity
}

/*
 * Describes the event of a process
 * eventType: The type of the Event
 * entity: The process that fires the event (optional)
 * core: The core that processes the process when the event is fired (optional) 
 */
class ProcessEvent extends EntityEvent
{
	ProcessEventType[1] eventType
	refers Process entity
	refers Core core
}

/*
 * Describes the event of some process within a process chain
 * eventType: The type of the Event
 * entity: The process that fires the event (optional)
 * core: The core that processes the process when the event is fired (optional) 
 */
class ProcessChainEvent extends EntityEvent
{
	ProcessEventType[1] eventType
	refers ProcessChain entity
	refers Core core
}

/*
 * Describes the event of a runnable
 * eventType: The type of event
 * entity: The runnable that fires the event (optional)
 * process: The process that executes the runnable (optional)
 * core: The core that processes the runnable (processes the process that executes the runnable) (optional) 
 */
class RunnableEvent extends EntityEvent
{
	RunnableEventType[1] eventType
	refers Runnable entity
	refers Process process
	refers Core core
}

/*
 * Describes the event of a label access
 * eventType: The type of event
 * entity: The accessed label that fires the event
 * runnable: The runnable that accesses the label (optional)
 * process: The process that accesses the label (optional)
 */
class LabelEvent extends EntityEvent
{
	LabelEventType[1] eventType
	refers Label entity
	refers Runnable runnable
	refers Process process
}

/*
 * Describes the event of a semaphore access
 * eventType: The type of event
 * entity: The accessed semaphore that fires the event
 * runnable: The runnable that accesses the semaphore (optional)
 * process: The process that accesses the semaphore (optional)
 * core: The core that processes the process/runnable that accesses the semaphore (optional)
 */
class SemaphoreEvent extends EntityEvent
{
	SemaphoreEventType[1] eventType
	refers Semaphore entity
	refers Runnable runnable
	refers Process process
	refers Core core
}

/*
 * The types of a process event
 */
enum ProcessEventType
{
	_all_
	activate
	deadline
	start
	resume
	preempt
	poll
	run
	wait
	poll_parking
	park
	release_parking
	release
	terminate
}

/*
 * The types of a runnable event
 */
enum RunnableEventType
{
	_all_
	start
	suspend
	resume
	terminate
}

/*
 * The types of a label event
 */
enum LabelEventType
{
	_all_
	read
	write
}

/*
 * the types of a semaphore event
 */
enum SemaphoreEventType
{
	_all_
	lock
	unlock
}


/**
 * ===============================================================================
 * ===============================================================================
 * 
 * 								HW Model
 * 
 * ===============================================================================
 * ===============================================================================
 */


class HWModel extends BaseObject {
	contains Tag[] tags
	// containments of all hardware type descriptions, i.e. Core(s), Memory(s), Network(s), ...
	contains SystemType[] systemTypes
	contains ECUType[] ecuTypes
	contains MicrocontrollerType[] mcTypes
	contains CoreType[] coreTypes
	contains MemoryType[] memoryTypes
	contains NetworkType[] networkTypes
	contains AccessPath[] accessPaths
	// Containment of the system described by this model
	contains HwSystem system
}

// Each instance of an Element may have an unique configuration, i.e. name, Ports, Prescaler and nested hardware elements
abstract class ComplexNode extends ReferableBaseObject, ITaggable
{
	contains Quartz[] quartzes
	contains Prescaler prescaler
	contains Memory[] memories
	contains Network[] networks
	contains HwComponent[] components
	contains HwPort[] ports
}

class HwSystem extends ComplexNode
{
	refers SystemType systemType
	contains ECU[+] ecus
}

class ECU extends ComplexNode
{
	refers ECUType ecuType
	contains Microcontroller[+] microcontrollers
}

class Microcontroller extends ComplexNode
{
	refers MicrocontrollerType microcontrollerType
	contains Core[+] cores
}

class Core extends ComplexNode
{
	refers CoreType coreType
	int lockstepGroup="0"
}

class Memory extends ComplexNode
{
	refers MemoryType ^type
	
	// back pointer (readonly)
	@GenModel(property="Readonly", suppressedSetVisibility="true")
	@GenModel(propertyCategory="Read only", propertyFilterFlags="org.eclipse.ui.views.properties.expert")
	refers transient Mapping mapping opposite memoryLinkInt
}

class Network extends ComplexNode
{
	refers NetworkType ^type
}

class Quartz extends ComplexNode
{
	contains Frequency frequency
	QType ^type
}

// Unclassified Components, i.e. additional periphery that may be used by Autosar
class HwComponent extends ComplexNode
{
	contains HwComponent[] nestedComponents
}

abstract class HardwareTypeDescription extends ReferableBaseObject, ITaggable
{
}

abstract class AbstractionType extends HardwareTypeDescription
{
}

class SystemType extends AbstractionType
{
}

class ECUType extends AbstractionType
{
}

class MicrocontrollerType extends AbstractionType
{
}

class CoreType extends AbstractionType
{
	int bitWidth="0"
	int instructionsPerCycle="0"
}

class MemoryType extends HardwareTypeDescription
{
	String xAccessPattern
	MemoryTypeEnum ^type
	contains DataSize size
}

class NetworkType extends HardwareTypeDescription
{
	SchedType schedPolicy
	int bitWidth="0"
}

// Element for Autosar PinGroup entities
class HwPort extends ReferableBaseObject
{
	contains Pin pins
	
	op String computeUniqueName() {
		val containerName = encode(eContainer?.eGet(eClass.getEStructuralFeature("name")) as String)
		return containerName + "/" + super.computeUniqueName
	}
}

// Element for Autosar Pin entities
class Pin extends ReferableBaseObject
{
}

// Specialization of the Port with additional attributes
class ComplexPort extends HwPort
{
	refers Network[1] network
	boolean master ="false"
	int bitWidth="0"
	long baseAddress="0"
	long addressRange="0"
	RWType direction
	int writeCycles="0"
	int readCycles="0"
	int schedValue="0"
}

// Specialization of the Pin with additional attributes
class ComplexPin extends Pin
{
	PinType ^type
	long baseAddress="0"
	RWType direction
}

class Prescaler
{
	String name
	double clockRatio="0.0"
	refers Quartz[1] quartz
}

class CrossbarSwitch extends NetworkType
{
	int conConnections="0"
}

class Bus extends NetworkType
{
	BusType busType
}

class Bridge extends NetworkType
{
}

enum QType
{
	_undefined_
	DYNAMIC
	STATIC
}

enum MemoryTypeEnum
{
	_undefined_
	RAM
	CACHE
	FLASH_INT
	FLASH_EXT
}

enum BusType
{
	_undefined_
	CAN
	TTCAN
	LIN
	FLEXRAY
	ETHERNET
	SPI
	NA
}

enum RWType
{
	_undefined_
	R
	W
	RW
}

enum SchedType
{
	_undefined_
	RROBIN
	PRIORITY
}

enum PinType
{
	_undefined_
	ANALOG
	DIGITAL
}


interface AccessPath extends IReferable
{
	refers ComplexNode source
	refers ComplexNode target
}

/* AccessPath represented by latencies in cycles */
class LatencyAccessPath extends AccessPath
{
	contains LatencyAccessPathElement[] latencies
}

/* AccessPath represented by directly referencing to existing HW elements (Ports) */
class HwAccessPath extends AccessPath
{
	contains HwAccessPathElement[] hwElements
}

interface LatencyAccessPathElement
{
}

class AccessPathRef extends LatencyAccessPathElement
{
	refers LatencyAccessPath ref
}

interface Latency extends LatencyAccessPathElement
{
	RWType accessType
	long transferSize="0"
	refers Quartz[1] quartz
}

class LatencyConstant extends Latency
{
	long value="0"
}

class LatencyDeviation extends Latency
{
	contains resolving Deviation<LongObject> deviation
}

interface HwAccessPathElement
{
}

class HwAccessPathRef extends HwAccessPathElement
{
	refers HwAccessPath ref
}

class HwElementRef extends HwAccessPathElement
{
	refers ComplexPort port
}


/**
 * ===============================================================================
 * ===============================================================================
 * 
 * 								Mapping Model
 * 
 * ===============================================================================
 * ===============================================================================
 */


class MappingModel extends BaseObject
{
	contains resolving TaskAllocation[] taskAllocation
	contains resolving ISRAllocation[] isrAllocation
	contains resolving RunnableAllocation[] runnableAllocation
	contains resolving CoreAllocation[] coreAllocation
	contains resolving Mapping[] mapping
	contains resolving PhysicalSectionMapping[] physicalSectionMapping
	
	MemoryAddressMappingType addressMappingType
}

////////////////Generalizations for the Allocations (assignment to cores) and 
////////////////Mappings (assignment to memories)
/*
 * Allocation of Cores to schedulers
 */
class CoreAllocation extends BaseObject
{
	refers Scheduler[1] scheduler
	refers Core[1] core
	
	// hidden link (internal)
	@GenModel(property="None", suppressedGetVisibility="true", suppressedSetVisibility="true")
	refers transient Scheduler schedulerLinkInt opposite coreAllocation

// *** Handling of lists ???
//	@GenModel(suppressedGetVisibility="true",suppressedSetVisibility="true")
//	@GenModel(property="None")
//	refers transient Core[] coreLinkInt opposite coreAllocation
}


class PhysicalSectionMapping extends ReferableBaseObject
{
	@GenModel(propertyCategory="Main")
	refers Section[+] origin 
	
	@GenModel(propertyCategory="Memory")
	refers Memory[1] memory

	@GenModel(propertyCategory="Memory")
	long startAddress	="0"

	@GenModel(propertyCategory="Memory")
	long endAddress	="0"

	refers Label[] labels  

	refers Runnable[] runEntities	
 
  
}



/*
 * Generalization for all Mapping types.
 * Mappings assign Runnables/Signals to memories
 */
abstract class Mapping extends BaseObject
{
	/*
	 * The memory where the element is mapped to
	 */
	refers Memory memory
	/*
	 * The position of the element in the mapped memory
	 */
	long memoryPositionAddress="0"
	
	// hidden link (internal)
	@GenModel(property="None", suppressedGetVisibility="true", suppressedSetVisibility="true")
	refers transient Memory memoryLinkInt opposite mapping
}

/*
 * Defines how to interpret the memory addresses in this mapping model
 */
enum MemoryAddressMappingType
{
	_undefined_ // Display: "<address type>"
	//no addresses required
	none
	//absolute memory address
	address
	//offset from first address of memory
	offset
}

//////////////// Specializations of Mappings
/*
 * Sections (D4.2, Chapter 3.3.2)
 * Sections refer to Labels and/or Runnables.
 */
 

/*
 * AbstractElementMemoryInformation (D4.2, Chapter 3.3.2)
 * Generalization of Label, Runnable, AbstractProcess ( ISR & Task) and 
 * TaskPrototype. 
 * This mapping describes the allocation of its specializations to a specific 
 * memory.
 */
class AbstractElementMapping extends Mapping
{
	refers AbstractElementMemoryInformation[1] abstractElement
}

//////////////// Specializations of Allocations

class TaskAllocation extends BaseObject
{
	refers Task[1] task
	refers TaskScheduler[1] scheduler
}

class ISRAllocation extends BaseObject
{
	refers ISR[1] isr
	refers InterruptController[1] controller
}


class RunnableAllocation extends BaseObject
{
	refers Scheduler[1] scheduler
	refers Runnable[1] entity
}


/**
 * ===============================================================================
 * ===============================================================================
 * 
 * 								OS Model
 * 
 * ===============================================================================
 * ===============================================================================
 */


class OSModel extends BaseObject
{
	contains resolving OsBuffering osBuffering
	contains resolving Semaphore[] semaphores
	contains resolving OperatingSystem[] operatingSystems
	contains resolving OsInstructions[] osOverheads
}

/*
 * buffering for intercore communication (process on core 1 communicates witch process on core 2)
 * runnable-, process-, and scheduleSectionLevel defines the section where buffering occurs
 * at selected layer, data is read at beginning of section and written back at the end of the section
 */
class OsBuffering extends BaseObject
{
	boolean runnableLevel ="false"
	boolean processLevel ="false"
	boolean scheduleSectionLevel ="false"
	String bufferingAlgorithm
}

/*
 * name: Name of semaphore
 * maxValue: maximum number of users which can access the semaphore simultaneously
 * initialValue: number of users which access semaphore at system startup
 * priorityCeilingProtocol: enables priority ceiling for this resource

 */
class Semaphore extends ReferableBaseObject
{
	int initalValue="0"
	int maxValue="0"
	boolean priorityCeilingProtocol ="false"
}

/*
 * scheduling Algorithm: The used algorithm for scheduling
 * schedulingUnit: The unit that performs the scheduling algorithm, this can be a hardware or software unit
 */
abstract class Scheduler extends ReferableBaseObject
{
	contains resolving SchedulingUnit schedulingUnit
	int scheduleUnitPriority="0"
	
	// back pointer (readonly)
	@GenModel(property="Readonly", suppressedSetVisibility="true")
	@GenModel(propertyCategory="Read only", propertyFilterFlags="org.eclipse.ui.views.properties.expert")
	refers transient CoreAllocation coreAllocation opposite schedulerLinkInt
}

/*
 * Interrupt Scheduling Algorithm
 * these are the different scheduling algorithms
 */
abstract class InterruptSchedulingAlgorithm extends BaseObject
{
}

/*
 * Task Scheduling Algorithm
 * these are the different scheduling algorithms
 */
abstract class TaskSchedulingAlgorithm extends BaseObject
{
}

/*
 * Priority based scheduling algorithm
 */
class OSEK extends TaskSchedulingAlgorithm
{
}

/*
 * global scheduling algorithm
 */
class PartlyPFairPD2 extends TaskSchedulingAlgorithm
{
	int quantSizeNs="0"
}

/*
 * global scheduling algorithm
 */
class PfairPD2 extends TaskSchedulingAlgorithm
{
	int quantSizeNs="0"
}

/*
 * global scheduling algorithm
 */
class PartlyEarlyReleaseFairPD2 extends TaskSchedulingAlgorithm
{
	int quantSizeNs="0"
}

/*
 * global scheduling algorithm
 */
class EarlyReleaseFairPD2 extends TaskSchedulingAlgorithm
{
	int quantSizeNs="0"
}

/*
 * global scheduling algorithm
 */
class LeastLocalRemainingExecutionTimeFirst extends TaskSchedulingAlgorithm
{
}

/*
 * earliest absolute deadline first
 */
class EarliestDeadlineFirst extends TaskSchedulingAlgorithm
{
}

/*
 * task with shortest deadline has highest priority
 */
class DeadlineMonotonic extends TaskSchedulingAlgorithm
{
}

/*
 * task with shortest recurrence (i.e. period) has highest priority
 */
class RateMonotonic extends TaskSchedulingAlgorithm
{
}

/*
 * all tasks with equal priority executed for certain time slice
 */
class PriorityBasedRoundRobin extends TaskSchedulingAlgorithm
{
}

/*
 * allows the user to define own scheduling algorithm (TA-Toolsuite feature)
 */
class UserSpecificSchedulingAlgorithm extends TaskSchedulingAlgorithm, InterruptSchedulingAlgorithm
{
	contains resolving AlgorithmParameter[] parameter
}

/*
 * Priority based Scheduling Algorithm for Interrupts
 */
class PriorityBased extends InterruptSchedulingAlgorithm
{
}

/*
 * parameter entry for UserSpecificSchedulingAlgorithm
 */
class AlgorithmParameter
{
	String key
	String value
}

/*
 * Scheduling Unit
 * see Scheduler
 */
abstract class SchedulingUnit
{
}

/*
 * Hardware scheduling unit is used in Scheduler when scheduling performs by hardware
 * Each schedule core requires a amount of time equal to delay to execute scheduling
 * 
 */
class SchedulingHWUnit extends SchedulingUnit, BaseObject
{
	contains resolving Time delay
}

/*
 * The Software Scheduling Unit is used in a Scheduler when scheduling performs by Software
 * It describes an ISR that performs scheduling.
 */
class SchedulingSWUnit extends SchedulingUnit, BaseObject
{
	/*
	 * The priority of the scheduling ISR
	 */
	int priority="0"
	/*
	 * The instructions of the scheduling ISR
	 */
	contains resolving OsExecutionInstructions [] instructions
	/*
	 * The Interrupt Controller that manages the scheduling ISR 
	 */
	refers InterruptController interruptController
}

class OperatingSystem extends BaseObject
{
	String name
	refers OsInstructions overhead
	contains resolving TaskScheduler[] taskSchedulers
	contains resolving InterruptController[] interruptControllers
}

class VendorOperatingSystem extends OperatingSystem
{
	String osName
	String vendor
	String version
}

class TaskScheduler extends Scheduler
{
	contains resolving TaskSchedulingAlgorithm schedulingAlgorithm
}

class InterruptController extends Scheduler
{
	contains resolving InterruptSchedulingAlgorithm schedulingAlgorithm
}

class OsInstructions extends ReferableBaseObject
{
	contains resolving OsAPIInstructions apiOverhead
	contains resolving OsISRInstructions isrCategory1Overhead
	contains resolving OsISRInstructions isrCategory2Overhead
}

class OsAPIInstructions extends BaseObject
{
	contains resolving OsExecutionInstructions apiSendMessage
	contains resolving OsExecutionInstructions apiTerminateTask
	contains resolving OsExecutionInstructions apiSchedule
	contains resolving OsExecutionInstructions apiRequestResource
	contains resolving OsExecutionInstructions apiReleaseResource
	contains resolving OsExecutionInstructions apiSetEvent
	contains resolving OsExecutionInstructions apiWaitEvent
	contains resolving OsExecutionInstructions apiClearEvent
	contains resolving OsExecutionInstructions apiActivateTask
	contains resolving OsExecutionInstructions apiEnforcedMigration
}

class OsISRInstructions extends BaseObject
{
	contains resolving OsExecutionInstructions preExecutionOverhead
	contains resolving OsExecutionInstructions postExecutionOverhead
}

abstract class OsExecutionInstructions
{
}

/*
 * Represents a deviated set of execution cycles
 */
class OsExecutionInstructionsDeviation extends OsExecutionInstructions, BaseObject
{
	contains resolving Deviation<LongObject> deviation
}

/*
 * Represents a constant set of execution cycles 
 */
class OsExecutionInstructionsConstant extends OsExecutionInstructions, BaseObject
{
	long value="0"
}


/**
 * ===============================================================================
 * ===============================================================================
 * 
 * 								Property Constraints Model
 * 
 * ===============================================================================
 * ===============================================================================
 */

class PropertyConstraintsModel extends BaseObject
{
	contains resolving AllocationConstraint[] allocationConstraints
	contains resolving MappingConstraint[] mappingConstraints
	contains resolving CoreType[] coreTypeDefinitions
	contains resolving MemoryType[] memoryTypeDefinitions
}

enum ComparatorType
{
	_undefined_ // Display: "<comparator>"
	equal
	unequal
	greater
	lower
}

enum ConjunctionType
{
	_undefined_ // Display: "<conjunction>"
	and
	or
}

//////////////// Constraints
/*abstract class Constraint {
	// reference: Software Component
	// containment: List of HW Features or Components we need
}*/
/*
 * Abstract Class, used to describe Constraints for Allocations
 * (these usually target Cores and their features/attributes)
 */
abstract class AllocationConstraint extends BaseObject
{
	contains resolving HwCoreConstraint hwConstraint
}

/*
 * Abstract Class, used to describe Constraints for Mapping
 * (these usually target Memories and their features/attributes)
 */
abstract class MappingConstraint extends BaseObject
{
	contains resolving HwMemoryConstraint hwConstraint
}

/*
 * ProcessAllocationConstraints describe the constraints for
 * Process-to-Core allocations
 */
class ProcessAllocationConstraint extends AllocationConstraint
{
	refers Process process
}

/*
 * ProcessPrototypeAllocationConstraints describe the constraints for
 * ProcessPrototype-to-Core allocations
 */
class ProcessPrototypeAllocationConstraint extends AllocationConstraint
{
	refers ProcessPrototype processPrototype
}

/*
 * RunnableAllocationConstraints describe the constraints for
 * Runnable-to-Core allocations
 */
class RunnableAllocationConstraint extends AllocationConstraint
{
	refers Runnable runnable
}

 
/*
 * AbstractElementMappingConstraints describe the constraints for 
 * AbstractElementMemoryInformation-to-Memory Mapping
 */
class AbstractElementMappingConstraint extends MappingConstraint
{
	refers AbstractElementMemoryInformation abstractElement
}

/*
 * Generalization for all Hardware related constraints
 */
 
abstract class HwCoreConstraint extends BaseObject
{
}

abstract class HwMemoryConstraint extends BaseObject
{
}

/*
 * Core-Constraints for describing the least amount of properties which are required by
 * executables.
 */
class HwCoreProperty extends HwCoreConstraint
{
	contains resolving Core core
	ComparatorType comparator
}

class HwCoreConjunction extends HwCoreConstraint
{
	ConjunctionType conjunction
	contains resolving HwCoreConstraint firstConstraint
	contains resolving HwCoreConstraint secondConstraint
}

/*
 * Memory-Constraints for describing the least amount of properties which are required by
 * data.
 */
class HwMemoryProperty extends HwMemoryConstraint
{
	contains resolving Memory memory
	ComparatorType comparator
}

class HwMemoryConjunction extends HwMemoryConstraint
{
	ConjunctionType conjunction
	contains resolving HwMemoryConstraint firstConstraint
	contains resolving HwMemoryConstraint secondConstraint
}


/**
 * ===============================================================================
 * ===============================================================================
 * 
 * 								Stimuli Model
 * 
 * ===============================================================================
 * ===============================================================================
 */


class StimuliModel extends BaseObject
{
	contains resolving Stimulus[] stimuli
	contains resolving Clock[] clocks
}

/*
 * Every process/task can have one or more stimuli
 * A stimulus activates the process
 * deviationStimulus: defines the deviation of the activation times of the stimulus
 */
abstract class Stimulus extends ReferableBaseObject
{
	contains resolving Deviation<SignedTime> stimulusDeviation
	contains resolving ModeValueList setModeValueList
	contains resolving ModeValueList enablingModeValueList
	contains resolving ModeValueList disablingModeValueList
}

class ModeValueList extends BaseObject
{
	contains resolving ModeValueListEntry[] entries
}

class ModeValueListEntry extends BaseObject
{
	refers ModeValueProvider[1] valueProvider
	refers ModeLiteral [1] value
}

/*
 * This activates a task periodically
 * offset: Time of first activation
 * recurrence: Time between following activations
 * clock: Time base which defines deviation of time, multiple stimuli can have the same time base
 */
class Periodic extends Stimulus
{
	contains resolving Time offset
	contains resolving Time recurrence
	refers Clock clock
}

/*
 * Periodic avtivation based on other events, like rotation speed dependency
 */
class PeriodicEvent extends Stimulus
{
}

/*
 * Activations triggered depending on a defined list of trigger times
 * offset: to shift the occurrences in negative or positive direction on the time bar
 * period: to set the period, after which the trigger times are to be repeated
 * triggerTimes: the list of all trigger times
 */
class Synthetic extends Stimulus
{
	contains resolving Time offset
	contains resolving Time period
	contains resolving TimestampList triggerTimes
}

class TimestampList extends BaseObject
{
	contains resolving Time[] timestamps
}

/*
 * Stimulus to describe own custom types of activations, including properties
 */
class CustomStimulus extends Stimulus
{
}

/*
 * Single scheduling event at a defined time.
 */
class Single extends Stimulus
{
	contains resolving Time activation
}

/*
 * Defines activation based on a explicit inter process activation.
 */
class InterProcess extends Stimulus
{
}

/*
 * Stimulus for sporadic activation of task
 */
class Sporadic extends Stimulus
{
}

/*
 * Arrival Curve Stimulus
 */
class ArrivalCurve extends Stimulus
{
	contains resolving ArrivalCurveEntry[] arrivalCurveEntries
}

class ArrivalCurveEntry extends BaseObject
{
	int numberOfEvents="0"
	contains resolving Time lowerTimeBorder
	contains resolving Time upperTimeBorder
}

/*
 * This is the time base for one or more periodic stimuli
 * A clock defines the time of its stimuli.
 * The faster the clock, the faster stimuli
 */
abstract class Clock extends ReferableBaseObject
{
}

class ClockTriangleFunction extends Clock
{
	contains resolving SignedTime shift
	contains resolving Time period
	double max="0.0"
	double min="0.0"
}

class ClockSinusFunction extends Clock
{
	contains resolving SignedTime shift
	contains resolving Time period
	double amplitude="0.0"
	double yOffset="0.0"
}

/*
 * A list of timestamp-value pairs
 * At the specified timestamp, the clock changes to the corresponding value 
 */
class ClockMultiplierList extends Clock
{
	contains resolving ClockMultiplierListEntry[] entries
}

/*
 * A timestamp-value par for ClockMultiplierList
 */
class ClockMultiplierListEntry extends BaseObject
{
	double multiplier="0.0"
	contains resolving Time time
}


/**
 * ===============================================================================
 * ===============================================================================
 * 
 * 								SW Model
 * 
 * ===============================================================================
 * ===============================================================================
 */

/*
 * Central instance to provide central access. 
 */
class SWModel extends BaseObject
{
	contains resolving ISR[] isrs
	contains resolving Task[] tasks
	contains resolving Runnable[] runnables
	contains resolving Label[] labels
	contains resolving ProcessPrototype[] processPrototypes
	contains resolving Section[] sections
	contains resolving Activation[] activations
	contains resolving Tag[] tags
	contains resolving OsEvent[] events
	contains resolving TypeDefinition[] typeDefinitions
	contains resolving CustomEntity[] customEntities
	contains resolving ProcessChain [] processChains
	contains resolving Mode [] modes
	contains resolving ModeLabel[] modeLabels
}

abstract class AbstractElementMemoryInformation extends ReferableBaseObject, ITaggable
{
	/*
	 * Specifying the size of the element corresponding to the needed memory allocation
	 */
	contains resolving DataSize size
}

abstract class AbstractProcess extends AbstractElementMemoryInformation
{
	int priority="0"
}

/*
 * Possibility to define general custom elements
 */
class CustomEntity extends AbstractElementMemoryInformation
{
	String typeName
}

/*
 * Groups a list of processes to a process chain.
 * This does not define how the processes are chained, like beeing executed by one parent or like they trigger each other (therfore Enforced Migration is used)
 * This just defines that the processes should be chained.
 */
class ProcessChain extends ReferableBaseObject 
{
	refers Process [] processes
}


/*
 * TODO: Refine name of element
 * Generalizes interrupt service routines and tasks
 */
abstract class Process extends AbstractProcess
{
	contains resolving CallGraph callGraph
	refers Stimulus[] stimuli
}

/*
 * Describes the different execution paths of a process 
 */
class CallGraph extends BaseObject
{
	contains resolving GraphEntryBase[] graphEntries
}

/*
 * A abstract entry for a call graph
 */
abstract class GraphEntryBase extends BaseObject
{
}

/*
 * A sequence of callable items that can be placed in the call graph 
 */
class CallSequence extends GraphEntryBase
{
	String name
	contains resolving CallSequenceItem[] calls
}

/*
 * A switch in the call graph, the selected path depends on the value of the provided ModeLabel
 */
class ModeSwitch extends GraphEntryBase
{
	refers ModeValueProvider valueProvider
	contains resolving ModeSwitchEntry<GraphEntryBase>[] entries
	contains resolving ModeSwitchDefault<GraphEntryBase> defaultEntry	
}

/*
 * A switch entry for a ModeSwitch. 
 * It describes a path of the switch and the required mode values to use this path
 */
class ModeSwitchEntry<T> extends BaseObject
{
	refers ModeLiteral[+] values
	contains resolving T[] items
}

class ModeSwitchDefault<T> extends BaseObject
{
	contains resolving T[] items
}

/*
 * A switch in the call graph, each path has a probability
 */
class ProbabiltitySwitch extends GraphEntryBase
{
	contains resolving ProbabilitySwitchEntry[] entries
}

/*
 * A switch entry for a ProbabiltitySwitch
 * It describes a path of the switch and it's probability
 */
class ProbabilitySwitchEntry extends BaseObject
{
	double probability="0.0"
	contains resolving GraphEntryBase[] items
}

/*
 * A counter for the call sequence items
 */
class Counter extends BaseObject
{
	long offset="0"
	long prescaler="0"
}

/*
 * Generalizes task calls
 */
abstract class CallSequenceItem extends BaseObject
{
	contains resolving Counter counter
}

/*
 * Let the process wait for a combination of events defined by eventMask
 * maskType defines if the events in eventMask are linked by a AND or OR
 */
class WaitEvent extends CallSequenceItem
{
	contains resolving EventMask eventMask
	WaitEventType maskType
	WaitingBehaviour waitingBehaviour
}

enum WaitEventType
{
	_undefined_ // Display: "<wait event>"
	AND
	OR
}

enum WaitingBehaviour
{
	_undefined_ // Display: "<waiting>"
	active
	passive
}

/*
 * Sets the events of eventMask 
 * These events can be set for a specific process, if there is no process, is is global (for all processes)
 * If there is a process, it is possible to set the event for a specific process instance that is currently activated
 */
class SetEvent extends CallSequenceItem
{
	contains resolving EventMask eventMask
	refers Process process
}

/*
 * Clears the events of eventMask
 */
class ClearEvent extends CallSequenceItem
{
	contains resolving EventMask eventMask
}

/*
 * A event mask
 */
class EventMask extends BaseObject
{
	refers OsEvent[] events
}

/*
 * A event that can be set, cleared and waited for by a process 
 */
class OsEvent extends ReferableBaseObject, ITaggable
{
	int communicationOverheadInBit="0"
}

/*
 * Triggers a stimulus to activate its processes
 */
class InterProcessActivation extends CallSequenceItem
{
	refers Stimulus stimulus
}

/*
 * Migrates task to core of resource owner
 */
class EnforcedMigration extends CallSequenceItem
{
	refers Scheduler resourceOwner
}

/*
 * Executes a runnable
 */
class TaskRunnableCall extends CallSequenceItem
{
	refers Runnable[1] runnable
	contains resolving RunEntityCallStatistic statistic
	
	// hidden link (internal)
	@GenModel(property="None", suppressedGetVisibility="true", suppressedSetVisibility="true")
	refers transient Runnable[1] runnableLinkInt opposite taskRunnableCalls
}

/*
 * Triggers scheduler
 */
class SchedulePoint extends CallSequenceItem
{
}

/*
 * Terminates the process
 */
class TerminateProcess extends CallSequenceItem
{
}

/*
 * Schedulable entity, which is managed by the OS. An instance of a Task is mapped to exactly one core
 * and includes the direct representation of all abstractions.
 */
class Task extends Process
{
	int osekTaskGroup="0"
	Preemption preemption
	
	int multipleTaskActivationLimit = "0"
}

/*
 * Interrupt service routine
 */
class ISR extends Process
{
}

/*
 * Prototype class for Process. 
 * It does contain meta information of potential processes, which does not represent the final state.
 * The final state can be several Tasks, which can be computed using provided information of this prototype.
 */
class ProcessPrototype extends AbstractProcess
{
	Preemption preemption
	refers Runnable firstRunnable
	refers Runnable lastRunnable
	/*
	 * Defines the general label accesses
	 */
	contains resolving AccessPrecedenceSpec[] accessPrecedenceSpec
	/*
	 * Defines the general order of runnables
	 */
	contains resolving OrderPrecedenceSpec[] orderPrecedenceSpec
	contains resolving ChainedProcessPrototype[] chainedPrototypes
	refers Activation activation
	contains resolving TaskRunnableCall[] runnableCalls
}

class ChainedProcessPrototype extends BaseObject
{
	refers ProcessPrototype[1] prototype
	int apply="0"
	int offset="0"
}

/*
 * General abstraction for precedence
 */
abstract class GeneralPrecedence extends BaseObject
{
	refers Runnable origin
	refers Runnable target
}

/*
 * 
 */
class AccessPrecedenceSpec extends GeneralPrecedence
{
	refers Label label
	AccessPrecedenceType orderType
}

/*
 * Defines the access precedence at the time of one task period.
 */
enum AccessPrecedenceType
{
	_undefined_ // Display: "<access>"
	/*
	 * Writer of label has to be performed before the reader.
	 */
	defaultWR
	/*
	 * Dependency between writer and reader can be ignored.
	 */
	ignoreWR
	/*
	 * Reader of label has to be performed before the writer (delay unit of controller).
	 */
	enforceRW
}

/*
 * 
 */
class OrderPrecedenceSpec extends GeneralPrecedence
{
	OrderType orderType
}

enum OrderType
{
	_undefined_ // Display: "<order>"
	/*
	 * Defines a general order, the included elements must not follow directly
	 */
	order
	/*
	 * The defined elements must follow directly
	 */
	directOrder
	startSequence
	endSequence
}

/*
 * Smallest allocatable unit, which provides additional (optional) attributes for allocation algorithms.
 */
class Runnable extends AbstractElementMemoryInformation
{
	contains resolving RunnableItem[] runnableItems
	refers Activation activation
	/*
	 * Optional parameter for allocation to task or time slice.
	 */
	contains Time deadline
	/*
	 * Marker if runnable is used as callback.
	 */
	boolean callback = "false"
	/*
	 * Marker if runnable is used as a service.
	 */
	boolean service = "false"
	
	// back pointer (readonly)
	@GenModel(property="Readonly", suppressedSetVisibility="true")
	@GenModel(propertyCategory="Read only", propertyFilterFlags="org.eclipse.ui.views.properties.expert")
	refers transient RunnableCall[] runnableCalls opposite runnableLinkInt
	
	// back pointer (readonly)
	@GenModel(property="Readonly", suppressedSetVisibility="true")
	@GenModel(propertyCategory="Read only", propertyFilterFlags="org.eclipse.ui.views.properties.expert")
	refers transient TaskRunnableCall[] taskRunnableCalls opposite runnableLinkInt 
	
	refers Section section
	
	// hidden link (internal)
	@GenModel(property="None", suppressedGetVisibility="true", suppressedSetVisibility="true")
	refers transient Section sectionLinkInt opposite runnables
}

/*
 * Data representation, which can be accessed by run entities.
 */
class Label extends AbstractElementMemoryInformation, IDisplayName
{
	contains DataType dataType
	/*
	 * Defines the label as a constant, not modifiable entity
	 */
	boolean constant ="false"
	/*
	 * Defines if the label value is volatile or persistent to survive shutdown and start of system
	 */
	boolean bVolatile ="false"
	
	/*
	 * Defines if the label is buffered or not
	 */
	LabelBuffering buffered
	
	// back pointer (readonly)
	@GenModel(property="Readonly", suppressedSetVisibility="true")
	@GenModel(propertyCategory="Read only", propertyFilterFlags="org.eclipse.ui.views.properties.expert")
	refers transient LabelAccess[] labelAccesses opposite dataLinkInt
	
	refers Section section
	
	// hidden link (internal)
	@GenModel(property="None", suppressedGetVisibility="true", suppressedSetVisibility="true")
	refers transient Section sectionLinkInt opposite labels
	
}

class ModeLabel extends AbstractElementMemoryInformation, ModeValueProvider, IDisplayName
{
}

enum LabelBuffering {
	_undefined_ // Display: "<buffering>"
	buffered
	notBuffered
}

/*
 * A section is a logical structure, which contains labels and abstract run entities.
 * It is used to provide an easy mechanism to distribute objects to memory, 
 * which are belonging together.
 */
class Section extends ReferableBaseObject
{
	
	// back pointer (readonly)
	@GenModel(property="Readonly", suppressedSetVisibility="true")
	@GenModel(propertyCategory="Read only", propertyFilterFlags="org.eclipse.ui.views.properties.expert")
	refers transient Label[] labels opposite sectionLinkInt 
	
	// back pointer (readonly)
	@GenModel(property="Readonly", suppressedSetVisibility="true")
	@GenModel(propertyCategory="Read only", propertyFilterFlags="org.eclipse.ui.views.properties.expert")
	refers transient Runnable[] runnables opposite sectionLinkInt 
	
	/*
	 * for specifying the ASIL level for the "virtual memory sections"
	 */
 	ASILType asilLevel
 
}

/*
 * Representation of a object that can be executed by a Runnable
 */
abstract class RunnableItem extends BaseObject
{
	op boolean containerNotificationRequired() {
		return true
	}
}

/*
 * Representation of a mode label access of a run entity.
 */
class ModeLabelAccess extends RunnableItem
{
	refers ModeLabel[1] data
	LabelAccessEnum access
	
	/*
	 * Just used in case that this access writes a value to a Mode-Label.
	 * It can be used to define which mode value is written to the label. 
	 */
	 refers ModeLiteral modeValue
}

class RunnableModeSwitch extends RunnableItem
{
	refers ModeValueProvider valueProvider
	contains resolving ModeSwitchEntry<RunnableItem>[] entries
	contains resolving ModeSwitchDefault<RunnableItem> defaultEntry
}

/*
 * Representation of a label access of a run entity.
 */
class LabelAccess extends RunnableItem
{
	refers Label[1] data
	LabelAccessEnum access
	/*
	 * Optional parameter for statistic values
	 */
	contains resolving LabelAccessStatistic statistic
	
	/*
	 * Defines if the access to the label is buffered
	 */
	LabelAccessBuffering buffered

	// hidden link (internal)
	@GenModel(property="None", suppressedGetVisibility="true", suppressedSetVisibility="true")
	refers transient Label[1] dataLinkInt opposite labelAccesses
}


/*
 * Defines the buffering of a label access.
 * It can be buffered, not-buffered and inherited
 * Inherited means that the buffered-setting of the Label is used
 */
enum LabelAccessBuffering {
	_undefined_ // Display: "<buffering>"
	inherited
	buffered
	notBuffered
}

enum LabelAccessEnum
{
	_undefined_ // Display: "<access>"
	read
	write
}

/*
 * Describes an semaphore access
 */
class SemaphoreAccess extends RunnableItem
{
	refers Semaphore[1] semaphore
	SemaphoreAccessEnum access
}

/*
 * request: requests access to semaphore
 * release: release accessed semaphore
 * exclusive: gets access to requested semaphore only when there is no other user accessing it
 */
enum SemaphoreAccessEnum
{
	_undefined_ // Display: "<access>"
	request
	exclusive
	release
}

/*
 * A abstract description for sender-receiver-communication (it can be read or write)
 */
abstract class SenderReceiverCommunication extends RunnableItem
{
	boolean buffered ="false"
	refers Label[1] label
}

/*
* The read operation of the receiver of the sender-receiver-communication
*/
class SenderReceiverRead extends SenderReceiverCommunication
{
}

/*
* The write operation of the sender of the sender-receiver-communication
* It contains the runnables that have the corresponding SenderReceiverRead  
*/
class SenderReceiverWrite extends SenderReceiverCommunication
{
	refers Runnable[] notifiedRunnables
}

/*
 * A abstract description for client/server communication
 * It refers to a required runnable that describes the called server operation
 */
abstract class ServerCall extends RunnableItem
{
	refers Runnable[1] serverRunnable
}

/*
 * A synchronous server call
 */
class SynchronousServerCall extends ServerCall
{
	WaitingBehaviour waitingBehaviour
}

/*
 * A asynchronous server call
 * It refers to a optional runnable that exploits the results produced by the server
 */
class AsynchronousServerCall extends ServerCall
{
	refers Runnable resultRunnable
}

/*
 * Describes a group of runnable items with a probability
 */
class ProbabilityGroup extends RunnableItem
{
	contains resolving ProbabilityRunnableItem[] items
}

/*
 * A runnable item with a probability
 */
class ProbabilityRunnableItem extends BaseObject
{
	int probability="0"
	contains resolving RunnableItem runnableItem
}

/*
 * Describes a group of deviation runnable items
 * It can be also a group of runnable items without deviation, because the deviation is optional for each item
 */
class Group extends RunnableItem
{
	String name
	boolean ordered ="false"
	contains resolving DeviationRunnableItem[] items
}

/*
 * A runnable item with a deviation
 * The deviation is optional
 */
class DeviationRunnableItem extends BaseObject
{
	contains resolving RunnableItem runnableItem
	contains resolving Deviation<LongObject> deviation
}

/*
 * Representation of a runnable call of a run entity.
 */
class RunnableCall extends RunnableItem
{
	refers Runnable[1] runnable
	contains resolving RunEntityCallStatistic statistic
	
	// hidden link (internal)
	@GenModel(property="None", suppressedGetVisibility="true", suppressedSetVisibility="true")
	refers transient Runnable[1] runnableLinkInt opposite runnableCalls
}

/*
 * Represents a abstract description for a set of execution cycles in a runnable
 */
abstract class Instructions extends RunnableItem
{
	/*
	 * optional parameter for fetch statistic
	 */
	contains resolving InstructionFetch fetchStatistic
}

/*
 * Represents a deviated set of execution cycles
 */
class InstructionsDeviation extends Instructions
{
	contains resolving Deviation<LongObject> deviation
}

/*
 * Represents a constant set of execution cycles 
 */
class InstructionsConstant extends Instructions
{
	long value="0"
}

/*
 * Preemption type for scheduling
 */
enum Preemption
{
	_undefined_ // Display: "<preemption>"
	cooperative
	preemptive
	unknown
}

/*
 * Concurrency type of an entity
 */
enum ConcurrencyType
{
	_undefined_ // Display: "<concurrency>"
	/*
	 * Safe for access inside of the same core
	 */
	SingleCoreSafe
	/*
	 * Safe for access from another core
	 */
	MultiCoreSafe
	SingleCorePrioSafe
}

/*
 * Central access point for different data type definitions
 */
interface DataType
{
}

/*
 * Couple of compound data types
 */
interface CompoundType extends DataType
{
}

/*
 * Representing a struct definition, containing different entries
 */
class Struct extends CompoundType, BaseObject
{
	contains StructEntry[] entries
}

/*
 * Representation of one struct entry
 */
class StructEntry extends BaseObject
{
	String name
	contains DataType dataType
}

/*
 * Representation of an array data type
 */
class Array extends CompoundType, BaseObject
{
	int numberElements="0"
	contains DataType dataType
}

/*
 * Representing a pointer
 */
class Pointer extends CompoundType, BaseObject
{
	contains DataType dataType
}

class TypeRef extends DataType, BaseObject
{
	refers TypeDefinition typeDef
}

/*
 * Mapping of a data type to a target platform.
 */
class DataPlatformMapping extends BaseObject
{
	/*
	 * Name of the target platform
	 */
	String platformName
	/*
	 * Corresponding type of the target platform
	 */
	String platformType
}

abstract class TypeDefinition extends ReferableBaseObject
{
}

class DataTypeDefinition extends TypeDefinition
{
	contains DataType dataType
}

/*
 * Basic data type definition, including information of mapping to target platforms
 */
class BaseTypeDefinition extends TypeDefinition
{
	/*
	 * Size of the data type
	 */
	contains resolving DataSize size
	/*
	 * Data mappings of target platforms
	 */
	contains resolving DataPlatformMapping[] dataMapping
}

/*
 * General abstraction for activation source.
 * Used for first definition of an activation rate, which is later refined by stimulus.
 */
abstract class Activation extends ReferableBaseObject
{
}

/*
 * Min and Max execution frequency within a task or timeslice
 */
class PeriodicActivation extends Activation
{
	contains Time min
	contains Time max
	contains Time offset
	contains Time deadline
}

class SporadicActivation extends Activation
{
}

/*
 * A single activation between time min and max
 */
class SingleActivation extends Activation
{
	contains Time min
	contains Time max
}

class CustomActivation extends Activation
{
	String description
}

/*
 * Contains information about access statistic values
 */
class LabelAccessStatistic extends BaseObject
{
	contains resolving NumericStatistic value
	contains resolving NumericStatistic cacheMisses
}

/*
 * 
 */
class InstructionFetch extends BaseObject
{
	contains resolving NumericStatistic count
	contains resolving NumericStatistic misses
	contains resolving NumericStatistic cyclesPerFetch
}

class RunEntityCallStatistic extends BaseObject
{
	contains resolving NumericStatistic statistic
}

enum ASILType
{
	_undefined_ // Display: "<ASIL Level>"
	D
	C
	B
	A
	QM
}
