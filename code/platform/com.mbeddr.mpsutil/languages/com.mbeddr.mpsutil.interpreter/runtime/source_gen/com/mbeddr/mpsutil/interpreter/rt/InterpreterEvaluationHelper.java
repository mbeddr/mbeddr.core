package com.mbeddr.mpsutil.interpreter.rt;

/*Generated by MPS */

import java.util.Map;
import com.intellij.util.containers.ContainerUtil;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import jetbrains.mps.internal.collections.runtime.Sequence;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import org.jetbrains.mps.openapi.language.SReferenceLink;
import org.jetbrains.mps.openapi.language.SProperty;

public class InterpreterEvaluationHelper {
  private final String category;
  private IContextProvider contextProvider;

  private static boolean cacheInterpreter = true;
  private static final Map<String, IInterpreter> interpreterCache = ContainerUtil.createSoftValueMap();

  private ComputationTrace lastComputationTrace;


  public InterpreterEvaluationHelper(String category) {
    this.category = category;
  }


  public static boolean isCachingEnabled() {
    return cacheInterpreter;
  }
  public static void setCachingEnabled(boolean b) {
    cacheInterpreter = b;
  }

  public static void clearInterpreterCache() {
    MapSequence.fromMap(interpreterCache).clear();
  }



  public static IInterpreter getInterpreter(String category) {
    if (!(cacheInterpreter) || MapSequence.fromMap(interpreterCache).get(category) == null) {
      IInterpreter[] interpreters = Sequence.fromIterable(InterpreterRegistry.findAllInterpreterExecutablesForCategory(category)).toGenericArray(IInterpreter.class);

      if (interpreters.length == 0) {
        // try old approach
        interpreters = Sequence.fromIterable(CachedInterpreterFinder.getInstance().findInterpretersForCategory(category)).select((it) -> InterpreterRegistry.getInterpreterExecutable(it)).toGenericArray(IInterpreter.class);
      }

      CombinedInterpreter interpreter = new CombinedInterpreter(interpreters);
      MapSequence.fromMap(interpreterCache).put(category, interpreter);

    }
    return MapSequence.fromMap(interpreterCache).get(category);
  }

  public EvaluationOptions evaluateWithOptions(SNode node) {
    return new EvaluationOptions(node);
  }

  public class EvaluationOptions {
    private IContext context;
    private boolean createComputationTrace = true;
    private ICoverageAnalyzer coverageAnalyzer = null;
    private IInterpreter interpreter;

    private SNode node;

    public EvaluationOptions(SNode node) {
      this.node = node;
    }

    public EvaluationOptions withContext(IContext context) {
      this.context = context;
      return this;
    }

    public EvaluationOptions withComputationTrace(boolean flag) {
      this.createComputationTrace = flag;
      return this;
    }

    public EvaluationOptions withCoverAnalyzer(ICoverageAnalyzer coverageAnalyzer) {
      this.coverageAnalyzer = coverageAnalyzer;
      return this;
    }

    public EvaluationOptions withInterpreter(IInterpreter interpreter) {
      this.interpreter = interpreter;
      return this;
    }

    public Object execute() {
      if (coverageAnalyzer == null) {
        coverageAnalyzer = new NullCoverageAnalyzer();
      }

      if (context == null) {
        context = createContext(node);
      }

      if (interpreter == null) {
        interpreter = getInterpreter(getCategory());
      }

      context.setRootInterpreter(interpreter);

      if (createComputationTrace) {
        lastComputationTrace = new ComputationTrace(node);
      }
      return interpreter.evaluate(node, context, coverageAnalyzer, (createComputationTrace ? lastComputationTrace : null), false);
    }
  }

  public Object evaluate(SNode node) throws InterpreterBaseException {
    return evaluateWithOptions(node).execute();
  }

  public Object evaluateWithContext(SNode node, IContext context) throws InterpreterBaseException {
    return evaluateWithOptions(node).withContext(context).execute();
  }

  public Object evaluateWithContextAndCoverage(SNode node, IContext context, ICoverageAnalyzer coverage) throws InterpreterBaseException {
    return evaluateWithOptions(node).withContext(context).withCoverAnalyzer(coverage).execute();
  }

  public Object evaluateWithContextAndCoverage(SNode node, IInterpreter interpreter, IContext context, ICoverageAnalyzer coverage) throws InterpreterBaseException {
    return evaluateWithOptions(node).withInterpreter(interpreter).withContext(context).withCoverAnalyzer(coverage).execute();
  }

  public Object evaluateIfStructurallySound(SNode node) throws InterpreterBaseException {
    if (!(isStructurallySound(node))) {
      return null;
    }
    return evaluate(node);
  }

  public Object evaluateWithStructuralException(SNode node) throws StructurallyUnsoundException, InterpreterBaseException {
    if (!(isStructurallySound(node))) {
      throw new StructurallyUnsoundException();
    }
    return evaluate(node);
  }

  public String getCategory() {
    return this.category;
  }

  public IContextProvider getContextProvider() {
    return this.contextProvider;
  }

  public void setContextProvider(IContextProvider contextProvider) {
    this.contextProvider = contextProvider;
  }

  protected IContext createContext(SNode node) {
    IContext defaultContext = createDefaultContext(node);
    IContextProvider contextProvider = getContextProvider();
    if (contextProvider == null) {
      return defaultContext;
    } else {
      return contextProvider.createContext(node, defaultContext);
    }
  }

  protected IContext createDefaultContext(SNode node) {
    return new ContextImpl();
  }

  protected boolean isStructurallySound(SNode node) {
    return !(ListSequence.fromList(SNodeOperations.getNodeDescendants(node, null, true, new SAbstractConcept[]{})).any((it) -> isNodeNull(it) || isNodeAbstract(it) || hasMissingChildren(it) || hasMissingReferences(it) || hasInvalidProperties(it)));
  }

  protected boolean isNodeNull(SNode node) {
    return (node == null);
  }

  protected boolean isNodeAbstract(SNode node) {
    return SNodeOperations.getConcept(node).isAbstract();
  }

  protected boolean hasMissingChildren(final SNode node) {
    return Sequence.fromIterable(((Iterable<SContainmentLink>) SNodeOperations.getConcept(node).getContainmentLinks())).where((it) -> !(it.isOptional())).any((it) -> Sequence.fromIterable(((Iterable<SNode>) node.getChildren(it))).isEmpty());
  }

  protected boolean hasMissingReferences(final SNode node) {
    return Sequence.fromIterable(((Iterable<SReferenceLink>) SNodeOperations.getConcept(node).getReferenceLinks())).where((it) -> !(it.isOptional())).any((it) -> node.getReference(it) == null);
  }

  protected boolean hasInvalidProperties(final SNode node) {
    return Sequence.fromIterable(((Iterable<SProperty>) SNodeOperations.getConcept(node).getProperties())).any((it) -> !(it.isValid(node.getProperty(it))));
  }

  public ComputationTrace getLastLog() {
    return this.lastComputationTrace;
  }
}
