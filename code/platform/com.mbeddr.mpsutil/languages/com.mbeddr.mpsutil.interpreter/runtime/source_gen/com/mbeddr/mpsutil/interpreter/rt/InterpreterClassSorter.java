package com.mbeddr.mpsutil.interpreter.rt;

/*Generated by MPS */

import com.mbeddr.mpsutil.common.graph.Graph;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.NotNullWhereFilter;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.LinkedHashSet;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import com.mbeddr.mpsutil.common.graph.GraphUtil;

public class InterpreterClassSorter<I extends IInterpreter> {
  protected Graph<I> dependencyGraph = new Graph<I>();

  public InterpreterClassSorter() {
  }

  public InterpreterClassSorter(I... interpreters) {
    add(interpreters);
  }

  public static <SI extends IInterpreter> List<SI> sort(SI... interpreters) {
    return new InterpreterClassSorter<SI>(interpreters).sort();
  }

  public void add(I... interpreters) {
    // ensure deterministic order, in which interpreters are added to the graph 
    // (makes sure that the resulting topological sort order won't be in any way affected by the interpreters lookup order)
    Iterable<I> orderedInterpreters = Sequence.fromIterable(Sequence.fromArray(interpreters)).where(new NotNullWhereFilter()).sort((it) -> {
      // using interpreter name for sorting (reflected by the class name) 
      return it.getClass().getSimpleName();
    }, true);
    Set<I> interpretersSet = SetSequence.fromSetWithValues(new LinkedHashSet<I>(), orderedInterpreters);

    SetSequence.fromSet(interpretersSet).visitAll((it) -> dependencyGraph.addNode(it));

    for (I interpreter : SetSequence.fromSet(interpretersSet)) {
      for (I existingInterpreter : SetSequence.fromSet(interpretersSet)) {
        for (IRelationship relationship : ListSequence.fromList(interpreter.listRelationships())) {
          switch (relationship.calcEvaluationOrder(existingInterpreter)) {
            case BEFORE:
              dependencyGraph.addEdge(interpreter, existingInterpreter);
              break;
            case AFTER:
              dependencyGraph.addEdge(existingInterpreter, interpreter);
              break;
            default:
              break;
          }
        }
      }
    }
  }

  public List<I> sort() {
    return GraphUtil.computeTopologicalSorting(dependencyGraph, true);
  }
}
