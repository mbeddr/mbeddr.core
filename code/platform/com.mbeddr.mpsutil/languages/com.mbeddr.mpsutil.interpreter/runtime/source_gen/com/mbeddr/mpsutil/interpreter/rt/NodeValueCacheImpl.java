package com.mbeddr.mpsutil.interpreter.rt;

/*Generated by MPS */

import jetbrains.mps.logging.Logger;
import java.util.Map;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.LinkedHashMap;
import jetbrains.mps.lang.core.behavior.BaseConcept__BehaviorDescriptor;
import jetbrains.mps.internal.collections.runtime.IterableUtils;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;

public class NodeValueCacheImpl implements INodeValueCache {
  private static final Logger LOG = Logger.getLogger(NodeValueCacheImpl.class);
  private Map<SNode, Object> cache = MapSequence.fromMap(new LinkedHashMap<SNode, Object>(16, (float) 0.75, false));

  public boolean isCached(SNode node) {
    return MapSequence.fromMap(cache).containsKey(node);
  }

  public void set(SNode node, Object value) {
    if (LOG.isTraceLevel()) {
      LOG.trace("caching " + BaseConcept__BehaviorDescriptor.getPresentation_idhEwIMiw.invoke(node) + "->" + value);
    }
    MapSequence.fromMap(cache).put(node, value);
  }

  public Object get(SNode node) {
    Object result = MapSequence.fromMap(cache).get(node);
    if (LOG.isTraceLevel()) {
      LOG.trace("returning " + BaseConcept__BehaviorDescriptor.getPresentation_idhEwIMiw.invoke(node) + "->" + result);
    }
    return result;
  }

  public void remove(SNode node) {
    MapSequence.fromMap(cache).removeKey(node);
  }

  public void clear() {
    MapSequence.fromMap(cache).clear();
  }

  protected Map<SNode, Object> getCache() {
    return cache;
  }

  @Override
  public String toString() {
    return "cache: [" + IterableUtils.join(MapSequence.fromMap(cache).select((it) -> SNodeOperations.present(it.key()) + " " + it.key().getNodeId() + "=" + it.value()), ", ") + "]";
  }
}
