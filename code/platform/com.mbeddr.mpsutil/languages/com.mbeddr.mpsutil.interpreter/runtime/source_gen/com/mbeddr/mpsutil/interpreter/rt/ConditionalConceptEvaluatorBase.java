package com.mbeddr.mpsutil.interpreter.rt;

/*Generated by MPS */

import org.jetbrains.mps.openapi.language.SAbstractConcept;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import jetbrains.mps.internal.collections.runtime.Sequence;
import org.jetbrains.mps.openapi.language.SConcept;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;

public abstract class ConditionalConceptEvaluatorBase extends ConceptEvaluatorBase implements IConditionalEvaluator {
  public ConditionalConceptEvaluatorBase(SAbstractConcept concept, String sourceURL, boolean shouldCache, IConstraint... constraints) {
    super(concept, sourceURL, shouldCache, constraints);
  }

  public boolean isEvaluable(SNode node, final IContext context) {
    if (ListSequence.fromList(SNodeOperations.getChildren(node)).isEmpty()) {
      return true;
    } else {
      final Iterable<SContainmentLink> baseLinkDeclarations = CONCEPTS.BaseConcept$gP.getContainmentLinks();
      return ListSequence.fromList(SNodeOperations.getChildren(node)).where((it) -> !(Sequence.fromIterable(baseLinkDeclarations).contains(SNodeOperations.getContainingLink(it)))).all((it) -> ((IConditionalInterpreter) context.getRootInterpreter()).isEvaluable(it, context));
    }
  }

  public boolean matchesEvaluatorTypeless(SNode node, IContext context) {
    return matchesConcept(node);
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept BaseConcept$gP = MetaAdapterFactory.getConcept(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x10802efe25aL, "jetbrains.mps.lang.core.structure.BaseConcept");
  }
}
