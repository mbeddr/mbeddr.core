package com.mbeddr.mpsutil.interpreter.rt;

/*Generated by MPS */

import java.util.LinkedHashMap;
import org.jetbrains.mps.openapi.model.SNode;
import java.util.Map;
import jetbrains.mps.internal.collections.runtime.SetSequence;

public class EnvironmentImpl extends LinkedHashMap<SNode, Object> implements IEnvironment {
  private IEnvironment parent;
  private INodeValueCache cache;

  public EnvironmentImpl() {
    super();
    this.parent = null;
  }

  protected EnvironmentImpl(INodeValueCache cache) {
    this();
    this.cache = cache;
  }

  public IEnvironment push(SNode node, Map<SNode, Object> initialEnvironment) {
    EnvironmentImpl result = create();
    result.setParentEnvironment(this);
    result.setCache(this.getCache());
    result.putAll(initialEnvironment);

    return result;
  }

  protected EnvironmentImpl create() {
    return new EnvironmentImpl();
  }

  public IEnvironment pop(SNode node) {
    IEnvironment parentEnvironment = this.getParentEnvironment();
    if (parentEnvironment != null) {
      return parentEnvironment;
    } else {
      return this;
    }
  }

  public IEnvironment getParentEnvironment() {
    return this.parent;
  }

  public IEnvironment getRootEnvironment() {
    IEnvironment current = this;
    IEnvironment result;

    do {
      result = current;
      current = current.getParentEnvironment();
    } while (current != null);

    return result;
  }

  protected void setParentEnvironment(IEnvironment parent) {
    this.parent = parent;
  }

  public void setCache(INodeValueCache cache) {
    this.cache = cache;
  }

  public INodeValueCache getCache() {
    return this.cache;
  }

  @Override
  public boolean containsValueInCurrent(Object object) {
    return super.containsValue(object);
  }
  @Override
  public boolean containsValue(Object object) {
    boolean result = super.containsValue(object);
    if (result) {
      return true;
    }
    IEnvironment parentEnvironment = getParentEnvironment();
    if (parentEnvironment != null) {
      return parentEnvironment.containsValue(object);
    }
    return false;
  }

  @Override
  public Object getInCurrent(Object object) {
    return super.get(object);
  }
  @Override
  public Object get(Object object) {
    if (super.containsKey(object)) {
      return super.get(object);
    }
    IEnvironment parentEnvironment = getParentEnvironment();
    if (parentEnvironment != null) {
      return parentEnvironment.get(object);
    }
    return null;
  }

  @Override
  public boolean containsKeyInCurrent(Object object) {
    return super.containsKey(object);
  }
  @Override
  public boolean containsKey(Object object) {
    boolean result = super.containsKey(object);
    if (result) {
      return true;
    }
    IEnvironment parentEnvironment = getParentEnvironment();
    if (parentEnvironment != null) {
      return parentEnvironment.containsKey(object);
    }
    return false;
  }

  @Override
  public Object put(SNode node, Object object) {
    if (cache != null) {
      cache.remove(node);
    }
    return super.put(node, object);
  }

  @Override
  public void putAll(Map<? extends SNode, ?> map) {
    if (cache != null) {
      for (SNode node : SetSequence.fromSet(map.keySet())) {
        cache.remove(node);
      }
    }
    super.putAll(map);
  }
}
