package com.mbeddr.mpsutil.interpreter.rt;

/*Generated by MPS */

import jetbrains.mps.logging.Logger;
import org.jetbrains.mps.openapi.model.SNode;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import jetbrains.mps.typechecking.TypecheckingFacade;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import com.mbeddr.mpsutil.interpreter.behavior.IInterpreterWrapperType__BehaviorDescriptor;
import jetbrains.mps.typesystem.inference.TypeChecker;
import org.jetbrains.mps.openapi.language.SInterfaceConcept;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;

public class TypedChildConstraintImpl implements IConstraint {
  private static final Logger LOG = Logger.getLogger(TypedChildConstraintImpl.class);
  private final SNode child;
  private final SNode type;

  public TypedChildConstraintImpl(SNode child, SNode type) {
    this.child = child;
    this.type = type;
  }
  public TypedChildConstraintImpl(SContainmentLink child, SNode type) {
    this.child = ((SNode) child.getDeclarationNode());
    this.type = type;
  }
  public boolean matchesConstraint(SNode node, IContext context) {
    SNode matchingChild = RtUtil.findNamedChild(node, child);
    TypecheckingFacade typechecking = TypecheckingFacade.getFromContext();

    if ((matchingChild == null)) {
      return false;
    }

    if (LOG.isTraceLevel()) {
      LOG.trace("matchingChild: " + SNodeOperations.present(matchingChild) + "::" + matchingChild.getNodeId());
    }

    SNode matchingChildType = null;
    if (context instanceof ITypeCachingContext) {
      matchingChildType = ((ITypeCachingContext) context).getNodeTypeCache().get(matchingChild);
      if (LOG.isTraceLevel()) {
        LOG.trace("matchingChildType: " + matchingChildType);
      }
    }
    if (matchingChildType == null) {
      matchingChildType = typechecking.getTypeOf(matchingChild);
      if (context instanceof ITypeCachingContext) {
        ((ITypeCachingContext) context).getNodeTypeCache().set(matchingChild, matchingChildType);
      }
      if (LOG.isTraceLevel()) {
        LOG.trace("notMatchingChildType: " + matchingChildType);
      }
    }

    SNode childType = context.getMapTypeProvider().mapType(((SNode) matchingChildType), context);

    while (SNodeOperations.isInstanceOf(childType, CONCEPTS.IInterpreterWrapperType$KD)) {
      childType = IInterpreterWrapperType__BehaviorDescriptor.wrappedType_id6bG6MAFRDvi.invoke(SNodeOperations.cast(childType, CONCEPTS.IInterpreterWrapperType$KD));
    }

    // TypeChecker allows to check isSubTypeByReplacementRules() which TypecheckingFacade doesn't support
    // hence we still need to use TypeChecker for compatibility 
    TypeChecker typeChecker = TypeChecker.getInstance();
    boolean result = typeChecker.getSubtypingManager().isSubtype(childType, type);
    if (!(result)) {
      result = typeChecker.getSubtypingManager().isSubTypeByReplacementRules(childType, type, true);
    }

    if (LOG.isTraceLevel()) {
      LOG.trace("trying to match childType: " + SNodeOperations.present(childType) + " against typeGuard: " + type + " result: " + result);
    }

    return result;
  }

  private static final class CONCEPTS {
    /*package*/ static final SInterfaceConcept IInterpreterWrapperType$KD = MetaAdapterFactory.getInterfaceConcept(0x47f075a6558e4640L, 0xa6067ce0236c8023L, 0x62ec1b29abde62acL, "com.mbeddr.mpsutil.interpreter.structure.IInterpreterWrapperType");
  }
}
