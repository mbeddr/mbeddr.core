package com.mbeddr.mpsutil.interpreter.rt;

/*Generated by MPS */

import com.mbeddr.mpsutil.traceExplorer.plugin.IRerunnableTraceRecord;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.mps.openapi.model.SNode;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import com.mbeddr.mpsutil.traceExplorer.plugin.ITraceRerunner;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.lang.core.behavior.BaseConcept__BehaviorDescriptor;
import com.mbeddr.mpsutil.interpreter.behavior.ITracerFrame__BehaviorDescriptor;
import jetbrains.mps.internal.collections.runtime.ISequence;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.mps.openapi.model.SNodeReference;
import jetbrains.mps.internal.collections.runtime.Sequence;
import com.mbeddr.mpsutil.interpreter.behavior.ITrivialNode__BehaviorDescriptor;
import com.mbeddr.mpsutil.traceExplorer.plugin.ITraceRecord;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import org.jetbrains.mps.openapi.language.SInterfaceConcept;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;

public class ComputationTrace implements IRerunnableTraceRecord {


  @NotNull
  private SNode node;
  private SNode iconNode;
  private String computationSourceURL;
  private List<ComputationTrace> children = ListSequence.fromList(new ArrayList<ComputationTrace>());
  private boolean isFrame;
  private boolean isInfo;
  private String kind;
  private String syntax;
  private String conceptName;
  private Object value;
  private long time;
  private boolean showInAnyCase;
  private boolean showNever;
  private boolean skip;
  private ITraceRerunner rerunner;
  private String constraintFailure;
  private ComputationTrace parent;
  private String customLabel;
  private boolean representsCachedValue;
  private static _FunctionTypes._void_P1_E0<? super ComputationTrace> childAddedCallBackFunction = null;

  private long constructionTime = 0;

  private boolean mustBeRevealed = false;

  public static void setCallBackWhenChildAdded(_FunctionTypes._void_P1_E0<? super ComputationTrace> childAddedCallBack) {
    childAddedCallBackFunction = childAddedCallBack;
  }
  public static _FunctionTypes._void_P1_E0<? super ComputationTrace> getCallBackWhenChildAdded() {
    return childAddedCallBackFunction;
  }

  public ComputationTrace(SNode n) {
    this();
    node = n;
    kind = SNodeOperations.getConcept(n).getConceptAlias();
    syntax = BaseConcept__BehaviorDescriptor.getPresentation_idhEwIMiw.invoke(n);
    conceptName = SNodeOperations.getConcept(n).getName();

    if (SNodeOperations.isInstanceOf(n, CONCEPTS.ITracerFrame$iZ) && (boolean) ITracerFrame__BehaviorDescriptor.isFrame_id7obiejCehQ6.invoke(SNodeOperations.cast(n, CONCEPTS.ITracerFrame$iZ))) {
      isFrame = true;
      syntax = ITracerFrame__BehaviorDescriptor.renderTraceSyntax_id5Beavy0LkEa.invoke(SNodeOperations.cast(n, CONCEPTS.ITracerFrame$iZ));
    }
  }

  public ComputationTrace(SNode n, boolean showAlways) {
    this(n);
    if (showAlways) {
      markAsShowInAnyCase();
    }
  }

  public ComputationTrace markAsShowInAnyCase() {
    this.showInAnyCase = true;
    return this;
  }

  public ComputationTrace markAsShowNever() {
    this.showNever = true;
    return this;
  }

  public ComputationTrace unmarkAsShowNever() {
    this.showNever = false;
    return this;
  }

  public ComputationTrace markAsSkip() {
    this.skip = true;
    return this;
  }

  public boolean mustShowInAnyCase() {
    return this.showInAnyCase && !(showNever);
  }

  public boolean mustShowNever() {
    return this.showNever;
  }

  public boolean markAsCached() {
    return this.representsCachedValue = true;
  }

  public boolean isCachedValue() {
    return this.representsCachedValue;
  }

  public ComputationTrace setCustomLabel(String l) {
    this.customLabel = l;
    return this;
  }

  public ComputationTrace() {
    this.constructionTime = System.currentTimeMillis();
  }

  public void setValue(Object val) {
    setValue(val, System.currentTimeMillis() - this.constructionTime);
  }

  public void setValue(Object val, long time) {
    if (val instanceof ISequence) {
      // explicitly de-lazy-fy the sequence to avoid strange behavior
      List<Object> l = ListSequence.fromList(new ArrayList<Object>());
      for (Object e : ((ISequence) val)) {
        ListSequence.fromList(l).addElement(e);
      }
      this.value = l;
    } else {
      this.value = val;
    }
    this.time = time;
  }

  public void markAsFrame() {
    isFrame = true;
  }

  public ComputationTrace addChild(ComputationTrace t) {
    if (t == null) {
      return this;
    }
    ComputationTrace next = this;
    while (next != null) {
      // prevent creating cycles in computation trace
      if (next == t) {
        return this;
      }
      next = next.parent;
    }
    t.parent = this;
    ListSequence.fromList(children).addElement(t);
    if (childAddedCallBackFunction != null) {
      childAddedCallBackFunction.invoke(t);
    }
    return this;
  }

  public ComputationTrace addChild(ComputationTrace t, boolean showInAnyCase, String label) {
    if (t == null) {
      return this;
    }
    if (showInAnyCase) {
      t.markAsShowInAnyCase();
    }
    t.setCustomLabel(label);
    addChild(t);
    return this;
  }

  public ComputationTrace newChild(SNode n, boolean showInAnyCase, String label) {
    ComputationTrace newTrace = new ComputationTrace(n);
    this.addChild(newTrace, showInAnyCase, label);
    return newTrace;
  }

  public ComputationTrace newChild(SNode n, boolean showInAnyCase, String label, Object value) {
    ComputationTrace newTrace = newChild(n, showInAnyCase, label);
    newTrace.setValue(value);
    return newTrace;
  }


  public List<ComputationTrace> children() {
    return this.children;
  }


  public boolean representsNode(SNode n) {
    return this.getTargetNode() == n;
  }

  public ComputationTrace childForNode(final SNode n) {
    return ListSequence.fromList(this.children).findFirst((it) -> it.representsNode(n));
  }

  public ComputationTrace descendantForNode(SNode n) {
    if (this.representsNode(n)) {
      return this;
    }
    for (ComputationTrace c : ListSequence.fromList(children())) {
      if (c.representsNode(n)) {
        return c;
      }
    }
    for (ComputationTrace c : ListSequence.fromList(children())) {
      ComputationTrace enkel = c.descendantForNode(n);
      if (enkel != null) {
        return enkel;
      }
    }
    return null;
  }

  public void dump(String indent) {
    if (indent == null) {
      indent = "";
    }
    String valStr = (value != null ? value.toString() : "<no value>");
    if (this.isFrame) {
      System.err.println(indent + "--------");
    }
    System.err.println(indent + kind + " --> " + valStr);
    for (ComputationTrace c : ListSequence.fromList(children)) {
      c.dump(indent + "  ");
    }
  }

  public void dumpFromRoot() {
    this.rootTrace().dump("");
  }

  @NotNull
  @Override
  public String getName() {
    return this.kind + "  ==>  " + this.value;
  }

  @Nullable
  @Override
  public SNodeReference getTarget() {
    return this.node.getReference();
  }

  @NotNull
  public SNode getTargetNode() {
    return node;
  }

  public boolean getSkip() {
    return skip;
  }

  public boolean getShowInAnyCase() {
    return showInAnyCase;
  }

  @NotNull
  @Override
  public Iterable<? extends ComputationTrace> getChildren(boolean filtered) {
    return children;
  }


  public Iterable<ComputationTrace> findNextLevelFiltered(ComputationTrace t) {
    List<ComputationTrace> res = ListSequence.fromList(new ArrayList<ComputationTrace>());
    for (ComputationTrace c : ListSequence.fromList(t.children)) {
      if (c.showInAnyCase) {
        ListSequence.fromList(res).addElement(c);
      } else {
        ListSequence.fromList(res).addSequence(Sequence.fromIterable(findNextLevelFiltered(c)));
      }
    }
    return res;
  }


  public int getWeight() {
    SNode n = this.getTargetNode();
    if (SNodeOperations.isInstanceOf(n, CONCEPTS.ITracerFrame$iZ)) {
      return 50;
    }
    return 0;
  }


  public String getTimeAsString() {
    if (this.time == 0) {
      return null;
    }
    return this.time + "";
  }

  public String getKind() {
    return this.kind;

  }
  public String getSyntax() {
    String s = this.syntax;
    if (s == null) {
      return "<no syntax>";
    }
    return s;
  }

  public String getConceptName() {
    return this.conceptName;
  }

  @Override
  public Object getTracedValue() {
    return this.value;
  }

  public boolean isInAnEditor() {
    SNode n = this.node;
    return n != null && SNodeOperations.getModel(n) != null;
  }

  public void setRerunner(ITraceRerunner r) {
    this.rerunner = r;
  }

  @Override
  public ITraceRerunner getRerunner() {
    return rerunner;
  }

  @Override
  public boolean mustBeRevealed() {
    return this.mustBeRevealed;
  }

  public boolean markForReveal() {
    return this.mustBeRevealed = true;
  }

  public void setConstraintFailure(String message) {
    this.constraintFailure = message;
  }

  public String getConstrainFailureMessage() {
    return this.constraintFailure;
  }

  public boolean hasConstraintFailure() {
    return this.getConstrainFailureMessage() != null;
  }

  public ComputationTrace rootTrace() {
    if (this.parent == null) {
      return this;
    } else {
      return this.parent.rootTrace();
    }
  }

  public String getCustomLabel() {
    return this.customLabel;
  }

  public boolean hasCustomLabel() {
    return this.customLabel != null;
  }

  public boolean neverEverShow() {
    if (this.showNever) {
      return true;
    }
    SNode n = this.getTargetNode();
    return SNodeOperations.isInstanceOf(n, CONCEPTS.ITrivialNode$6J) && (boolean) ITrivialNode__BehaviorDescriptor.isTrivial_id3T40JVg3mh$.invoke(SNodeOperations.cast(n, CONCEPTS.ITrivialNode$6J));
  }


  @Override
  public ITraceRecord getParent() {
    return this.parent;
  }

  public void deleteChildren() {
    ListSequence.fromList(this.children).clear();
  }

  public List<ComputationTrace> createStackTraceToThisOne(boolean filtered) {
    List<ComputationTrace> stackTrace = ListSequence.fromList(new ArrayList<ComputationTrace>());
    ComputationTrace cur = this;
    do {
      if (cur == this || SNodeOperations.isInstanceOf(cur.getTargetNode(), CONCEPTS.ITracerFrame$iZ) || cur.mustShowInAnyCase()) {
        ListSequence.fromList(stackTrace).addElement(cur);
      }
      cur = ((ComputationTrace) cur.getParent());
    } while (cur != null);
    return stackTrace;
  }

  public String createStackTraceToThisOneAsString(boolean filtered, int indent) {
    final Wrappers._T<String> ind = new Wrappers._T<String>("");
    for (int i = 0; i < indent; i++) {
      ind.value += " ";
    }
    final StringBuilder sb = new StringBuilder();
    List<ComputationTrace> st = createStackTraceToThisOne(filtered);
    ListSequence.fromList(st).visitAll((it) -> sb.append(ind.value + it.toString() + "\n"));
    return sb.toString();
  }

  @Override
  public String toString() {
    return this.getSyntax() + " ==> " + this.getTracedValue();
  }

  public ComputationTrace getFirstChild() {
    return ListSequence.fromList(this.children).first();
  }

  public SNode getIconNode() {
    return this.iconNode;
  }

  public boolean isInfoNode() {
    return this.isInfo;
  }

  public ComputationTrace setIconNode(SNode n) {
    this.iconNode = n;
    return this;
  }

  public ComputationTrace setInfo(boolean i) {
    this.isInfo = i;
    return this;
  }

  @Override
  public String computationSourceURL() {
    return this.computationSourceURL;
  }

  public void setComputationSource(String source) {
    this.computationSourceURL = source;
  }


  private static final class CONCEPTS {
    /*package*/ static final SInterfaceConcept ITracerFrame$iZ = MetaAdapterFactory.getInterfaceConcept(0x47f075a6558e4640L, 0xa6067ce0236c8023L, 0x760b48e4e8391c1fL, "com.mbeddr.mpsutil.interpreter.structure.ITracerFrame");
    /*package*/ static final SInterfaceConcept ITrivialNode$6J = MetaAdapterFactory.getInterfaceConcept(0x47f075a6558e4640L, 0xa6067ce0236c8023L, 0x3e4402fed00d643fL, "com.mbeddr.mpsutil.interpreter.structure.ITrivialNode");
  }
}
