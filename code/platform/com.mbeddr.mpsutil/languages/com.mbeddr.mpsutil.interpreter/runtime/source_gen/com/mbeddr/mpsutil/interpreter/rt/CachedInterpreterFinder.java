package com.mbeddr.mpsutil.interpreter.rt;

/*Generated by MPS */

import java.util.Map;
import java.util.Set;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.LinkedHashMap;
import jetbrains.mps.internal.collections.runtime.Sequence;
import com.mbeddr.mpsutil.common.model.ConceptInstanceFinder;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.LinkedHashSet;
import org.jetbrains.mps.openapi.language.SConcept;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import org.jetbrains.mps.openapi.language.SProperty;

public class CachedInterpreterFinder {
  private static CachedInterpreterFinder instance;

  private final Map<String, Set<SNode>> cachedInterpreters = MapSequence.fromMap(new LinkedHashMap<String, Set<SNode>>(16, (float) 0.75, false));
  private boolean alreadySearched = false;

  protected CachedInterpreterFinder() {
  }

  public static CachedInterpreterFinder getInstance() {
    if (instance == null) {
      instance = new CachedInterpreterFinder();
    }

    return instance;
  }


  public Iterable<SNode> findAllInterpreters() {
    searchInterpreters();
    return Sequence.fromIterable(MapSequence.fromMap(cachedInterpreters).values()).translate((it) -> it);
  }

  public Iterable<SNode> findInterpretersForCategory(String cat) {
    searchInterpreters();
    return MapSequence.fromMap(cachedInterpreters).get(cat);
  }

  public void flushCache() {
    MapSequence.fromMap(cachedInterpreters).clear();
    alreadySearched = false;
  }

  protected void searchInterpreters() {
    if (!(alreadySearched)) {
      Sequence.fromIterable(((Iterable<SNode>) ConceptInstanceFinder.findAllInstances(CONCEPTS.Interpreter$pR))).visitAll((it) -> {
        if (!(MapSequence.fromMap(cachedInterpreters).containsKey(SPropertyOperations.getString(it, PROPS.category$ODvC)))) {
          MapSequence.fromMap(cachedInterpreters).put(SPropertyOperations.getString(it, PROPS.category$ODvC), SetSequence.fromSet(new LinkedHashSet<SNode>()));
        }
        SetSequence.fromSet(MapSequence.fromMap(cachedInterpreters).get(SPropertyOperations.getString(it, PROPS.category$ODvC))).addElement(it);
      });

      alreadySearched = true;
    }
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept Interpreter$pR = MetaAdapterFactory.getConcept(0x47f075a6558e4640L, 0xa6067ce0236c8023L, 0x778ee47a6de672eaL, "com.mbeddr.mpsutil.interpreter.structure.Interpreter");
  }

  private static final class PROPS {
    /*package*/ static final SProperty category$ODvC = MetaAdapterFactory.getProperty(0x47f075a6558e4640L, 0xa6067ce0236c8023L, 0x778ee47a6de672eaL, 0x74efbb724e165bf7L, "category");
  }
}
