package com.mbeddr.mpsutil.interpreter.rt;

/*Generated by MPS */

import jetbrains.mps.logging.Logger;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import java.util.List;
import java.util.Arrays;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import java.math.BigInteger;
import java.math.BigDecimal;

public abstract class ConceptEvaluatorBase implements IEvaluator {
  private static final Logger LOG = Logger.getLogger(ConceptEvaluatorBase.class);
  protected final SAbstractConcept concept;
  private final boolean shouldCache;

  private String sourceURL;
  protected final List<IConstraint> constraints;

  public ConceptEvaluatorBase(SAbstractConcept concept, String sourceURL, boolean shouldCache, IConstraint... constraints) {
    this.concept = concept;
    this.shouldCache = shouldCache;
    this.constraints = Arrays.asList(constraints);
    this.sourceURL = sourceURL;
  }


  @Override
  public String computationSource() {
    return this.sourceURL;
  }

  @Override
  public boolean canLookupBeCached() {
    return ListSequence.fromList(this.constraints).isEmpty();
  }

  public boolean matchesEvaluator(SNode node, IContext context) {
    if (LOG.isTraceLevel()) {
      LOG.trace("node: " + SNodeOperations.present(node) + " matchesConcept: " + matchesConcept(node) + " matchesConstraints: " + matchesConstraints(node, context));
    }
    return matchesConcept(node) && matchesConstraints(node, context);
  }

  public abstract Object evaluateEvaluator(SNode node, IContext context, ICoverageAnalyzer coverage, ComputationTrace trace);

  public boolean shouldCache(SNode node, IContext context) {
    return this.shouldCache;
  }

  protected boolean matchesConcept(SNode node) {
    boolean result = concept != null && (SNodeOperations.isInstanceOf(node, SNodeOperations.asSConcept(this.concept)));

    if (LOG.isTraceLevel()) {
      LOG.trace("trying to match node " + SNodeOperations.present(node) + "[" + SNodeOperations.getConcept(node) + "] against concept " + concept + ": " + result);
    }

    return result;
  }

  protected boolean matchesConstraints(SNode node, IContext context) {
    for (IConstraint constraint : constraints) {
      if (!(constraint.matchesConstraint(node, context))) {
        return false;
      }
    }
    return true;
  }

  public static Object castUp(Object input, Class targetType) {
    Object mangledInput = input;
    boolean targetIsNumber = Number.class.isAssignableFrom(targetType);
    if (input instanceof Character && targetIsNumber) {
      mangledInput = Integer.valueOf(((Character) input));
    }
    if (mangledInput instanceof Number) {
      Number numberInput = (Number) mangledInput;
      if (targetType == Double.class) {
        return numberInput.doubleValue();
      } else if (targetType == Float.class) {
        return numberInput.floatValue();
      } else if (targetType == Long.class) {
        return numberInput.longValue();
      } else if (targetType == Integer.class) {
        return numberInput.intValue();
      } else if (targetType == Short.class) {
        return numberInput.shortValue();
      } else if (targetType == Character.class) {
        return ((char) numberInput.intValue());
      } else if (targetType == Byte.class) {
        return numberInput.byteValue();
      } else if (targetType == BigInteger.class) {
        if (input instanceof BigInteger) {
          return input;
        } else {
          return BigInteger.valueOf(numberInput.longValue());
        }
      } else if (targetType == BigDecimal.class) {
        if (input instanceof BigDecimal) {
          return input;
        } else if (input instanceof Double || input instanceof Float) {
          return BigDecimal.valueOf(numberInput.doubleValue());
        } else {
          return BigDecimal.valueOf(numberInput.longValue());
        }
      }
    } else if (targetIsNumber) {
      throw new InvalidUpCastException(input, targetType);
    }

    return input;
  }
  @Override
  public SAbstractConcept getConcept() {
    return this.concept;
  }
}
