package com.mbeddr.mpsutil.interpreter.rt;

/*Generated by MPS */

import jetbrains.mps.logging.Logger;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import java.util.Set;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import java.util.Map;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.IAttributeDescriptor;
import com.mbeddr.mpsutil.interpreter.behavior.ValueInspector__BehaviorDescriptor;
import com.mbeddr.mpsutil.interpreter.behavior.IReveal__BehaviorDescriptor;
import jetbrains.mps.lang.core.behavior.BaseConcept__BehaviorDescriptor;
import java.util.LinkedHashMap;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import org.jetbrains.mps.openapi.language.SInterfaceConcept;
import org.jetbrains.mps.openapi.language.SConcept;

public abstract class InterpreterBase implements IInterpreter, IMapTypeProvider {
  private static final Logger LOG = Logger.getLogger(InterpreterBase.class);

  public static final Object __NEXT__INTERPRETER__ = "__NEXT__INTERPRETER__";

  private final List<? extends IEvaluator> evaluators = ListSequence.fromList(new ArrayList<IEvaluator>());
  private final List<? extends ITypeMapper> typeMappers = ListSequence.fromList(new ArrayList<ITypeMapper>());
  private final List<? extends IRelationship> relationships = ListSequence.fromList(new ArrayList<IRelationship>());

  private Set<SAbstractConcept> neverCacheLookup = SetSequence.fromSet(new HashSet<SAbstractConcept>());
  private Map<SAbstractConcept, IEvaluator> evalLookupCache = MapSequence.fromMap(new HashMap<SAbstractConcept, IEvaluator>());

  protected void init() {
    populateEvaluators(evaluators);
    for (IEvaluator e : ListSequence.fromList(evaluators)) {
      if (!(e.canLookupBeCached())) {
        SetSequence.fromSet(neverCacheLookup).addElement(e.getConcept());
      }
    }
    populateTypeMappers(typeMappers);
    populateRelationships(relationships);
  }

  protected abstract void populateEvaluators(List<? extends IEvaluator> evaluators);

  public List<? extends IEvaluator> listEvaluators() {
    return ListSequence.fromList(evaluators).sort((it) -> it.canLookupBeCached(), true).toList();
  }


  protected abstract void populateTypeMappers(List<? extends ITypeMapper> typeMappers);

  public List<? extends ITypeMapper> listTypeMappers() {
    return typeMappers;
  }

  public void regsiterNeverCacheConcept(SAbstractConcept concept) {
    SetSequence.fromSet(this.neverCacheLookup).addElement(concept);
  }

  protected abstract void populateRelationships(List<? extends IRelationship> relationships);

  public List<? extends IRelationship> listRelationships() {
    return relationships;
  }


  public Object evaluate(SNode node, IContext context, ICoverageAnalyzer coverage, ComputationTrace contextTrace, boolean stopOnStop) throws InterpreterBaseException {
    if ((node == null)) {
      return null;
    }

    IInterpreter rootInterpreter = context.getRootInterpreter();
    Object cachedValue = rootInterpreter.getCachedValue(node, context);
    if (cachedValue != null) {
      return cachedValue;
    }

    context.setMapTypeProvider(this);

    IEvaluator cachedEvaluator = MapSequence.fromMap(evalLookupCache).get(SNodeOperations.getConcept(node));
    if (cachedEvaluator != null) {
      Object evalResult = evalInternal(cachedEvaluator, node, context, coverage, contextTrace, stopOnStop);
      // cached evaluator might still return tryAnotherInterpreter
      // if this is the case, we try to look for another interpreter 
      if (evalResult != __NEXT__INTERPRETER__) {
        return evalResult;
      }
    }

    List<? extends IEvaluator> evaluators = listEvaluators();

    for (IEvaluator evaluator : ListSequence.fromList(evaluators)) {
      // skip evaluator that was previously looked up in the cache  
      if (evaluator == cachedEvaluator) {
        continue;
      }

      if (LOG.isTraceLevel()) {
        LOG.trace("checking evaluator match for: " + evaluator);
      }
      if (evaluator.matchesEvaluator(node, context)) {

        if (!(MapSequence.fromMap(evalLookupCache).containsKey(SNodeOperations.getConcept(node))) && evaluator.canLookupBeCached() && !(SetSequence.fromSet(neverCacheLookup).contains(SNodeOperations.getConcept(node)))) {
          MapSequence.fromMap(evalLookupCache).put(SNodeOperations.getConcept(node), evaluator);
        }
        Object evalResult = evalInternal(evaluator, node, context, coverage, contextTrace, stopOnStop);
        if (evalResult == __NEXT__INTERPRETER__) {
          continue;
        }
        return evalResult;
      }
    }

    if (LOG.isErrorLevel()) {
      LOG.error("None of the following evaluators matched:");
    }
    for (IEvaluator evaluator : ListSequence.fromList(evaluators)) {
      if (LOG.isErrorLevel()) {
        LOG.error(evaluator.getInfo().toString());
      }
    }
    throw new EvaluatorNotApplicableException(node);
  }

  private Object evalInternal(IEvaluator evaluator, SNode node, IContext context, ICoverageAnalyzer coverage, ComputationTrace contextTrace, boolean stopOnStop) {
    if (LOG.isTraceLevel()) {
      LOG.trace("evaluator matched");
    }

    Object result;
    ComputationTrace newTrace = null;
    if (contextTrace != null) {
      long start = System.currentTimeMillis();
      newTrace = new ComputationTrace(node);
      newTrace.setComputationSource(evaluator.computationSource());
      contextTrace.addChild(newTrace);
      SNode revealer = null;
      if (ListSequence.fromList(SLinkOperations.getChildren(node, LINKS.smodelAttribute$KJ43)).isNotEmpty()) {
        revealer = (SNode) ListSequence.fromList(SLinkOperations.getChildren(node, LINKS.smodelAttribute$KJ43)).findFirst((it) -> SNodeOperations.isInstanceOf(it, CONCEPTS.IReveal$bc));
      }
      result = evaluator.evaluateEvaluator(node, context, coverage, newTrace);
      if (revealer != null) {
        context.getEnvironment().put(revealer, result);
      }
      if (new IAttributeDescriptor.NodeAttribute(CONCEPTS.ValueInspector$ql).get(node) != null) {
        ValueInspector__BehaviorDescriptor.addValue_id2ufoZQIGI7Z.invoke(new IAttributeDescriptor.NodeAttribute(CONCEPTS.ValueInspector$ql).get(node), result);
      }
      if (result instanceof IRequiresSnapshot) {
        newTrace.setValue(((IRequiresSnapshot) result).createSnapshot(), System.currentTimeMillis() - start);
      } else {
        newTrace.setValue(result, System.currentTimeMillis() - start);
      }
      if (revealer != null && result != __NEXT__INTERPRETER__) {
        SNode cond = IReveal__BehaviorDescriptor.getTheNodeToEvalute_id4hW8Ne0mTH4.invoke(revealer);
        if (cond == null) {
          newTrace.markForReveal();
        } else {
          Object res = this.evaluate(cond, context, coverage, contextTrace, stopOnStop);
          if ((boolean) IReveal__BehaviorDescriptor.mustBeRevealed_id4hW8Ne0aLJi.invoke(revealer, res)) {
            newTrace.markForReveal();
          }
        }

      }

    } else {
      result = evaluator.evaluateEvaluator(node, context, coverage, null);
    }

    if (stopOnStop && result instanceof IStopAndReturn) {
      throw new StopAndReturnException(((IStopAndReturn) result));
    }
    if (result == __NEXT__INTERPRETER__) {
      if (contextTrace != null) {
        contextTrace.setValue(null);
        contextTrace.deleteChildren();
      }
      return __NEXT__INTERPRETER__;
    }
    coverage.coverValue(node, result);
    if (!(context.getConfiguration().isNullValid())) {
      if (result == null) {
        if (newTrace != null) {
          newTrace.setConstraintFailure("invalid <null> value detected");
          newTrace.markForReveal();
        }
        String info = "node: " + BaseConcept__BehaviorDescriptor.getPresentation_idhEwIMiw.invoke(node) + " / eval: " + evaluator.getInfo();
        throw new InvalidValueException(node, "invalid null value detected\n" + info, context, newTrace);
      }
    }

    context.getRootInterpreter().setCachedValue(node, result, context, evaluator);

    return result;
  }


  public Object evaluate(SNode node, IContext context) throws InterpreterBaseException {
    return evaluate(node, context, new NullCoverageAnalyzer(), null, false);
  }

  protected Object callOperation(SNode base, SNode operation, List actualParameter, List<SNode> formalParameter, IContext context, ICoverageAnalyzer coverage, ComputationTrace trace) {
    Map<SNode, Object> parameters = MapSequence.fromMap(new LinkedHashMap<SNode, Object>(16, (float) 0.75, false));
    for (int i = 0; i < ListSequence.fromList(formalParameter).count(); i++) {
      MapSequence.fromMap(parameters).put(ListSequence.fromList(formalParameter).getElement(i), actualParameter.get(i));
    }
    IInterpreter rootInterpreter = context.getRootInterpreter();
    context.pushEnvironment(base, parameters);
    try {
      rootInterpreter.removeCachedValue(operation, context);
      for (SNode param : ListSequence.fromList(formalParameter)) {
        rootInterpreter.removeCachedValue(param, context);
      }

      return rootInterpreter.evaluate(operation, context, coverage, trace, false);
    } finally {
      context.popEnvironment(base);
    }
  }


  public Object getCachedValue(SNode node, IContext context) {
    INodeValueCache nodeValueCache = context.getNodeValueCache();
    if (nodeValueCache != null) {
      return nodeValueCache.get(node);
    } else {
      return null;
    }
  }

  public void setCachedValue(SNode node, Object value, IContext context, IEvaluator evaluator) {
    INodeValueCache nodeValueCache = context.getNodeValueCache();
    if (nodeValueCache != null && evaluator.shouldCache(node, context)) {
      nodeValueCache.set(node, value);
    }
  }

  public void removeCachedValue(SNode node, IContext context) {
    INodeValueCache nodeValueCache = context.getNodeValueCache();
    if (nodeValueCache != null) {
      nodeValueCache.remove(node);
    }
  }

  public SNode mapType(SNode fromType, IContext context) {
    for (ITypeMapper typeMapper : ListSequence.fromList(listTypeMappers())) {
      if (typeMapper.matchesType(fromType, context)) {
        return typeMapper.mapType(fromType, context);
      }
    }

    return fromType;
  }

  private String interpreterId() {
    // generated interpreters assumed to have unique fully-qualified class name
    return this.getClass().getName();
  }

  @Override
  public int hashCode() {
    // hashCode/equals based on the interpreter FQN ensures deterministic computation of the topological sorting order for all registered interpreters
    return interpreterId().hashCode();
  }

  @Override
  public boolean equals(Object obj) {
    if (!(this.getClass().isInstance(obj))) {
      return false;
    }

    InterpreterBase other = ((InterpreterBase) obj);
    return this.interpreterId().equals(other.interpreterId());
  }

  @Override
  public String toString() {
    return this.getClass().getSimpleName();
  }

  private static final class LINKS {
    /*package*/ static final SContainmentLink smodelAttribute$KJ43 = MetaAdapterFactory.getContainmentLink(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x10802efe25aL, 0x47bf8397520e5942L, "smodelAttribute");
  }

  private static final class CONCEPTS {
    /*package*/ static final SInterfaceConcept IReveal$bc = MetaAdapterFactory.getInterfaceConcept(0x47f075a6558e4640L, 0xa6067ce0236c8023L, 0x447c2333802b1b10L, "com.mbeddr.mpsutil.interpreter.structure.IReveal");
    /*package*/ static final SConcept ValueInspector$ql = MetaAdapterFactory.getConcept(0x47f075a6558e4640L, 0xa6067ce0236c8023L, 0x278f63fdaeb2e1d6L, "com.mbeddr.mpsutil.interpreter.structure.ValueInspector");
  }
}
