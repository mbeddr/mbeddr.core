package com.mbeddr.mpsutil.interpreter.behavior;

/*Generated by MPS */

import jetbrains.mps.logging.Logger;
import com.mbeddr.mpsutil.common.graph.Graph;
import org.jetbrains.mps.openapi.model.SNode;
import java.util.List;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.LinkedHashSet;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import com.mbeddr.mpsutil.common.graph.GraphUtil;
import org.jetbrains.mps.openapi.language.SReferenceLink;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import org.jetbrains.mps.openapi.language.SProperty;
import org.jetbrains.mps.openapi.language.SConcept;

public class InterpreterSorter {
  private static final Logger LOG = Logger.getLogger(InterpreterSorter.class);
  protected Graph<SNode> dependencyGraph = new Graph<SNode>();

  public InterpreterSorter() {
  }

  public InterpreterSorter(SNode... interpreters) {
    add(interpreters);
  }

  public static List<SNode> sort(SNode... interpreters) {
    return new InterpreterSorter(interpreters).sort();
  }

  public void add(SNode... interpreters) {
    Set<SNode> interpretersSet = SetSequence.fromSet(new LinkedHashSet<SNode>());
    SetSequence.fromSet(interpretersSet).addSequence(Sequence.fromIterable(Sequence.fromArray(interpreters)));

    for (SNode interpreter : interpreters) {
      for (SNode relationship : Sequence.fromIterable(Interpreter__BehaviorDescriptor.collectAllRelationships_id5LSSDsNyu1z.invoke(interpreter))) {
        SNode target = SLinkOperations.getTarget(relationship, LINKS.target$de6W);
        if (SetSequence.fromSet(interpretersSet).contains(target) || contains(target)) {
          add(interpreter, relationship);
        }
      }
    }
  }

  public void add(SNode interpreter, SNode relationship) {
    SNode target = SLinkOperations.getTarget(relationship, LINKS.target$de6W);
    if (SNodeOperations.isInstanceOf(relationship, CONCEPTS.InterpretBeforeRelationship$MA)) {
      if (LOG.isTraceLevel()) {
        LOG.trace(SPropertyOperations.getString(interpreter, PROPS.name$MnvL) + " --> " + SPropertyOperations.getString(target, PROPS.name$MnvL));
      }
      dependencyGraph.addEdge(interpreter, target);
    } else if (SNodeOperations.isInstanceOf(relationship, CONCEPTS.InterpretAfterRelationship$Wk)) {
      if (LOG.isTraceLevel()) {
        LOG.trace(SPropertyOperations.getString(target, PROPS.name$MnvL) + " --> " + SPropertyOperations.getString(interpreter, PROPS.name$MnvL));
      }
      dependencyGraph.addEdge(target, interpreter);
    } else {
      dependencyGraph.addNode(interpreter);
    }
  }

  public boolean contains(SNode interpreter) {
    return SetSequence.fromSet(dependencyGraph.getAllNodes()).contains(interpreter);
  }

  public List<SNode> sort() {
    return GraphUtil.computeTopologicalSorting(dependencyGraph, true);
  }

  private static final class LINKS {
    /*package*/ static final SReferenceLink target$de6W = MetaAdapterFactory.getReferenceLink(0x47f075a6558e4640L, 0xa6067ce0236c8023L, 0x5c78e2973360a2c1L, 0x5c78e29733672c61L, "target");
  }

  private static final class PROPS {
    /*package*/ static final SProperty name$MnvL = MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name");
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept InterpretBeforeRelationship$MA = MetaAdapterFactory.getConcept(0x47f075a6558e4640L, 0xa6067ce0236c8023L, 0x5c78e29733672c63L, "com.mbeddr.mpsutil.interpreter.structure.InterpretBeforeRelationship");
    /*package*/ static final SConcept InterpretAfterRelationship$Wk = MetaAdapterFactory.getConcept(0x47f075a6558e4640L, 0xa6067ce0236c8023L, 0x5c78e2973367f2eeL, "com.mbeddr.mpsutil.interpreter.structure.InterpretAfterRelationship");
  }
}
