package com.mbeddr.mpsutil.interpreter.structure;

/*Generated by MPS */

import jetbrains.mps.lang.smodel.LanguageConceptIndex;
import jetbrains.mps.lang.smodel.LanguageConceptIndexBuilder;
import jetbrains.mps.smodel.adapter.ids.SConceptId;
import org.jetbrains.mps.openapi.language.SAbstractConcept;

public final class LanguageConceptSwitch {
  private final LanguageConceptIndex myIndex;
  public static final int AbstractConceptEvaluatorConstraint = 0;
  public static final int AbstractConceptEvaluatorImplementation = 1;
  public static final int AbstractConstraintRecursionExpression = 2;
  public static final int AbstractEvaluator = 3;
  public static final int AbstractEvaluatorCondition = 4;
  public static final int AbstractInterpreterRelationship = 5;
  public static final int AbstractRecursionExpression = 6;
  public static final int AbstractTypeMapping = 7;
  public static final int ApplicableLanguage = 8;
  public static final int BaseLanguageTypeMapping = 9;
  public static final int BranchID = 10;
  public static final int CastUpExpression = 11;
  public static final int ConceptEvaluator = 12;
  public static final int ConceptEvaluatorBody = 13;
  public static final int ConceptEvaluatorInline = 14;
  public static final int ConceptTypeExpression = 15;
  public static final int ConditionalConceptEvaluator = 16;
  public static final int ConditionalInterpreter = 17;
  public static final int ContextExpression = 18;
  public static final int CoverConceptStatement = 19;
  public static final int CoverageExpression = 20;
  public static final int DeclareListCoverage = 21;
  public static final int DelegateToNextInterpreterExpression = 22;
  public static final int DummyEvaluator = 23;
  public static final int EnvExpression = 24;
  public static final int EnvExpressionType = 25;
  public static final int EvaluatorConditionBody = 26;
  public static final int EvaluatorConditionInline = 27;
  public static final int EvaluatorExpression = 28;
  public static final int ExprOperationCallExpression = 29;
  public static final int FromTypeExpression = 30;
  public static final int ICanHaveTestCoverage = 31;
  public static final int IExcludeFromCoverage = 32;
  public static final int IInterpreterWrapperType = 33;
  public static final int IReveal = 34;
  public static final int ITracerFrame = 35;
  public static final int ITrivialNode = 36;
  public static final int InterpretAfterRelationship = 37;
  public static final int InterpretBeforeRelationship = 38;
  public static final int InterpretConstraintExpression = 39;
  public static final int InterpretExpression = 40;
  public static final int Interpreter = 41;
  public static final int InterpreterCreator = 42;
  public static final int IsEvaluableConstraintExpression = 43;
  public static final int IsEvaluableExpression = 44;
  public static final int NodeExpression = 45;
  public static final int OperationCallExpression = 46;
  public static final int RegisterBranchesStatement = 47;
  public static final int StopExpression = 48;
  public static final int TraceExpression = 49;
  public static final int TypeMapping = 50;
  public static final int TypedChildConstraint = 51;
  public static final int ValueInspector = 52;
  public static final int VisitBranchStatement = 53;

  public LanguageConceptSwitch() {
    LanguageConceptIndexBuilder builder = new LanguageConceptIndexBuilder(0x47f075a6558e4640L, 0xa6067ce0236c8023L);
    builder.put(0x4f47d8cd8320e29aL, AbstractConceptEvaluatorConstraint);
    builder.put(0x525a35a38d629025L, AbstractConceptEvaluatorImplementation);
    builder.put(0x761e4e6b8ed9bb7bL, AbstractConstraintRecursionExpression);
    builder.put(0x525a35a38d72237cL, AbstractEvaluator);
    builder.put(0x761e4e6b8ed3e7a5L, AbstractEvaluatorCondition);
    builder.put(0x5c78e2973360a2c1L, AbstractInterpreterRelationship);
    builder.put(0x761e4e6b8ed94d07L, AbstractRecursionExpression);
    builder.put(0x4976653a5204c44cL, AbstractTypeMapping);
    builder.put(0x616a1a166cfa5077L, ApplicableLanguage);
    builder.put(0x4976653a520b278aL, BaseLanguageTypeMapping);
    builder.put(0x6e19635d9039de74L, BranchID);
    builder.put(0x4596c1cd891d9532L, CastUpExpression);
    builder.put(0x778ee47a6de6793bL, ConceptEvaluator);
    builder.put(0x4f47d8cd82dd83deL, ConceptEvaluatorBody);
    builder.put(0x525a35a38d63e731L, ConceptEvaluatorInline);
    builder.put(0x4976653a52f1e247L, ConceptTypeExpression);
    builder.put(0x761e4e6b8ed3d1e2L, ConditionalConceptEvaluator);
    builder.put(0x761e4e6b8ed33e66L, ConditionalInterpreter);
    builder.put(0x4976653a51f15282L, ContextExpression);
    builder.put(0x31fb043bf724f016L, CoverConceptStatement);
    builder.put(0x495af83a866bb2daL, CoverageExpression);
    builder.put(0x363b019888e4a1f5L, DeclareListCoverage);
    builder.put(0x42b67d75d2859a5aL, DelegateToNextInterpreterExpression);
    builder.put(0x22e7c5e837506431L, DummyEvaluator);
    builder.put(0x2f4493db163a4768L, EnvExpression);
    builder.put(0x7ac27f5fc58e98acL, EnvExpressionType);
    builder.put(0x761e4e6b8ed3e7a7L, EvaluatorConditionBody);
    builder.put(0x761e4e6b8ed3e7a6L, EvaluatorConditionInline);
    builder.put(0x3afc2564197a9cdaL, EvaluatorExpression);
    builder.put(0x6cb34733ba13d585L, ExprOperationCallExpression);
    builder.put(0xb1c6984febab0b5L, FromTypeExpression);
    builder.put(0x5bb0bdbbedce7ccbL, ICanHaveTestCoverage);
    builder.put(0x5bb0bdbbee2b138eL, IExcludeFromCoverage);
    builder.put(0x62ec1b29abde62acL, IInterpreterWrapperType);
    builder.put(0x447c2333802b1b10L, IReveal);
    builder.put(0x760b48e4e8391c1fL, ITracerFrame);
    builder.put(0x3e4402fed00d643fL, ITrivialNode);
    builder.put(0x5c78e2973367f2eeL, InterpretAfterRelationship);
    builder.put(0x5c78e29733672c63L, InterpretBeforeRelationship);
    builder.put(0x4976653a521d1330L, InterpretConstraintExpression);
    builder.put(0x778ee47a6de884e5L, InterpretExpression);
    builder.put(0x778ee47a6de672eaL, Interpreter);
    builder.put(0x34bc3b671f26b347L, InterpreterCreator);
    builder.put(0x761e4e6b8ed90e75L, IsEvaluableConstraintExpression);
    builder.put(0x761e4e6b8ed90e6cL, IsEvaluableExpression);
    builder.put(0x4976653a51f0a841L, NodeExpression);
    builder.put(0x7ac27f5fc3bff520L, OperationCallExpression);
    builder.put(0x6e19635d9039de24L, RegisterBranchesStatement);
    builder.put(0x6cb34733ba9d69daL, StopExpression);
    builder.put(0x5344eca2decabb27L, TraceExpression);
    builder.put(0x778ee47a6de67938L, TypeMapping);
    builder.put(0x778ee47a6de85e1bL, TypedChildConstraint);
    builder.put(0x278f63fdaeb2e1d6L, ValueInspector);
    builder.put(0x6e19635d904202d6L, VisitBranchStatement);
    myIndex = builder.seal();
  }

  /*package*/ int index(SConceptId cid) {
    return myIndex.index(cid);
  }

  public int index(SAbstractConcept concept) {
    return myIndex.index(concept);
  }
}
