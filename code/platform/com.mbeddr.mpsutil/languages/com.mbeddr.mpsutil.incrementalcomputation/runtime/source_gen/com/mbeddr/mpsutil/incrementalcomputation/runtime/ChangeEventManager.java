package com.mbeddr.mpsutil.incrementalcomputation.runtime;

/*Generated by MPS */

import org.jetbrains.mps.openapi.model.SNodeChangeListener;
import java.util.Map;
import org.jetbrains.mps.openapi.model.SNode;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.LinkedHashMap;
import java.util.Set;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.LinkedHashSet;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.LinkedList;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.mps.openapi.event.SPropertyChangeEvent;
import org.jetbrains.mps.openapi.event.SReferenceChangeEvent;
import org.jetbrains.mps.openapi.event.SNodeAddEvent;
import org.jetbrains.mps.openapi.event.SNodeRemoveEvent;
import org.jetbrains.mps.openapi.language.SInterfaceConcept;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;

public class ChangeEventManager implements SNodeChangeListener {
  private static final ChangeEventManager _instance = new ChangeEventManager();
  public static ChangeEventManager getInstance() {
    return _instance;
  }

  private final Map<SNode, List<ValueCache>> _participantMap = MapSequence.fromMap(new LinkedHashMap<SNode, List<ValueCache>>(16, (float) 0.75, false));
  private final Set<SModel> _listenedModels = SetSequence.fromSet(new LinkedHashSet<SModel>());

  /**
   * not intended to be used by clients
   */
  public void registerValueCache(ValueCache valueCache) {
    SNode participant = valueCache.getValueHolder();
    List<ValueCache> caches = MapSequence.fromMap(_participantMap).get(participant);
    if (caches == null) {
      caches = ListSequence.fromList(new LinkedList<ValueCache>());
      MapSequence.fromMap(_participantMap).put(participant, caches);
    }
    ListSequence.fromList(caches).addElement(valueCache);

    SModel model = SNodeOperations.getModel(participant);
    if (!(SetSequence.fromSet(_listenedModels).contains(model))) {
      SetSequence.fromSet(_listenedModels).addElement(model);
      model.addChangeListener(this);
    }
  }

  /**
   * not intended to be used by clients, wipes ALL cache information
   */
  public void reset() {
    SetSequence.fromSet(_listenedModels).visitAll((it) -> it.removeChangeListener(ChangeEventManager.this));
    SetSequence.fromSet(_listenedModels).clear();
    MapSequence.fromMap(_participantMap).visitAll((it) -> {
      ListSequence.fromList(it.value()).visitAll(new _FunctionTypes._void_P1_E0<ValueCache>() {
        public void invoke(ValueCache it) {
          it.dispose();
        }
      });
    });
    MapSequence.fromMap(_participantMap).clear();
  }

  /**
   * may be used by clients to invalidate one part of the cached information but have no opportunity to access affected instances (e.g. invalidation must be triggered from some external context)
   * last resort only!
   */
  public void forceInvalidation(final Object valueSelector) {
    MapSequence.fromMap(_participantMap).translate((it) -> it.value()).where((it) -> it.getValueSelector().equals(valueSelector)).visitAll((it) -> it.invalidate(EChangeEffectKind.ValueAndDependencies, ListSequence.fromList(new LinkedList<ValueHolderInfo>())));
  }

  @Override
  public void propertyChanged(@NotNull SPropertyChangeEvent event) {
    notifyCache(new ContentChangedEvent(event.getNode(), event.getProperty(), null, null, null, false));
  }

  @Override
  public void referenceChanged(@NotNull SReferenceChangeEvent event) {
    notifyCache(new ContentChangedEvent(event.getNode(), null, event.getAssociationLink(), null, null, false));
  }

  @Override
  public void nodeAdded(@NotNull SNodeAddEvent event) {
    notifyCache(new ContentChangedEvent(event.getParent(), null, null, event.getAggregationLink(), event.getChild(), false));
  }

  @Override
  public void nodeRemoved(@NotNull SNodeRemoveEvent event) {
    notifyCache(new ContentChangedEvent(event.getParent(), null, null, event.getAggregationLink(), event.getChild(), true));
  }

  private void notifyCache(final ContentChangedEvent event) {
    SNode participant = SNodeOperations.getNodeAncestor(event.getNode(), CONCEPTS.IncrementallyComputedValueHolder$Iz, true, false);
    if (participant == null) {
      return;
    }

    List<ValueCache> caches = MapSequence.fromMap(_participantMap).get(participant);
    if (caches != null) {
      ListSequence.fromList(caches).visitAll((it) -> it.contentChanged(event));
    }
  }

  private static final class CONCEPTS {
    /*package*/ static final SInterfaceConcept IncrementallyComputedValueHolder$Iz = MetaAdapterFactory.getInterfaceConcept(0xfca4b68711d4461fL, 0x9cd4f00968145931L, 0x2e023b1452ca10b6L, "com.mbeddr.mpsutil.incrementalcomputation.structure.IncrementallyComputedValueHolder");
  }
}
