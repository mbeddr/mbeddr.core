package com.mbeddr.mpsutil.incrementalcomputation.runtime;

/*Generated by MPS */

import org.jetbrains.mps.openapi.model.SNode;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.LinkedList;
import jetbrains.mps.internal.collections.runtime.Sequence;
import com.mbeddr.mpsutil.incrementalcomputation.behavior.IncrementallyComputedValueHolder__BehaviorDescriptor;
import jetbrains.mps.internal.collections.runtime.LinkedListSequence;
import jetbrains.mps.internal.collections.runtime.DequeSequence;
import java.util.Deque;
import de.slisson.mps.hacks.editor.EditorComponentHacks;
import jetbrains.mps.lang.core.behavior.BaseConcept__BehaviorDescriptor;

public class ValueCache {

  private final ValueHolderInfo _valueHolderInfo;
  private final Object _valueSelector;
  private final SNode _valueHolder;

  private List<ValueHolderInfo> _cachedPropagationSources = ListSequence.fromList(new LinkedList<ValueHolderInfo>());
  private List<ValueHolderInfo> _cachedPropagationTargets = ListSequence.fromList(new LinkedList<ValueHolderInfo>());
  private Object _cachedValue = null;
  private Boolean _cachedHasCycle = null;
  private Iterable<SNode> _cachedCycle = null;

  public ValueCache(ValueHolderInfo valueHolder, Object valueSelector) {
    _valueHolderInfo = valueHolder;
    _valueSelector = valueSelector;
    _valueHolder = _valueHolderInfo.getValueHolder();

    ChangeEventManager.getInstance().registerValueCache(this);
  }

  public void init() {
    Iterable<ValueHolderInfo> newSources = Sequence.fromIterable(IncrementallyComputedValueHolder__BehaviorDescriptor.getDependencies_id2S2eLhiMzhL.invoke(_valueHolder, _valueSelector)).select((it) -> (ValueHolderInfo) IncrementallyComputedValueHolder__BehaviorDescriptor.getValueHolderInfo_id2S2eLhiM$ey.invoke(it));
    Sequence.fromIterable(newSources).visitAll((source) -> source.addPropagationTarget(_valueSelector, _valueHolderInfo));
    _cachedPropagationSources = Sequence.fromIterable(newSources).toList();
  }

  public Object getValueSelector() {
    return _valueSelector;
  }

  public SNode getValueHolder() {
    return _valueHolder;
  }

  public Object getValue() {
    if (_cachedValue != null) {
      return _cachedValue;
    }

    if (!((boolean) IncrementallyComputedValueHolder__BehaviorDescriptor.isActive_id5nAcTtn9HEK.invoke(_valueHolder, _valueSelector))) {
      return null;
    }

    if (hasCycle()) {
      return null;
    }

    _cachedValue = IncrementallyComputedValueHolder__BehaviorDescriptor.calculateValue_idRObVTFnZ_0.invoke(_valueHolder, _valueSelector);
    return _cachedValue;
  }

  public void invalidate(final EChangeEffectKind changeEffectKind, final List<ValueHolderInfo> visitedParticipants) {
    if (ListSequence.fromList(visitedParticipants).contains(_valueHolderInfo)) {
      return;
    }
    ListSequence.fromList(visitedParticipants).addElement(_valueHolderInfo);

    _cachedValue = null;

    if (changeEffectKind == EChangeEffectKind.ValueAndDependencies) {
      _cachedHasCycle = null;
      final Iterable<ValueHolderInfo> newSources = Sequence.fromIterable(IncrementallyComputedValueHolder__BehaviorDescriptor.getDependencies_id2S2eLhiMzhL.invoke(_valueHolder, _valueSelector)).select((it) -> (ValueHolderInfo) IncrementallyComputedValueHolder__BehaviorDescriptor.getValueHolderInfo_id2S2eLhiM$ey.invoke(it));
      Sequence.fromIterable(newSources).where((newSource) -> !(ListSequence.fromList(_cachedPropagationSources).contains(newSource))).visitAll((newSource) -> newSource.addPropagationTarget(_valueSelector, _valueHolderInfo));
      ListSequence.fromList(_cachedPropagationSources).where((oldSource) -> !(Sequence.fromIterable(newSources).contains(oldSource))).visitAll((oldSource) -> oldSource.removePropagationTarget(_valueSelector, _valueHolderInfo));
      _cachedPropagationSources = Sequence.fromIterable(newSources).toList();
    }

    LinkedListSequence.fromLinkedListNew(LinkedListSequence.fromListWithValues(new LinkedList<ValueHolderInfo>(), _cachedPropagationTargets)).visitAll((target) -> target.invalidate(_valueSelector, changeEffectKind, visitedParticipants));
  }

  public void addPropagationTarget(ValueHolderInfo other) {
    ListSequence.fromList(_cachedPropagationTargets).addElement(other);
  }

  public void removePropagationTarget(ValueHolderInfo other) {
    ListSequence.fromList(_cachedPropagationTargets).removeElement(other);
  }

  public boolean hasCycle() {
    if (_cachedHasCycle != null) {
      return _cachedHasCycle;
    }

    try {
      checkForCycle(DequeSequence.fromDeque(new LinkedList<SNode>()), _valueHolder);
      _cachedHasCycle = false;
      _cachedCycle = null;
    } catch (CycleDetectedException ex) {
      _cachedHasCycle = true;
      _cachedCycle = ex.getCycle();
    } finally {
      return _cachedHasCycle;
    }
  }

  public Iterable<SNode> getCycle() {
    return _cachedCycle;
  }

  private void checkForCycle(final Deque<SNode> participantStack, SNode participant) {
    if (DequeSequence.fromDequeNew(participantStack).contains(participant)) {
      DequeSequence.fromDequeNew(participantStack).pushElement(participant);
      throw new CycleDetectedException(DequeSequence.fromDequeNew(participantStack).toList());
    }

    DequeSequence.fromDequeNew(participantStack).pushElement(participant);
    Sequence.fromIterable(IncrementallyComputedValueHolder__BehaviorDescriptor.getDependencies_id2S2eLhiMzhL.invoke(participant, _valueSelector)).visitAll((it) -> checkForCycle(participantStack, it));
    DequeSequence.fromDequeNew(participantStack).popElement();
  }

  public void contentChanged(ContentChangedEvent event) {
    reactOnChange(IncrementallyComputedValueHolder__BehaviorDescriptor.getChangeEffect_idKudFejX3SG.invoke(_valueHolder, event, _valueSelector));
  }

  public void dispose() {
    _valueHolder.putUserObject(ValueHolderInfo.USER_OBJECT_ID, null);
  }

  private void reactOnChange(final ChangeEffect changeEffect) {
    if (changeEffect == null) {
      return;
    }

    final List<ValueHolderInfo> visitedParticipants = ListSequence.fromList(new LinkedList<ValueHolderInfo>());

    invalidate(changeEffect.getKind(), visitedParticipants);

    if (changeEffect.getInvalidationHint() != null) {
      Sequence.fromIterable(changeEffect.getInvalidationHint()).visitAll((it) -> IncrementallyComputedValueHolder__BehaviorDescriptor.getValueHolderInfo_id2S2eLhiM$ey.invoke(it).invalidate(_valueSelector, changeEffect.getKind(), visitedParticipants));
    }

    for (final SNode participant : ListSequence.fromList(visitedParticipants).select((it) -> it.getValueHolder())) {
      if ((boolean) IncrementallyComputedValueHolder__BehaviorDescriptor.isEditorUpdateEnabled_id5nAcTtnb1YA.invoke(participant, _valueSelector)) {
        // TODO: EditorComponentHacks does not seem to work? no instances are returned...
        ListSequence.fromList(EditorComponentHacks.findAllInstances()).where((it) -> it.getRootCell().getSNode() == participant).visitAll((it) -> it.update());
      }
    }
  }

  public String getDebugInfo() {
    StringBuilder sb = new StringBuilder();
    sb.append("SOURCES:\n");
    for (ValueHolderInfo source : ListSequence.fromList(_cachedPropagationSources)) {
      sb.append(BaseConcept__BehaviorDescriptor.getPresentation_idhEwIMiw.invoke(source.getValueHolder()) + "\n");
    }
    sb.append("TARGETS:\n");
    for (ValueHolderInfo target : ListSequence.fromList(_cachedPropagationTargets)) {
      sb.append(BaseConcept__BehaviorDescriptor.getPresentation_idhEwIMiw.invoke(target.getValueHolder()) + "\n");
    }
    return sb.toString();
  }

}
