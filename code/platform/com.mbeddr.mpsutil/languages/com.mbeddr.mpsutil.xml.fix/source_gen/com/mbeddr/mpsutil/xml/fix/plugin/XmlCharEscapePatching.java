package com.mbeddr.mpsutil.xml.fix.plugin;

/*Generated by MPS */

import java.util.Map;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.lang.reflect.Field;
import jetbrains.mps.core.xml.textGen.XmlCharEscape;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.smodel.structure.ExtensionPoint;

/**
 * This is a workaround for a bug introduced in MPS 2021.3 (MPS-35321/MPSSPRT-409) where XmlCharEscape will escape
 * a quote as &quote; rather than the correct &quot;.
 * 
 * Additionally, the XML language in 2021.3 tries to be smart and only escape entities that were not already escaped.
 * Taken together, this means that &quot; in XML will be wrongly considered unescaped and turned into &amp;quot;.
 * 
 * The bug is fixed in 2022.2 so the workaround should be temporary.
 */
public class XmlCharEscapePatching {

  private static final Map<Character, String> codesForIdentifiers = XmlCharEscapePatching.readMapField("codesForIdentifiers");
  private static final Map<Character, String> codesForAttributes = XmlCharEscapePatching.readMapField("codesForAttributes");
  private static final Map<Character, String> codesForText = XmlCharEscapePatching.readMapField("codesForText");

  private static final String originalQuoteI = MapSequence.fromMap(codesForIdentifiers).get('"');
  private static final String originalQuoteA = MapSequence.fromMap(codesForAttributes).get('"');

  private static final String originalQuoteAmpersandText = MapSequence.fromMap(codesForText).get('&');
  private static final String originalQuoteLessThanText = MapSequence.fromMap(codesForText).get('<');

  private XmlCharEscapePatching() {
  }

  public static void patch() {
    MapSequence.fromMap(codesForIdentifiers).put('"', "&quot;");
    MapSequence.fromMap(codesForAttributes).put('"', "&quot;");
    if (escapeTextFully()) {
      MapSequence.fromMap(codesForText).put('>', "&gt;");
      MapSequence.fromMap(codesForText).put('\'', "&apos;");
      MapSequence.fromMap(codesForText).put('"', "&quot;");
    }
  }

  public static void unpatch() {
    MapSequence.fromMap(codesForIdentifiers).put('"', originalQuoteI);
    MapSequence.fromMap(codesForAttributes).put('"', originalQuoteA);
    MapSequence.fromMap(codesForText).clear();
    MapSequence.fromMap(codesForText).put('&', originalQuoteAmpersandText);
    MapSequence.fromMap(codesForText).put('<', originalQuoteLessThanText);
  }

  private static Map<Character, String> readMapField(String fieldName) {
    try {
      Field field = XmlCharEscape.class.getDeclaredField(fieldName);
      field.setAccessible(true);
      return (Map<Character, String>) field.get(null);
    } catch (Exception ex) {
      throw new RuntimeException("Cannot read static field '" + fieldName + "' in class '" + XmlCharEscape.class + "'", ex);
    }
  }

  public static boolean escapeTextFully() {
    XMLConfiguration configuration = Sequence.fromIterable(new ExtensionPoint<XMLConfiguration>("com.mbeddr.mpsutil.xml.fix.XMLExtension").getObjects()).first();
    return (configuration != null ? configuration.escapeTextFully() : true);
  }
}
