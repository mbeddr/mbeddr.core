package com.mbeddr.mpsutil.richstring.typesystem;

/*Generated by MPS */

import org.jetbrains.mps.openapi.model.SNode;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import com.mbeddr.mpsutil.richstring.behavior.InlineFormat__BehaviorDescriptor;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import com.mbeddr.mpsutil.richstring.behavior.IInlineFormatCategory__BehaviorDescriptor;
import jetbrains.mps.typesystem.inference.SubtypingManager;
import jetbrains.mps.typesystem.inference.TypeChecker;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.baseLanguage.behavior.IClassifierType__BehaviorDescriptor;
import jetbrains.mps.smodel.SNodePointer;
import java.util.Objects;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import org.jetbrains.mps.openapi.language.SConcept;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;

public class InlineFormatTypecheckHelper {
  public static String checkApplicability(SNode descendant, SAbstractConcept category) {
    if (!(matchesCategory(InlineFormat__BehaviorDescriptor.getExpressionType_id7Ssz$kYjeZx.invoke(SNodeOperations.getNodeAncestor(descendant, CONCEPTS.InlineFormat$AE, false, false)), category))) {
      return "only applicable for " + IInlineFormatCategory__BehaviorDescriptor.getExpressionDescription_id6Go9U2yp2P0.invoke(SNodeOperations.asSConcept(category)) + " expressions";
    } else {
      return null;
    }
  }

  public static boolean matchesCategory(SNode type, SAbstractConcept category) {
    SubtypingManager subtypingManager = TypeChecker.getInstance().getSubtypingManager();

    boolean found = false;
    for (SNode typicalType : Sequence.fromIterable(IInlineFormatCategory__BehaviorDescriptor.getApplicableTypes_id6Go9U2y2JzF.invoke(SNodeOperations.asSConcept(category)))) {
      if (SNodeOperations.isInstanceOf(typicalType, CONCEPTS.ClassifierType$bL) && SNodeOperations.is(IClassifierType__BehaviorDescriptor.getClassifier_id6r77ob2URY9.invoke(SNodeOperations.cast(typicalType, CONCEPTS.ClassifierType$bL)), new SNodePointer("6354ebe7-c22a-4a0f-ac54-50b52ab9b065/java:java.lang(JDK/)", "~Object"))) {
        found = true;
        break;
      } else if (Objects.equals(type.getConcept(), typicalType.getConcept())) {
        if (SConceptOperations.isExactly(SNodeOperations.asSConcept(SNodeOperations.getConcept(typicalType)), CONCEPTS.ClassifierType$bL)) {
          found = subtypingManager.isSubtype(type, typicalType, false);
          if (found) {
            break;
          }
        } else {
          found = true;
          break;
        }
      }
    }

    return found;
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept InlineFormat$AE = MetaAdapterFactory.getConcept(0x442d3b7dfe4a4293L, 0xa7c16744d440ecaaL, 0x2e8be43a04395836L, "com.mbeddr.mpsutil.richstring.structure.InlineFormat");
    /*package*/ static final SConcept ClassifierType$bL = MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101de48bf9eL, "jetbrains.mps.baseLanguage.structure.ClassifierType");
  }
}
